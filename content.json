{"pages":[],"posts":[{"title":"[API] Swagger - Công cụ hỗ trợ mô tả cấu trúc API","text":"Chắc hẳn khi làm việc với API, việc xây dựng tài liệu (documents) đặc tả API, chức năng, tham số, các respone là điều cần thiết. Nếu như bạn đang gặp khó khăn trong việc đặt tả này hay không muốn đặc tả trên các file định dạng excel chưa theo chuẩn thì hãy xem xét sử dụng Swagger. Swagger cho phép bạn đặc tả cấu trúc APIs của bạn để máy có thể đọc được. Khả năng mô tả API đến tận “root” là điều thật tuyệt vời mà Swagger mang lại. Swagger không chỉ đặc tả cấu trúc APIs, nó còn làm được nhiều hơn thế với hệ sinh thái đa dạng như sinh tạo 1 stub server cho APIs, sinh thư viện clients với 40 ngôn ngữ hay việc có thể test API trên chính Swagger. Tuy nhiên trọng phạm vi bài viết, mình chỉ nói về cấu trúc file mà Swagger sử dụng để đặc tả API. Demo: Swagger API Swagger demo with editor 1. Basic StructureSwagger có thể được viết dưới dạng JSON hoặc YAML. Trong hướng dẫn này, chúng tôi chỉ sử dụng ví dụ dạng YAML nhưng JSON hoạt động tốt tương đương. Một Swagger với định dạng YAML sẽ có dạng như sau12345678910111213141516171819swagger: &quot;2.0&quot;info: title: Sample API description: API description in Markdown. version: 1.0.0host: api.example.combasePath: /v1schemes: - httpspaths: /users: get: summary: Returns a list of users. description: Optional extended description in Markdown. produces: - application/json responses: 200: description: OKNào, chúng ta cùng điểm qua các thành phần của nó là cái gì nhé :D 2. MetadataKhởi đầu cho mỗi Swagger bắt đầu với version, 2.0 đang là phiên bản cuối cùng của nó. Phiên bản giúp các trình dịch hiểu được cấu trúc tổng thể của phần nội dung tiếp theo.1swagger: &quot;2.0&quot;Tiếp theo, bạn cần định nghĩa các thông tin về API trong trường info với các trường title, description (tùy chọn), version (API version, không phải version của file hay Swagger)1234info: title: Sample API description: API description in Markdown. version: 1.0.0 3. Base URLBase URL là phần dùng cho tất cả các API định nghĩa bao gồm: schemes, host, basePath:1234host: api.example.combasePath: /v1schemes: - httpsTất cả các đường link API đều quan hệ với base URL này. Ví dụ /users thực tế có nghĩa là https://api.example.com/v1/users. 4. Consumes, ProducesPhần Consumes và produces định nghĩa loại MIME được hỗ trợ bởi API. “Root-level” định nghĩa có thể được ghi đè bởi các toán tử riêng biệt (các API cụ thể có thể định nghĩa lại phần này).123456consumes: - application/json - application/xmlproduces: - application/json - application/xml 5. PathPhần này chính là phần quan trọng, định nghĩa từng API cụ thể và phương thức HTTP được hỗ trợ trong các API này. GET /users được mô tả như sau:12345678910paths: /users: get: summary: Returns a list of users. description: Optional extended description in Markdown. produces: - application/json responses: 200: description: OK 6. ParametersCác toán tử có thể cần các tham số dựa trên URL path (/users/{userId}), query string (/users?role=admin), headers (X-CustomHeader: Value)và trong request body. Bạn có thể định nghĩa các loại tham số, cấu trúc, mô tả chi tiết, yêu cầu hay tùy chọn hoặc các thông tin khác trong swagger như sau:1234567891011121314paths: /users/{userId}: get: summary: Returns a user by ID. parameters: - in: path name: userId required: true type: integer minimum: 1 description: Parameter description in Markdown. responses: 200: description: OK 7. ResponsesMỗi API tất nhiên đều response về một trạng thái (status codes) như 200 OK hoặc 404 Not Found và schema (cấu trúc) của response body. Schemas này thì có thể được định nghĩa trực tiếp trong respone hoặc có thể tách ra định nghĩa ngoài vùng dựa bào $ref1234567891011121314151617181920212223242526272829paths: /users/{userId}: get: summary: Returns a user by ID. parameters: - in: path name: userId required: true type: integer minimum: 1 description: The ID of the user to return. responses: 200: description: A User object. schema: type: object properties: id: type: integer example: 4 name: type: string example: Arthur Dent 400: description: The specified user ID is invalid (e.g. not a number). 404: description: A user with the specified ID was not found. default: description: Unexpected error 8. Input and Output ModelsPhần definitions sẽ định nghĩa các cấu trúc dữ liệu chung để sử dụng trong API của bạn. Phần này có thể được tham chiếu qua $ref bất cứ một shema nào - ở cả request body và response body. Ví dụ đây là JSON object:1234{ &quot;id&quot;: 4, &quot;name&quot;: &quot;Minh NV&quot;}Có thể được mô tả bởi1234567891011definitions: User: properties: id: type: integer name: type: string # Both properties are required required: - id - nameVà được tham chiếu trong request body schema và response body schema như sau thông qua $ref:12345678910111213141516171819202122232425paths: /users/{userId}: get: summary: Returns a user by ID. parameters: - in: path name: userId required: true type: integer responses: 200: description: OK schema: $ref: '#/definitions/User' /users: post: summary: Creates a new user. parameters: - in: body name: user schema: $ref: '#/definitions/User' responses: 200: description: OK 9. AuthenticationTừ khóa securityDefinitions và security được sử dụng để mô tả các phương thức yêu cầu xác thực.12345securityDefinitions: BasicAuth: type: basicsecurity: - BasicAuth: []Phương thức xác thức được hỗ trợ bao gồm: Basic authentication API key (as a header or query parameter) OAuth 2 common flows (implicit, password, application and access code) Tài liệu tham khảo Swagger Editor Basic Strcuture","link":"/2019/11/16/API-Swagger-Cong-cu-ho-tro-mo-ta-cau-truc-API/"},{"title":"AWS - Amazon Virtual Private Cloud (VPC)","text":"Network basic - AWS - Amazon Virtual Private Cloud (VPC) Public Subnet &amp; Private Subnet Public Subnet Private Subnet Sử dụng địa chỉ IP Global Chỉ Sử dụng địa chỉ IP Private Cho phép truy cập trực tiếp từ Internet Không thể truy cập trực tiếp từ Internet Subnet gán với Internet gateway Subnet gán với NAT Subnet gán với Internet Gateway =&gt; Public Subnet Subnet gán với NAT =&gt; Private Subnet AWS SG &amp; ACL Định nghĩa các role cho phép truy cập tài nguyên hệ thống Cho phép ai (Des) Cho phép cái gì (Port) Security GroupChỉ ALLOW (còn lại là deny) Thường sẽ chỉ quy định Inbound, Outbound sẽ mở all. Vì nếu config cả Outbound sẽ khá là rắc rối=&gt; Control 1 chiều là đủ Security group sẽ được gán cho các Instance của AWS: EC2, RDS, Redis, ES, Lambda SG hoàn toàn config được thay thế bằng IP Table trong OS, nhưng vì vậy thì bất tiện do phải tác động vào OS ACLCheck là Allow và DenyVà Deny mạnh nhất Mạng đi vào cổng 22 thì sẽ không phải đi ra ở cổng 22=&gt; Ephemeral Ports Nếu cả ALC và SG, sao không controll 1 cái thôi=&gt; Với các dự án nhỉ, thì điều này là OK (Lúc này SG =&gt; Allow và ACL sẽ mở ALL)Tuy nhiên phụ thuộc vào các dự án mà config thay thế Không nên edit SG, ACL đã tồn tại khi project đã chạy ổn. Thay vào đó, tạo SG, ACL mới và gán lại Instance ACL không nên setting nhiều (dự án nhỏ có thể mở all. Nó chỉ là tổng quan. SG mới là nơi cần controll chi tiếtHơn nữa ACL chỉ max 40 rule và càng nhiều, hệ thống có thể càng chậm cho phải kiểm tra nhiều rule Best practice - Networking Security Group &amp; Bastion Host Một vài cấu hình VPCBạn có thể sử dụng một trong các mô hình sau để áp dụng cho dự án của bạn mà không có trong mặc định AWS VPC - Scenario 1: VPC with a Single Public Subnet AWS VPC - Scenario 2: VPC with Public and Private Subnets (NAT) AWS VPC - Scenario 3: VPC with Public and Private Subnets and AWS Managed VPN Access AWS VPC - Scenario 4: VPC with a Private Subnet Only and AWS Managed VPN Access =&gt; Đa số các dự án sẽ theo Scenario 2","link":"/2021/02/06/AWS-Amazon-Virtual-Private-Cloud-VPC/"},{"title":"AWS- Network basic","text":"Network là một lĩnh vực rất rộng, gồm nhiều các thiết bị, giao thức để giao tiếp với nhau. Tuy nhiên trong phạm vi bài viết, tác giả sẽ không liệt kê toàn bộ các phần thiết bị hay giao thức một cách chi tiết mà chỉ nói qua một số phần cơ bản nhất trong Network, từ đó có thể áp dụng để triển khai một mạng ảo trên Amazon Virtual Private Cloud. What is the networkMạng các máy tính bao gồm 2 hoặc nhiều máy liên kết với nhau để chia sẻ tài nguyên RouteBộ định tuyến coi như như một chiếc bản đồ, chứa các thông tin định tuyến gói tin trong mạngMỗi Route sẽ chứa các thông tin điểm đến (Destination), đích (target) và route tiếp theo cần đến để đến được đích. MAC AddressĐây là một khái niệm định danh duy nhất cho các thiết bị, không bao giờ trùng nhau. MAC thường được nhắc đến nhiều khi cấu hình card mạng. Địa chỉ IP Sử dụng để giao tiếp trong các giao thức mạng Địa chỉ IP cung cấp nhận dạng cho một thiết bị mạng, tương tự như địa chỉ nhà riêng hoặc doanh nghiệp. Các thiết bị trên mạng có các địa chỉ IP khác nhau. Có thể trùng đối với các IP Address Private, đối với các IP Address Public thì không. Có 2 loại là IP Address Public và IP Address Private IP Private: Các địa chỉ IP Private sẽ bắt đầu bởi các địa chỉ12310.172.16~31192.168 Xem IP Private bằng lệnh1ipconfig Ip Public giống như tên gọi khi đi ra ngoài của bạn, và mỗi thiết bị cần có 1 tên riêng biệt IP Private giống như biệt danh, tên gọi ở nhà (Bơ, Mít, Kem,…) có thể trùng nhau giữa các “gia đình” nhưng trong mỗi gia đình, tên phải là duy nhất. Ping - Trace route - TelnetĐây là các lệnh cơ bản để kiểm tra network của 1 server PingKiểm tra trạng thái các gói tin đến server, độ trễ có gói tin Ping thấp nghĩa là độ trễ thấp và việc giao tiếp với máy chủ sẽ diễn ra nhanh hơn Ping không trả lời khác với việc server bị sập. Ping chặn có thể là do chặn IP hoặc response quá lâu 1234567$ ping -c 5 vi.wikipedia.orgPING vi.wikipedia.org (130.94.122.195): 56 data bytes64 bytes from 130.94.122.195: icmp_seq=0 ttl=235 time=284.3 ms64 bytes from 130.94.122.195: icmp_seq=1 ttl=235 time=292.9 ms64 bytes from 130.94.122.195: icmp_seq=2 ttl=235 time=289.7 ms64 bytes from 130.94.122.195: icmp_seq=3 ttl=235 time=282.4 ms64 bytes from 130.94.122.195: icmp_seq=4 ttl=235 time=272.0 ms Trace routeTruy vết đường đi của các gói tin dữ liệu trong các giao thức mạng Lệnh PING: kiểm tra kết nối internet giữa 2 máy tính. Bằng cách gửi đi các gói tin, rồi nhận lại tín hiệu phản hồi từ phía bên kia. Lệnh Tracert thì có vẻ “cao siêu” hơn 1 chút, dùng để kiểm tra đường đi của các gói tin của lệnh Ping. 123456789101112131415161718192021C:\\&gt;tracert wikipedia.comTracing route to wikipedia.com [208.80.152.201]over a maximum of 30 hops: 1 1 ms 1 ms 1 ms 192.168.8.1 [192.168.8.1] 2 * * * Request timed out. 3 12 ms 16 ms 6 ms 14.92.730.165 4 24 ms 25 ms 23 ms 203-144-128-22.uio.co.vh [203.144.128.22] 5 13 ms 8 ms 7 ms 203-144-128-13.static.qwa.co.tm [203.144.128.13] 6 14 ms 10 ms 17 ms 181.91.213.225.alop.co.uk [181.91.213.225] 7 7 ms 7 ms 7 ms 167.91.213.35.static.net.pl.org [167.91.213.35] 8 10 ms 9 ms 9 ms 121.91.213.81.static.poe.ao.com [121.91.213.81] 9 8 ms 7 ms 7 ms 68.19.101.251 10 217 ms 217 ms 215 ms 207.4.253.210 11 233 ms 259 ms 232 ms ae0-140.par20.ip4.bit.net [77.6.74.281] 12 299 ms 308 ms 302 ms xe-9-2-0.was10.ip4.bit.net [89.149.183.154] 13 293 ms 293 ms * xe-5-3-1.cr2-eqiad.wikimedia.org [173.241.131.218] 14 318 ms 327 ms 316 ms xe-1-1-0.cr1-sdtpa.wikimedia.org [208.80.154.214] 15 320 ms 319 ms 321 ms wikipedia-lb.pmtpa.wikimedia.org [208.80.152.201]Trace complete. Port protocol Các giao thức mạng đều có cổng giao tiếp Danh sách các cổng: https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers Lệnh telnet có thể sử dụng để kiểm tra các cổng của 1 giao thức1Telnet &lt;IP_ADDRESS&gt; &lt;PORT PROTOCOL&gt; If Web Server can not connect to Database Server? DNS - Hệ thống phân giải tên miềnCác giao thức mạng không giao tiếp với nhau qua các domain (ví dụ www.example.com) mà sẽ sử dụng địa chỉ IP. Do đó cần có 1 hệ thống phân giải tên miền để chuyển đổi từ domain sang địa chỉ IP, đó là hệ thống DNS. nslookup command1234567891011121314151617$ nslookup google.comServer: 127.0.1.1Address: 127.0.1.1#53Non-authoritative answer:Name: google.comAddress: 172.217.194.113Name: google.comAddress: 172.217.194.139Name: google.comAddress: 172.217.194.100Name: google.comAddress: 172.217.194.101Name: google.comAddress: 172.217.194.138Name: google.comAddress: 172.217.194.102 Domain mainNhư đã nói ở trên, domain sẽ đại diện cho địa chỉ IP, là một các kí tự dễ nhớ với con người. Có thể hiểu, domain chính ta tên trong danh bạ, còn địa chỉ IP chính là số điện thoại của người đó. Tên chỉ là để dễ nhớ, cho con người biết là số của ai, còn điện thoại và các tổng đài sẽ giao tiếp thông qua số điện thoại chứ không phải tên danh bạ Sud domain edu1.com=&gt; Lev 2: env.edu1.com=&gt; Lev 3: admin.env.edu1.com Có thể áp dụng sub domain để triển khai ứng dụng web cho các môi trường (dev, stg, product) và nội dung web (api, backend, frontend). NATNAT cơ bản có thể sử dụng để kết nối hai mạng máy tính có địa chỉ không tương thích. (Kiểu ánh xạ IP Public và IP Private) NAT là một kỹ thuật cho phép một hoặc nhiều địa chỉ IP nội miền chuyển đổi sang một hoặc nhiều địa chỉ IP ngoại miền. Xem xét ví dụ gia đình Minh có 2 người con là Minh (tên gọi private ở nhà là M) và Nam (tên gọi private ở nhà là N) Khi đơn vị nào đó (mạng trên Internet) muốn giao tiếp với Minh, gửi một lá thư cho gia đình Minh (gia đình Minh lúc này đóng vai trò như server tiếp nhận request), và mẹ Minh sẽ đọc địa chỉ từ lá thư, gửi cho Minh =&gt; chuyển cho M (tên gọi ở nhà - Private Network). Minh có trả lời thì lại gửi lá thư cho mẹ, sau đó mẹ phản hồi lại bên gửi đến với tên Minh. Mẹ Minh ở đây đóng vai trò là NAT, chuyển đổi tên public và tên private, giúp các giao thức mạng vận hành 1 các trơn tru Như vậy rõ ràng M (hay Minh) được bảo vệ, không cho phép mạng bên ngoài truy cập trực tiếp. Nếu muốn truy cập vào M, phải ở trong “gia đình” hoặc thông qua mẹ Minh (ở trong mạng nội bộ) Địa chỉ A giao tiếp bên ngoài luôn là Minh (Giúp che giấu IP bên trong mạng LAN) Các địa chỉ gửi đến gia đình Minh cho Minh khi sai tên sẽ không được gửi đến =&gt; Lọc các gói tin và kiểm duyệt truy cập đến port NAT sử dụng khi có Private Subnet Forward Proxy &amp; Reserve ProxyReverse Proxy &amp; Load Balancer","link":"/2021/02/07/AWS-Network-basic/"},{"title":"AWS - WebApp Architecture Design","text":"Mỗi trang web đều có mục đích sử dụng khác nhau và các đặc thù riêng. Hơn nữa phần chi phí xây dựng, duy trì web từ phía khách hàng và yêu cầu về tải hệ thống, phục vụ số lượng user như thế nào cũng là các yếu tố quyết định đến việc bạn sẽ thiết kế kiến trúc như thế nào. Trước tiên ta cùng xem các service cơ bản của AWS cần dùng để xây dựng một website. EC2Chọn loại EC2 cho phù hợp Đối với môi trường lại Test/dev, bạn có thể sử dụng loại T Với các môi trường Product, có thể chọn loại M hoặc R (loại R cần khi dùng nhiều RAM) hơn.Với các loại C, G2, dùng cho các trường hợp đòi hỏi xử lý cao như các website cần phân tích nhiều, hoặc gaming. AWS EC2 - Instance LifeCycleCó thể sử dụng EC2 hook khi pending, In Service hoặc Terminate để can thiệp nếu cần ELBMột trong những thành phần cân bằng tải trên AWS● Listener● Health Checks● Layer 4/ Layer 7 Load Balancing● Across-AZs● WebSocket Support● Sticky SessionTrong trường hợp ELB sử dụng nhiều máy ảo EC2, một việc được đặt ra là duy trì phiên làm việc của user. Chẳng hạn như user đang thực hiện thao tác trên Instnace EC2 (1) sau đó qua ELB, lần request tiếp theo sẽ được chuyển sang EC2 (2), khi đó phiên hoàn toàn đã bị mất.Để khắc phục vấn đề này, bạn có thể sử dụng Sticky Session, tất cả các yêu cầu của bạn sẽ được chuyển đến cùng một máy EC2 trong khi trong trường hợp non-sticky có thể chọn bất kỳ máy chủ web nào để phục vụ yêu cầu của bạn. Như vậy sticky session giúp bạn giữ lại phiên làm việc, các request sẽ được gửi tới cùng 1 máy EC2Note: Sticky note là vô dụng với scale ● Connection Draining (Default is 300s)Khi một ứng dụng scale in (xóa server đi), nó cần thời gian để xử lý nốt các request hiện đang có trên EC2 đó tránh việc website của bạn bị gián đoạn, và thời gian đó là Connection Draining Bạn có thể tham khảo phần EC2 Life Cycle để có thể can thiệp vào hook, xử lý các request trong 5 mins của Connection Draining, tránh việc vẫn còn request chưa được xử lý.● Idle Connection (Default is 60s) AWS CloudWatchCác tính năng cần kết hợp lại với nhau để giúp bạn xây dựng các ứng dụng có khả năng mở rộng và tính khả dụng cao. Amazon CloudWatch sẽ giám sát dung lượng Amazone EC2, Auto Sacling tự động mở rộng dựa trên nhu cầu và Elastic Load Balancing sẽ phân phối tải trên nhiều instances với 1 hoặc nhiều các Availability Zones CloudWatch sẽ theo dõi các thông số, các request đến ELB, nếu trong một khoảng thời gian (gọi là chu kì) nếu số lượng request vượt ngưỡng được config, nó sẽ kích hoạt một Alarm, cho phép scale hệ thống thông qua Auto Scaling đã được config từ trước. Một câu hỏi được đặt ra là ta nên đặt ngưỡng scale ở mức 30% CPU, 50% hay 70%. Câu trả lời sẽ là tùy tình hình thực tế cho project của bạn chứ không theo một chuẩn nào. Ban đầu bạn nên quan sát ứng dụng của mình chạy ở ngưỡng bao nhiêu, ví dụ 15%. Khi đó bạn có thể đặt ngưỡng scale là 20%. Về sau, khi ứng dụng đã phát triển nhiều chức năng, có thể bình thường, ứng dụng của bạn chạy bình thường ở mức 15% lên 30%, khi đó bạn cần đặt ngưỡng scale mới là 40% cho phù hợp. Chúng ta cũng không nên để ngưỡng scale là 70-80% CPU vì cần tính thời gian AWS bật các dịch vụ scale đi kèm (như bật EC2). Chúng ta nên đặt ngưỡng scale là 40%. Khi đó giả sử ứng dụng lên ngưỡng 40%, ta đoán được 2,3 phút tới, CPU sẽ đạt ngưỡng 70%, lúc đó ta bật EC2 luôn và khi CPU đạt ngưỡng 70% thật, server mới đã sẵn sàng để phục vụ. À mà tất nhiên đối với các app ít scale, bạn đặt 70% ngưỡng CPU cũng không vấn đề! Static content with S3 and CloudFrontElastic CacheRDS, Dynamo DBAuto ScalingAWS Application and Messaging ServiceSNSSQSSESWeb/App architecture design1 User - Amazon LightsailĐối với các website chỉ 1 user, bạn chỉ cần để tất cả các dịch vụ trong EC2 (webapp, database), cần một EIP và Route53 cho DNS Ngoài ra bạn cũng có thể sử dụng dịch vụ Amazon Lightsail, phục vụ cho các web cỡ nhỏ &gt; 1 UserLúc này bạn có thể tách thêm một database service Database options &gt; 1000 UserĐối với các website cỡ lớn hơn, bạn cần thêm cân bằng tải và các dịch vụ khác của AWS So if 10,000 ~ 100,000 Users … Như phần scale đã nói, để hệ thống có thể scale được thì cần move các dịch vụ ra ngoài để server là trạng thái stateless Move static contentĐầu tiên move các nội dung static ra Amazon S3 và Amazon CloudFront Move session to cache, dynamic content● Session/state to Amazon DynamoDB● DB caching to Amazon ElastiCache● Dynamic content to Amazon CloudFront &gt; 100,000 UserLúc này ta cần multi-AZ, ELB giữa các bậc, kết hợp Auto Scaling Go on Loose Coupling &amp; Service-Oriented Architecture … Loose Coupling + SOA = Winning … Bây giờ hệ thống của bạn lớn hơn rất nhiều và ta cần một hướng thiết kế đáp ứng được yêu cầu này. Hãy xem xét hướng thiết kế hướng dịch vụ. Đầu tiên chúng ta sẽ để tất cả trong một (all in one - Monolidthid) và bắt đầu suy nghĩ về tách dịch vụ Trang web sẽ chia nhỏ thành các dịch vụ back-end (BE), front-end (FE) Front-end Page cho admin Page các role kháTách thành các server riêng biệt Back-endVới back-end, bạn có thể tách theo từng chức năng cho service. Ở đây tôi ví dụ các dịch vụ có thể tách (1) Authentication(2) search(3) content(4) Batch, job, tách ra các service SQSSau đó điều hướng ELB trỏ các API tương ứng /login, /search, /content vào các server bên trên theo các dịch vụ Với các chia nhỏ server thành các dịch vụ như vậy, thậm chí cả 3 service của bạn có thể độc lập luôn cả về ngôn ngữ lập trình (PHP, Ruby, …) Thậm chí bạn vẫn có thể tách chúng nhỏ hơn nữa thành các microservice, chuyển login thành các API Gateway, viết bằng Lamdba bằng python tùy ý bạn. Tuy nhiên hãy xem xét mức độ cần thiết vì như vậy hệ thống có thể trở nên phức tạp vì quá nhỏ, xây dựng document API không đồng bộ được các bên &gt; +++ User AWS Security Best PracticesAWS Blue/Green Deployment …","link":"/2021/02/09/AWS-WebApp-Architecture-Design/"},{"title":"[Auth] OAuth2","text":"OAuth là một phương thức chứng thực giúp các ứng dụng có thể chia sẻ tài nguyên với nhau mà không cần chia sẻ thông tin username và password.Từ Auth ở đây mang 2 nghĩa: Authentication: xác thực người dùng thông qua việc đăng nhập. Authorization: cấp quyền truy cập vào các Resource. Bài viết chỉ muốn tổng hợp lại 2 mô hình của OAuth, một mô hình cơ bản và một mô hình cho cách cấp ủy quyền được sử dụng phổ biến nhất: Authorization Code Grant Mô hình chung+--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ Ref: https://tools.ietf.org/html/rfc6749 Một vài điểm chú ý về sơ đồ này Resource owner là người dùng, chính là bạn Client là application bên thứ 3, bạn có thể hình dung là 1 ứng dụng sử dụng facebook api chẳng hạn Authrization Server và Resource Server là những dịch vụ mà phía bên facebook hay twitter phải implement để thực hiện oauth. Đây chính là điểm cơ bản tạo nên khác biệt giữa Oauth2 và Oauth1, khi “tách biệt” giữa việc chứng thực (authorization) , và việc cung cấp thông tin người dùng (resource) thành 2 server riêng. Mục đích cuối cùng là lấy được access_token để truy cập tài nguyên bên bạn cần đăng nhập (Facebook chẳng hạn), tất nhiên, token này có thể bị hạn chế 1 số quyền hơn khi bạn sử dụng Facebook thật. Dựa vào cách cấp access_token khác nhau mà ta có các loại triển khai OAuth2 khác nhau Bước Authorization Grant (C và D) tùy vào loại OAuth2 bạn triển khai mà nó có thể có hoặc không :D Các cách cấp ủy quyềnNhư tôi đã nói ở trên, tùy cách cấp phát access_token mà chúng ta có các cách cấp ủy quyền khác nhau. Về cơ bản sẽ có 4 cách, tuy nhiên cách đầu tiên Authorization Code được sử dụng phổ biến nhất. Ba cách cấp ủy quyền còn lại ít được sử dụng. Authorization Code Grant+----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------&apos; | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------&apos; +---------+ (w/ Optional Refresh Token) Giả định User Agent là bạn Client là ứng dụng thứ 3 - XXX, cần lấy tài nguyên qua Facebook của bạn (name + avatar + email chẳng hạn). Các thông tin này được lưu ở Authorization Server (Facebook Resource) và cần đăng nhập từ Resource Owner (Facebook OAuth API) (Hình như Facebook đang để Facebook Resource và Facebook OAuth API là 1, nhưng ví dụ này tôi cứ để tách ra cho rõ). Hình minh họa trên được mô tả như sau (A) + (B) Bạn vào trang XXX, click đăng nhập với Facebook, và được chuyển hướng đến trang12345https://Facebook-OAuth-API.DOMAIN/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read response_type=token =&gt; Ý bảo với ứng dụng Facebook OAuth API là cấp mã ủy quyền redirect_uri =&gt; Sau khi Facebook OAuth API xác thực các thông tin là đúng, chuyển token về URI này cho tôi nhé Tất nhiên URL ở trên cần có middleware Auth để yêu cầu người dùng nhập tài khoản facebook mới xử lý tiếp :D (C): Tiếp theo phần trên, khi có mã ủy quyền (token), Facebook OAuth API sẽ chuyển về url XXX và bên này cần có router đón nó1https://XXX.DOMAIN/callback?code=AUTHORIZATION_CODE (D): Sau khi có ACCESS_TOKEN, XXX cần gửi tiếp 1 request đến Facebook, nhưng lần này là Facebook Resoure để lấy access_token12345https://Facebook-Resource.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL grant_type =&gt; cách cấp access_token, ở đây là authorization_code redirect_uri =&gt; khi Facebook Resource kiểm tra các thông tin đúng, gửi access_token cho tôi về địa chỉ này nhé, thường sẽ là về lại trang XXX (E): XXX nhận access_token qua redirect_uri ở bước D thôi. Từ access_token này, bạn có thể gọi các API lấy thông tin name, avatar, email của user qua Facebook được rồi đó :D Như vậy, cả client (ứng dụng của bạn) và ứng dụng thứ 3 (Facebook đều phải triển khai OAuth). Các URL của 2 bên12345678910111213141516(1) https://Facebook-OAuth-API.DOMAIN/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read=&gt; Middlware Auth(2) https://XXX.DOMAIN/callback?code=AUTHORIZATION_CODE=&gt; Bên XXX xử lý để nhận code từ bước 1(3) https://Facebook-Resource.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL=&gt; Lấy access_tokenÁp dụng OAuth2 trong Laravel Passport: (Ứng dụng của bạn chính là Client - XXX) Bước ấn nút chuyển hướng đăng nhập bằng Facebook123456789101112131415161718192021Route::get('/redirect', function (Request $request) { $request-&gt;session()-&gt;put('state', $state = Str::random(40)); $request-&gt;session()-&gt;put('code_verifier', $code_verifier = Str::random(128)); $codeChallenge = strtr(rtrim( base64_encode(hash('sha256', $code_verifier, true)) , '='), '+/', '-_'); $query = http_build_query([ 'client_id' =&gt; 'client-id', 'redirect_uri' =&gt; 'http://example.com/callback', 'response_type' =&gt; 'code', 'scope' =&gt; '', 'state' =&gt; $state, 'code_challenge' =&gt; $codeChallenge, 'code_challenge_method' =&gt; 'S256', ]); return redirect('http://your-app.com/oauth/authorize?'.$query);});Đây là bước request access_token (3)12345678910111213141516171819202122Route::get('/callback', function (Request $request) { $state = $request-&gt;session()-&gt;pull('state'); $codeVerifier = $request-&gt;session()-&gt;pull('code_verifier'); throw_unless( strlen($state) &gt; 0 &amp;&amp; $state === $request-&gt;state, InvalidArgumentException::class ); $response = (new GuzzleHttp\\Client)-&gt;post('http://your-app.com/oauth/token', [ 'form_params' =&gt; [ 'grant_type' =&gt; 'authorization_code', 'client_id' =&gt; 'client-id', 'redirect_uri' =&gt; 'http://example.com/callback', 'code_verifier' =&gt; $codeVerifier, 'code' =&gt; $request-&gt;code, ], ]); return json_decode((string) $response-&gt;getBody(), true);}); Password Grant Tokens Cung cấp cả thông tin username + password (tài khoản facebook của bạn), sử dụng khi thật tin tưởng Do có cả username và password nên bạn gọi thẳng 1 API vào Authorization Server để xin cấp access_token123456789$response = (new GuzzleHttp\\Client)-&gt;post('http://your-app.com/oauth/token', [ 'form_params' =&gt; [ 'grant_type' =&gt; 'authorization_code', 'client_id' =&gt; 'client-id', 'redirect_uri' =&gt; 'http://example.com/callback', 'code_verifier' =&gt; $codeVerifier, 'code' =&gt; $request-&gt;code, ],]); Client CredentialsSinh token từ chính client_id và secret_idDevice Code Tài liệu đọc thêm https://viblo.asia/p/introduction-to-oauth2-3OEqGjDpR9bL https://tools.ietf.org/html/rfc6749 https://kipalog.com/posts/Tro-lai-co-ban--Oauth-2","link":"/2020/06/01/Auth-OAuth2/"},{"title":"Cấu hình virtual host apache2","text":"Note lại cấu hình virtual host cho khỏi quên :D! Tạo file cấu hình12cd /etc/apache2/sites-availabletouch blog.local.conf Nội dung file blog.local.conf sẽ như sau: blog.local.confblog.local.conf12345678910111213&lt;VirtualHost *:80&gt; ServerAdmin admin@blog.local DocumentRoot /var/www/html/blog/public ServerName blog.local ServerAlias www.blog.local &lt;Directory /var/www/html/blog/public&gt; AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; ErrorLog ${APACHE_LOG_DIR}/blog_error.log CustomLog ${APACHE_LOG_DIR}/blog_access.log combined&lt;/VirtualHost&gt; Enable cấu hình này1sudo a2ensite blog.local.conf Đăng kí nó vào DNS trên máy local1sudo vi /etc/hosts Thêm dòng này vào nhé1127.0.0.1 blog.localSau đó restart lại apache1sudo service apache2 restartThế là xong rồi đó, bật trình duyệt và vào http://blog.local để kiểm tra thôi :D Cấu hình sslSinh chứng thư sốĐể cấu hình ssl, trang web sử dụng phương thức https, bạn cần đăng kí thêm chứng thư số cho trang web. Cách 1: Sử dụng lệnh opensslGenerate Certhttps://www.digitalocean.com1sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt Định dạng key và crt có thể dạng .pem Cách này tạo chứng thư số nhanh chóng, do openssl đã hỗ trợ sẵn trên các hệ điều hành Linux. Tuy nhiên với cách này, chứng thư số sẽ không đáng tin cậy trên trình duyệt do đó bạn load trang web https có thể cảnh báo. Cách 2: sử dụng mkcertĐể chứng chỉ đáng tin cậy, bạn có thể sử dụng mkcert, bạn phải cài thêm nó: Generate Certmkcert123456$ mkcert -installCreated a new local CA at &quot;/Users/filippo/Library/Application Support/mkcert&quot; 💥The local CA is now installed in the system trust store! ⚡️The local CA is now installed in the Firefox trust store (requires browser restart)!$ mkcert blog.local Cấu hình httpsNormal configurationVề cơ bản https bạn chỉ cần mở thêm 1 cổng 443 kèm theo đường dẫn chứng thư số:blog.local.conf12345678910111213141516171819&lt;VirtualHost *:443&gt; ServerAdmin admin@blog.local DocumentRoot /var/www/html/blog/public ServerName blog.local ServerAlias www.blog.local &lt;Directory /var/www/html/blog/public&gt; AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; # SSL config SSLEngine on SSLCertificateFile /etc/apache2/ssl/blog/blog.local.pem SSLCertificateKeyFile /etc/apache2/ssl/blog/blog.local-key.pem ErrorLog ${APACHE_LOG_DIR}/blog_error.log CustomLog ${APACHE_LOG_DIR}/blog_access.log combined&lt;/VirtualHost&gt;Khởi động lại apache21sudo service apache2 restartBạn có thể test ứng dụng tại: https://blog.local Proxy configurationblog.local.conf1234567891011121314&lt;VirtualHost *:443&gt; ProxyPreserveHost On ProxyRequests Off ServerName blog.local # SSL config SSLEngine On SSLCertificateFile /etc/apache2/ssl/blog/blog.local.pem SSLCertificateKeyFile /etc/apache2/ssl/blog/blog.local-key.pem ProxyPass / http://127.0.0.1:8000/ ProxyPassReverse / http://127.0.0.1:8000/ RequestHeader set X-Forwarded-Proto &quot;https&quot;&lt;/VirtualHost&gt; _N.V.M_","link":"/2020/05/29/Cau-hinh-virtual-host-apache2/"},{"title":"Chapter 1: Code Should Be Easy to Understand","text":"Khoảng 5 năm trước, chúng tôi đã thu thập hàng nghìn các ví dụ về “bad code” (phần lớn là của chúng tôi) và phân tích xem cái gì đã làm nó tệ và các kĩ thuật/nguyên tắc được sử dụng để làm code tốt hơn. Cái mà chúng tôi nhận được là tất cả các nguyên tắc xuất phát từ 1 chủ đề duy nhất. KEY IDEACode should be easy to understand. Chúng tôi tin rằng nguyên tắc hướng dẫn quan trọng nhất bạn có thể sử dụng khi quyết định code như thế nào. Xuyên suốt cuốn sách, chúng tôi sẽ chỉ ra cách áp dụng những nguyên tắc này với khía cạnh khác nhau để bạn cải thiện khả năng từng ngày. Nhưng trước khi bắt đầu, chúng tôi sẽ giải thích các nguyên tắc này và giải thích tại sao nó lại rất quan trọng. What Makes Code “Better”?Đa số lập trình viên (bao gồm cả tác giả) đưa ra các quyết định lập trình dựa vào cảm giác và trực quan. Tất cả những gì chúng ta biết là code như:12for (Node* node = list-&gt;head; node != NULL; node = node-&gt;next) Print(node-&gt;data);sẽ tốt hơn là code:12345678Node* node = list-&gt;head;if (node == NULL) return;while (node-&gt;next != NULL) { Print(node-&gt;data); node = node-&gt;next;}if (node != NULL) Print(node-&gt;data);(mặc dù 2 đoạn code thực hiện hành vi như nhau) Nhưng nhiều lần, 1 sự lựa chọn khó khăn hơn:1return exponent &gt;= 0 ? mantissa * (1 &lt;&lt; exponent) : mantissa / (1 &lt;&lt; -exponent);tốt hơn hay tệ hơn:12345if (exponent &gt;= 0) { return mantissa * (1 &lt;&lt; exponent);} else { return mantissa / (1 &lt;&lt; -exponent);}Phiên bản đầu tiên thì gọn nhẹ hơn nhưng phiên bản thứ 2 thì ít đáng sợ. Tiêu chí nào quan trọng hơn? Nói chung, làm sao để bạn quyết định cách nào để code? Định lý cơ bản về khả năng đọcSau khi học nhiều ví dụ như vậy, chúng tôi đi đến kết luận rằng có 1 số liệu cho khả năng đọc quan trọng hơn bất kì số liệu nào khác. Nó rất quan trọng và chúng tôi gọi là “Định lý cơ bản về khả năng đọc”. KEY IDEACode should be written to minimize the time it would take for someone else to understand it. Điều này có ý nghĩa gì? Theo đúng nghĩa đen, nếu bạn là 1 đồng nghiệp điển hình của chính bạn và thước đó lượng thời gian anh ta cần để đọc code và hiểu nó, thời gian hiểu được là thước đo mà bạn muốn giảm thiểu. Và khi chúng ta nói “hiểu”, chúng ta 1 biện chứng rất cao cho từ này. Đối với 1 vài người, hiểu đầy đủ code của bạn, họ nên có thể tạo ra sự thay đổi nó, tìm ra lỗi và hiểu nó tương tác như thế nào với phần còn lại của code. Bây giờ bạn có thể nghĩ, Ai quan tâm nếu người khác có thể hiểu nó? Tôi là người duy nhất sử dụng đoạn code này! Thậm chí nếu bạn là project 1 thành viên, nó cũng có giá trị để theo đuổi mục đích này. “Người nào đó” có thể là bạn 6 tháng sau, khi code của bạn nhìn lạ lẫm với bạn. Và bạn không bao giờ biết - ai đó có thể tham gia dự án của bạn, hoặc “các đoạn mã quẳng đi này” có thể được sử dụng lại ở 1 dự án khác. Is Smaller Always Better?Nói chung, bạn viết càng ít code để giải quyết vấn đề thì càng tốt (xem thêm Chapter 13, Writing Less Code).). Nó có thể mất ít thời gian hơn để hiểu 1 lớp 2000 dòng hơn là 1 lớp 5000 dòng. Nhưng ít code hơn chưa phải lúc nào cũng tốt! Có rất nhiều lần khi 1 biểu thức 1 dòng như:1assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied());Mất nhiều thời gian để hiểu hơn nếu bạn viết 2 dòng:12bucket = FindBucket(key);if (bucket != NULL) assert(!bucket-&gt;IsOccupied());Tương tự, một comment làm code của bạn có thể hiểu nhanh chóng, mặc dù nó “thêm code” vào file:12// Fast version of &quot;hash = (65599 * hash) + c&quot;hash = (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash + c;Bởi vậy, có ít dòng code hơn là 1 mục đích tốt, tối thiểu hỏa thời gian hiểu là thậm chí là 1 mục tiêu tốt hơn. Does Time-Till-Understanding Conflict with Other Goals?Bạn có thể nghĩ, những ràng buộc khác thì sao, như làm code hiệu quả hơn, kiến trúc tốt hoặc dễ dàng để test, vân vân? Những ràng buộc này có mẫu thuân với việc làm cho code dễ đọc? Chúng tôi đã tìm ra mục đích này không can thiệp quá nhiều vào tất cả. Ngay cả trong lĩnh vực mã được tối ưu hóa cao, vẫn có những cách để làm cho nó dễ đọc hơn. Và làm cho code đễ đọc hơn thường dẫn đến việc có 1 kiến trúc tốt và kiểm thử dễ dàng. Phần còn lại của cuốn sách sẽ thảo luận làm sao để áp dụng “easy to read” trong các hoàn cảnh khác nhau. Nhưng hãy nhớ rằng, khi nghi ngờ, Các định lý cơ bản về khả năng đọc bỏ qua bất kì nguyên tắc hoặc quy tắc trong cuốn sách này. Ngoai ra, một số lập trình viên có nhu cầu bắt buộc phải sửa bất kì đoạn code nào không hoàn hảo. Luôn luôn quan trọng khi bạn cần lùi lại các bước và hỏi Đoạn code này đã để đọc chưa. Nếu ổn, có thể chuyển sang đoạn code khác. The Hard PartĐúng, nó yêu cầu thêm công việc để liên tục nghĩ về việc người ngoài trong tưởng tượng khi tìm code của bạn sẽ dễ hiểu. Làm như vậy đòi hỏi phải bật 1 phần bộ não của bạn, cái mà có thể không bật trong khi code trước đó. Nhưng nếu bạn áp dụng mục đích này (như chúng tôi đang làm), chúng tôi chắc chắn rằng bạn sẽ trở thành 1 coder tốt, ít lỗi, có nhiều thứ tự hào trong công việc và tạo ra những dòng code mà ai đó xung quanh bạn sẽ yêu thích sử dụng nó. Hãy bắt đầu nào!","link":"/2020/05/24/Chapter-1-Code-Should-Be-Easy-to-Understand/"},{"title":"Chapter 12: Turning Thoughts into Code","text":"You do not really understand something unless you can explain it to your grandmother.—Albert Einstein Khi giải thích 1 ý tưởng phức tạp cho ai đó, nó dễ dàng gây mơ hồ đối với họ với 1 vài chi tiết. Nó là 1 kĩ năng có giá trị để có thể giải thích 1 ý tưởng “bằng tiếng Anh” để 1 ai đó ít sự hiểu biết hơn bạn có thể hiểu.Nó yêu cầu đặt 1 ý tưởng xuống với nhiều khái niệm quan trọng. Làm điều này không chỉ giúp người khác hiểu mà còn giúp bạn nghĩ về ý tưởng của mình rõ ràng hơn. Kĩ năng giống như vậy nên được sử dụng khi “giới thiệu” code của bạn cho người đọc. Chúng ta xem mã nguồn và nó là cách cơ bản giải thích những gì 1 chương trình đan làm. Bởi vậy, code nên viết “in plain English” (bản rõ tiếng Anh) Trong chương này, chúng tôi sẽ sử dụng quá trình đơn giản giúp bạn code rõ ràng hơn: Mô tả những thứ code cần làm, bằng tiếng Anh, như bạn muốn nói với đồng nghiệp Chú ý đến các từ khóa và cụm từ được sử dụng trong mô tả Viết code của bạn trùng với mô tả này. Describing Logic ClearlyĐây là 1 đoạn mã từ 1 trang web trong PHP. Đoạn code này ở đầu một trang bảo mật. Nó kiểm tra chỗ nào người dùng xác thực để xem được page và nếu không, lập tức trả về 1 trang lỗi quyền:1234567891011$is_admin = is_admin_request();if ($document) { if (!$is_admin &amp;&amp; ($document['username'] != $_SESSION['username'])) { return not_authorized(); }} else { if (!$is_admin) { return not_authorized(); }}// continue rendering the page ...Chỉ có 1 chút logic trong code. Như bạn đã thấy từ phần II, Simplying Loops and Logic, cây logic lớn như này không dễ để hiểu. Những logic trong đoạn code này có thể được đơn giản hóa, nhưng bằng cách nào. Hãy bắt đầu mô tả nó bằng tiếng Anh:1234There are two ways you can be authorized:1) you are an admin2) you own the current document (if there is one)Otherwise, you are not authorized.Đây là cách giải quyết thay thế theo cảm hứng mô tả này:123456789if (is_admin_request()) { // authorized} elseif ($document &amp;&amp; ($document['username'] == $_SESSION['username'])) { // authorized} else { return not_authorized();}// continue rendering the page ...Phiên bản này hơi bất thường vì nó có 2 body trống. Nhưng đoạn code này nhỏ hơn và logic đơn giản hơn bởi vì nó không có phủ định (còn cách giải quyết trước có 3 “nots”). Dòng ở dưới dễ hiểu hơn. Knowing Your Libraries HelpsChúng ta đã từng có 1 trang web bao gồm “tips box” chỉ ra những gợi ý hữu ích cho người dùng như: Tip: Log in to see your past queries. [Show me another tip!] Có vài chục lời khuyên và tất cả chúng được ẩn trong HTML:123&lt;div id=&quot;tip-1&quot; class=&quot;tip&quot;&gt;Tip: Log in to see your past queries.&lt;/div&gt;&lt;div id=&quot;tip-2&quot; class=&quot;tip&quot;&gt;Tip: Click on a picture to see it close up.&lt;/div&gt;...Khi người dùng thăm trang web, 1 trong những divs này ngẫu nhiên có thể thấy và phần còn lại vẫn ẩn. Nếu click vào lin “Show me another tip!”, nó sẽ chuyển tới tip tiếp theo. Đây là đoạn code thự thi chức năng này bằng JQuery:123456789101112var show_next_tip = function () { var num_tips = $('.tip').size(); var shown_tip = $('.tip:visible'); var shown_tip_num = Number(shown_tip.attr('id').slice(4)); if (shown_tip_num === num_tips) { $('#tip-1').show(); } else { $('#tip-' + (shown_tip_num + 1)).show(); } shown_tip.hide();};Đoạn code này okay. Nhưng nó có thể tốt hơn. Hãy bắt đầu việc mô tả, bằng từ với những gì đoạn code này cố gắng làm:123Find the currently visible tip and hide it.Then find the next tip after it and show that.If we've run out of tips, cycle back to the first tip.Dựa vào mô tả này, đây là cách khác giải quyết vấn đề:12345678var show_next_tip = function () { var cur_tip = $('.tip:visible').hide(); // find the currently visible tip and hide it var next_tip = cur_tip.next('.tip'); // find the next tip after it if (next_tip.size() === 0) { // if we've run out of tips, next_tip = $('.tip:first'); // cycle back to the first tip } next_tip.show(); // show the new tip};Cách giải quyết này ít code hơn và không phải thao tác số nguyên trực tiếp. Nó cũng liên kết nhiều hơn với cách mà 1 người sẽ nghĩ về đoạn code này Trong trường hợp này, nó giúp jQuery có 1 phương thức .next() chúng ta có thể sử dụng. Một phần của việc viết mã ngắn gọn là nhờ thư viện Applying This Method to Larger ProblemsVí dụ trước có đã áp dụng cho quá trình xử lý các khối code nhỏ. Trong ví dụ tiếp theo, chúng tôi sẽ áp dụng nó với các hàm lớn hơn. Như bạn sẽ thây, cách thức này có thể giúp bạn phá vỡ code bằng cách giúp bạn nhận định các phần code bạn có thể phá vỡ. Tưởng tượng chúng ta có 1 hệ thống ghi lại việc mua bán cổ phiếu. Mỗi phiên có 1 phần sau:• time (a precise date and time of the purchase)• ticker_symbol (e.g., GOOG)• price (e.g., $600)• number_of_shares (e.g., 100) Vì 1 ví do nào đó, dữ liệu được trải rộng ra 1 bảng cơ sở dữ liệu, như minh họa. Với mỗi database, time là khóa chính duy nhất: Bây giờ, chúng tôi cần viết 1 hương trình join 3 bảng này lại với nhau (Sử dụng toán tử JOIN trong SQL). Bước này đơn giản vì các hàng đã được sắp xếp theo time, nhưng không may, một vài cột đã bị mất. Bạn muốn tìm tất cả các hàng với 1 times trùng nhau và bỏ qua 1 vài hàng không được xép, như bạn có thể thấy ở phần dưới Đây là đoạn code Python tìm kiếm tất cả các hàng trùng nhau:123456789101112131415161718192021222324252627282930313233def PrintStockTransactions(): stock_iter = db_read(&quot;SELECT time, ticker_symbol FROM ...&quot;) price_iter = ... num_shares_iter = ... # Iterate through all the rows of the 3 tables in parallel. while stock_iter and price_iter and num_shares_iter: stock_time = stock_iter.time price_time = price_iter.time num_shares_time = num_shares_iter.time # If all 3 rows don't have the same time, skip over the oldest row # Note: the &quot;&lt;=&quot; below can't just be &quot;&lt;&quot; in case there are 2 tied-oldest. if stock_time != price_time or stock_time != num_shares_time: if stock_time &lt;= price_time and stock_time &lt;= num_shares_time: stock_iter.NextRow() elif price_time &lt;= stock_time and price_time &lt;= num_shares_time: price_iter.NextRow() elif num_shares_time &lt;= stock_time and num_shares_time &lt;= price_time: num_shares_iter.NextRow() else: assert False # impossible continue assert stock_time == price_time == num_shares_time # Print the aligned rows. print &quot;@&quot;, stock_time, print stock_iter.ticker_symbol, print price_iter.price, print num_shares_iter.number_of_shares stock_iter.NextRow() price_iter.NextRow() num_shares_iter.NextRow()Đoạn code này hoạt động, nhưng có quá nhiều thứ đang diễn ra với vòng lặp bỏ qua các hàng không trùng. Một số cờ cảnh báo có thể đã tóm tắt trong đầu bạn: Liệu có thể bỏ mất 1 số hàng? Nó có thể đọc đến cuối của vòng lặp không? Vậy chúng ta có thể làm cho nó dễ đọc hơn? An English Description of the SolutionMột lần nữa, hãy lùi lại và mô tả chúng bằng tiếng Anh những thử chúng ta thử làm: We are reading three row iterators in parallel. Whenever the rows’ times don’t line up, advance the rows so they do line up. Then print the aligned rows, and advance the rows again. Keep doing this until there are no more matching rows left. Nhìn lại code ban đầu, phần lộn xộn nhất trong giao dịch khối “advance the rows so they do line up.”. Để trình bày đoạn mã rõ ràng hơn, chúng ta trích xuất tất cả các logic lộn xộn vào trong 1 hàm mới với tên là AdvanceToMatchingTime(). Và đây là phiên bản code mới, sử dụng hàm này:12345678910111213141516171819def PrintStockTransactions(): stock_iter = ... price_iter = ... num_shares_iter = ... while True: time = AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter) if time is None: return # Print the aligned rows. print &quot;@&quot;, time, print stock_iter.ticker_symbol, print price_iter.price, print num_shares_iter.number_of_shares stock_iter.NextRow() price_iter.NextRow() num_shares_iter.NextRow()Như bạn có thể nhìn thấy, đoạn code này dễ hiểu hơn, chúng ta đã ẩn tất cả những code chi tiết bẩn thỉu của việc xếp các hàng đi Applying the Method RecursivelyDễ dàng để tưởng tượng bạn sẽ viết AdvanceToMatchingTime() như thế nào - trong trường hợp tệ nhất, nó sẽ nhìn tương tự như khối code trong phiên bản đầu tiên:123456789101112131415161718192021def AdvanceToMatchingTime(stock_iter, price_iter, num_shares_iter): # Iterate through all the rows of the 3 tables in parallel. while stock_iter and price_iter and num_shares_iter: stock_time = stock_iter.time price_time = price_iter.time num_shares_time = num_shares_iter.time # If all 3 rows don't have the same time, skip over the oldest row if stock_time != price_time or stock_time != num_shares_time: if stock_time &lt;= price_time and stock_time &lt;= num_shares_time: stock_iter.NextRow() elif price_time &lt;= stock_time and price_time &lt;= num_shares_time: price_iter.NextRow() elif num_shares_time &lt;= stock_time and num_shares_time &lt;= price_time: num_shares_iter.NextRow() else: assert False # impossible continue assert stock_time == price_time == num_shares_time return stock_timeNhưng hãy cải thiện đoạn code này bằng cách cách làm của chúng ta với AdvanceToMatchingTime(). Đây là mô tả những thử hàm này cần làm:123Look at the times of each current row: if they're aligned, we're done.Otherwise, advance any rows that are &quot;behind.&quot;Keep doing this until the rows are aligned (or one of the iterators has ended).Mô tả này rõ ràng và thanh lịch hơn đoạn code trước. Một thứ nhận ra là mô tả này không bao giờ nhắc đến stock_iter hoặc các chi tiết khác cụ thể cho vấn đề của chúng tôi. Điều đó có nghĩa chúng tôi có thể đổi tên biến thành đơn giản và tổng quát hơn. Đây là kết quả code: 123456789101112131415def AdvanceToMatchingTime(row_iter1, row_iter2, row_iter3): while row_iter1 and row_iter2 and row_iter3: t1 = row_iter1.time t2 = row_iter2.time t3 = row_iter3.time if t1 == t2 == t3: return t1 tmax = max(t1, t2, t3) # If any row is &quot;behind,&quot; advance it. # Eventually, this while loop will align them all. if t1 &lt; tmax: row_iter1.NextRow() if t2 &lt; tmax: row_iter2.NextRow() if t3 &lt; tmax: row_iter3.NextRow() return None # no alignment could be found Như bạn có thể thấy, đoạn code này rõ ràng hơn trước rất nhiều. Thuật toán trở nên đơn giản hơn và bât giờ có ít hơn các phép so sánh, Và chúng ta đã sử dụng tên ngắn hơn như t1 và không phảo nghĩ về các cột cụ thể database liên quan. SummaryChương này thảo luận về các kĩ thuật đơn giản để mô tả chương trình của bạn bằng tiếng Anh và sử dụng mô tả này giúp bạn viết code 1 cách tự nhiên. Kĩ thuật này đơn giản nhưng rất công hiệu. Nhìn vào các từ và cụm từ được sử dụng trong mô tả có thể giúp bạn tìm ra các vấn đề con và ngắn chúng ra. Nhưng quá trình “saying things in plain English” đơn giản là áp dụng bên ngoài việc viết code. Ví dụ, 1 chính sách của phòng thí nghiệm máy tính, khi sinh viên cần gỡ lỗi chương trình của anh ấy, đầu tiên anh ấy phải giải thích vấn đề đến 1 con gấu bông chuyên dụng ở góc phòng. Thật ngạc nhiên, chỉ mô tả vấn đề phát ra thành tiếng có thể giúp sinh viên tìm ra giải pháp. Kỹ thuật này được gọi là “rubber ducking” - vịt cao su. Một cách khác để nhìn việc này: nếu bạn không thể mô tả vấn đề hoặc các ý định của bạn bằng từ, 1 vài thứ có thể quên hoặc chưa xác định. Bắt 1 chương trình (hoặc 1 vài ý tưởng) thành từ ngữ có thể thực sự bắt buộc nó thành hình (shape).","link":"/2020/05/24/Chapter-12-Turning-Thoughts-into-Code/"},{"title":"Chapter 13: Writing Less Code","text":"Biết khi nào không viết code có khả năng là kĩ năng quan trọng nhất 1 lập trình viên có thể học. Mỗi dòng code bạn viết là 1 dòng cần phải kiểm thử và bảo trì. Bằng cách sử dụng lại các thư viện hoặc loại bỏ các tính năng, bạn có thể tiết kiện thời gian và giữ codebase của bạn mỏng và có ý nghĩa. KEY IDEA The most readable code is no code at all. Don’t Bother Implementing That Feature—You Won’t Need ItKhi bạn bắt đầu 1 project, về lẽ tự nhiên sẽ rất hào hứng và nghĩ về tất cả các chức năng cool ngầu bạn sẽ làm. Nhưng lập trình viên có xu hướng đánh giá quá cao có bao nhiêu chức năng thực sự thiết yếu cho project của họ. Rất nhiều các chức năng chưa hoàn thành hoặc không hữu ích hoặc chỉ làm phức tạp thêm cho ứng dụng. Lập trình viên cũng có xu hướng đánh giá thấp họ cần bao nhiêu effort để thực thi 1 chức năng. Chúng ta ước lượng lạc quan thời gian cần có thực thi một chức năng nguyên mẫu nhưng quên thời gian thêm liên quan đến việc bảo trì, viết tài liệu và thêm “weight” đến codebase. Question and Break Down Your RequirementsKhông phải tất cả các lập trình viên đề cần nhanh, 100% chính xác, và có thể xử lý mọi đầu vào có thể. Nếu bạn thực sự xem xét kĩ lưỡng yêu cầu của mình, đôi khi bạn có thể thấy 1 số vấn đề đơn giản mà yêu cầu ít code hơn. Hãy xem xét 1 vài ví dụ đưới đây. Example: A Store LocatorGiả sử bạn đang viết 1 chương trình “định vị cửa hàng” để kinh doanh. Bạn nghĩ rằng các yêu cầu là: For any given user’s latitude/longitude, find the store with the closest latitude/longitude. Nhận đầu vào là kinh độ vĩ độ từ người dùng, tìm cửa hàng có kinh độ, vĩ độ gần nhất Để thực thi với 100% chính xác, bạn cần xử lý: Khi địa điểm nằm ở 2 bên của International Date Line Khi địa điểm gần Bắc Cực hoặc Nam Cực Điều chỉnh độ cong của Trái Đất, như thay đổi “tính toán theo chiều dọc trên mỗi dặm” Xử lý tất cả các trường hợp trên yêu cầu một số tiền hợp lý =)) Tuy nhiên, đối với ứng dụng của bạn, chỉ có 30 cửa hàng ở bang Texas. Trong 1 khi vực khỏ hơn, 3 vấn đề trong danh sách không quan trọng. Và như là kết quả, bạn có thể giảm yêu cầu thành For a user near Texas, find (approximately) the closest store in Texas. Giải quyết vấn đề này dễ dàng hơn vì bạn có thể thoát khỏi chỉ vòng lặp với mỗi cửa hàng và tính toán khoảng cách Euclidean giữa kinh độ/vĩ độ Example: Adding a CacheChúng tôi đã từng có 1 ứng dụng Java thường xuyên đọc các objects thật từ đĩa. Tốc độ của ứng dụng bị giới hạn bởi cách đọc này, do đó chúng tôi cần caching 1 vài thứ. Một thứ tự chung đọc sẽ như sau:12345678read Object Aread Object Aread Object Aread Object Bread Object Bread Object Cread Object Dread Object DNhư bạn có thể nhìn thấy, có rất nhiều các truy cập lặp lại với các đối tượng giống nhau do đó cache có thể hữu ích cho trường hợp này. Khi đối mặt với vấn đề này, bản năng đầu tiên của chúng ta là sử dụng cache. Chúng ta không có 1 thư viện khả dụng, dó đó chúng tôi phải tự thực thi. Điều này không phải là vấn đề mặc dù, do chúng ta đã thực thi với kiểu cấu trúc như vậy trước đó (nó liên quan cả 1 hash table và 1 danh sách liên kết đơn - có thể tổng cộng 100 dòng code). Tuy nhiên, chúng tôi nhận thấy rằng việc truy cập từng hàng có thể luôn luôn cho mỗi hàng. Do đó thay vì thực thi URL cache, chúng ta sẽ thực thi one-item cache:1234567DiskObject lastUsed; // class memberDiskObject lookUp(String key) { if (lastUsed == null || !lastUsed.key().equals(key)) { lastUsed = loadDiskObject(key); }}Điều này cho chúng ta 90% lợi ích mà không cần quá nhiều code, và chương trình có bộ nhớ nhỏ hơn. Lợi ích của việc “xóa bỏ yêu cầu” và “giải quyết các vấn đề đơn giản hơn” không thể được nói quá. Yêu cầu thường xem kẽ với nhau theo 1 cách tinh tế. Điều này có nghĩa là việc giải quyết một nửa vấn đề có thể chỉ mất một phần tư nỗ lực code. Keeping Your Codebase Small Khi bạn bắt đầu 1 dự án phần mềm và bạn chỉ có 1 hoặc 2 files gốc, điều này thật tuyệt. Biên dịch và chạy code là 1 snap, dễ dàng thay đổi và dễ dàng nhơ mỗi hàm, lớp được định nghĩa. Sau đó, project phát triển, các thư mục của bạn càng ngày càng nhiều files hơn. Bạn cần nhiều thư mục để tổ chức lại chúng. Nó trở nên khó nhớ hơn các hàm gọi các hàm khác và mất nhiều việc hơn để theo dõi ra được bug. Cuối cùng, bạn có rất nhiều mã nguồn được trải rộng vào nhiều thư mục khác nhau. Dự án sẽ lớn và và không còn 1 mình ai hiểu tất cả nó. Thêm chức năng mới trở thành cái gì đó đau đớn và làm việc với các đoạn code này thì cồng kềnh và khó chịu. Cách tốt nhất để đối phó là giữ codebase của bạn nhỏ và nhẹ kí (lightweight) nhất có thể, thậm chí dự án của bạn lớn dần. Vì vậy bạn nên: Tạo nhiều code “tiện ích” chung nhất cỏa thể để loại bỏ lặp lại code (Xem thêm chương 10, Extracting Unrelated Subproblems) Xóa các code không hữu ích hoặc chức năng không sử dụng Giữ dự án của bạn ngăn cách với các dự án con đã ngắt kết nối (các dự án không kết nối với nhau thì nên tách biệt) Nói chung là, có ý thức về “weight” của codebase. Giữ nó nhẹ và nhanh. REMOVING UNUSED CODE Người làm vườn thường tỉa cây để giữ chúng sống và lớn lên. Tương tự, đây cũng là 1 ý tưởng tốt để tỉa 1 vài đoạn code không sử dụng, cải mà làm cản trở. Một khi code đã được viết ra, coders thường không thích, phân vân xóa nó, vì nó diễn tả rất nhiều công việc thực tế. Để nó xóa, cũng đồng nghĩa với việc thời gian giành cho nó là lãng phí. Well, hãy vượt qua nó! Đây là 1 lĩnh vực sáng tạo - thợ chụp ảnh, nhà văn và nhà làm phim không giữ tất cả công việc của họ. Xóa các hàm cô lập là đơn giản nhưng đôi khi “các đoạn code không sử dụng” thực tế kết hợp với nhau trong dự án của bạn, mà bạn không biết. Đây là 1 vài ví dụ: Bạn thiết kế ban đầu hệ thống của bạn để xử lý các tập tin quốc tế, và bây giờ đoạn code xả ra các vấn đề về convention. Tuy nhiên, đoạn code không đầy đủ chức năng và ứng dụng của bạn không bao giờ sử dụng với tập tin quốc tế dù sau đi nữa?Tại sao bạn không xóa những hàm này? Bạn muốn chương trình của bạn làm việc ngay cả khi hệ thống hết bộ nhớ, do đó bạn có rất nhiều logic thông minh để cố gắng khôi phục các vấn đề out-of-memory. Đó là 1 ý tưởng tốt nhưng trên thực tế, khi hệ thống tràn bộ nhớ, chương trình của bạn chỉ trở thành 1 zombie không ổn định - tất cả các chức năng chính không sử dụng được và có thể chỉ 1 click chuột là oẳng. Tại sao bạn không chấm dứt chương trình luôn với 1 thông báo đơn giản “Hệ thống đã tràn bộ nhớ, xin lỗi” và xóa tất cả các code out-of-memory? Be Familiar with the Libraries Around You: Làm quen với các thư viện xung quanh bạnRất nhiều thời gian, các lập trình viên không nhận thức được rằng các thư viện đã tồn tại có thể giải quyết được vấn đề của họ. Hoặc thỉnh thoảng họ quên mất rằng 1 thư viện có thể làm gì. Rất quan trọng để biết kahr năng code thư viện bạn cùng có thể làm gì để bạn có thể sử dụng nó hiệu quả. Đây là một gợi ý nhã nhặn: thỉnh thoảng, hãy dành ra 15 phút đọc tên và tất cả các hàm/modules/kiểu trong thư viện tiểu chuẩn của bạn. Điều này bao gồm thư viện Standard Template Library (STL) trong C++, Java API, các build-in Python modules và 1 vài cái khác. Mục đích không phải nhớ tất cả thư viện. Nó chỉ cho bạn cảm giác có những thứ gì đó đã có, để trong lần tới bạn làm việc với các đoạn code mới, bạn sẽ nghĩ “Chờ chút, cái này nghe tương tự như cái mèo gì đó tôi đã thấy ở 1 API …”. Chúng tôi tin bằng làm công việc này sẽ có hiệu quả nhanh chóng vì bạn sẽ có xu hướng sử dụng nhiều hơn thư viện này trong lần nhìn đầu tiên. Example: Lists and Sets in PythonGiả sử bạn có 1 danh sách phần tử Python (như [2,1,2]) và bạn muốn danh sách các phần tử là duy nhất (trong trường hợp này là [2,1]). Bạn có thể thực thi phần này như sau:1234567def unique(elements): temp = {} for element in elements: temp[element] = None # The value doesn't matter. return temp.keys() unique_elements = unique([2,1,2])Nhưng thay vào đó bạn có thể chỉ sử dụng kiểu set ít được biết đến:1unique_elements = set([2,1,2]) # Remove duplicatesĐối tượng này lặp đi lặp lại, chỉ như 1 list bình thường. Nếu bạn muốn lại một danh sách, bạn có thể chỉ sử dụng:1unique_elements = list(set([2,1,2])) # Remove duplicatesRõ ràng set là một công cụ tốt cho công việc này. Nhưng nếu bạn không biết kiểu set, bạn phải tự thực thi hàm unique() như trên. Why Reusing Libraries Is Such a Win?Một thống kê thường được trích dẫn là trung bình kĩ sư phần mềm tạo ra 10 dòng code có thể chuyển đổi trong 1 ngày. Khi lần đầu tiên các lập trình viên nghe thấy điều này, họ có thể biện hộ “10 dòng code? Tôi có thể viết trong 1 phút!”. Từ khóa ở đây là có thể chuyển đổi. Mỗi dòng code trong thư viện đã được đầu tư để thiết kế, debugging, viết lại, xây dựng tài liệu, tối ưu và test. Đó là lý do tại sao sử dụng lại thư viện lại là 1 chiến thắng, trong khi nó vừa tiết kiệm thời gian mà lại vừa viết code ít hơn. Example: Using Unix Tools Instead of CodingKhi một ứng dụng web thường xuyên trả về mã HTTP 4xx hoặc 5xx, nó là 1 dấu hiệu của vấn đề ngầm (4xx là client error và 5xx là server error). Do đó chúng tôi muốn viết 1 chương trình có thể chuyển 1 logs địa chỉa của web server và xác định xem URLs nào gây ra nhiều lỗi. Phần truy cập log đó cơ bản nhìn như sau:12341.2.3.4 example.com [24/Aug/2010:01:08:34] &quot;GET /index.html HTTP/1.1&quot; 200 ...2.3.4.5 example.com [24/Aug/2010:01:14:27] &quot;GET /help?topic=8 HTTP/1.1&quot; 500 ...3.4.5.6 example.com [24/Aug/2010:01:15:54] &quot;GET /favicon.ico HTTP/1.1&quot; 404 ......Nói chung là chúng chứa những dòng với form:1browser-IP host [date] &quot;GET /url-path HTTP/1.1&quot; HTTP-response-code ...Viết 1 chương trình để tìm kiếm url-path với nhiều lỗi 4xx hoặc 5xx nhất khá dễ dàng, chỉ mất tầm 20 dòng code trong ngôn ngữ như C++ hoặc Java. Thay vì đó, trên Unix, bạn có thể gõ câu lệnh sau:12cat access.log | awk '{ print $5 &quot; &quot; $7 }' | egrep &quot;[45]..$&quot; \\| sort | uniq -c | sort -nrVà đây là output:1234595 /favicon.ico 40413 /help?topic=8 50011 /login 403...&lt;count&gt; &lt;path&gt; &lt;http response code&gt;Dòng lệnh này thật tuyệt và chúng ta tránh được viết một và code “thật” hoặc kiểm tra 1 điều gì đó trong code. SummaryAdventure, excitement—a Jedi craves not these things._Yoda Chương này nói về việc viết ít code mới nhất có thể. Mỗi dòng code mới cần được kiểm thử, xây dựng tài liệu và bảo trì. Thêm nữa, nhiều code trong codebase, sự “nặng nề” nó nhận vào và làm khó để phát triển hơn. Bạn có thể tránh viết những dòng code mới theo 1 số cách: Loại bỏ các chức năng không quan trọng từ sản phẩm của bạn Xem xét lại các yêu cầu để giải quyết theo phiên bản dễ nhất của vấn đề mà vẫn xong được công việc. Làm quen với các thư viện chuẩn bằng cách đọc định kì toàn bộ các APIs của chúng","link":"/2020/05/24/Chapter-13-Writing-Less-Code/"},{"title":"Chapter 6: Making Comments Precise and Compact","text":"Trong chương trước, chúng ta có nói về cái mà chúng ta nên comment (what). Trong chương này, sẽ nói về cách viết comment rõ ràng và gọn nhẹ Nếu bạn đang định viết 1 comment, nó nên được tóm lược (tỉ mỉ) - cụ thể và chi tiết nhất có thể. Mặt khác, comments cũng chiếm thêm không gian màn hình, mất thời gian để đọc. Do vậy, comment cũng nên được gọn nhẹ K E Y I D E AComments should have a high information-to-space ratio. Keep Comments CompactĐây là 1 ví dụ về comment khi định nghĩ kiểu trong C++ 1234// The int is the CategoryType.// The first float in the inner pair is the 'score',// the second is the 'weight'.typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap; Nhưng tại sao sử dụng 3 dòng để giải thích nó trong khi bạn có thể chú thích, minh họa nó chỉ trong 1 dòng12// CategoryType -&gt; (score, weight)typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap;Một vài comments cần 3 dòng, nhưng đây không phải là 1 trong số đó. Avoid Ambiguous Pronouns: Tránh sử dụng đại từ mơ hồTránh sử dụng các từ mà người đọc mấy thêm thời gian để “giải quyết” 1 từ. Và trong 1 vài trường hợp, nó không rõ ràng cái “it” hoặc “this” đang tham chiếu đến. Ví dụ:1// Insert the data into the cache, but check if it's too big first.Trong comment này, “it” nên được tham chiếu tới data hoặc cache. Bạn có thể tìm ra câu trả lời bằng cách đọc phần còn lại của mã. Nhưng nếu bạn phải làm vậy, comment ở đây làm gì? Điều an toàn nhất là điền luôn các thông tin khi có sự mật mờ này. Trong ví dụ trước “it” đang là “the data”:1// Insert the data into the cache, but check if the data is too big first.Rất dễ dàng để thay đổi. Bạn cũng có thể đã chỉnh lại cú pháp câu văn để làm “it” rõ ràng hoàn hảo:1// If the data is small enough, insert it into the cache. Polish Sloppy SentencesTrong 1 vài trường hợp, tạo 1 comment chính xác hơn luôn đi đôi với việc làm cho nó nhỏ gọn. Đây là 1 ví dụ từ web crawler:1# Depending on whether we've already crawled this URL before, give it a different priority.Cây này nhìn có vẻ okay, nhưng so sánh thử với phiên bản sau:1# Give higher priority to URLs we've never crawled before.Câu văn đơn giản, nhỏ gọn và thẳng thắn. Nó cũng giải thích rằng sự ưu tiên cao hơn là nhận 1 URLs chưa crawled - comment trước đó không chứa thông tin này. Describe Function Behavior Precisely: Mô tả chính xác hành vi của hàmTưởng tượng bạn chỉ viết 1 hàm đếm số dòng của 1 file:12// Return the number of lines in this file.int CountLines(string filename) { ... }Comment không tỉ mỉ - có rất nhiều cánh để định nghĩa 1 “dòng”. Đây là 1 cái trường hợp liên quan tôi có thể nghĩ tới: “” (dòng trống) - 0 hay 1 dòng? “hello”: 0 hay 1 dòng? “hello\\n” - 1 hay 2 dòng? “hello\\n world” - 1 hay 2 dòng? “hello\\n\\r cruel\\n world\\r” - 2,3 hay 4 dòng Sự thực thi đơn giản là đếm số dòng qua kí tự dòng mới (\\n) (đây là cách mà lệnh wc của Unix làm việc). Ở đây 1 comment tốt hơn là trùng với sự thực hiện:12// Count how many newline bytes ('\\n') are in the file.int CountLines(string filename) { ... }Comment này không quá dài hơn so với phiên bản trước đó nhưng chứa nhiều thông tin hơn. Nó nói với người đọc rằng hàm sẽ trả về không nếu không có kí tự xuống dòng. Nó cũng nói với người đọc rằng kí tự (\\r) cũng không được tính là dòng mới. Use Input/Output Examples That Illustrate Corner CasesKhi bạn viết 1 comment, ví dụ lựa chọn 1 input/ouput cẩn thận có thể có thể giá trị như 1 nghìn từ. Ví dụ, đây là 1 hàm chung xóa đi 1 phần của string:12// Remove the suffix/prefix of 'chars' from the input 'src'.String Strip(String src, String chars) { ... }Comment này không cụ thể tỉ mỉ vì nó không thể trả lời được câu hỏi như: Kí tự này là cả 1 chuỗi con được xóa bỏ hay thực sự chỉ là 1 tập hợp các chữ cái không có thứ tự? Chuyện gì sẽ xảy ra nếu có nhiều kí tự chars trong cuối cùng của src Thay vì đó, một ví dụ với các sự lựa chọn đầy đủ sẽ trả lời các câu hỏi này:123// ...// Example: Strip(&quot;abba/a/ba&quot;, &quot;ab&quot;) returns &quot;/a/&quot;String Strip(String src, String chars) { ... }Ví dụ chỉ ra đầy đủ chức năng của hàm Strip(). Chú ý rằng 1 ví dụ đơn giản không thực sự hữu ích, nếu bạn không trả lời được những câu hỏi này:1// Example: Strip(&quot;ab&quot;, &quot;a&quot;) returns &quot;b&quot;Đây là 1 ví dụ khác để minh họa:123// Rearrange 'v' so that elements &lt; pivot come before those &gt;= pivot;// Then return the largest 'i' for which v[i] &lt; pivot (or -1 if none are &lt; pivot)int Partition(vector&lt;int&gt;* v, int pivot);Comment này thực sự đủ tỉ mỉ, chi tiết nhưng có 1 chút khó khăn để hình dung. Đây là 1 ví dụ bạn có thể minh họa thêm:123// ...// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1int Partition(vector&lt;int&gt;* v, int pivot);Có 1 vài điểm cần nhắc tới khi chỉ định ví dụ input/ouput chúng ta chọn: pivot bằng cách phần tử trong vector để minh họa trường hợp canh đó Chúng ta đặt sự trùng lặp trong vector (8) để minh họa rằng đây là 1 input được chấp nhận. Vector kết quả không được sắp xếp - nếu nó được, người đọc có thể hiểu sai Vì giá trị trả về là 1, chúng ta đảm bảo rằng 1 không phải là 1 giá trị trong vector - cái mà có thể gây nhầm lẫn. State the Intent of Your CodeNhư chúng ta đã nhắc tới từ chương trước, comment thường nói cho người đọc cái mà chúng ta nghĩ khi chúng ta viết code. Không may, rất nhiều comment cuối cùng chỉ mô tả cái mà code đang làm theo nghĩa đen, mà không có thêm nhiều thông tin hữu ích Đây là 1 ví dụ comment như vậy:1234567void DisplayProducts(list&lt;Product&gt; products) { products.sort(CompareProductByPrice); // Iterate through the list in reverse order for (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); it != products.rend(); ++it) DisplayPrice(it-&gt;price); ...}Tất cả những thứ trong comment chỉ đang diễn tả cho dòng bên dưới nó. Thay vào đó, cân nhắc 1 commnent tốt hơn:12// Display each price, from highest to lowestfor (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); ... )Comment này giải thích cái mà chương trình đang làm ở tầng ca hơn. Điều này phù hợp hơn nhiều với những gì lập trình viên đã nghĩ khi cô ấy viết mã. Một điều thú vị, có 1 bug trong chương trình này! Hàm CompareProductByPrice đã sắp xếp các items giá cao đầu tiên. Đoạn code đang làm ngược với những gì tác giả dự định. Đây là 1 lý do tốt tại sao tham số thứ 2 lại quan trọng. Mặc dù bug, comment đầu tiên rất đúng kĩ thuật (vòng lặp không lặp theo thứ tự ngược lại). Nhưng với comment thứ 2, người đọc nhiều khả năng nhận thấy rằng ý đồ của người viết (đầu tiên là đưa ra items giá cao) mâu thuẫn với cách mà code đang làm. Trong thực tế, các comment hoạt động như 1 kiểm tra dự phòng (sẽ được đề cập trong chương 14) “Named Function Parameter” CommentsGiả sử bạn nhìn thấy 1 hàm như:1Connect(10, false);Hàm này gọi cái gì đó bí ẩn với số integer và boolean truyền vào. Trong ngôn ngữ như Python, bạn có thể gán đối số truyền vào bằng tên123def Connect(timeout, use_encryption): ...# Call the function using named parametersConnect(timeout = 10, use_encryption = False)Không giống như C++ và Java, bạn không thể làm vậy. Tuy nhiên, bạn có thể sử dụng comment inline để có được hiệu quả tương tự:123void Connect(int timeout, bool use_encryption) { ... }// Call the function with commented parametersConnect(/* timeout_ms = */ 10, /* use_encryption = */ false);Nhận thấy rằng chúng ta đã “đặt tên” cho tham số đầu tiên là timeout_ms thay vì timeout. Lý tưởng nhất, đối số của hàm thực sự nên là timeout_ms, nhưng nếu vì 1 số lý do nào đó chúng ta không thể thay đổi nó, thì đây là 1 cách tiện dụng để “cải thiện” tên. Khi bạn có đối số boolean, thực sự quan trọng để đặt /* name = */ trước giá trị. Đặt 1 comment đằng sau giá trị là rất khó hiểu:1234// Don't do this!Connect( ... , false /* use_encryption */);// Don't do this either!Connect( ... , false /* = use_encryption */);Trong ví dụ trên, không rõ ràng là false là sử dụng mã hóa hay không sử dụng mã hóa. Đa số các hàm không cần comment như vậy, nhưng nó là một cách tiện dụng (và gọn nhẹ) để giải thích các đối số trông có vẻ bí ẩn. Use Information-Dense Words: Sử dụng các từ “nặng thông tin”, các từ mọi người lập trình đều hiểu.Một khi bạn đã lập trình được 1 vài năm, bạn nhận thấy rằng vấn đề và giải pháp chung tương tự xuất hiện nhiều lần. Thường xuyên, sẽ có 1 vài từ hoặc cụm từ được các developers mô tả trong các mẫu/thành ngữ này. Sử dụng những từ này làm comment của bạn ngắn gọn hơn. Ví dụ giả sử commen của bạn như sau:1234// This class contains a number of members that store the same information as in the// database, but are stored here for speed. When this class is read from later, those// members are checked first to see if they exist, and if so are returned; otherwise the// database is read from and that data stored in those fields for next time.Thay vào đó, bạn chỉ cần nói:1// This class acts as a caching layer to the database.Một ví dụ khác, comment như1234// Remove excess whitespace from the street address, and do lots of other cleanup// like turn &quot;Avenue&quot; into &quot;Ave.&quot; This way, if there are two different street addresses// that are typed in slightly differently, they will have the same cleaned-up version and// we can detect that these are equal.Có thể thay thế:1// Canonicalize the street address (remove extra spaces, &quot;Avenue&quot; -&gt; &quot;Ave.&quot;, etc.)Có rất nhiều từ và cụm từ chứa nhiều thông tin có nghĩa, như là “heuristic”, “brute force”, “naive solution” và tương tự. Nếu bạn có 1 comment cảm thấy hơi dài dòng, tìm xem nó có thể được mô tả như 1 vấn đề lập trình kinh điển. SummaryChương này thảo luận về viết comment đóng gói nhiều thông tin trong một không gian nhỏ nhất có thể. Đây là 1 vài tips Tránh các từ “it”, “this” khi chúng ta có thể tham chiếu tới 1 vài thứ Mô tả hành vi của hàm càng chi tiết thì càng tiện lợi Minh họa comment của bạn với ví dụ lựa chọn input/ouput cẩn thận Nêu ra ý định ở level cao thay vì chi tiết thực hiện bên dưới Sử dụng các comments inline (e.g., Function(/ arg = / … ) ) để giải thích các tham số mơ hồ của 1 hàm Giữ comment của bạn ngắn gọn bằng các từ với nhiều nghĩa.","link":"/2020/05/24/Chapter-6-Making-Comments-Precise-and-Compact/"},{"title":"[Circle CI] Auto deploying ứng dựng trên Google Cloud","text":"Bài viết sẽ giải thích các tham số để có thể auto deploy 1 project lên Google Cloud. Các bước cụ thể hãy đọc theo Quickstart vì nó khá đơn giản Để tự động deploy được thì tài liệu đang sử dụng deploy trên Google Kubernetes Engine. Các App Engine hay Compute Engine có được hay không thì tác giả không rõ Project Demo: https://github.com/CircleCI-Public/circleci-demo-k8s-gcp-hello-app Docs: https://circleci.com/docs/2.0/deployment-integrations/#google-cloud 0. Yêu cầuBạn có thể tự deploy thủ công ứng dụng với Google Kubernetes Engine, ít nhất cũng theo hướng dẫn nàyhttps://cloud.google.com/kubernetes-engine/docs/quickstart 1. Giải thích các tham số cấu hình GCLOUD_SERVICE_KEY: &lt;base64-encoded GCP service account key value&gt; Đây là giá trị mã hóa base-64 file JSON chứa key của service accout của bạn. Copy giá trị trong file auth.json đó và đưa lên trang https://www.base64encode.org/ lấy nội dung cho vào biến này. GOOGLE_PROJECT_ID: e.g. hello-app-12345 GOOGLE_CLUSTER_NAME: e.g. cluster-1 (the cluster will be created if it doesn’t yet exist) GOOGLE_COMPUTE_ZONE: e.g. us-central1-a DOCKER_IMAGE_NAME: e.g. gcr.io/hello-app-12345/hello-app (should match project id) Giá trị hellp-app-12345 đó là project id Tham khảo thêm tại đây1docker push [HOSTNAME]/[PROJECT-ID]/[IMAGE] DELETE_CLUSTER_AT_END_OF_TEST: true|false (If set to true, the deployment’s resources including the cluster named by GOOGLE_CLUSTER_NAME will be deleted after the test. This will prevent unwanted charges incurring on your GCP account) 2. Giải thích CircleCI configNội dung file config: https://github.com/CircleCI-Public/circleci-demo-k8s-gcp-hello-app/blob/master/.circleci/config.yml 2.1. Build Jobsname: Generate full image name for new docker imagePhần này chắc không cần giải thích đâu nhỉ, nó chỉ là sinh tên cho docker image Tên này được lưu vào biến full_docker_image_name name: Build imageBuild image xây dựng được từ bước trên. name: Push image1echo $GCLOUD_SERVICE_KEY | base64 --decode --ignore-garbage &gt; gcloud-service-key.json Lấy nội dung biến env GCLOUD_SERVICE_KEY đã mã hóa base 64 ở trên, nội dung file JSON được sinnh từ Google Cloud lưu vào file mới với tên gcloud-service-key.json12gcloud auth activate-service-account --key-file gcloud-service-key.jsongcloud --quiet auth configure-dockerTiếp theo là gcloud xác thực user và config docker thôi. Chi tiết: https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account https://cloud.google.com/sdk/gcloud/reference/auth/configure-docker name: Test local imageBật (run) docker 2.2. Deploy Jobsname: DeployĐây là các việc cần làm khi thủ công để tiến hành deploy 1 project len Google Cloud. Để deploy tự động được, bạn phải sử dụng Kubernetes Engine Các lệnh trong Jobs này thực hiện tương tự GKE Quickstart Đầu tiên sẽ là xác thực và cấu hình project id, zone với gcloud123gcloud auth activate-service-account --key-file gcloud-service-key.jsongcloud --quiet config set project $GOOGLE_PROJECT_IDgcloud --quiet config set compute/zone $GOOGLE_COMPUTE_ZONEBước tiếp theo là tạo hoặc kết nối với GKE cluster:12345678EXISTING_CLUSTER=$(gcloud container clusters list --format=&quot;value(name)&quot; --filter=&quot;name=$GOOGLE_CLUSTER_NAME&quot;)if [ &quot;${EXISTING_CLUSTER}&quot; != $GOOGLE_CLUSTER_NAME ]then # Create cluster if it doesn't already exist gcloud --quiet container clusters create $GOOGLE_CLUSTER_NAME --num-nodes=1else gcloud --quiet container clusters get-credentials $GOOGLE_CLUSTER_NAMEfiTiếp theo là: Deploying an application to the cluster:1234FULL_DOCKER_IMAGE_NAME=$(cat workspace/full_docker_image_name)# Replace DOCKER_IMAGE_NAME placeholder in manifest with actual image nameKUBE_CONFIG=$(cat hello-app/manifests/helloweb-all-in-one.yaml.template | sed &quot;s|DOCKER_IMAGE_NAME|$FULL_DOCKER_IMAGE_NAME|g&quot;)echo &quot;$KUBE_CONFIG&quot; | kubectl apply -f -Inspecting the application1kubectl get podsNhư vậy là deploy xong rồi đó :D name: Test deployed applicationKiểm tra xem đã deploy thành công chưa thông qua curl và các tham số được lấy từ kubectl command. name: Tear down application and resources if configured (since this is a demo)Cái này chắc khỏi cần giải thích. 3. Test auto deployĐể thử xem nó đã tự động deploy chưa, bạn chỉ cần tạo một commit và đẩy thằng vào master thôi. Kết quả thực sự đúng như ýhttps://github.com/minhnv2306/circleci-demo-k8s-gcp-hello-app/commit/dbe2cdcf49def4bd3c2ccd23ce98e39886465e36 Ngon thật. 4. Tổng kết Như vậy để ứng dụng Auto deploy trên CircleCI, bạn cần tìm hiểu Kubernetes Engine deploy qua các Cluster chứ không thể dùng Compute Engine deploy trên các VM Instance được. Cần kết hợp thêm docker và push lên Container Registry nữa nhé. Đau đầu @@. Đây mới chỉ là auto deploy ứng dụng example trên trang chủ, hi vọng bài viết tiếp theo sẽ deploy được project laravel =)) Tài liệu tham khảo Github demo project: https://github.com/CircleCI-Public/circleci-demo-k8s-gcp-hello-app Circle CI: https://circleci.com/docs/2.0/deployment-integrations/#google-cloud","link":"/2020/02/06/Circle-CI-Auto-deploying-ung-dung-tren-Google-Cloud/"},{"title":"[Circle CI] Auto deploying ứng dụng web trên Heroku","text":"Bài viết lần trước có hướng dẫn qua cách build projects với CircleCI. Tuy nhiên CircleCI còn một ưu điểm nữa là tự động hóa việc deploy ứng dụng sau khi build và chạy tests xong. Phần này chúng ta cùng xem cấu hình để nó tự động deploying nhé. Cũng đơn giản thôi :DLet’s practice!!!!! 1. Deploy ứng dụng lên HerokuTất nhiên, để deploy được 1 cách tự động thì bạn phải deploy thủ công đã phải không nào.Về cơ bản, bạn chỉ cần remote vào heroku remote và push lên nhánh master12$ heroku git:remote -a first-cd$ git push heroku masterChi tiết tham khảo tại bài viết 2. Cấu hình CI cho ứng dụngBài trước mình đã hướng dẫn cách cấu hình trên CircleCI 2.0. Phần này mình không nhắc lại nữa mà tập trung cấu hình phần auto deploy trên Heroku 2.1. Thêm biến môi trườngĐầu tiên bạn cần thêm các biến từ ứng dụng Heroku như những biến môi trường. Chúng ta cần thêm 2 biến HEROKU_APP_NAME và HEROKU_API_KEY để có thể tự động deployRefs: https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-project Bước 1: Vào ứng dụng Circle, chọn project (Nhấn JOBS) bạn muốn auto deploy. Nhấn vào icon Setting bên phải của project Bước 2: Trong phần Build Setting, click Environment Variables Bước 3: Import biến từ project khác bằng cách nhấn vào button Import Variable(s) hoặc thêm các biến mới bằng cách nhấn vào button Add Variable (Lưu ý rằng Import Variables(s) không khả dụng trên CircleCI được cài đặt private) Bước 4: Sử dụng các biến này trong file .circleci/config.yml thôi. 2.2. Chỉnh sửa configFile .circleci/config.yml:12345678910111213141516171819202122232425version: 2jobs: build: ... deploy: docker: - image: buildpack-deps:trusty steps: - checkout - run: name: Deploy Master to Heroku command: | git push https://heroku:$HEROKU_API_KEY@git.heroku.com/$HEROKU_APP_NAME.git masterworkflows: version: 2 build-deploy: jobs: - build - deploy: requires: - build filters: branches: only: masterMình chỉ thử nghiệm tự động deploy, không tiến hành build và tests nên nó sẽ đơn giản như sau:1234567891011version: 2jobs: build: docker: - image: circleci/php:7.1-apache steps: - checkout - run: name: Deploy Master to Heroku command: | git push https://heroku:$HEROKU_API_KEY@git.heroku.com/$HEROKU_APP_NAME.git masterNgon rồi, vậy là từ giờ mỗi lần bạn commit code lên nhánh master, project sẽ tự động được build, check các thứ bạn đã cấu hình (trong build jobs) và tự động deploy lên Heroku qua lệnh1git push https://heroku:$HEROKU_API_KEY@git.heroku.com/$HEROKU_APP_NAME.git master Đây là kết quả chi tiết Deploy Đơn giản vậy thôi. Tuy nhiên đây mới chỉ là mức đơn giản nhất (hello world) cho việc tự động deploy ứng dụng, các phần khác bạn có thể tìm hiểu thêm trên trang chủ CircleCI để cấu hình Tài liệu tham khảo Setting an Environment Variable in a Project - CircleCI Configuring Deploys - CircleCI Deploying project to Heroku - Viblo Github repository","link":"/2020/01/09/Circle-CI-Auto-deploying-ung-dung-web-tren-Heroku/"},{"title":"[CircleCI] Running Your First Build","text":"CI/CD là một bộ đôi công việc liên quan đến việc tự động làm những công việc lặp đi lặp lại của developers, bao gồm CI (Continuous Integration) và CD (Continuous Delivery), ý nói là quá trình tích hợp (integration) thường xuyên, nhanh chóng hơn khi code cũng như thường xuyên cập nhật phiên bản mới (delivery). CircleCI là một sản phẩm thực hiện cả CI/CD, cụ thể nó build, kiểm thử các script bạn cài đặt và tests (unit test) chẳng hạn và tự động deploy ứng dụng - Continuous Deploy. CircleCI automates your software builds, tests, and deployments. CircleCI chạy gần 1 triệu jobs mỗi ngày, hỗ trợ 30.000 tổ chức. Các tổ chức này chọn CircloCI bởi vì jobs chạy nhanh và việc builds ứng dụng có thể được tối ưu xử lý về tốc độ. CircleCI có thể được cấu hình để chạy nhiều pipelines phức tạp một cách hiệu quả. Với một developer cũng có thể sử dụng SSH into any joib để debug các vấn đề khi build, cài đặt song song các jobs để chạy nhanh hơn, và config caching với 1 vài từ khóa đơn giản để có thể sử dụng lại dữ liệu từ jobs trước đó qua workflow. Đối với người điều hành và quản trị viên, sử dụng CircleCI cài đặt trên server chung, CircleCI cung cấp giao diện trực quan theo dõi việc build của bạn. Tài liệu cung cấp hướng dẫn từng bước để bạn build thành công lần đầu trên Circle 2.0 0. Yêu cầu trước khi chạy build lần đầu Các kiến thức cơ bản về Git, có tài khoản GitHub.com, GitHub repository Có kiến thức cơ bản về terminal hoặc bash để sử dụng command line một cách hữu ích 1. Createting a RepositoryBước 1: Chọn repositories và nhấn New hoặc vào trực tiếp trang này https://github.com/new Bước 2: Chọn Initialize this repository with a README và click Create repository button: 2. Thêm một .yml fileCircle sử dụng 1file YAML để xác định làm sao bạn muốn test môi trường và test những thứ bạn muốn chạy. Trong Circle 2.0, file này phải được gọi là config.yml và phải được trong thư mục ẩn .circleci. Trên Mac, Linux và Windows, tên files và folders bắt đầu với dấu chấm sẽ bị ấn đi theo cài đặt mặc định.12mkdir .circlecitouch .circleci/config.ymlVà nội dung của file config.yml12345678version: 2jobs: build: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A first hello&quot;sau đó commit và push lên repo như thông thường nhé123git add .circleci/config.ymlgit commit -m &quot;Create circle-ci config&quot;git push origin masterHoặc bạn cũng có thể tạo với giao diện 3. Setting up Your Build on CircleCI Bước 1: Trước khi thực hiện bước này bạn cần tạo một tài khoản CircleCI. Sau đó vào trang Dashboard. Bước 2: Tiếp theo bạn sẽ nhận được tùy chọn danh sách các projects bạn có thể truy cập và building CircleCI. Ở màn hình tiếp theo, bạn có thể thêm repo bạn đã tạp như 1 project mới trên CircleCI Bước 3: Để thêm repo mới của bạn, nhấn Set Up project Bước 4: Ở màn hình tiếp theo, bạn sẽ nhận được 1 vài tùy chọn cấu hình cho project của bạn trên CircleCI. Lựa chọn phù hợp và nhấn Start building 4. Running Your First CircleCI Build!Bạn nên xem lần build chạy tự động và pass! Vậy, cái gì đang diễn ra? Nhấn vào nút Success xanh trên Dashboard để xem xét các phần chạy. Spin up environment: CircleCI đã sử dụng circleci/ruby:2.4.1. Docker image to launch a virtual computing environment. Checkout code: CircleCI checked out your GitHub repository và “cloned” vào vào the virtual environment launched in Step 1. echo: Đây là các lệnh khác trong file config.yml: CircleCI chạy lệnh echo với inpuit “A first hello”.Mặc dù thực chất không có source code trên repo của bạn và thực tế không được cấu hình tests trong file config.yml, CircleCI vẫn xem xét build của bạn đã “succeeded” vì tất cả các bước đã thành công (đã được trả về 0). Thực chất nhiều projects phức tạp hơn rất nhiều, thông thường sẽ có nhiều Docker images và nhiều bước, bao gồm số lượng test rất lớn. 5. Breaking Your Build!Chỉnh sửa file config.yml trên GitHub và tạo commit mới để thực hiệnlần build mới. Nếu build lỗi, sẽ có nút đỏ Failed và CircleCI sẽ gửi cho bạn 1 email để thông báo lỗi. 6. Using the Workflows FunctionalityHướng dẫn tiếp theo sẽ hướng dẫn bạn sử dụng workflow, một điểm mạnh của CircleCI giúp build các jobs song song hoặc cần phụ thuộc vào nhau. Bước 1: Để xem luồng làm việc, chỉnh sửa file .circleci/config.yml1234567891011121314version: 2jobs: build: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A first hello&quot; build: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A first hello&quot; Bước 2: Tiếp theo, đổi tên 2 jobs để chúng khác tên. Trong ví dụ này chúng tôi sẽ đặt tên chúng là one và two. Thay đổi nội dung echo khác nhau nữa. Để có thời gian giữa csac lần build trước, chúng ta có thể thêm lệnh sleep. Bước 3: Thêm phần workflows vào file config.yml. Phần này có thể được đặt ở bất cứ đâu trong file. Nhưng nó thường được đặt ở đầu hoặc cuối file:12345678910111213141516171819202122version: 2jobs: one: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A first hello&quot; - run: sleep 25 two: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A more familiar hi&quot; - run: sleep 15workflows: version: 2 one_and_two: jobs: - one - two Bước 4: Commit sự thay đổi này, đẩy lên repository của bạn và nhìn lại CircleCI dashboard Bước 5: Click vào link để xem workflow 2 jobs chạy song song Xem thêm workflow tại: https://circleci.com/docs/2.0/workflows/#overview 7. Adding Some Changes to use the Workspaces FunctionalityMỗi workflow cần liên kết không gian làm việc, cái mà có thể dùng để chuyển file từ jobs trên xuống xác workflow đang xử lý. Bạn có thể sử dụng workflow để làm việc này.12345678910111213141516171819202122232425262728293031323334353637383940version: 2jobs: one: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A first hello&quot; - run: mkdir -p my_workspace - run: echo &quot;Trying out workspaces&quot; &gt; my_workspace/echo-output - persist_to_workspace: # Must be an absolute path, or relative path from working_directory root: my_workspace # Must be relative path from root paths: - echo-output two: docker: - image: circleci/ruby:2.4.1 steps: - checkout - run: echo &quot;A more familiar hi&quot; - attach_workspace: # Must be absolute path or relative path from working_directory at: my_workspace - run: | if [[ $(cat my_workspace/echo-output) == &quot;Trying out workspaces&quot; ]]; then echo &quot;It worked!&quot;; else echo &quot;Nope!&quot;; exit 1 fiworkflows: version: 2 one_and_two: jobs: - one - two: requires: - one 8. SSH into Your BuildNếu bạn cảm thấy thoải mái hơn với terminal, bạn có thể sử dụng SSH trực tiếp tới jobs CircleCI để xử lý vấn đề với builds bằng cách chạy lại build với SSH enabled option. Sử dụng cách này cũng rất thuận tiện để bạn debug các jobs của mình, tuyệt vời phải không nào. Note that you will need to add your SSH keys to your GitHub account: https://help.github.com/articles/connecting-to-github-with-ssh/. OK rồi đó, bạn có thể copy lệnh shh sinh ra và truy cập thôi1ssh -p 64539 54.146.195.254Như vậy bạn đang thực thi jobs này dưới dạng command line. Bạn có thể sử dụng các lệnh trong workspace thôi:1234pwd # print what directory, find out where you are in the file systemls -al # list what files and directories are in the current directorycd &lt;directory_name&gt; # change directory to the &lt;directory_name&gt; directorycat &lt;file_name&gt; # show me the contents of the file &lt;file_name&gt; Tổng kết Để tích hợp CircleCI ứng dụng, cũng đơn giản, tạo file cấu hình .circleci/config.yml và cấu hình trên Dashboard là được https://circleci.com/dashboard Nếu bạn chỉ cần chạy 1 jobs đơn giản như check convention, unit test, không cần setting quá nhiều thứ nội dung file này sẽ khá đơn giản, bao gồm các run trong steps là được1234567891011121314151617181920212223version: 2.1jobs: build: docker: - image: circleci/php:7.2-node-browsers steps: - checkout - run: name: Install Composer command: | php -r &quot;copy('https://getcomposer.org/installer', 'composer-setup.php');&quot; php -r &quot;if (hash_file('SHA384', 'composer-setup.php') === trim(file_get_contents('https://composer.github.io/installer.sig'))) { echo 'Installer verified'; } else { echo 'Installer invalid'; unlink('composer-setup.php'); } echo PHP_EOL;&quot; php composer-setup.php php -r &quot;unlink('composer-setup.php');&quot; - run: name: Running PHPCS command: | cd ./vendor/squizlabs/php_codesniffer/src/Standards git clone git@github.com:wataridori/framgia-php-codesniffer.git Framgia cd ../../../../../ ./vendor/bin/phpcs -n Nếu có nhiều jobs hơn, hãy xem xét sử dụng jobs và workflows (ví dụ như bạn vừa muốn check các tests và muốn deploy chẳng hạn) Sử dụng SSH để debug các jobs, truy cập vào container để kiểm tra. Các lệnh trong CircleCI hoàn toàn có thể tham chiếu tới các biến môi trường, cho phép bạn làm việc có thể mở rộng hơn! Tài liệu tham khảoCircleCI - Get started","link":"/2020/01/09/CircleCI-Running-Your-First-Build/"},{"title":"[Clean code] Chapter 2: Đặt tên có ý nghĩa","text":"Tên xuất hiện mọi nơi trong phần mềm. Chúng ta có tên biến, tên hàm, tên đối số, tên lớp, và package. Chúng ta đặt tên cho file mã nguồn, đường dẫn chứa chúng… Chúng ta thực hiện đặt tên, đặt tên và đặt tên. Bởi vì chúng ta làm việc đặt tên rất nhiều nên hãy cố làm nó một cách tốt nhất. Một số tips là một số rule đơn giản giúp bạn tạo ra một cái tên tốt ^^ Sử dụng tên có thể gợi lên các thông tinTên cuả một biến, hàm hoặc lớp nên trả lời tất cả các câu hỏi lớn: nó nói cho bạn là tại sao nó tồn tại, nó làm cái gì và sử dụng nó như thế nào. Hãy xem xét cách đặt tên sau:1int d; // elapsed time in daysTên d hoàn toàn không có một ý nghĩa nào. Bạn không nên đặt tên như vậy, thay vào đó bạn nên đặt một tên gợi lên ý nghĩa, như thêm đơn vị chẳng hạn, cái gì đang được đo lường trong biến này và đơn vị đo lường của nó là gì: 1234int elapsedTimeInDays;int daysSinceCreation;int daysSinceModification;int fileAgeInDays; OK, code có vẻ dễ đọc hơn rồi đó. Bây giờ thử xem xét đoạn code sau:1234567public List&lt;int[]&gt; getThem() { List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;(); for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1;}Đoạn code chạy rất ổn nhưng có vẻ khó hiểu quá. Hàng tỉ câu hỏi có thể được đặt ra với đống code này nhưng mình trích xuất 4 câu hỏi chính: theList là cái quái gì? Tầm quan trọng cuả x[0], tại sao lại dùng nó để so sánh? Dấu hiệu 4 để so sánh mang ý nghĩa gì ???? Giá trị trả về được sử dụng như thế nào? Các câu trả lời hoặc hàm ý trả lời các câu hỏi đó hoàn toàn có thể được bạn thể hiện trong code nếu bạn tinh ý một chút trong việc đặt tên biến. Hãy coi đoạn code trên xử lý một trò chơi, mỗi hàng (Cell) trên bảng (gameBoard) được biểu diễn bởi một mảng đơn giản. Nhiện vụ của ta là xem phần tử đầu của mỗi hàng đó có phải là một “cờ” nào đó không (isFlagged) và trả về các cột thỏa mãn điều kiện đó, easy thôi mà: 1234567public List&lt;Cell&gt; getFlaggedCells() { List&lt;Cell&gt; flaggedCells = new ArrayList&lt;Cell&gt;(); for (Cell cell : gameBoard) if (cell.isFlagged()) flaggedCells.add(cell); return flaggedCells;} Đoạn code có vẻ ngon hơn rồi đó :D nó mang nhiều ý nghĩa hơn rồi. Tránh sai lệch ý nghĩaLập trình viên nên tránh các tên gây hiểu nhầm, sai lệch nghĩa cho người khác. Ví dụ như đặt tên là accountLists nhưng các phần tử trong nó lại là một array chứ không phải là một list. Thay vào đó, hãy đặt tên là accountGroup hoặc bunchofAccounts hoặc tốt nhất là accounts. Tạo sự phân biệt có nghĩaCách đặt tên biến theo kiểu a1, a2, ... aN tạo ra sự phân biệt nhưng đó thực sự là một cách đặt tên biến tồi. Xem xét đoạn code copy chuỗi mà ta vẫn hay viết:12345public static void copyChars(char a1[], char a2[]) { for (int i = 0; i &lt; a1.length; i++) { a2[i] = a1[i]; }}Nhìn vào tên hàm thật khó biết đâu là chuỗi đích đâu là chuỗi nguồn. Thay vào đó hãy đổi tên thành source và destination.Các từ “noise words” (a, an, the…) cũng không nên xuất hiện xuất hiện làm tiền tố trong tên biến. Từ varialbe không bao giờ nên xuất hiện trong tên biến, từ table không bao giờ nên xuất hiện trong tên một cái bàn. Bạn có bao giờ thử hỏi NameString tốt hơn hay Name tốt hơn. Có khi nào Name lại có kiểu float hay int? OK tôi cứ thích thì sao? Vậy bạn nên đọc lại nguyên tắc số 2 :D. Sử dụng một tên có thể phát âm đượcNghe có vẻ kỳ kỳ nhưng nó thực sự rất hay. Bạn đặt tên biến là genymdhms (giả sử là viết tắt các chữ cái đầu của 1 cụm từ nào đó bạn nhớ được đi) sau đó anh X review code cho bạn nói “X ơi, dòng XXX em viết biến ….” (5 phút để đọc). Với các tên không thể phát âm gây khó chịu và rắc rối khi trao đổi giữa các thành viên, nó biến chúng ta nói chuyện như những người bất bình thường @@. Sử dụng tên có thể tìm kiếm đượcCác trình soạn thảo ngày càng được phát triển mạnh mẽ giúp việc tìm kiếm trở nên dễ dàng trong đó có cả tên. Bạn thích đặt tên ngắn, một hoặc 2 ký tự cho code nhanh (ví dụ tên s chẳng hạn), vào đoạn code 1000 dòng, bạn nhớ là mình đã đặ tên nó là s xong tìm kiếm từ s và kết quả là bạn nhận về 300 kết quả. Chịu khó ngồi dò đi nhé :D. Các số cũng vậy, tìm một số sẽ có rất nhiều kết quả, thay vào đó bạn nên gắn nó một biến const:123for (int j=0; j&lt;34; j++) { s += (t[j]*4)/5;}nên được chuyển thành:12345678int realDaysPerIdealDay = 4;const int WORK_DAYS_PER_WEEK = 5;int sum = 0;for (int j=0; j &lt; NUMBER_OF_TASKS; j++) { int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; int realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK); sum += realTaskWeeks;}Đặt tên một biến có thể tìm kiếm giúp bạn rút ngắn thời gian tìm kiếm tên biến, hàm và lớp đó một cách dễ dàng. Rõ ràng tìm kiếm biến NUMBER_OF_TASKS, realDaysPerIdealDay có ít kết quả hơn và dễ dàng hơn rất nhiều so với 4 hay 5 hay s. Tránh các ánh xạ về tinh thần (Avoid Mental Mapping)Nó nên được hiểu như thế nào? Bạn có để ý là trong vòng lặp for() bạn hay dùng biến i và j thậm chí k để chạy vòng lặp. Có bao giờ bạn dùng biến n? Hầu như mọi người lập trình đều bị tâm lý rằng biến i,j để lưu biến trong vòng lặp. Thật là thảm họa khi bạn dùng biến i lưu tổng số sinh viên của một lớp. Nói đơn giản hơn, mọi người Việt Nam nhìn chữ “Thị” trong tên là trong đầu hiểu với nhau đưá đó là con gái rồi. Vì vậy nếu bạn là con trai, bạn không nên lấy cái tên “Bùi Thị Hiếu” =)) Tên lớpTên lớp nên là danh từ hoặc cụm danh từ như Customer, WikiPage, Account and AddressParser tránh sử dụng động từ như Manager , Processor , Data , or Info. Tên phương thứcTên phương thức hoặc tên hàm nên bắt đầu là động từ, trả lời câu hỏi làm gì với cái gì?. Accessors, mutators, và nhận định nên bắt đầu là get, set và is:123string name = employee.getName();customer.setName(&quot;mike&quot;);if (paycheck.isPosted()).. Đừng đặt tên “cute”, chơi chữCute và chơi chữ giúp văn của bạn trở nên sinh động cuốn hút người đọc nhưng làm ơn chúng ta đang lập trình, đừng nên đem lối viết văn đó vào việc đặt tên biến. Thay vì tên phương thức đặt là HolyHandGrenade() hãy đặt là DeleteItem(), thay vì đặt tên là whack(), hãy đặt là kill(), thay vì đặt tên là eatMyShorts() hãy đặt tên là abort() Ngữ cảnh trong tên biếnTrong phương thức làm việc với địa chỉ, các tên biến như firstName, lastName, street, houseNumber, state có thể làm cho bạn dễ hiểu đó là các biến để lưu thông tin về địa chỉ. Tuy nhiên khi đứng một mình state liệu bạn có dám chắc là nó để lưu một thông tin về địa chỉ.Do đó bạn có thể gán các thông tin về context (ngữ cảnh) cho nó để làm cho người đọc thực sự hiểu nó hơn. Bạn có thể thêm context bằng cách sử dụng prefix: addrFirstName, addrLastName, addrState,... Tổng kếtTên ngắn hay tên dài không quan trọng, quan trọng là bạn phải đặt tên theo cách dễ đọc, dễ tìm kiếm, dễ maintain code, dễ trao đổi nhất có thể. Hi vọng với một số tips trên giúp các bạn có thể làm điều đó một cách tốt hơn. Tài liệu tham khảoChapter 2: Clean Code","link":"/2019/04/11/Clean-code-Chapter-2-Dat-ten-co-y-nghia/"},{"title":"[Clean code] Chapter 3: Function - Phần 1","text":"Các function, method xuất hiện rất nhiều trong lập trình và phần clean code của phần này cũng là một phần mình thấy khá khó. Trong bài viết mình đưa ra một vài nguyên tắc và cố gắng clean code chính mình theo các nguyên tắc đó và tất nhiên các đoạn code mình tối ưu chưa phải là tốt nhất :D.Trước hết hãy xem đoạn code xử lý bước login sau (Xứ lý với framework FuelPHP nhé): Tống tất cả vào 1 hàm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public function post_login(){ $input = array(); $vali = $this-&gt;_vali(); $check_vali = $vali-&gt;run(); // was the login form posted? if (\\Input::method() == 'POST') { if ($check_vali) { // check the credentials. if (\\Auth::instance()-&gt;login(\\Input::param('username'), \\Input::param('password'))) { // did the user want to be remembered? if (\\Input::param('remember', false)) { // create the remember-me cookie \\Auth::remember_me(); } else { // delete the remember-me cookie if present \\Auth::dont_remember_me(); } // logged in, go back to the page the user came from, or the // application dashboard if no previous page can be detected \\Response::redirect_back('/'); } else { // login failed, show an error message //\\Messages::error(__('login.failure')); $errorMessage = 'Username or password not right!'; $data = [ 'errorMessage' =&gt; $errorMessage, ]; return Response::forge(View::forge('login/index')-&gt;set($data)); } } else { $errors = $vali-&gt;error(); $oldRequest = $vali-&gt;validated(); $data = [ 'errors' =&gt; $errors, 'oldRequest' =&gt; $oldRequest, ]; return Response::forge(View::forge('login/index')-&gt;set($data)); } } // display the login page return \\View::forge('login/index');}Đoạn code chạy ổn (tất nhiên là phải chạy ổn mới dám nghĩa tới clean code chứ :v) nhưng ta sẽ tối ưu nó ngon hơn hiện tại :D Small!!!Nguyên tắc đầu tiên viết hàm là hàm đỏ nên nhỏ và nguyên tắc thứ 2 là hàm đó nên nhỏ hơn nữa. Vậy thế nào là nhỏ? Trong cuốn clean code, tác giả có đề cập đến đoạn code xử lý 1 trò chơi. Nó cung cấp một hiệu ứng ảo nhìn rất đẹp, khi bạn di chuyển chuột, có các hình lấp lánh rơi xuống dưới màn hình như các đũa thần. Tác giả viết gộp tất cả vào khoảng 3000 dòng và sau khi tham khảo đoạn code của 1 người bạn để học các clean code, người bạn đó chia code thành các function cực nhỏ, nhỏ đến mức mỗi hàm chỉ 2,3 dòng. Khỏi lấy ví dụ đâu xa, hãy xem code trong Laravel xem function của họ nhỏ đến mức nào. Trích code của trait ThrottlesLogins trong Laravel:12345678910111213141516171819202122232425262728293031323334353637383940/** * Get the throttle key for the given request. * * @param \\Illuminate\\Http\\Request $request * @return string */ protected function throttleKey(Request $request) { return Str::lower($request-&gt;input($this-&gt;username())).'|'.$request-&gt;ip(); } /** * Get the rate limiter instance. * * @return \\Illuminate\\Cache\\RateLimiter */ protected function limiter() { return app(RateLimiter::class); } /** * Get the maximum number of attempts to allow. * * @return int */ public function maxAttempts() { return property_exists($this, 'maxAttempts') ? $this-&gt;maxAttempts : 5; } /** * Get the number of minutes to throttle for. * * @return int */ public function decayMinutes() { return property_exists($this, 'decayMinutes') ? $this-&gt;decayMinutes : 1; }Vì vậy đừng lo hàm của bạn có 1,2 dòng và thật vô nghĩa. Nên chia hàm thành các hàm nhỏ, nhỏ và nhỏ hơn nữa. 1.1. Blocks and IndentingBạn có thấy nếu bạn sử dụng quá nhiều if như đoạn code trên, code phồng khá to và gây khó đọc. Một nguyên tắc nữa là thực hiện với if, else, while .. sau đó chỉ nên có 1 dòng. Dòng này nên được gọi hàm. Điều này không chỉ giúp hàm trở nên small mà nó còn làm tài liệu có giá trị vì hàm được gọi bên trong block có 1 cái tên miêu tả rất đẹp:123456public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml();} 2. Do one thing!!!Hàm nên được rõ ràng và chỉ nên đảm nhiệm làm 1 thứ. Tư tưởng này đã xuất hiện từ hơn 30 năm về trước “FUNCTIONS SHOULD DO ONE THING . THEY SHOULD DO IT WELL .THEY SHOULD DO IT ONLY.“ Hàm đó có thể tạo các bộ nhớ đệm, chỉ format dữ liệu, chỉ render ra HTML … Tuy nhiên định nghĩa thế nào là làm 1 việc lại là vấn đề khó. Nhìn lại ví dụ trong 1.1 ta thấy hàm thực hiện: Determining whether the page is a test page. If so, including setups and teardowns. Rendering the page in HTML. Như vậy hàm đó thực hiện một việc hay nhiều việc. Hãy để ý rằng, 3 bước này là 3 bước để thực hiện một việc, mỗi bước được gọi một tên hàm @@. Như vậy nó thực hiện 1 việc. Chúng ta có thể mô tả hàm đó bằng đoạn văn TO sau: 123*TO RenderPageWithSetupsAndTeardowns, we check to see whether the page is a test page and if so, we include the setups and teardowns. In either case we render the page in HTML.* Hơi hack não một chút xíu. Nếu như bạn thực hiện theo kiểu từng bước như trên dưới dạng các hàm, hàm đó rõ ràng thực hiện 1 việc (Nguyên bản:v It should be very clear that Listing 3-1 contains steps at many different levels of abstraction. So it is clearly doing more than one thing). 3. One Level of Abstraction per FunctionĐể chắc chắn rằng 1 hàm làm 1 việc, bạn nên chỉ gọi 1 level hàm trong 1 hàm :v. Khó giải thích quá nhưng tóm lại là không nên gọi hàm trong hàm trong một hàm =)). OK nói thế này cho dễ hình dung nhé. 3.1. Reading Code from Top to Bottom: The Stepdown RuleQuy tắc này hiểu đơn giản là chúng ta muốn đọc chương trình của bạn từ trên xuống như là tập các đoạn văn bắt đầu là TO, mỗi bước miêu tả “current level of abstraction” ở hiện tại và các miêu tả các bước con ở level tiếp theo và mỗi hàm chỉ nên dừng lại ở 1 level của sự trừu tượng.Mô tả đoạn code như sau (theo các level):123456789To include the setups and teardowns, we include setups, then we include the test page content, and then we include the teardowns. To include the setups, we include the suite setup if this is a suite, then we include the regular setup. To include the suite setup, we search the parent hierarchy for the “SuiteSetUp” page and add an include statement with the path of that page. To search the parent. . .Từng TO như vậy ta có thể hiểu mỗi TO sẽ là một hàm và nên dùng lại ở 1 level TO thụt vào cho mỗi miêu tả theo nguyên tắc số 3 này. Rất khó để lập trình viên có thể tuân theo nguyên tắc này, nhưng đó chính là thứ giúp bạn có thể cụ thể hóa cái mỗi hàm chỉ làm 1 việc. 4. Ứng dụng để clean đoạn code ban đầuOK, chúng ta nhớ 2 thứ trong phần bài viết này đó là 1 hàm cần small và small hơn nữa. Thứ 2 là một hàm cần “DO ONE THING”, làm 1 việc như thế nào thì hãy sử dụng các đoạn văn TO, đọc code từ trên xuống dưới để dễ hình dung. OK vậy pha login ta mô tả đoạn văn TO như sau:1234567TO đăng nhập, bạn cần phải kiểm tra dữ liệu sau đó mới đăng nhập TO kiểm tra dữ liệu, bạn cần xây dựng các rules và chạy nó TO xây dựng các rules ... khoan đã, chỉ 1 level abstract trong 1 hàm, cái này mô tả vẫn được nhưng cần tách nó ra 1 hàm với cái bên trên để đảm bảo nguyên tắc này TO để đăng nhập bạn cần gọi API đăng nhập TO đăng nhập lỗi thì xử lý nóNhìn qua ta cần xây dựng các hàm login, kiểm tra dữ liệu, tác biệt riêng, không nên để chung hết như phần mở đầu. Cơ bản đoạn TO trên mô tả như sau:12345678910111213public function post_login(){ // TO kiểm tra dữ liệu $checkVali = $this-&gt;_vali_login(); if ($checkVali) { // TO đăng nhập (tách hàm riêng cho dễ đọc) $this-&gt;handleLoginEvent(); } else { // TO đăng nhập lỗi return $this-&gt;handleFailedValidateResponse($vali); }}Trong mô tả trên có đoạn ở level 2, bây giờ ta mới mô tả:1234TO kiểm tra dữ liệu, bạn cần xây dựng các rules và chạy nó TO xây dựng các roles, đã có API :D TO chạy nó, ta dùng hàm run() :D(không có level 2 là ngon rồi)Viết hàm validate thôi:12345678910private function _vali_login() { // TO xây dựng các rules trong hàm login $vali = Validation::forge(); $vali-&gt;add_field('username', 'Your username', 'required'); $vali-&gt;add_field('password', 'Your password', 'required|min_length[3]|max_length[10]'); // TO chạy, gọi methods run return $vali-&gt;run(); }Tương tự xử lý các pha login, ta có đoạn code đầy đủ sau:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Đây là hàm xử lý login, các phương thức sau mang tính chất bổ trợ và small, small, smallpublic function post_login(){ $checkVali = $$this-&gt;_vali_login(); if ($checkVali) { $this-&gt;handleLoginEvent(); } else { return $this-&gt;handleFailedValidateResponse($vali); }}// Smallprivate function _vali_login(){ $vali = Validation::forge(); $vali-&gt;add_field('username', 'Your username', 'required'); $vali-&gt;add_field('password', 'Your password', 'required|min_length[3]|max_length[10]'); return $vali-&gt;run();}private function login($username, $password){ return \\Auth::instance()-&gt;login($username, $password);}private function handleLoginEvent(){ $username = \\Input::param('username'); $password = \\Input::param('password'); $checkLogin = $this-&gt;login($username, $password); if ($checkLogin) { $this-&gt;handleRememberMe(\\Input::param('remember', false)); \\Response::redirect_back('/'); } else { $this-&gt;handleFailedLoginResponse(); }}private function handleFailedValidateResponse($vali){ $errors = $vali-&gt;error(); $oldRequest = $vali-&gt;validated(); $data = array( 'errors' =&gt; $errors, 'oldRequest' =&gt; $oldRequest, ); return Response::forge(View::forge('login/index')-&gt;set($data));}private function handleFailedLoginResponse(){ Session::set_flash('errorMessage', 'Username or password not right!'); return Response::redirect('login/login');}private function handleRememberMe($remeberMe = true){ if ($remeberMe) { \\Auth::remember_me(); } else { \\Auth::dont_remember_me(); }} Tổng kếtVới Function bạn cần nhớ Small. DO ONE THINGS? Đoạn văn TO.Tài liệu tham khảoChapter 3: Clean Code.","link":"/2019/04/11/Clean-code-Chapter-3-Function-Phan-1/"},{"title":"[Clean code] Chapter 3: Function - Phần 2","text":"Tiếp tục phần clean code cho hàm, mình xin đưa ra một số tip giúp bạn clean hàm tốt hơn. Khối SwitchThật khó để tạo ra một khối switch nhỏ. Thậm chí một khối switch chỉ có 2 cases cũng đã lớn hơn một khối block hoặc một hàm. Rất khó để tạo ra một khối switch chỉ làm 1 việc. Bản thân mặc định khối switch đã làm N việc :D. Ta cùng xem xét đoạn code tính lương theo thể loại nhân viên sau:12345678910111213public Money calculatePay(Employee e)throws InvalidEmployeeType { switch (e.type) { case COMMISSIONED: return calculateCommissionedPay(e); case HOURLY: return calculateHourlyPay(e); case SALARIED: return calculateSalariedPay(e); default: throw new InvalidEmployeeType(e.type); }}Có một vài vấn đề với hàm này. Đầu tiên, nó quá lớn và khi có một thể loại nhân viên mới được thêm, nó sẽ rất lớn. Vấn đề thứ 2 rất rõ ràng là nó làm nhiều hơn 1 việc. Thứ 3 là nó vi phạm Single Responsibility Principle (SRP) bởi vì có nhiều hơn 1 lý do cho sự thay đổi hàm này. Thứ 4 là nó vi phạm nguyên tắc Open Closed Principle (OCP) bởi vì một khi thêm 1 loại nhân viên thì phải thay đổi. Nhưng vấn đề tồi tệ nhất ở đây là chúng ta sẽ có hàng tỉ hàm dạng như này nữa, kiểu nhưisPayday(Employee e, Date date)hoặcdeliverPay(Employee e, Money pay). Giải pháp cho các khối switch-case này là tạo một “tầng hầm” ABSTRACT FACTORY và không để ai nhìn thấy nó. “Nhà máy” sẽ tạo ra các thể loại Employee cho chúng ta, các phương thức calculatePay , isPayday , và deliverPay sẽ được định nghĩa thông qua các interface:123456789101112131415161718192021222324public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay);}-----------------public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;}-----------------public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } }} Đối số của 1 hàmSố lượng đối số của 1 hàm lý tưởng nhất là 0 (niladic). Sau đó là 1 đối số (monadic), gần ngon hơn nữa thì là 2 (dyadic). Các hàm 3 đối số (triadic) được khuyên là nên tránh nếu thực sự không cần thiết. Các hàm hơn 3 đối số thì hạn chế sử dụng, trừ khi có lý do đặc biệt Mẫu hàm chung có 1 đối sốCó 2 lý do chung để bạn truyền 1 tham số vào hàm. Lý do đầu tiên là để trả lời câu hỏi về đối số đó, ví dụ như boolean fileExists(“MyFile”) (trả lời câu hỏi file này tồn tại hay không). Lý do thứ 2 là bạn truyền đối số này, xào nấu biến đổi nó để trả về một cái gì đó từ nó. Hai cách sử dụng này là những gì người đọc mong đợi khi họ thấy một hàm thực sự. Tuy nhiên, bạn hãy chú ý đến các đặt tên hàm để người đọc có thể phân biệt được ý nghĩa của hàm loại này đang được sử dụng với ly do nào. Một trường hợp khác cũng dùng kiểu hàm 1 tham số này là các sự kiện. Những mẫu event có 1 đối số đầu vào và không có đối số đầu ra. Tổng thể chương trình có nghĩa là diễn giải lời gọi hàm như một sự kiện và sử dụng đối số để thay đổi trạng thái của hệ thống, ví dụ, void passwordAttemptFailedNtimes(int attempts). Sử dụng sự kiện kiểu này cần chú ý. Cần phải rất rõ ràng cho người đọc rằng đây là một sự kiện. Chọn tên và bối cảnh cẩn thận Flag ArgumentsVới nhiều người các đối số cờ thật tuyệt, nó giúp giảm thiểu được các công việc trùng lặp và kiểm tra các thứ …. Tuy nhiên dưới góc nhìn clean code và test, nó không thực sự hoàn hảo như vậy. Cùng xem ý kiến của tác giả nhé :D Các tham số cờ thật là xấu xí và khó chịu. Truyền một giá trị boolean vào 1 hàm thực sự rất khủng khiếp. Nó ngay lập tức làm phức tạp chữ ký của phương thức, lớn tiếng tuyên bố rằng chức năng này làm nhiều hơn một điều. Nó làm một việc nếu cờ là đúng và một việc khác nếu cờ sai! Thay vì sử dụng một phương thức render(boolean isSuite) tác giả khuyên nên tách thành 2 phương thức renderForSuite()và renderForSingleTest() @@ Dyadic Function (hàm 2 đối số)Hàm 2 tham số thì khó hiểu hơn là hàm 1 tham số. Ví dụ writeField(name) thì dễ hiểu hơn là writeField(output-Stream, name). Mặc dù tên của 2 phương thức đều rõ ràng. Một vài trường hợp tất nhiên, hàm 2 tham số là cực kì thích hợp, ví dụ như Point p = new Point(0,0). Chúng ta sẽ rất ngạc nhiên nếu nhìn thấy new Point(0). Tuy nhiên 2 đối số trong trường hợp này thực ra là cách sắp xếp các phần tử của 1 giá trị đơn, khác với output-Stream và name ở trên Hãy xem xét đến việc cắt giảm đối số để chuyển nó về dạng 1 đối số. Ví dụ writeField(outputStream, name). Hãy xem xét lớp chứa phương thức này có thể tạo một đối tượng outputStream dùng chung trong hàm tạo, hoặc có thể xem xét tạo một lớp mới (OutputStream) chứa phương thức write(name) với chức năng tương tự nó TriadsHàm với 3 đối số khó đọc hơn đáng kể so với hàm 2 đối số. Tôi khuyên bạn nên suy nghĩ cẩn thận trước khi tạo ra hàm này Các hàm các nhiều đối số khi dùng khả năng xảy ra lỗi, sắp xếp tham số gây khó hiểu hơi rất nhiều so với các hàm 1,2 đối số. Đặc biệt khi test các hàm này cũng gặp rất nhiều các vấn đề đáng phải quan tâm. Do vậy hãy suy nghĩ trước khi tạo các hàm như vậy. Đối số là đối tượngKhi một hàm dường như cần nhiều hơn 2 hoặc 3 đối số, ta có thể xem xét bao bọc chúng trong các lớp. Cân nhắc sự khác biệt của 2 cách khai báo12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius);Cắt giảm đối số truyền bằng cách tạo đối tượng dường như đang gian lận, nhưng không phải vậy. Một thì nhóm các biến và truyền chúng cùng nhau, như cách nhóm x, y ví dụ trên Đối số là List thì sao nhể?Thỉnh thoảng chúng ta muốn truyền 1 số lượng biến vào 1 hàm. Xem xét ví dụ hàm String.format1String.format(&quot;%s worked %.2f hours.&quot;, name, hours);Nếu như tất cả các đối số được xử lý giống nhau như ví dụ trên, chúng tương đương với một đối số duy nhất của loại List. Với lý do này, hàm String.format thực chất chỉ là dyadic1public String format(String format, Object... args)Vì vậy, tất cả các quy tắc tương tự có thể áp dụng. Các hàm có đối số có thể là 1 đối số, 2 đối số hoặc 3 đối số123void monad(Integer... args);void dyad(String name, Integer... args);void triad(String name, int count, Integer... args); Verbs and KeywordsChọn 1 cái tên tốt cho hàm có thể giải thích nội dung hàm và thứ tự, ý nghĩa của các đối số. Đối với trường hợp hàm 1 đối số, tên hàm vài đối số nên là 1 cụm verb/noun thì đẹp nhất :v: . Ví dụ write(name) sẽ đủ gợi lên thông tin. Tuy nhiên câu hỏi đặt ra là “name” là cái gì? nó được viết bởi written? Một cái tên tốt hơn là writeField(name), cái mà sẽ nói với chúng ta “name” là một “field” Cuối cùng là một ví dụ về keyword trong tên hàm. Sử dụng mẫu này chúng ta sẽ mã hóa được tên đối số trong tên hàm. Ví dụ hàm assertEquals có thể được viết tốt hơn dưới dạng assertExpectedEqualsActual(expected, actual). Điều này mạnh mẽ giảm thiểu vấn đề phải nhớ thứ tự của các đối số. Không có các chức năng phụCác chức năng phụ là sự lừa dối. Hàm của bạn phải hứa là làm 1 thứ nhưng nó cũng làm những thứ ẩn khác. Đôi khi nó làm những thứ thay đổi không cần thiết cho các biến của lớp của nó, các biến global. Xem xét ví dụ check login:123456789101112131415public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName); if (user != User.NULL) { String codedPhrase = user.getPhraseEncodedByPassword(); String phrase = cryptographer.decrypt(codedPhrase, password); if (&quot;Valid Password&quot;.equals(phrase)) { Session.initialize(); return true; } } return false; }}Chức năng phụ ở đây là Session.initialize(). Tên hàm của nó chỉ mô tả kiểm tra mật khẩu, không nói đến việc khởi tạo Session. Vì vậy người gọi tin vào tên của nó, gọi hàm và rất có thể sẽ xóa bỏ toàn bộ thông tin đã tồn tại trong session. Lúc này có thể tên hàm sẽ là checkPasswordAndInitializeSession, nhưng nó không thỏa mãn tiêu chí Do one thing. Đối số đầu raCác đối số mặc định được hiểu là các đối số đầu vào của 1 hàm. Tuy nhiên hãy xem xét ví dụ1appendFooter(s);Hàm này thêm s vào footer hay thêm 1 vài footer vào s? s là input hay output. Nó không mất nhiều thời gian để xem chữ ký hàm và nhìn thấy:1public void appendFooter(StringBuffer report)Như vậy đã làm rõ được vấn đề nhưng chi phí bỏ ra là phải check khai báo hàm (thì ra là thêm footer cho một cái report nào đó, haizz). Mỗi thứ làm bạn phải check chữ ký của hàm tương đương với double-take. Điều đó cần tránh trong lập trình. Trong những ngày trước khi lập trình hướng đối tượng, đôi khi cần phải có đối số đầu ra. Tuy nhiên phần lớn nhu cầu đối số đầu ra biến mất trong các ngôn ngữ OOP, nó có thể được sử dụng thông qua this và tránh được các tham số đầu ra1report.appendFooter(); Command Query Separation: Phân tách các lệnh truy vấnCác hàm nên làm một cái gì đó hoặc trả lời một cái gì đó, nhưng không phải cả hai. Hoặc hàm sẽ thay đổi trạng thái của một đối tượng hoặc nó sẽ trả về một số thông tin về đối tượng đó. Làm cả hai thường dẫn đến nhầm lẫn. Hãy xem xét, ví dụ, sau đây chức năng:1public boolean set(String attribute, String value);hàm này sẽ set giá trị cho 1 thuộc tính và trả về true nếu nó thành công và false nếu không có thuộc tính tồn tại.1if (set(&quot;username&quot;, &quot;unclebob&quot;))...Tưởng tượng từ góc nhìn của người đọc. Điều đó có ý nghĩa gì? Nó kiểm tra “username” đã được set “unclebob” từ trước hay kiêm tra set “username” là “unclebob” thành công hay không? Nó khó có thể suy ra ý nghĩa từ cuộc gọi này vì nó không rõ ràng về việc từ “set” là một động từ hay tính từ. Người viết hàm dự định set là 1 động từ nhưng khi đặt nó trong bối cảnh với if, nó dường như lại là một tính từ. Do đó mới xảy ra sự hiểu nhầm như trên. Chúng ta nên cố giải quyết vấn đề bằng cách đặt tên lại cho hàm là setAndCheckIfExists nhưng nó lại không có ích cho việc có thể đọc được trong khối if. Giải pháp thực sự là tách lệnh từ truy vấn để sự mơ hồ không thể xảy ra.1234if (attributeExists(&quot;username&quot;)) { setAttribute(&quot;username&quot;, &quot;unclebob&quot;); ...} Bạn nên viết hàm như thế nào?Viết phần mềm cũng như viết các thứ khác. Khi bạn viết báo hoặc tạp chí. Bạn viết các ý tưởng của bạn đầu tiên, sau đó bạn chỉnh sửa nó cho tới khi đọc có vẻ ổn. Bản thảo đầu tiên có thể là vụng về và vô tổ chức, vì vậy bạn cơ cấu lại nó và tinh chỉnh nó cho đến khi nó có thể đọc theo cách bạn muốn nó đọc. Khi bạn viết 1 hàm, chúng quá dài và phức tạp. Có rất nhiều indenting và các vòng lặp lồng nhau. Nó có quá nhiều đối số. Các tên tùy ý, có các mã lặp lại. Và cũng có các đoạn mã unit tests để test chỗ code lôm côm này. Vì vậy, sau đó bạn xem lại và tinh chỉnh đoạn mã đó, tách các hàm nhỏ hơn, thay đổi tên, loại bỏ trùng lặp. Bạn cần thu nhỏ các phương thức và sắp xếp lại chúng, đôi khi bạn cần phá vỡ toàn bộ các lớp đã xây dựng từ trước đó. Cuối cùng, bạn kết thúc với các chức năng tuân theo các quy tắc mà tác giả đã đặt ra trong chương này. Tổng kết: Khi sử dụng switch-case, cân nhắc sử dụng ABSTRACT FACTORY. Cân nhắc và tìm cách giảm đối số truyền vào của 1 hàm, xuống 1 đến 2 là tốt để có thể test và dễ hiểu. Tên hàm cũng cực kì quan trọng, tránh để double-take. Tên đẹp nhất là cum verb/noun(cho loại hàm 1 đối số). Nguyên tắc mang tính chất tham khảo, tùy mục đích mà bạn có thể áp dụng cho không. Nếu các project không có các đoạn unit tests hoặc không coi trọng clean, bạn có thể tạo ra các hàm với nhiều đối số, cờ để thuận tiện nhất cho project :D. Tài liệu tham khảo Chapter 3: Clean Code. ABSTRAC FACTORY","link":"/2019/04/11/Clean-code-Chapter-3-Function-Phan-2/"},{"title":"[Clean code] Chapter 4: Comment","text":"Sự thật chức năng các hàm, lớp làm gì chỉ có thể được tìm thấy ở một nơi: code. Chỉ có code mới thực sự có thể cho bạn biết nó đang có gì và làm gì. Đây là nguồn thông tin thực sự chính xác duy nhất. Do đó, mặc dù comment là đôi khi là cần thiết, nhưng chúng ta sẽ tìm cách để tối thiểu nó trong code của mình để tránh gây hoang mang thông tin :v. Comment thường được khuyên là không nên cho vào trong code “Don’t comment bad code—rewrite it.” Comments Do Not Make Up for Bad CodeMột trong những lý do chính để bạn comment là bad code. Bạn viết xong 1 đoạn code, bạn đọc lại và thấy nó thật khó hiểu và vô tổ chức. Sau đó bạn thêm một vài đoạn comment vào giải thích cho các đoạn code đó và tự nhủ với mình “Đoạn code đã tốt hơn rồi”. Không, sẽ tốt hơn là bạn nên xóa nó đi :DMột đoạn mã tốt với chỉ với một vài comment sẽ tốt hơn rất nhiều so với sự lộn xộn và phức tạp của một đoạn mã với quá nhiều comment. Thay vì dành thời gian để viết comment cho những mớ hỗn độn của mình thì hãy dành thời gian để xóa nó. Explain Yourself in Code: Tự giải thích trong codeXem xét đoạn code sau với comment12// Check to see if the employee is eligible for full benefitsif ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))Bạn thấy ổn không? Có comment giải thích đoạn if cho bạn. Vậy tại sao không để nó tự giải thích như thế này chẳng hạn if (employee.isEligibleForFullBenefits()) Chỉ mất vài giây để người đọc hiểu đoạn code muốn đề cập đến vấn đề gì thay vì đọc comment Good CommentsNhận xét nên hạn chế được đưa vào code, tuy nhiên dưới đây là một số good comment bạn nên đưa vào để bổ sung các thông tin hữu ích cho các đoạn code của bạn. Legal Comments: Comment về pháp lýĐó là các comment để cho người khác biết ai viết đoạn code đó. Bạn nên comment để cho người khác biết. Nếu bạn dùng PHPStorm, các đoạn comment này được sinh mỗi khi bạn tạo file:12345678&lt;?php/** * Created by PhpStorm. * User: FRAMGIA\\nguyen.van.minhb * Date: 20/07/2018 * Time: 08:50 */class Controller_Event extends \\Controller Các comment chứa thông tinĐó là các thông tin khá hữu ích, cung cấp các thông tin cơ bản nhất về 1 hàm (chẳng hạn đầu vào, đầu ra):12// Returns an instance of the Responder being tested.protected abstract Responder responderInstance();Hoặc đôi khi là format dữ liệu đầu ra để bổ sung cho lập trình viên123// format matched kk:mm:ss EEE, MMM dd, yyyyPattern timeMatcher = Pattern.compile(&quot;\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d*, \\\\d*&quot;);Tuy nhiên lời khuyên ở đây là tốt nhất bạn vẫn nên để tên hàm nói lên các thông tin này. Nếu không thể hoặc muốn bổ trợ thì hãy dùng comment. (Ví dụ như Accesstor, Mutators hay các nhận định thì bản chất tên hàm đã nói lên ý nghĩa của nó rồi, chắc không cần comment nữa) Lời khuyên thứ 2 là bạn nên dùng PHPStorm để nó có thể sinh chuẩn format này cho bạn mã bạn đỡ phải nghĩ :D Giải thích thêm cho mục đích, quyết địnhĐôi khi, comment nên giải thích các thông tin hữu ích về việc thực thi và cung cấp ý định đằng sau quyết định, các đoạn code xử lý (trả lời câu hỏi Why). Đây là một ví dụ. Bạn có thể không đồng ý với giải pháp của lập trình viên để giải quyết vấn đề, nhưng ít nhất bạn biết những gì ông đã cố gắng để làm.1234567891011121314151617public void testConcurrentAddWidgets() throws Exception { WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[]{BoldWidget.class}); String text = &quot;'''bold text'''&quot;; ParentWidget parent = new BoldWidget(new MockWidgetRoot(), &quot;'''bold text'''&quot;); AtomicBoolean failFlag = new AtomicBoolean(); failFlag.set(false); //This is our best attempt to get a race condition //by creating large number of threads. for (int i = 0; i &lt; 25000; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); } assertEquals(false, failFlag.get());} Đưa ra cảnh báo hậu quảĐôi khi rất hữu ích khi cảnh báo những người lập trình khác về những hậu quả nhất định. Ví dụ dưới đây đưa ra các cảnh báo sử dụng hàm nếu bạn không có thời gian để tắt nó đi:1234567891011// Don't run unless you// have some time to kill.public void _testWithReallyBigFile(){ writeLinesToFile(10000000); response.setBody(testFile); response.readyToSend(this); String responseString = output.toString(); assertSubString(&quot;Content-Length: 1000000000&quot;, responseString); assertTrue(bytesSent &gt; 1000000000);} TO DO commentĐó là comment các công việc bạn chưa kịp thực hiện hoặc các chức năng bạn có thể phát triển trong tương lai:123456//TODO-MdM these are not needed// We expect this to go away when we do the checkout modelprotected VersionInfo makeVersion() throws Exception{ return null;} Bad commentsĐa số các comment đều thuộc thể loại này. Kể cả đối với các good comment người ta vẫn khuyên bạn không nên đưa nó vào trong code nếu thực sự không cần thiết. Comment thừaNhững comment như thế này là những comment không có ý nghĩa, đôi khi có làm gián đoạn hay khó chịu với người đọc. Xét ví dụ sau: i++; // increment i Chắc hẳn ví dụ này hơi ngây thơ. Thôi thử vào Laravel đi, lớp “User” mặc định nhé:12345678910111213141516171819202122class User extends Authenticatable{ use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ 'name', 'email', 'password', ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ 'password', 'remember_token', ];}Những comment như trên quả thật là thừa. Gần như ai cũng biết các biến $fillable, $hidden hay thâm chí là $table, $primaryKey để lưu làm gì rồi (vì nó đã có trong document và quy ước chung), comment như vậy không bố trợ thêm mà gây dài dòng khó chịu cho đoạn code. Commented-Out CodeĐó là những comment như thế nào. Đó là những comment không được chạy nhưng vẫn được comment kiểu như thế này:1234567891011121314this.bytePos = writeBytes(pngIdBytes, 0);//hdrPos = bytePos;writeHeader();writeResolution();//dataPos = bytePos;if (writeImageData()) { writeEnd(); this.pngBytes = resizeByteArray(this.pngBytes, this.maxPos);}else { this.pngBytes = null;}return this.pngBytes;Những người khác thấy rằng mã đã nhận xét sẽ không có đủ can đảm để xóa nó. Họ sẽ nghĩ nó ở đây vì một vào lý do và rất quan trọng không dám xóa.Họ sẽ đặt ra các câu hỏi, tại sao đoạn code này ở đây? Nó có quan trọng? Họ để lại nó như là một lời nhắc với một vài sự thay đổi? Đã có một thời gian, trở lại vào những năm sáu mươi, khi mã bình luận ra có thể là hữu ích. Nhưng bây giờ công nghệ phát triển, chúng ta đã có các hệ thống quản lý mã nguồn trong một thời gian rất dài (như git chẳng hạn), những comment như vậy là hoàn toàn không cần thiết. Những hệ thống sẽ nhớ code giúp chúng ta. Chúng ta không phải bình luận thêm nữa. Chỉ xóa mã. Chúng ta sẽ không mất nó. Hứa đó :D. Đừng comment khi bạn có thể sử dụng biến để thay thếHãy ưu tiên sử dụng biến, hàm hơn là comment. Thay vì comment nhiều như thế này 123// does the module from the global list &lt;mod&gt; depend on the// subsystem we are part of?if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) Hãy biến chúng thành các biến:123ArrayList moduleDependees = smodule.getDependSubsystems();String ourSubSystem = subSysMod.getSubSystem();if (moduleDependees.contains(ourSubSystem))Lần đầu viết đoạn code bạn có thể comment và sau đó viết đoạn code để thực hiện comment đó. Tuy nhiên trong lần tái cấu trúc, hãy thêm biến để xóa bỏ các comment đó như ông Robert Cecil Martin đã làm =)) Nonlocal InformationÝ tưởng chung của nó là khi bạn comment gì thì bạn tập trung vào vấn đề đó. Nếu bạn phải viết comment và sau đó, hãy chắc chắn nó miêu tả cho đoạn code xuất hiện gần đó. Không được cung cấp thông tin toàn hệ thống trong ngữ cảnh nào đó xa xôi:123456789/*** Port on which fitnesse would run. Defaults to &lt;b&gt;8082&lt;/b&gt;.** @param fitnessePort*/public void setFitnessePort(int fitnessePort){ this.fitnessePort = fitnessePort;} Comment có quá nhiều thông tinComment không cần đưa lịch sử công nghệ vào :v, chỉ cần đưa RFC cho họ tự tìm là được rồi:123456789101112131415/*RFC 2045 - Multipurpose Internet Mail Extensions (MIME)Part One: Format of Internet Message Bodiessection 6.8. Base64 Content-Transfer-EncodingThe encoding process represents 24-bit groups of input bits as outputstrings of 4 encoded characters. Proceeding from left to right, a24-bit input group is formed by concatenating 3 8-bit input groups.These 24 bits are then treated as 4 concatenated 6-bit groups, eachof which is translated into a single digit in the base64 alphabet.When encoding a bit stream via the base64 encoding, the bit streammust be presumed to be ordered with the most-significant-bit first.That is, the first bit in the stream will be the high-order bit inthe first 8-bit byte, and the eighth bit will be the low-order bit inthe first 8-bit byte, and so on.*/ Tổng kết Hạn chế đưa comment vào code của bạn, hãy cố gắng để các hàm, các biến, các lớp tự nói lên chức năng của nó. Một vài trường hợp “good comment” như comment về pháp lý để chứng thực tác giả, comment tổng quan về chắc năng hàm (input, output), comment để đưa ra lý do quyết định thực hiện quyết định (tại sao lại if, for, while ở chỗ này). Còn lại hầu như là các “bad comment”. Lý thuyết chỉ mang tính chất lời khuyên để code của bạn dễ đọc hơn chứ không bắt buộc bạn phải tuân theo, vì vậy thực tiễn bạn có thể thay đổi, miễn là code của bạn dễ đọc với bạn và với team là được =)). Tài liệu tham khảoChapter 4: Clean Code","link":"/2019/04/11/Clean-code-Chapter-4-Comment/"},{"title":"[Clean code] Chapter 7: Error Handling","text":"Trong chương này, một số tips có thể giúp bạn xử lý các error tốt hơn, làm code đẹp hơn :D Use Exceptions Rather Than Return Codes (Sử dụng Exceptions hơn là trả về giá trị trong code)Trở lại quá khứ xa xôi có nhiều ngôn ngữ không có ngoại lệ. Trong những ngôn ngữ các kỹ thuật xử lý và báo cáo lỗi bị hạn chế. Bạn có thể đặt lỗi cờ hoặc trả lại mã lỗi mà người gọi có thể kiểm traVấn đề với các phương pháp này là chúng gây lộn xộn, khó xử lý cho người đọc. Người gọi hàm phải check lỗi ngay lập tức sau khi gọi nó. Không may, nó quá dễ để quên. Cách tốt hơn là bạn bắn ra một ngoại lệ khi bạn gặp một lỗi. Mã sẽ sạch đẹp hơn và code logic không bị che khuất đi bởi việc xử lý lỗi Ví dụ như:12345678910111213141516171819202122public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(&quot;Device suspended. Unable to shut down&quot;); } } else { logger.log(&quot;Invalid handle for: &quot; + DEV1.toString()); } } ...}Nên tách thành code như sau:123456789101112131415161718192021222324public class DeviceController { ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { ... throw new DeviceShutDownError(&quot;Invalid handle for: &quot; + id.toString()); ... } ...}Ta xét trong Laravel, chẳng hạn repository bạn xử lý hàm update một model:12345678910public function updateBook($id, $attribute){ $boook = Book::find($id); if (!empty($book)) { $book-&gt;update($attribute); return true; } else { return false; }}Đoạn code trên trả về true, false đồng nghĩa việc sinh thêm việc cho phần code nào gọi nó lại phải check true, false, đặc biệt là khi trả về false lớp gọi hàm này lại phải xem vì sao false? Thay vào đó hãy để hàm đó tự xử để lớp gọi nó đỡ phải kiểm tra123456789public function updateBook($id, $attribute){ $boook = Book::find($id); if (!empty($book)) { $book-&gt;update($attribute); } else { throw new Exception('404'); }}Như vậy hàm đó đã tự xử lý lỗi mà không đẩy trách nhiệm cho ai gọi nó nữa. Nếu không tìm thấy nó sẽ bắn ra exception 404 Write Your Try-Catch-Finally Statement FirstMột trong những thứ quan trọng về ngoại lệ là chúng được “define a scope” (định nghĩa các phạm vi) với chương trình của bạn. Khi bạn thực thi code trong khối try, trong khối try-cactch-finally. Bạn đang nói rõ hơn là đoạn code thực thi này có thể bị gián đoạn ở một vài chỗ, cái sẽ được xử lý trong catch Trong cách này, khối try giống như một transactions (phiên giao dịch). Catch của bạn sẽ không được thực thi nếu không có vấn đề gì với try. Với lý do này, thật là một good practice để bắt đầu một khối try-catch-finally khi bạn viết code có thể xảy ra ngoại lệ. có thể khiển người dùng định nghĩa được cái mong muốn, không vấn đề gì phát sinh nếu như sai đoạn code trong try 12345678910111213public static function createModel($request){ try { $book = Book::forge(); $book-&gt;title = $request['title']; $book-&gt;author = $request['author']; $book-&gt;price = $request['price']; $book-&gt;cover_img = $request['cover_img']; $book-&gt;save(); } catch (Exception $ex) { throw new Exception($ex-&gt;getCode()); }} Provide Context with Exceptions (Cung cấp “ngữ cảnh” với các ngoại lệ)Mỗi ngoại lệ mà bạn “ném ra” phải cung cấp đủ ngữ cảnh để xác định nguồn và vị trí của một lỗi.tạo ra các thông báo lỗi và truyền nó cùng với ngoại lệ của bạn. Đề cập đến hoạt động đó, lỗi gì và vì sau lại lỗi. Ví dụ nếu bạn đăng nhập vào ứng dụng của mình, truyền đủ thông tin nhất có thể để bạn có thể log lại các lỗi mỗi khi bạn bắt đượcÝ tưởng chung là hãy ghi lỗi ra log một cách chi tiết nhất có thể để dễ dàng debug 1234567891011121314151617public function store(CategoryRequest $request){ $this-&gt;authorize('create', Category::class); try { $data = $request-&gt;only('name'); $this-&gt;cateRepository-&gt;create($data); return redirect()-&gt;route('categories.index') -&gt;with('message', trans('admin.category.success_add')); } catch (Exception $ex) { Log::useDailyFiles(config('app.file_log')); Log::error($ex-&gt;getMessage()); return redirect()-&gt;route('categories.index') -&gt;with('error', trans('admin.category.error')); }} Define Exception Classes in Terms of a Caller’s Needs: Định nghĩa các lớp Exception cần thiếtPhần này để cập đến việc xử lý lỗi đến từ bên thứ 3 (Có thể là API hoặc các dịch vụ bên thứ 3). Có rất nhiều cách để phân loại lỗi. Bạn có thể phân loại lỗi theo nguồn gốc của chúng: chúng đến từ thành phần nào, loại lỗi gì, thiết bị hay mạng hay lỗi do lập trình. Tuy nhiên, khi chúng ta nên định nghĩa các lớp ngoại lệ trong một ứng dụng, mối quan tâm quan trọng nhất của chúng ta nên là chúng bị bắt như thế nào.Xem xét về một ví dụ về try catch cơ bản, có gọi thư viện bên thứ 3: 123456789101112131415ACMEPort port = new ACMEPort(12);try { port.open();} catch (DeviceResponseException e) { reportPortError(e); logger.log(&quot;Device response exception&quot;, e);} catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(&quot;Unlock exception&quot;, e);} catch (GMXError e) { reportPortError(e); logger.log(&quot;Device response exception&quot;);} finally {...} Chúng ta có thể thấy đoạn code chỉ thực hiện mở 1 port từ bên thứ 3 mà xử lý nhiều ngoại lệ quá :D. Có quá nhiều đoạn mã xử lý lỗi giống nhau được lặp lại và bạn không thể theo dõi. Trong hầu hết các trường hợp xử lý ngoại lệ, công việc chúng tôi làm là tương đối chuẩn bất kể nguyên nhân thực sự. Chúng tôi phải ghi lại lỗi và đảm bảo rằng chúng tôi có thể xử lý.Để giải quyết nó, ta sẽ tạo một lớp mới chuyên dụng xử lý riêng cho bên thứ 3. Đoạn code viết lại như sau:123456789LocalPort port = new LocalPort(12);try { port.open();} catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e);} finally {...}Với lớp LocalPort là lớp chuyên dụng xử lý các ngoại lệ có thể xảy ra khi mở port ACMEPort123456789101112131415161718public class LocalPort { private ACMEPort innerPort; public LocalPort(int portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); } catch (DeviceResponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } catch (GMXError e) { throw new PortDeviceFailure(e); } } ...} Define the Normal Flow: Định nghĩa một luồng bình thường (khi ngoại lệ lẫn lộn với code logic)Nếu như bạn theo dõi các lời khuyên từ phần trước, bạn sẽ kết thúc với ý niệm tách biệt code logic nghiệp vụ và code xử lý lỗi. Phần lớn code của bạn sẽ bắt đầu trông giống như một thuật toán chưa được sắp xếp. Tuy nhiên, quá trình thực hiện điều này đẩy phát hiện lỗi đến các cạnh của chương trình của bạn (kiểu đẩy các phần xử lý error xuống dưới). Bạn bọc các “external API” để ném vào các error và định nghĩa các xử lý nó. Nhưng đôi khi bạn không muốn bỏ qua hẳn nó mà vẫn muốn xử lý thêm thì sao? Xem xét ví dụ sau:123456try { MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal();} catch(MealExpensesNotFound e) { m_total += getMealPerDiem();}Trong ví dụ này, nếu bữa ăn được mở rộng, nó trở thành một phần của tổng số. Exception lại hỗn độn với code logic. Nó sẽ tốt hơn nếu bạn không có giao dịch nào với trường hợp đặc biệt ở đây, code của bạn có thể trông đơn giản hơn, như thế này 12MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());m_total += expenses.getTotal(); Chúng ta có thể làm code trở nên đơn giản như vậy? Chúng ta có thể thay đổi ExpenseReportDAO để nó luôn trả về một đối tượng MealExpense. Nếu không có bữa ăn chi phí, nó trả về một đối tượng MealExpense trả về cho mỗi diem như tổng số của nó: 12345public class PerDiemMealExpenses implements MealExpenses { public int getTotal() { // return the per diem default }} Cái này gọi là SPECIAL CASE PATTERN [Fowler]. Bạn tạo 1 lớp hoặc config 1 object để nó xử lý các trường hợp đặc biệt cho bạn. Khi bạn làm vậy, client code không có giao dịch nào với hành động ngọai lệ. Hành động đó được đóng gói trong lớp đặc biệt Đừng trả về nullXem xét ví dụ sau:1234567891011public void registerItem(Item item) { if (item != null) { ItemRegistry registry = peristentStore.getItemRegistry(); if (registry != null) { Item existing = registry.getItem(item.getID()); if (existing.getBillingPeriod().hasRetailOwner()) { existing.register(item); } } }}Khi chúng ta trả về null, chúng ta chủ yếu tạo ra công việc cho chính chúng ta và đẩy vấn đề khi người gọi. Tất cả phải mất là một mất kiểm tra null để gửi một ứng dụng quay ra khỏi tầm kiểm soát.Bạn có để ý là trên thực tế khi có một check null, bạn lại phải tạo 1 block lồng bên trong 1 khối if? Điều gì sẽ xảy ra nếu persistentStore là null? Nó sẽ sinh ra một NullPointerException trong khi chạy và ai đó có thể bắt trên cùng hoặc là không? Đúng là tồi tệ Thật dễ dàng để nói rằng vấn đề với đoạn code ở trên là thiếu check null nhưng trong thực tế vấn đề này có rất nhiều. Hãy xem xét ném ra một ngoại lên hoặc trả về một SPECIAL CASE object thay thế. Nếu bạn nhận một giá trị null trả về từ API của bên thứ 3, cân nhắc đóng nó vào với một phương thức, cái mà thay vì trả về một ngoại lệ nó sẽ trả về một SPECIAL CASE OBJECT. Xem xét đoạn code sau: 123456List&lt;Employee&gt; employees = getEmployees();if (employees != null) { for(Employee e : employees) { totalPay += e.getPay(); }} Nêu được sửa thành:1234List&lt;Employee&gt; employees = getEmployees();for(Employee e : employees) { totalPay += e.getPay();}và (trả về danh sách trống hơn là null)1234public List&lt;Employee&gt; getEmployees() { if( .. there are no employees .. ) return Collections.emptyList();}Nếu bạn code theo cách này, bạn sẽ giảm thiểu cơ hội cho NullPointerExceptions và code của bạn sẽ rõ ràng hơn Đừng truyền vào nullPhương thức trả về null là tồi nhưng truyền null vào 1 phương thức còn tệ hại hơn. Trừ khi bạn đang làm việc với API, cái mà yêu cầu bạn truyền null, bằng không bạn nên tránh truyền null vào code của bạnXem xét ví dụ dưới đây để hiểu vì sao? Phương thức tính toán số liệu cho 2 điểm: 1234567public class MetricsCalculator{ public double xProjection(Point p1, Point p2) { return (p2.x – p1.x) * 1.5; } ...} Chuyện gì sẽ xảy ta nếu truyền null vào như 1 đối số calculator.xProjection(null, new Point(12, 13)); Chúng ta nhận được một NullPointerException tất nhiên. Làm sao đến fix nó123456789public class MetricsCalculator{ public double xProjection(Point p1, Point p2) { if (p1 == null || p2 == null) { throw InvalidArgumentException(&quot;Invalid argument for MetricsCalculator.xProjection&quot;); } return (p2.x – p1.x) * 1.5; }}Liệu nó có ngon hơn không? nó có thể tốt hơn một chút là nhận về exception null nhưng hãy nhớ rằng chúng ta lại phải sinh ra một thứ xử lý cho InvalidArgumentException? Hàm xử lý đó nên làm gì? Nó có bất kì hành động nào tốt không? 12345678public class MetricsCalculator{ public double xProjection(Point p1, Point p2) { assert p1 != null : &quot;p1 should not be null&quot;; assert p2 != null : &quot;p2 should not be null&quot;; return (p2.x – p1.x) * 1.5; }} Đó là một tài liệu tốt nhưng vẫn chưa giải quyết được vấn đề. Nếu có ai dó truyền vào null, chúng ta vẫn bị lỗi runtime errorTrong hầu hết các ngôn ngữ lập trình, chưa có cách tốt nhất để deal với null, cái mà có thể gây ra một “tai nạn” cho người gọi :v. Bởi vì trong trường hợp này, cách tiếp cận tốt nhất là cấm truyền null như là mặc định :v. Khi bạn làm, bạn có thể viết mã với kiến thức rằng một null trong mộtdanh sách đối số là dấu hiệu của sự cố và kết thúc với ít sai sót bất cẩn hơn rất nhiều Tóm lại Sử dụng các exception thay vì trả về giá trị để các lớp gọi nó đỡ phải xử lý tiếp. Viết các đoạn code thành Try-Catch-Finally để dễ quan sát các xử lý code và ngoại lệ. Cung cấp đầy đủ thông tin ngoại lệ nhất (có thể ghi log) để dễ dàng debug :D. Nếu exception có code logic hoặc các exception gây ra bởi bên thứ 3, cân nhắc “wrapping”- đóng gọi lại trong một lớp ngoại lệ mới ta xây dựng. Chưa có cách hoàn hảo nhất để xử lý với null, hạn chế truyền và nhận nó vào các hàm. Hi vọng một vài tips trên giúp bạn xử lý lỗi tốt hơn trong code của mình &lt;3 Tài liệu tham khảoChapter 7: Clean Code","link":"/2019/04/11/Clean-code-Chapter-7-Error-Handling/"},{"title":"[Collection] Functional Building Blocks","text":"Map chỉ là 1 trong hàng chục hàm bậc cao mạnh (HOF) mẽ để làm việc với mảng. Chúng ta sẽ nói về rất nhiều về chúng trong các ví dụ sau, nhưng chúng ta hãy xem xét 1 số điều cơ bản ở những cấp độ đầu tiên. EACHEach is no more than a foreach loop wrapped inside of a higher order function: (không khác gì 1 vòng lặp foreach) 123456function each($items, $func){ foreach ($items as $item) { $func($item); }} Bạn có thể tự hỏi là “tại sao ai đó lại quan tâm đến việc này”? Một trong những lợi ích là nó ẩn các chi tiết thực hiện của vòng lặp (và chúng tôi ghét vòng lặp) :D Hãy tưởng tượng PHP không có vòng lặp foreach. Khi đó để thực thi each, chúng ta sẽ làm như sau 123456function each($items, $func){ for ($i = 0; $i &lt; count($items); $i++) { $func($items[$i]); }} Và với cách này, có 1 sự trừu tượng cần thực hiện là “làm điều này với mọi phần tử trong mảng”. Nó sẽ như sau: 123for ($i = 0; $i &lt; count($productsToDelete); $i++) { $productsToDelete[$i]-&gt;delete();} Và viết lại nó như sau, rõ ràng hơn một chút 123each($productsToDelete, function ($product) { $product-&gt;delete();}); Each cũng trở nên cải tiến rõ ràng so với việc sử dụng foreach trực tiếp ngay cả khi bạn nhận nó trong toán tử của hàm nào đó, cái mà chúng ta sẽ đề cập trong phần sau của cuốn sách Một vài thứ bạn cần nhớ với each: Nếu bạn đang muốn sử dụng một loại biến nào đó để thu thập giá trị (1 biến lưu giá trị) (sử dụng 1 biến để lưu giá trị của collection), each không phải là một sự lựa chọn.123456789// Bad! Use `map` instead.each($customers, function ($customer) use (&amp;$emails) { $emails[] = $customer-&gt;email;});// Good!$emails = map($customers, function ($customer) { return $customer-&gt;email;}); Không giống như các toán tử cơ bản với mảng khác, each không trả về giá trị. Điều nó gợi ý cho bạn rằng nó nên để dành cho thực hiện hành đồng, như xóa products, shiping orders, sending emails, vân vân123each($orders, function ($order) { $order-&gt;markAsShipped();}); MAP Map được sử dụng để transform (chuyển đổi) mỗi item trong mảng sang cái gì đó. Nhận vào 1 vài mảng của các items và 1 hàm, map sẽ apply hàm đó với mỗi phần tử và tạo ra mảng mới giống size 12345678910function map($items, $func){ $result = []; foreach ($items as $item) { $result[] = $func($item); } return $result;} Nhớ rằng mỗi phần tử của mảng mới có quan hệ tương ứng phần tử mảng gốc. Một cách tốt để nhớ map làm việc như thế nào là nghĩ nó là 1 mapping giữa mỗi phần tử mảng cũ và mảng mới. Map sẽ công cụ tuyệt vời để thực hiện: Lấy, trích xuất 1 trường từ 1 mảng các đối tượng, như là mapping customes vào địa chỉ email123$emails = map($customers, function ($customer) { return $customer-&gt;email;}); Tạo một mảng các đối tượng từ dữ liệu thô, như mapping 1 mảng kết quả dữ liệu JSON vào mảng đối tượng ta quan tâm123$products = map($productJson, function ($productData) { return new Product($productData);}); Chuyển đổi mỗi phần tử với 1 format mới123$displayPrices = map($prices, function ($price) { return '$' . number_format($price / 100, 2);}); MAP vs EACH Một lỗi chung tôi nhìn thấy của mọi người là sử dụng map khi mà họ nên sử dụng each. Xem xét ví dụ each sau khi xóa products. Bạn có thể thực thi sử dụng mao và về mặt kỹ thuật thì nó không hề ảnh hưởng:123map($productsToDelete, function ($product) { $product-&gt;delete();});Mặc dù code hoạt động nhưng dường như nó chưa đúng về mặt ngữ nghĩa. Chúng ta đang không map cái qué gì cả. Đoạn code sẽ đi qua tất cả các lỗi (kiểu các lỗi có thể gặp phải) tạo 1 mảng mới cho chúng ta và mảng được tạo với mỗi phần tử là null và chúng ta không làm gì với chúng. Map được dùng để transforming 1 mảng vào mảng mới. Nếu bạn không chuyển đổi cái gì, bạn không nên dùng map. Như 1 chuẩn chung, bạn nên sử dụng each thay cho map nếu 1 trong nhưng điều sao là đúng: Callback không trả về gì? map có trả về dữ liệu nhưng về sau bạn lại ko thực hiện thao tác gì với nó (You don’t do anything with the return value of map .) Bạn chỉ đang cố gắng thực hiện 1 vài hành động gì đó với mỗi phẩn tử của mảng FILTERChúng ta có 1 danh sách các sản phẩm và chúng ta biết cái nào đã hết. Nếu không sử dụng HOF, code sẽ như sau:123456789$outOfStockProducts = [];foreach ($products as $product) { if ($product-&gt;isOutOfStock()) { $outOfStockProducts[] = $product; }}return $outOfStockProducts;Tương tự, nếu bạn muốn products cái mà có giá lớn hơn $10012345678$expensiveProducts = [];foreach ($products as $product) { if ($product-&gt;price &gt; 100) { $expensiveProducts[] = $product; }}return $expensiveProducts;Điểm khác biệt giữa 2 ví dụ trên chỉ là điều kiện và ta có thể trừu tượng hóa nó tương tự map. Hàm mà chúng ta để thực hiện việc đó được gọi là filter12345678910111213141516171819function filter($items, $func){ $result = []; foreach ($items as $item) { if ($func($item)) { $result[] = $item; } } return $result;}$outOfStockProducts = filter($products, function ($product) { return $product-&gt;isOutOfStock();});$expensiveProducts = filter($products, function ($product) { return $product-&gt;price &gt; 100;});Toán tử filter được sử dụng để filter out (loại bỏ khỏi) 1 vài phần tử ra khỏi mảng mà bạn không muốn. Bạn nói với filter rằng phần tử nào truyền callback vào trả về true nếu bạn muốn giữ nó, trả về false nếu bạn muốn xóa nó. Một thứ quan trọng để hiểu về filter là nó KHÔNG thay đổi hay chuyển đổi giá trị trong mảng, nó chỉ đẩy các phần tử bạn không muốn. Điều đó có nghĩa các phần tử trong mảng mới không chỉ giống kiểu với các phần tử mảng cũ, chúng là same items. Điều này thì hoàn toàn trái ngược với map. Bạn phải map products với giá, nhưng bạn luôn luôn filter products vào mảng products mới Reject: ngược với filter REDUCEChúng ta có giỏ hàng mua sắm của các items và chúng ta cần tính toán tổng giá của giỏ hàng đó. Một cách đơn giản chúng ta làm là lặp qua tất cả các phần tử và tính toán:1234567$totalPrice = 0;foreach ($cart-&gt;items as $item) { $totalPrice = $totalPrice + $item-&gt;price;}return $totalPrice;Bây giờ hãy tưởng tượng vấn đề khác nơi bạn muốn gửi 1 email tới nhóm khách hàng và bạn cần sinh ra BCC line là dấu phẩy phân cách các email đó:1234567$bcc = '';foreach ($customers as $customer) { $bcc = $bcc . $customer-&gt;email . ', ';}return $bcc;Câu hỏi được đặt ra tương tự, liệu có thể trừu tượng hóa toán tử này?123456789101112131415161718function reduce($items, $callback, $initial){ $accumulator = $initial; foreach ($items as $item) { $accumulator = $callback($accumulator, $item); } return $accumulator;}$totalPrice = reduce($cart-&gt;items, function ($totalPrice, $item) { return $totalPrice + $item-&gt;price;}, 0);$bcc = reduce($customers, function ($bcc, $customer) { return $bcc . $customer-&gt;email . ', ';}, '');Higher order function như trên được gọi là reduce, cái mà nhận vào tất cả các biến chúng ta muốn lấy như 1 tham số With Great PowerNote 1: Toán tử reduce được sử dụng để nhận vào mảng các items và cắt giảm (reduce) nó xuống thành 1 giá trị đơn. Không có ràng buộc gì về giá trị đơn này, nó có thể là 1 số, 1 chuỗi, 1 object hoặc thậm chí là bất cứ gì bạn muốn, không vấn đề. Nó thậm chí có thể được sử dụng để giảm 1 mảng items vào 1 mảng khác, điều đó có nghĩa bạn thậm chí có thể thực thi map và filter trong điều kiện của reduce1234567function map($items, $func){ return reduce($items, function ($mapped, $item) use ($func) { $mapped[] = $func($item); return $mapped; }, []);}Note 2: Vì reduce là toán tử hàm ở level khá thấp, cái có thể biến 1 mảng thành bất cứ cái gì, và nó không phải luôn luôn giàu tính biểu đạt @@. Thỉnh thoảng khi bạn tự tìm thấy cách sử dụng reduce, cái mà bạn thực sự muốn là 1 higher level abstraction được built trên cao hơn của reduce, liên kết cái bạn đang cố làm rõ (kiểu sử dụng reduce ở mức thấp để trừu tượng hóa ở dưới, cái mình cần là lớp cao hơn, xây dựng các hàm giàu sức biểu đạt hơn như sum được xây dựng dựa trên reduce) Ví dụ tính tổng giá, ta tạo một trừu tượng mới trên top của reduce với tên gọi là sum:12345678910function sum($items, $callback){ return reduce($items, function ($total, $item) use ($callback) { return $total + $callback($item); }, 0);}$totalPrice = sum($cart-&gt;items, function ($item) { return $item-&gt;price;});And BCC list12345678910function join($items, $callback){ return reduce($items, function ($string, $item) use ($callback) { return $string . $callback($item); }, '');}$bcc = join($customers, function ($customer) { return $customer-&gt;email . ', ';});Trong 4 toán tử chúng ta tìm hiểu, reduce chắc chắn là khó nhớ nhất để áp dụng cho bạn. Khi thực hành, hãy cố gắng thực thi lại filter với reducer là và xem những gì bạn đã nghĩ ra =))","link":"/2019/12/27/Collection-Functional-Building-Blocks/"},{"title":"[Collection] Higher Order Functions","text":"Điểm qua một số lý thuyết về collection nào! Imperative vs. Declarative ProgrammingNó không phải là back và white nhé Imperative ProgrammingLập trình theo lệnh hay còn được gọi với tên khác là lập trình hướng thủ tục (Procedural Programming) Kiểu lập trình này tập trung vào việc “how something gets done“. Code sẽ thường xuyên tập trung vào việc building kết quả trong các biến trung gian và quản lý các luồng thông qua vòng lặp và các điều kiện. Chúng ta có 1 tập users và chúng ta muốn lấy danh sách email của các users. Code sẽ như sau1234567891011121314function getUserEmails($users){ $emails = []; for ($i = 0; $i &lt; count($users); $i++) { $user = $users[$i]; if ($user-&gt;email !== null) { $emails[] = $user-&gt;email; } } return $emails;}Thay vì cố gắng nói “give me the emails of users who have emails”, việc giải quyết tập trung vào việc thực thi chi tiết vào việc số vòng lặp, truy cập vào chỉ số của cấu trúc dữ liệu và quản lý bộ đếm Declarative ProgrammingThay vì tập trung vào việc máy tính nên làm việc như thế nào thì declaractive programing tập trung vào việc “what we need it to accomplish” (những gì chúng ta cần nó để đạt được mục đích.) So sánh đoạn code trên với đoạn code trong SQL:1SELECT email FROM users WHERE email IS NOT NULLChúng ta không phải viết bất cứ gì về vòng lặp, bộ đếm hay array indexs. Chúng ta chỉ nói với máy tính cái chúng ta muốn và không quan tâm nó lấy dữ liệu như thế nào. Under the hood, I’m sure the SQL engine must be doing some sort of iteration or keeping track of which records it’s checked or which records it hasn’t, but I don’t really know for sure. And that’s the beauty of it: I don’t need to know. Và dĩ nhiên PHP và một ngôn ngữ khác SQL và chúng ta sẽ không thể tạo lại cú pháp chính xác đó. Tuy nhiên chúng ta có thể tạo 1 cái gì đó gần giống? Chắc chắn là được, sử dụng Higher Order Functions Higher Order FunctionsTạm dịch là hàm bậc cao đi :D A higher order function is a function that takes another function as a parameter, returns a function, or does both.(Một higher order function là 1 hàm nhận 1 hàm khác như 1 tham số, trả về 1 hàm hoặc làm cả 2) Xem xét ví dụ sau, hàm bọc code database transaction:1234567891011121314public function transaction($func){ $this-&gt;beginTransaction(); try { $result = $func(); $this-&gt;commitTransaction(); } catch (Exception $e) { $this-&gt;rollbackTransaction(); throw $e; } return $result}Và đây là cách chúng ta sử dụng:1234567try { $databaseConnection-&gt;transaction(function () use ($comment) { $comment-&gt;save(); });} catch (Exception $e) { echo &quot;Something went wrong!&quot;;} Noticing PatternsHOF có sức mạnh to lớn vì chúng cho phép chúng ta tạo sự trừu tượng xung quanh các mẫu lập trình phổ biến mà không thể sử dụng lại Trở lại bài toán lấy danh ách email của khách hàng: 1234567$customerEmails = [];foreach ($customers as $customer) { $customerEmails[] = $customer-&gt;email;}return $customerEmails; Và bây giờ chúng ta cũng có danh sách các sản phẩm hàng tồn kho và chúng ta muốn biết tổng giá trị dư thừa của chúng ta là bao nhiêu: 12345678910$stockTotals = [];foreach ($inventoryItems as $item) { $stockTotals[] = [ 'product' =&gt; $item-&gt;productName, 'total_value' =&gt; $item-&gt;quantity * $item-&gt;price, ];}return $stockTotals; Nhìn lướt qua thì nó không có gì là quá trừu tượng hóa (abstract) được ở đây nhưng nếu bạn nhìn kỹ lại bạn sẽ nhận thấy chỉ có 1 điểm khác nhau thực sự giữa 2 ví dụ này. Trong cả 2 ví dụ, tất cả cái chúng ta làm là tạo ra 1 mảng mới bằng cách áp dụng 1 vài toán tử với mỗi item trong danh sách đã tồn tại. Cái mà chỉ khác nhau giữa 2 vi dụ thực chất là toán tử mà ta áp dụng Trong ví dụ đầu tiên, chúng ta chỉ thêm trường email vào mỗi item Trong ví dụ thứ 2, chúng ta tạo ra một tập hợp mảng từ 1 vài trường của item. Như vậy chúng ta đã thấy được sự trừu tượng có thể áp dụng ở đây, đó là việc truyền vào hàm xử lý cho mỗi xử lý là được 123456789101112131415161718192021function map($items, $func){ $results = []; foreach ($items as $item) { $results[] = $func($item); } return $results;}$customerEmails = map($customers, function ($customer) { return $customer-&gt;email;});$stockTotals = map($inventoryItems, function ($item) { return [ 'product' =&gt; $item-&gt;productName, 'total_value' =&gt; $item-&gt;quantity * $item-&gt;price, ];});","link":"/2019/12/27/Collection-Higher-Order-Functions/"},{"title":"[Collection] Practice 1: Pricing Lamps and Wallets","text":"Bây giờ chúng ta đã có những khái niệm cơ bản rồi, hãy xem cách sử dụng chúng thôi nào! Chúng ta đã thấy chúng ta có thể viết Collection, nhưng những ví dụ dưới đây chúng ta sẽ sử dụng những thứ thực thi có sẵn=&gt; Chọn Laravel để thực thi Bạn có thể tạo 1 Laravel Collection bằng 3 cách: Truyền 1 mảng vào hàm tạo:1$collection = new Collection($items); Sử dụng hàm tạo có tên làm make:1$collection = Collection::make($items); Sử dụng helper collect()1$collection = collect($items); Theo tác giả sử dụng cách 3 với helper tiết kiệm khoảng trống, code ngắn đẹp hơn và sẽ áp dụng cách đó cho phần tiếp theo Bài toánBài toán: Cho 1 JSON là products từ 1 cửa hàng, tính toán giá tiền của loại, biến thể (variants) đèn đơn và ví Ví dụ JSON:1234567891011121314151617181920212223242526272829303132333435{ &quot;products&quot;: [ { &quot;title&quot;: &quot;Small Rubber Wallet&quot;, &quot;product_type&quot;: &quot;Wallet&quot;, &quot;variants&quot;: [ { &quot;title&quot;: &quot;Blue&quot;, &quot;price&quot;: 29.33 }, { &quot;title&quot;: &quot;Turquoise&quot;, &quot;price&quot;: 18.50 } ] }, { &quot;title&quot;: &quot;Sleek Cotton Shoes&quot;, &quot;product_type&quot;: &quot;Shoes&quot;, &quot;variants&quot;: [ { &quot;title&quot;: &quot;Sky Blue&quot;, &quot;price&quot;: 20.00 } ] }, { &quot;title&quot;: &quot;Intelligent Cotton Wallet&quot;, &quot;product_type&quot;: &quot;Wallet&quot;, &quot;variants&quot;: [ { &quot;title&quot;: &quot;White&quot;, &quot;price&quot;: 17.97 } ] }, { &quot;title&quot;: &quot;Enormous Leather Lamp&quot;, &quot;product_type&quot;: &quot;Lamp&quot;, &quot;variants&quot;: [ { &quot;title&quot;: &quot;Azure&quot;, &quot;price&quot;: 65.99 }, { &quot;title&quot;: &quot;Salmon&quot;, &quot;price&quot;: 1.66 } ] }, // ... ]}Như vậy chúng ra có các tập sản phẩm, 1 vài cái có product_type là “Lamp” hoặc “Wallet” và 1 vài thì không. Mỗi sản phẩm cũng có số lượng “variants” và variants là cái thực tế sẽ có giá. Cách giải quyết đơn giản:123456789101112131415$totalCost = 0;// Loop over every productforeach ($products as $product) { $productType = $product['product_type']; // If the product is a lamp or wallet... if ($productType == 'Lamp' || $productType == 'Wallet') { // Loop over the variants and add up their prices foreach ($product['variants'] as $productVariant) { $totalCost += $productVariant['price']; } }}return $totalCost;OK bây giờ chúng ta cùng cải thiện vấn đề này nhé. Replace Conditional with Filter (cái này dễ đoán)Mục đích của chúng ta là phá vỡ foreach to và tìm cách cho vào chuỗi các bước đơn giản, độc lập, liên kết:12345678910111213$lampsAndWallets = $products-&gt;filter(function ($product) { $productType = $product['product_type']; return $productType == 'Lamp' || $productType == 'Wallet';});$totalCost = 0;foreach ($lampsAndWallets as $product) { foreach ($product['variants'] as $productVariant) { $totalCost += $productVariant['price']; }}return $totalCost; Replace || with Contains (contains methods)Một sự khéo léo nhẹ ở đây là sử dụng in_array để check123$lampsAndWallets = $products-&gt;filter(function ($product) { return in_array($product['product_type'], ['Lamp', 'Wallet']);});Trong collection thì in_array là contains, 1 sự cải tiến tuyệt vời vì nó xóa đi một vài sự mơ hồ trong thứ tự tham số:123$lampsAndWallets = $products-&gt;filter(function ($product) { return collect(['Lamp', 'Wallet'])-&gt;contains($product['product_type']);}); Reduce to SumOK phần filter ngon rồi, giờ tới phần dưới nào:123456789101112131415/**$lampsAndWallets = $products-&gt;filter(function ($product) { $productType = $product['product_type']; return $productType == 'Lamp' || $productType == 'Wallet';});**/$totalCost = 0;foreach ($lampsAndWallets as $product) { foreach ($product['variants'] as $productVariant) { $totalCost += $productVariant['price']; }}return $totalCost;Đoạn code này đang được tách biệt thành 2 phần Lấy giá của mỗi product variant Tính tổng giá để lấy tổng chung Chúng ta có thể chia như sau, và chúng ta có thể sử dụng reduce để thay thế bước 2123456789101112131415// Get all of the product variant prices$prices = collect();foreach ($lampsAndWallets as $product) { foreach ($product['variants'] as $productVariant) { $prices[] = $productVariant['price']; }}// Sum the prices to get a total cost$totalCost = $prices-&gt;reduce(function ($total, $price) { return $total + $price;}, 0);return $totalCost;Hãy nhớ rằng những gì tôi đã nói sớm hơn về chúng ta có thể thay thế reduce bằng nhưng toán tử giàu tính biểu đạt hơn. Thực ra thì thay reduce bằng sum nhanh hơn1return $prices-&gt;sum(); Replace Nested Loop with FlatMapBây giờ còn đoạn lấy ra giá các sản phẩm ở giữa12345678910111213141516/**// Get all of the product variant prices**/$prices = collect();foreach ($lampsAndWallets as $product) { foreach ($product['variants'] as $productVariant) { $prices[] = $productVariant['price']; }}/**// Sum the prices to get a total cost$totalCost = $prices-&gt;sum()return $totalCost;**/Nhìn qua thì có vẻ như chỉ cần map product variants với giá của nó nhưng chúng ta lại đang làm việc với tập products chứ không phải là với variants. Vậy chúng ta có thể làm ntn xây dựng 1 collection là tập variants và sau đó map chúng với giá là ngon :D. Ừ ok, dùng map lấy ra123$variants = $lampsAndWallets-&gt;map(function ($product) { return $product['variants'];});Vấn đề là bây giờ chúng ta có 1 colelction của mảng các variants, không phải mảng các vartiants123456789101112131415161718[ // ... [ { &quot;title&quot;: &quot;Blue&quot;, &quot;price&quot;: 29.33 }, { &quot;title&quot;: &quot;Turquoise&quot;, &quot;price&quot;: 18.50 } ], [ { &quot;title&quot;: &quot;Sky Blue&quot;, &quot;price&quot;: 20.00 } ], [ { &quot;title&quot;: &quot;White&quot;, &quot;price&quot;: 17.97 } ], { &quot;title&quot;: &quot;Azure&quot;, &quot;price&quot;: 65.99 }, { &quot;title&quot;: &quot;Salmon&quot;, &quot;price&quot;: 1.66 } ], // ...]Thật may khi chúng ta có 1 toán tử “làm phẳng” 1 collection về 1 level. Và kết hợp với map nữa thì nó là flatMap. Sử dụng nó để thay thế 2 cái foreach:1234567$variants = $lampsAndWallets-&gt;flatMap(function ($product) { return $product['variants'];});$prices = $variants-&gt;map(function ($productVariant) { return $productVariant['price'];});Rồi OK, đến thời điểm này có thể đặp tất cả mọi thứ thành 1 single pipeline:1234567return $products-&gt;filter(function ($product) { return collect(['Lamp', 'Wallet'])-&gt;contains($product['product_type']);})-&gt;flatMap(function ($product) { return $product['variants'];})-&gt;map(function ($productVariant) { return $productVariant['price'];})-&gt;sum();Haha, nhìn có vẻ ngon rồi nhỉ. Nhưng tin tôi đi, vẫn có thể ngon hơn đó Plucking for Fun and Profitpluck là shortcut của mapping 1 trường đơn với mỗi phần tử của collection. Ví dụ123$emails = $users-&gt;map(function ($user) { return $user['email'];});Thì tương đương với:1$emails = $users-&gt;pluck('email');Do đó có thể thay thế đoạn map trên bằng pluck12345return $products-&gt;filter(function ($product) { return collect(['Lamp', 'Wallet'])-&gt;contains($product['product_type']);})-&gt;flatMap(function ($product) { return $product['variants'];})-&gt;pluck('price')-&gt;sum();Xong vẫn chưa hết, ta lại có thể thay thế -&gt;pluck('price')-&gt;sum() bằng -&gt;sum('price') , và kết quả cuối cùng12345return $products-&gt;filter(function ($product) { return collect(['Lamp', 'Wallet'])-&gt;contains($product['product_type']);})-&gt;flatMap(function ($product) { return $product['variants'];})-&gt;sum('price');Không có vòng lặp đơn, điều kiện hay biến tạm thời nào được tìm thấy. Rất là thanh lịch nếu bạn hỏi tôi :D Tổng kết vấn đềĐoạn code ban đầu123456789101112131415$totalCost = 0;// Loop over every productforeach ($products as $product) { $productType = $product['product_type']; // If the product is a lamp or wallet... if ($productType == 'Lamp' || $productType == 'Wallet') { // Loop over the variants and add up their prices foreach ($product['variants'] as $productVariant) { $totalCost += $productVariant['price']; } }}return $totalCost; và sau khi được refactor: 12345return $products-&gt;filter(function ($product) { return collect(['Lamp', 'Wallet'])-&gt;contains($product['product_type']);})-&gt;flatMap(function ($product) { return $product['variants'];})-&gt;sum('price'); Các helper đã được dùng:flatten(): san phẳng mảng đa chiều thành mảng 1 chiều. Bạn cũng có thể truyền “độ sâu” của mảng như 1 đối số12345678910111213141516171819$collection = collect([ 'Apple' =&gt; [ ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'], ], 'Samsung' =&gt; [ ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'] ],]);$products = $collection-&gt;flatten(1);$products-&gt;values()-&gt;all();/* [ ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'], ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'], ]*/flatMap(): flatMap is a shortcut for mapping a collection and then flattening it by one Sự kết hợp giữa map để xử lý dữ liệu Sau đó “san phẳng” chúng thành 1 mảng. pluck(): pluck is a shortcut for mapping a single field out of each element in a collection. sum() contains(): kiểm tra 1 collection có chưa 1 phần tử nhận vào hay không. Nó rất hữu ích để sử dụng cho phép hoặc (||) reduce(): thu nhỏ, cắt giảm cả collection thành một giá trị đơn duy nhất. N.V.M","link":"/2019/12/27/Collection-Practice-1-Pricing-Lamps-and-Wallets/"},{"title":"[Collection] Practice 3: Binary to Decimal","text":"Bài toán chuyển đổi từ nhị phân sang thập phân: So given a string like “100110101” , we need to write a function that spits out 309. Use a for loop123456789101112function binaryToDecimal($binary){ $total = 0; $exponent = strlen($binary) - 1; for ($i = 0; $i &lt; strlen($binary); $i++) { $decimal = $binary[$i] * (2 ** $exponent); $total += $decimal; $exponent--; } return $total;} Breaking It DownMột trong những thức quan trọng tôi muốn bạn học được từ cuốn sách này là cách dừng làm quá nhiều thứ trong 1 lúc và thay vào đó giải quyết vấn đề nhỏ, những bước đơn giản Hãy tưởng tượng trong giây lát rằng chúng ta không cho phép sử dụng biến tạm thời (trung gian). Vậy làm sao chúng ta có thể giải quyết vấn đề mà chỉ cho phép thực hiện các phép toán tử với dữ liệu đầu vào như 1 thể thống nhất? Đầu tiên cần tách chuỗi ra đã. Bạn có thể làm việc đó bằng cách sử dụng str_split, cái mà sẽ bọc kết quả trong collection123456function binaryToDecimal($binary){ // $binary =&gt; &quot;11010&quot; $columns = collect(str_split($binary)); // $columns =&gt; [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;]}OK, vậy chúng ta đã có 1 collection từ chuỗi string. Chúng ta sẽ làm gì tiếp theo để giải quyết vấn đề. Quay trở lại vấn đề, chúng ta nói về chuyển đổi dữ liệu nhị phân sang thập phân, có vẻ như dùng map ư? Reversing the CollectionPhải đảo ngược lại collection12345678$columns-&gt;reverse();// =&gt; [// 4 =&gt; &quot;0&quot;,// 3 =&gt; &quot;1&quot;,// 2 =&gt; &quot;0&quot;,// 1 =&gt; &quot;1&quot;,// 0 =&gt; &quot;1&quot;,// ]Sử dụng values để lấy giá trị. Hãy chú ý, reverse đảo ngược lại giá trị lại nhưng key của nó không đổi. Để reset lại key bắt đầu từ 0, bạn cần sử dụng toán tử values nữa1234567891011121314function binaryToDecimal($binary){ // $binary =&gt; &quot;11010&quot; $columns = collect(str_split($binary)) -&gt;reverse() -&gt;values(); // =&gt; [ // 0 =&gt; &quot;0&quot;, // 1 =&gt; &quot;1&quot;, // 2 =&gt; &quot;0&quot;, // 3 =&gt; &quot;1&quot;, // 4 =&gt; &quot;1&quot;, // ]} Mapping with KeysOK, giờ là ta sẽ map kết hợp sum để tính kết quả nào123456789function binaryToDecimal($binary){ return collect(str_split($binary)) -&gt;reverse() -&gt;values() -&gt;map(function ($column, $exponent) { return $column * (2 ** $exponent); })-&gt;sum();}Điều tuyệt vời là sau khi tái cấu trúc code, không biến tạm thời. Vấn đề lớn nhất với biến tạm thời là chúng bắt bạn giữ toàn bộ hàm trong đầu bạn trong mọi lúc để suy nghĩ về cách thức hoạt động của hàm (kiểu giữ biến để truyền vào hàm sau và theo dõi luồng với nhau. Kiểu nó giữ giá trị của hàm nào và truyền vào đâu nữa ý) Đối lập với phương án này là giải pháp đường ống (pipeline). Mỗi toán tử hoàn toàn độc lập. Bạn không cần hiểu giá trị của biến tạm thời ở dòng X để biết hàm reverse thực sự làm gì, nó chỉ phụ thuộc vào đầu ra của toán tử trước đó và không gì cả. Với tôi, nó là sự thanh lịch Tổng kếtHelper: reverse(), values(), sum() Chú ý: sử dụng một vài toán tử thay đổi thứ tự của collection, hãy chú ý xem chúng có đổi thứ tự key không. Như toán tử reverse()sẽ không thay đổi thứ tự key và bạn cần kết hợp với toán tử values để reset key lại từ 0 Ngoài ra với issue này, bạn có thể sử dụng hàm bindec của PHP","link":"/2019/12/27/Collection-Practice-3-Binary-to-Decimal/"},{"title":"[Collection] Practice 4: What&#39;s Your GitHub Score?","text":"Đây là 1 trong những câu hỏi trong cuộc phỏng vấn vào Reddit.GitHub cung cấp 1 public API trả về hoạt động public của người dùng gần đây. JSON respone này cho bạn 1 mảng các objects có dạng sau:1234567891011[ { &quot;id&quot;: &quot;3898913063&quot;, &quot;type&quot;: &quot;PushEvent&quot;, &quot;public&quot;: true, &quot;actor&quot;: &quot;adamwathan&quot;, &quot;repo&quot;: &quot;tightenco/jigsaw&quot;, &quot;payload&quot;: { /* ... */ } }, // ...]Nhiệm vụ của bạn là tính điểm GitHub của 1 user dựa vào điều kiện sau123451. Each PushEvent is worth 5 points.2. Each CreateEvent is worth 4 points.3. Each IssuesEvent is worth 3 points.4. Each CommitCommentEvent is worth 2 points.5. All other events are worth 1 point. Loops and Conditionals123456789101112131415161718192021222324252627282930313233343536373839function githubScore($username){ // Grab the events from the API, in the real world you'd probably use // Guzzle or similar here, but keeping it simple for the sake of brevity. $url = &quot;https://api.github.com/users/{$username}/events&quot;; $events = json_decode(file_get_contents($url), true); // Get all of the event types $eventTypes = []; foreach ($events as $event) { $eventTypes[] = $event['type']; } // Loop over the event types and add up the corresponding scores $score = 0; foreach ($eventTypes as $eventType) { switch ($eventType) { case 'PushEvent': $score += 5; break; case 'CreateEvent': $score += 4; break; case 'IssuesEvent': $score += 3; break; case 'CommitCommentEvent': $score += 2; break; default: $score += 1; break; } } return $score;} Nhìn hơi tù nhỉ, refactor nào :D Replace Collecting Loop with PluckChắc hẳn chúng ta đã nhìn ra ngay đoạn lấy trường type hoàn toàn có thể thay thế bằng pluck rồi nhỉ123456789/**// Get all of the event types$eventTypes = [];foreach ($events as $event) { $eventTypes[] = $event['type'];}**/$eventTypes = $events-&gt;pluck('type');Bây giờ cần xử lý đoạn này: 123456789101112131415161718192021222324$eventTypes = $events-&gt;pluck('type');$score = 0;foreach ($eventTypes as $eventType) { switch ($eventType) { case 'PushEvent': $score += 5; break; case 'CreateEvent': $score += 4; break; case 'IssuesEvent': $score += 3; break; case 'CommitCommentEvent': $score += 2; break; default: $score += 1; break; } }return $score; Extract Score Conversion with MapĐây rõ ràng là ánh xạ điểm số cho mỗi event rồi, dùng map là phù hợp123456789101112131415$scores = $eventTypes-&gt;map(function ($eventType) { switch ($eventType) { case 'PushEvent': return 5; case 'CreateEvent': return 4; case 'IssuesEvent': return 3; case 'CommitCommentEvent': return 2; default: return 1; } });return $scores-&gt;sum();Vẫn còn 1 vấn đề bẩn là switch thực sự cần được rút ngắn lại. Nào giải quyết nó thôi Replace Switch with Lookup TableMỗi khi bạn có 1 switch như vậy, bạn có thể thay thế nó với 1 mảng và case sẽ trở thành key123456789101112131415161718192021function githubScore($username){ /** $url = &quot;https://api.github.com/users/{$username}/events&quot;; $events = collect(json_decode(file_get_contents($url), true)); $eventTypes = $events-&gt;pluck('type'); **/ $scores = $eventTypes-&gt;map(function ($eventType) { $eventScores = [ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ]; return $eventScores[$eventType]; }); return $scores-&gt;sum();}Cảm giác code đã được dọn dẹp bởi vì nhìn vào điểm cho mỗi sự kiện trở nên rất tự nhiên về những gì chúng ta đang cố gắng làm với 1 biểu thức điều kiện như switch. Hình như vấn đề chúng ta quên mất default case, tất cả các trường hợp không phải sự kiện trên sẽ trả về 1. Cái này thì có thể bổ sung như sau: 1234567891011121314151617181920212223242526function githubScore($username){ /*** $url = &quot;https://api.github.com/users/{$username}/events&quot;; $events = collect(json_decode(file_get_contents($url), true)); $eventTypes = $events-&gt;pluck('type'); $scores = $eventTypes-&gt;map(function ($eventType) { $eventScores = [ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ]; **/ if (! isset($eventScores[$eventType])) { return 1; } /** return $eventScores[$eventType]; }); return $scores-&gt;sum(); **/} Đột nhiên, điều này không thực sự có vẻ tốt hơn nhiều so với khối switch, nhưng đừng sợ hãi, chúng ta vẫn còn hi vọng :D Associative Collections: Liên kết collectionsEverything is better as a collection, remember? Cho đến giờ thì chúng ta chỉ sử dụng collection cho các mảng số truyền thống nhưng collection cho chúng ta nhiều sức mạnh hơn khi làm việc với tập hợp mảng “Tell, Don’t Ask” Principle!!! Bạn đã bao giờ nghe về nguyên lý “Nói, đừng có hỏi”. Ý tưởng chung là bạn nên tránh việc hỏi 1 object 1 câu hỏi về chính nó để quyết định khác về điều gì đó bạn đang định làm với object này. Thay vào đó, bạn nên đẩy trách nhiệm vào object này, vì vậy bạn có thể nói với nó cái bạn cần thay vì hỏi nó đầu tiên Nó thì liên quan gì đến ví dụ này. Hãy nhìn lại nhé123456789101112$eventScores = [ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2,];if (! isset($eventScores[$eventType])) { return 1;}return $eventScores[$eventType];Bạn đang sử dụng một bảng để tra cứ nếu nó có 1 giá trị chắc chắn và nếu nó không có giá trị chắc chắn thì nó sẽ trả về giá trị mặc định Collection giúp chúng ta áp dụng nguyên tắc “Tell, Don’t Ask” để giải quyết vấn đề với get() method, cái mà sẽ nhận vào key và tra cứu và 1 giá trị mặc định sẽ được trả về nếu nó không tồn tại.12345678$eventScores = collect([ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2,]);return $eventScores-&gt;get($eventType, 1);Tập hợp lại nào:123456789101112131415function githubScore($username){ $url = &quot;https://api.github.com/users/{$username}/events&quot;; $events = collect(json_decode(file_get_contents($url), true)); return $events-&gt;pluck('type')-&gt;map(function ($eventType) { return collect([ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ])-&gt;get($eventType, 1); })-&gt;sum();} Extracting Helper FunctionsDường như body của toán tử map vẫn còn nhiều dòng cho việc tra cứu điểm cho sự kiện ở đây. Chúng tôi chưa nói nhiều từ trước, nhưng vì chúng ta đang làm việc với collection pipelines không có nghĩa là chúng ta nên ném những good practice khác ra ngoài như việc để logic ra các hàm nhỏ. Trong trường hợp của chúng ta là hàm call API và hàm kiểm tra điểm có thể tách ra:12345678910111213141516171819202122function githubScore($username){ return fetchEvents($username)-&gt;pluck('type')-&gt;map(function ($eventType) { return lookupEventScore($eventType); })-&gt;sum();}function fetchEvents($username){ $url = &quot;https://api.github.com/users/{$username}/events&quot;; return collect(json_decode(file_get_contents($url), true));}function lookupEventScore($eventType){ return collect([ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ])-&gt;get($eventType, 1);} Encapsulating in a ClassTạo 1 class nếu cần thiết Tổng kết Xử lý switch case với collection. Thông qua lookup Table Nguyên tắc “Tell, Don’t Ask” để làm việc giá trị mặc định.","link":"/2019/12/27/Collection-Practice-4-What-s-Your-GitHub-Score/"},{"title":"[Collection] Practice 5: Building a Lookup Table","text":"Tôi có 1 danh sách nhân viên và bạn cần chuyển đổi nó vào bảng tra cứu mapping địa chỉ email với tên của họ.Mảng đầu vào1234567891011121314151617$employees = [ [ 'name' =&gt; 'John', 'department' =&gt; 'Sales', 'email' =&gt; 'john@example.com' ], [ 'name' =&gt; 'Jane', 'department' =&gt; 'Marketing', 'email' =&gt; 'jane@example.com' ], [ 'name' =&gt; 'Dave', 'department' =&gt; 'Marketing', 'email' =&gt; 'dave@example.com' ],];Và chúng tôi cần tạo 1 mảng tra cứu có dạng như sau:12345$emailLookup = [ 'john@example.com' =&gt; 'John', 'jane@example.com' =&gt; 'Jane', 'dave@example.com' =&gt; 'Dave',];Vậy chúng ta có thể sử dụng collections và higher order functions? Map to nowhereKhi mà chuyển đổi dữ liệu ta nghĩ ngay đến map123$emailLookup = $employees-&gt;map(function ($employee) { return $employee['name'];});Điều này sẽ cho bạn 1 danh sách tên những nhân viên, mà khoan, key đâu?? PHP’s Array Identity Crisis: Cuộc khủng hoảng bản sắcVấn đề tùy chỉnh keys trong khi sử dụng toán tử map là điều mà tôi nhận được khá thường xuyên. Tôi nghĩ lý do mà làm cho vấn đế này trở nên hóc búa là bởi vì PHP, chúng ta sử dụng kiểu dữ liệu giống nhau đại diện cho cả list và dictionary. Quên PHP trong 1 vài phút và giả như chúng ta đang cố giải quyết vấn đề với Javascript… (xem ví dụ về Object) Vì vậy chúng ta không thực sự chuyển đổi 1 mảng thành mảng khác, chúng ta đang giảm (reducing) mảng ban đầu thành 1 đối tượng đơn. Thực thi chuyển đổi trong Javascript với reduce sẽ có dạng như sau:1234const emailLookup = employees.reduce(function (emailLookup, employee) { emailLookup[employee.email] = employee.name; return emailLookup;}, {});Và Laravel cũng tương tự:12345$emailLookup = $employees-&gt;reduce(function ($emailLookup, $employee) { $emailLookup[$employee['email']] = $employee['name']; return $emailLookup;}, []); A Reusable Abstraction: Một trừu tượng hóa có thể sử dụng lạiMặc dù chúng ta đã giải quyết được vấn đề ban đầu nhưng tôi thực sự chưa hài lòng với việc đọc code như thế nào? Như tôi đã nhắc ở phần trước cuốn sách, tôi thường xuyên nhìn thấy reduce như 1 dấu hiệu rằng tôi đang quên mất cách diễn đạt dễ hình dung hơn được xây dựng với reduce? =&gt; Tức là xây dựng function cao hơn, giàu tính biểu đạt hơn dựa vào reduce. Thật tuyệt vời nếu chúng ta tạo 1 toán tử với tên toAssoc() sử dụng để chuyển 1 danh sách vào mảng kết hợp (associative array), nhưng làm sao chúng ta có thể xác định được cả key và value? Learning from Other LanguagesRuby có kiểu mảng kết hợp là Hash. Bạn có thể chuyển 1 Enumerable vào trong Hash bằng cách sử dụng phương thức to_h miễn là enumerable tạo thành cặp [key, value]12345employees = [ ['john@example.com', 'John'], ['jane@example.com', 'Jane'], ['dave@example.com', 'Dave'],]và gọi phương thức to_h123456employees.to_h # =&gt; { # 'john@example.com' =&gt; 'John', # 'jane@example.com' =&gt; 'Jane', # 'dave@example.com' =&gt; 'Dave',# } The toAssoc Macro1234567Collection::macro('toAssoc', function () { return $this-&gt;reduce(function ($assoc, $keyValuePair) { list($key, $value) = $keyValuePair; $assoc[$key] = $value; return $assoc; }, new static);}); Và có thể sử dụng12345678910$emailLookup = collect([ ['john@example.com', 'John'], ['jane@example.com', 'Jane'], ['dave@example.com', 'Dave'],])-&gt;toAssoc();// =&gt; [// 'john@example.com' =&gt; 'John',// 'jane@example.com' =&gt; 'Jane',// 'dave@example.com' =&gt; 'Dave',// ] Mapping to PairsTất nhiên là sử dụng map, và khi đặt mọi thứ cùng nhau, nó sẽ như sau :D12345678910111213141516171819$emailLookup = collect([ [ 'name' =&gt; 'John', 'department' =&gt; 'Sales', 'email' =&gt; 'john@example.com' ], [ 'name' =&gt; 'Jane', 'department' =&gt; 'Marketing', 'email' =&gt; 'jane@example.com' ], [ 'name' =&gt; 'Dave', 'department' =&gt; 'Marketing', 'email' =&gt; 'dave@example.com' ],])-&gt;map(function ($employee) { return [$employee['email'], $employee['name']];})-&gt;toAssoc();Nếu bạn muốn cải tiến thêm 1 bước nữa, bạn hoàn toàn có thể xây dựng một phương thức với tên mapToAssoc giúp chúng ta chuyển đổi dữ liệu trong 1 bước:123Collection::macro('mapToAssoc', function ($callback) { return $this-&gt;map($callback)-&gt;toAssoc();});Và chúng ta có thể sử dụng nó như sau:123$emailLookup = $employees-&gt;mapToAssoc(function ($employee) { return [$employee['email'], $employee['name']];});Pretty slick!","link":"/2019/12/28/Collection-Practice-5-Building-a-Lookup-Table/"},{"title":"[Collection] Transforming Data, Introducing Collections","text":"….Trở về ví dụ đầu tiên, lấy danh sách email của users1234567891011121314function getUserEmails($users){ $emails = []; for ($i = 0; $i &lt; count($users); $i++) { $user = $users[$i]; if ($user-&gt;email !== null) { $emails[] = $user-&gt;email; } } return $emails;}Hay nhìn như kiểu này1SELECT email FROM users WHERE email IS NOT NULLĐối với những người mới bắt đầu, chựa chọn foreach dễ dàng hơn 123456789101112function getUserEmails($users){ $emails = []; foreach ($users as $user) { if ($user-&gt;email !== null) { $emails[] = $user-&gt;email; } } return $emails;} Nếu không kiểm tra null trong email, việc dùng map là phù hợp. Đặc điểm của map là áp dụng chuyển đổi mỗi phần tử của mảng, bởi vậy nó cũng trả về 1 mảng với size giống với mảng gốc. Hàm getUserEmails chỉ có nghĩa là trả về tập con (subset) của items, những item có trường $email khác null. Khi tạo subset, chúng ta sẽ sử dụng filter, nhưng filter cũng không đúng ở đây. Filter có nghĩa là trả cho bạn tất cả các phần tử thỏa mãn 1 vài điều kiện, trong trường hợp này là email not null. Vấn đề ở đây là filter là chúng trả về cho chúng ta users có email chứ không phải là địa chỉ email của họ Thinking in StepsVấn đề chúng đề đang phải đối mặt là chúng ta đang cố gắng làm quá nhiều thứ cùng 1 lúc. Khi bạn đang ở tình trạng này, thứ đầu tiên bạn làm là cố gắng cho “I can’t because …” vào “Nếu tôi có thể …” (I could if …). Ví dụ:Tôi không thể map vì nó sẽ được áp dụng cho mỗi users, không chỉ với users có email Trở thành:Tôi có thể sử dụng map nếu tôi chỉ làm việc với những users có email Well, lấy những users với email nghe thôi đã thấy ta có thể sử dụng với filter123$usersWithEmails = filter($users, function ($user) { return $user-&gt;email !== null;});Và giờ khi đã chúng ta chỉ làm việc với users có email rồi, chúng ta có thể xóa điều kiện ra khỏi lòng lặp1234567891011121314function getUserEmails($users){ $usersWithEmails = filter($users, function ($user) { return $user-&gt;email !== null; }); $emails = []; foreach ($usersWithEmails as $user) { $emails[] = $user-&gt;email; } return $emails;}Rồi nha, một khi điều kiện đã không còn, chúng ta sẽ thay thế nó với map123456789101112function getUserEmails($users){ $usersWithEmails = filter($users, function ($user) { return $user-&gt;email !== null; }); $emails = map($usersWithEmails, function ($user) { return $user-&gt;email; }); return $emails;}Chúng ta đã giải quyết xong vấn đề bằng cách tách biệt vào 1 toán tử riêng biệt, mỗi cái phụ trách 1 phần rõ ràng Khi code của bạn trở nên phức tạp hơn, việc tách biệt chia nhỏ mọi thứ như thế này bắt đầu hiệu quả bởi vì khi debug sẽ debug được các hoạt động độc lập, đơn giản hơn nhiều khi gỡ lỗi với các toán tử phức tạp The Problem with Primitives (Vấn đề với kiểu dữ liệu nguyên thủy)Cái mà chúng ta cần cải thiện nữa loại bỏ đi các biến trung gian $usersWithEmails và $email Loại bỏ $email thì rất đơn giản, chúng ta chỉ cần trả về trực tiếp:12345678910function getUserEmails($users){ $usersWithEmails = filter($users, function ($user) { return $user-&gt;email !== null; }); return map($usersWithEmails, function ($user) { return $user-&gt;email; });}Nhưng đoạn code bắt đầu khó hiểu 1 chút nếu bạn sử dụng biến $usersWithEmail cùng dòng như vậy12345678function getUserEmails($users){ return map(filter($users, function ($user) { return $user-&gt;email !== null; }), function ($user) { return $user-&gt;email; });}What? Nó không dễ để đọc. Nó nhìn thậm chí còn tồi tệ hơn nếu bạn sử dụng PHP’s build-in array functions vì chúng có thứ tự tham số không trực quan12345678function getUserEmails($users){ return array_map(function ($user) { return $user-&gt;email; }, array_filter($users, function ($user) { return $user-&gt;email !== null; }));}Lý do code khó hiểu là vì nó phải được đọc “inside-out” (đọc từ trong ra ngoài) Vấn đề giống nhau gặp phải phát sinh khi làm việc với string trong PHP. Ví dụ bạn có đoạn code chuyển đổi từ snake_case sang camelCase12345$camelString = lcfirst( str_replace(' ', '', ucwords(str_replace('_', ' ', $snakeString)) ));Mất một lúc để load não. Vì strings và array là kiểu dữ liệu nguyên thủy, chúng ta phải thực hiện toán tử với nó từ bên ngoài bằng cách truyền chúng dưới dạng tham số vào các hàm khác (kiểu phải thực hiện ở đâu đó rồi mới truyền vào được chứ không thể thực hiện trong hàm chính luôn ý). Đó là những gì dẫn đến “inside-out”, nơi bạn cần đếm các bước liên kết để xem chuyện gì xảy ra đầu tiên với biến của mình. Thay thế chỗ inside-out code kia bằng ví dụ sau đây?1234$camelString = $snakeString-&gt;replace('_', ' ') -&gt;ucwords() -&gt;replace(' ', '') -&gt;lcfirst();Có phải dễ hiểu hơn rất nhiều đúng ko? Điểm khác biệt ở đây là chúng ta xem $snakeString như là 1 object thay vì giá trị kiểu nguyên thủy. Bằng cách gọi các phương thức trực tiếp thay vì truyền nó thông qua các tham số, bạn chỉ cần đọc code từ trái qua phải với các toán tử xuất hiện đã được sắp xếp Arrays as ObjectsHãy tưởng tượng trong giây lát, cách chúng ta biến array thành Object trong hàm getUserEmails function:1234567891011121314function getUserEmails($users){- $usersWithEmails = filter($users, function ($user) {+ $usersWithEmails = $users-&gt;filter(function ($user) { return $user-&gt;email !== null; });- $emails = map($usersWithEmails, function ($user) {+ $emails = $usersWithEmails-&gt;map(function ($user) { return $user-&gt;email; }); return $emails;}Sự khác biệt lúc này là $usersWithEmails outside trong lời gọi map của chúng ta thay về inside. Bây giờ chúng ta chúng ta có thể inline nó, filter trước khi map, code của chúng ta được đọc từ trái qua phải mà không cần inside.12345678function getUserEmails($users){ return $users-&gt;filter(function ($user) { return $user-&gt;email !== null; })-&gt;map(function ($user) { return $user-&gt;email; });}Bạn có thấy thú vị không? Kiểu lập trình này được gọi chung là collection pipeline và chúng ta hoàn toàn có thể làm điều này trong PHP. Giới thiệu về Collection A collection is an object that bundles up an array and lets us perform array operations by calling methods on the collection instead of passing the array into functions. Một collection là 1 object “bó” lại 1 mảng và cho phép chúng ta thực hiện các toán tử được gọi là các methods với collection thay vì truyền mảng vào mảng. Đây là Collection class đơn giản chỉ hỗ trợ map và filter:123456789101112131415161718192021222324class Collection{ protected $items; public function __construct($items) { $this-&gt;items = $items; } public function map($callback) { return new static(array_map($callback, $this-&gt;items)); } public function filter($callback) { return new static(array_filter($this-&gt;items, $callback)); } public function toArray() { return $this-&gt;items; }}Để lấy dánh sách email của $user theo ví dụ trên chúng ta có thể dùng Collection12345678function getUserEmails($users){ return (new Collection($users))-&gt;filter(function ($user) { return $user-&gt;email !== null; })-&gt;map(function ($user) { return $user-&gt;email; })-&gt;toArray();}Phương thức liên kết sau hàm tạo có thể nhìn có 1 chút lộn xộn vì vậy tôi sẽ thường xuyên tạo hàm tạo có tên để rõ ràng mọi thứ1234public static function make($items){ return new static($items);}Sử dụng hàm tạo có tên giúp chúng ta tiết kiệm được các dấu ngoặc đơn và nhìn gọn hơn123456789function getUserEmails($users){- return (new Collection($users))-&gt;filter(function ($user) {+ return Collection::make($users)-&gt;filter(function ($user) { return $user-&gt;email !== null; })-&gt;map(function ($user) { return $user-&gt;email; })-&gt;toArray();} Một chú ý về khả năng biến đổi Bạn phải chú ý rằng trong các ví dụ tính đến thời điểm hiện tại, chúng ta áp dụng các toán tử với mảng và chúng ta luôn trả về mảng mới, chúng ta thực sự không thay đổi gì trong mảng gốc. Điều này rõ ràng với các thực thi Collection ở dưới khi mà ta trả về new static với cả map và filter So sánh điều đó với các thực hiện này, tahy vì trả về new collection, chúng ta sẽ trả về thuộc tinh $item thay thế12345public function map($callback){ $this-&gt;items = array_map($callback, $this-&gt;items); return $this;}Điều này có vẻ không phải là một sự khác biệt lớn, nhưng nó có thể gây ra các lỗi làm tan chảy não, ma quái hành động ở khoảng cách sẽ loại bỏ tất cả “niềm vui” ra khỏi lập trình.=&gt; điều này có thể hack não và gây bug đó :D Code sẽ như sau:12345678910111213$employees = new Collection([ ['name' =&gt; 'Mary', 'email' =&gt; 'mary@example.com', 'salaried' =&gt; true], ['name' =&gt; 'John', 'email' =&gt; 'john@example.com', 'salaried' =&gt; false], ['name' =&gt; 'Kelly', 'email' =&gt; 'kelly@example.com', 'salaried' =&gt; true],]);$employeeEmails = $employees-&gt;map(function ($employee) { return $employee['email'];});$salariedEmployees = $employees-&gt;filter(function ($employee) { return $employee['salaried'];});Bạn có thể phát hiện ra bug? Hãy nhìn map. Khi chúng ta đang cố filter danh sách nhân viên thì chúng ta thực tế lại đang lọc danh sách email của họ. Rất tiếc Quacking Like… an Array?Phần này nói về các interface để tương tác với Collection như 1 mảng nhé Collection đơn giản cho đến giờ khá gọn, nhưng hơi khó chịu 1 chút khi phải liên tục chuyển đổi dữ liệu qua lại giữa collection và array. Thật sự tuyệt vời nếu chúng ta có thể xây dựng collection, cái mà chúng ta có thể sử dụng thay cho mảng mà không cần hệ thống nhận thấy, và rất mắn, PHP được được điều đó (hầu hếu, đa số) thông qua 1 interfaces sau ArrayAccessMột trong những chức năng đặc biệt của mảng là bạn có thể lấy phần tử bằng cách xác định offset thông qua dấu []123$items = [1, 2, 3];echo $items[2];// =&gt; 3Nếu bạn thử làm nó với Collection, nó sẽ lỗi. Chúng ta có thể thêm nó thông qua interface ArrayAccess (xem thêm trong sách - 43) CountableInterface tương tự count() IteratorAggregateInterface cho vòng lặp The Golden Rule of Collection Programming: Nguyên tắc vàng của lập trình collection Never use a foreach loop outside of a collection! Mỗi khi bạn sử dụng vòng lặp foreach, bạn đang làm cái qué gì đó và tôi hứa với bạn rằng “cái qué gì đó” đã có tên: Cần vòng lặp trên 1 mảng để thực hiện 1 vài hành động với mỗi item và nhét kết quả vào mảng khác? Bạn không cần lặp, bạn cần map Bạn cần vòng lặp qua 1 mảng để loại bỏ 1 vài phần tử không trùng với điều kiện. Bạn không cần vòng lặp, bạn cần filter Pipeline programming (lập trình đường ống) là về các toán tử ở mức độ cao hơn. Thay vì làm điều gì đó với items trong collection, bạn hãy làm tự làm nó với collection =&gt; Câu này khó hiểu quá, huhu Map it, filter it, reduce it, sum it, zip it, reverse it, transpose it, flatten it, group it, count it, chunk it, sort it, slice it, search it; if you can do it with a foreach loop, you can do it with a collection method. Mỗi khi bạn nâng cấp mảng từ các kiểu nguyên thủy lên thành object, cái mà có các hành vi, thì không có lý do gì để sử dụng vòng lặp bên ngoài chính collection đó và tôi sẽ chứng minh điều đó với bạn. Kể từ thời điểm này, bạn sẽ không nhìn thấy 1 vòng foreach đơn nào trừ khi nó bên trong 1 collection method nữa. Let the games begin!","link":"/2019/12/27/Collection-Transforming-Data-Introducing-Collections/"},{"title":"Config nhiều tài khoản github trên cùng 1 máy","text":"Bài viết hướng dẫn cấu hình nhiều tài khoản github trên cùng 1 máy 1. Add new ssh key12cd ~/.sshssh-keygen -t rsa -C &quot;email@personal_mail.com&quot; -f &quot;id_rsa_personal&quot; 2. Thêm key đó vào GitHub (thêm public key nhé)3. Tạo file config để quản lý các keysĐể phân biệt SSH key với các host khác nhau. chúng ta phải tạo file config để xác định SSH key nào dùng cho tài khoản, host nào.123cd ~/.sshtouch confignano configCopy nội dung này vào1234567891011# Work account - default configHost github.comHostName github.comUser gitIdentityFile ~/.ssh/id_rsa# Personal accountHost github.com-personalHostName github.comUser gitIdentityFile ~/.ssh/id_rsa_personal 4. Cấu hình trong việc quản lý tài khoản git để quản lý nhiều keyhttps://viblo.asia/p/config-de-su-dung-duoc-nhieu-tai-khoan-git-tren-cung-mot-may-tinh-bWrZnwgYlxw#_tao-file-config-de-quan-ly-cac-keys-2 Nếu không dùng file, bạn có thể làm bằng tay (không nên)123git initgit config user.name &quot;User 1&quot; // Updates git config user namegit config user.email &quot;user1@workMail.com&quot; 5. Sử dụngĐể sử dụng csac key, bạn phải đổi đường dẫn remote url tương ứng thì nó mới nhận ssh key Nó đang là123 git@github.com:minhnv2306/Firebase.git======&gt; git@github.com-personal:minhnv2306/Firebase.git(để ý host trong ~/.ssh/config)Ví dụ:1git clone git@github.com-personal:minhnv2306/icarus_blog.gitRồi, hoạt động ngon :D Tham chiếu https://medium.com/the-andela-way/a-practical-guide-to-managing-multiple-github-accounts-8e7970c8fd46 https://viblo.asia/p/config-de-su-dung-duoc-nhieu-tai-khoan-git-tren-cung-mot-may-tinh-bWrZnwgYlxw","link":"/2020/02/06/Config-nhieu-tai-khoan-github-tren-cung-1-may/"},{"title":"Deploy Laravel project with Kubernetes","text":"Kubernetes hay K8s là một hệ thống để quản lý các “container“. Nói một cách dễ hiểu, nếu bạn biết dùng Docker hoặc rkt [0] để chạy các container, thì K8s là giải pháp để quản lý chúng (quản lý bao gồm: tạo, sửa, xoá, xếp lịch(schedule), hay mở rộng (scale)…) trên nhiều máy. Như vậy, để có thể sử dụng được K8s, bạn phải biết dùng Docker. Tham khảo thêm tạo Blog: https://www.familug.org/2017/03/kubernetes.html Vì đây là một chủ đề quá rộng và chưa có kinh nghiệm áp dụng, tác giả xin dừng lại ở mức giới thiệu, cưỡi tên lửa xem hoa. Github projects: https://github.com/minhnv2306/laravel_6_learn_deploy Bước 0: Test docker ở local12docker build -t my-laravel-image .docker run -p 8000:8000 my-laravel-image Sau đó kiểm tra qua đường dẫn http://localhost:8000/login xem ứng dụng lên chưa nhé :D Nếu docker đã chạy ngon ở local, bước tiếp theo là để nó được deploy lên Kubernetes thôi. Bước 1: Push Docker lên Container RegistryGuideline: https://cloud.google.com/container-registry/docs/pushing-and-pulling Ví dụ123456$ docker imagesmy-laravel-image 3.0 bd8aa88c505e 2 days ago 1.46GB$ docker tag bd8aa88c505e gcr.io/coastal-set-245303/my-laravel-image:3.0$ docker push gcr.io/coastal-set-245303/my-laravel-image:3.0 Bước 2: Deploy với KubernetesGuideline: https://cloud.google.com/kubernetes-engine/docs/quickstart1kubectl create deployment hello-laravel --image=[HOSTNAME]/[PROJECT-ID]/[IMAGE]:[TAG]Ví dụ1kubectl create deployment hello-laravel --image=gcr.io/coastal-set-245303/my-laravel-image:3.0Exposing the Deployment12kubectl expose deployment hello-laravel --type LoadBalancer \\ --port 80 --target-port 8000Inspecting and viewing the application Inspect the running Pods by using kubectl get pods:1kubectl get pods Xem thông tin service deploy1kubectl get service hello-laravel Góc nhìn ít ỏi của tác giả về Kubernetes Kubernetes ưu điểm trong việc tối ưu hệ thống, cân bằng tải, nên được sử dụng trong các hệ thống lớn, tải cao. Khi đó việc phân tải đa phần mình sẽ nhờ Google làm giúp. Chính vì vậy khi deploy với Kubernetes, nó sẽ tạo cho bạn 3 instance VM (xem trong instance group sẽ thấy rõ) để cùng chạy web của bạn Thực tế tác giả chưa làm về web tải lớn, khi nào có kinh nghiệm sẽ đọc tiếp, giờ xem qua thôi :D","link":"/2020/02/06/Deploy-Laravel-project-with-Kubernetes/"},{"title":"[Docker] Compose file version 3 reference","text":"Chúng ta cùng xem các tham số cấu hình trong docker compose nhé. Reference and guidelinesCompose file hiện đang có 3 version khi format. Phiên bản mới nhất tính đến ngày 30/4/2020 là 3.8 Ma trận tương thích Compose và DockerCó 1 vài version của Composer file format - 1,2,2.x và 3.x. Bảng dưới đây sẽ chỉ ra sự tương thích version Docker và Compose, nếu bạn dùng phiên bản Docker đã quá cũ nhưng muốn dùng file format cho Compose phiên bản mới, hãy nâng cấp Docker Compose file format Docker Engine release 3.8 19.03.0+ 3.7 18.06.0+ 3.6 18.02.0+ 3.5 17.12.0+ 3.4 17.09.0+ 3.3 17.06.0+ 3.2 17.04.0+ 3.1 1.13.1+ 3.0 1.13.0+ 2.4 17.12.0+ 2.3 17.06.0+ 2.2 1.13.0+ 2.1 1.12.0+ 2.0 1.10.0+ 1.0 1.9.1.+ Compose file structure and examplesĐây là 1 ví dụ về Composer file format Example Compose file version 31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495version: &quot;3.8&quot;services: redis: image: redis:alpine ports: - &quot;6379&quot; networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure db: image: postgres:9.4 volumes: - db-data:/var/lib/postgresql/data networks: - backend deploy: placement: constraints: - &quot;node.role==manager&quot; vote: image: dockersamples/examplevotingapp_vote:before ports: - &quot;5000:80&quot; networks: - frontend depends_on: - redis deploy: replicas: 2 update_config: parallelism: 2 restart_policy: condition: on-failure result: image: dockersamples/examplevotingapp_result:before ports: - &quot;5001:80&quot; networks: - backend depends_on: - db deploy: replicas: 1 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure worker: image: dockersamples/examplevotingapp_worker networks: - frontend - backend deploy: mode: replicated replicas: 1 labels: [APP=VOTING] restart_policy: condition: on-failure delay: 10s max_attempts: 3 window: 120s placement: constraints: - &quot;node.role==manager&quot; visualizer: image: dockersamples/visualizer:stable ports: - &quot;8080:8080&quot; stop_grace_period: 1m30s volumes: - &quot;/var/run/docker.sock:/var/run/docker.sock&quot; deploy: placement: constraints: - &quot;node.role==manager&quot;networks: frontend: backend:volumes: db-data: Service configuration referenceCompose file định nghĩa services, networks và volumes. Bạn có thể sử dụng cả phần mở rộng .yml hoặc .yaml đều được Mỗi service được định nghĩa chứa 1 cấu hình được áp dụng cho từng container trong service, giống như truyền tham số tới lệnh docker run. Tương tự, các định nghĩa volume và network tương tự như các lệnh docker network create và docker volume create. Cũng như với docker run, các tùy chọn được xác định trong Dockerfile, như CMD, EXPOSE, VOLUME, ENV được sử dụng mặc định - bạn không cần truyền chúng lại trong file docker-compose.yml. Phần tiếp theo sẽ trình bày tất cả các cấu hình được hỗ trợ trong version 3. build: Các tùy chọn cấu hình được áp dụng khi build context: Đường dẫn thư mục chứa 1 Dockerfile hoặc url tới git repository dockerfile: Thay đổi Dockerfile args: Thêm các đối số khi build cái mà được biến môi trường có thể truy cập chỉ trong quá trình build Đầu tiên, xác định các đối số của bạn trong Dockerfile12345ARG buildnoARG gitcommithashRUN echo &quot;Build number: $buildno&quot;RUN echo &quot;Based on commit: $gitcommithash&quot;Chỉ định các đối số này dưới từ khóa build. Bạn có thể map hoặc sử dụng list12345build: context: . args: buildno: 1 gitcommithash: cdc3b19Or12345build: context: . args: - buildno=1 - gitcommithash=cdc3b19 Scope of build-args In your Dockerfile, if you specify ARG before the FROM instruction, ARG is not available in the build instructions under FROM. If you need an argument to be available in both places, also specify it under the FROM instruction. Refer to the understand how ARGS and FROM interact section in the documentation for usage details. Bạn cũng có thể bỏ qua các giá trị này khi build, trong trường hợp đó, giá trị của nó sẽ là trong môi trường nơi mà Compose đang chạy.123args: - buildno - gitcommithash cache_fromMới được thêm từ version 3.2Danh sách images có thể sử dụng cache12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 labelMới được thêm từ version 3.3Thêm metdata vào kết quả image sử dụng Docker labelNó khuyên bạn nên sử dụng ký hiệu DNS ngược để ngăn label của bạn xung đột với các nhãn được sử dụng bởi phần mềm khác. shm-size target cap_add, cap_dropcgroup_parentcommandGhi đè command mặc định1command: bundle exec thin -p 3000Command cũng có thể là 1 danh sách, tương tự như dockerfile1command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;] configscontainer_nameĐịnh nghĩa 1 custom container name thay vì sinh ra mặc định credential_specĐược thêm từ phiên bản 3.3. Chỉ được sử dụng trên windows quản lý tài khoản group Managed Service Account (gMSA) depends_onMô tả sự phụ thuộc giữa các service. Sự phụ thuộc các dịch vụ gây ra các hành vi sau: docker-compose up: start service theo thứ tự sự phụ thuộc. Như ví dụ dưới, db và redis được start trước web docker-compose up SERVICE: tự động bao gồm các SERVICE phụ thuộc. Như ví dụ dưới, docker-compose up web cũng sẽ tạo và start db và redis docker-compose stop: stop service theo thứ tự sự phụ thuộc. Như ví dụ dưới đây, web sẽ bị stop trước db và redis1234567891011version: &quot;3.7&quot;services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres There are several things to be aware of when using depends_on: depends_on does not wait for db and redis to be “ready” before starting web - only until they have been started. If you need to wait for a service to be ready, see Controlling startup order for more on this problem and strategies for solving it.Version 3 no longer supports the condition form of depends_on.The depends_on option is ignored when deploying a stack in swarm mode with a version 3 Compose file. deployCác cấu hình để cho quá trình deploy và chạy các services. Nó chỉ ảnh hưởng khi deploying tới 1 swarm với docker stack deploy và nó bị bỏ qua bởi docker-compose up và docker-compose run(Chính vì bỏ qua nên khi nào cần sẽ đọc lại) devicesList of device mappings. Uses the same format as the –device docker client create option. dnsdns_searchentrypointGhi đè entrypoint mặc định1entrypoint: /code/entrypoint.shentrypoint cũng có thể là 1 danh sách, tương tự dockerfile1entrypoint: [&quot;php&quot;, &quot;-d&quot;, &quot;memory_limit=-1&quot;, &quot;vendor/bin/phpunit&quot;] env_fileThêm biến môi trường từ 1 file. Bạn có thể sử dụng giá trị đơn hoặc 1 danh sách1env_file: .envHoặc1234env_file: - ./common.env - ./apps/web.env - /opt/runtime_opts.envVà cấu trúc file .env sẽ như sau:12# Set Rails/Rack environmentRACK_ENV=development environmentThêm biến môi trường. Cái trên là thêm dựa vào file nhé :D1234environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET:Hoặc1234environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET exposeExpose ra cổng mà không truy xuất được xử host machine, chúng sẽ chỉ có thể truy cập được sử các link services. Chỉ coongt nội bộ có thể được chỉ định123expose: - &quot;3000&quot; - &quot;8000&quot;Ý kiến cá nhân: Docker-compose đã tự expose các cổng của các container, vì vậy tham số này bỏ đi thì cũng không ảnh hưởng lắm. Tuy nhiên bạn cũng nên có tham số này trong docker-compose.yml file để: Chú thích cho người đọc dễ hiểu các cổng expose mặc định Không expose ra host machine Expose các cổng custome, vẫn được (KHÔNG KHUYẾN KHÍCH_, ví dụ mysql:5.7 có thể expose cổng 3307 external_linksextra_hostshealthcheck123456healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] interval: 1m30s timeout: 10s retries: 3 start_period: 40s imageXác định image để bắt đầu container. Bạn có thể sử dụng cả dạng repository/tag hoặc một phần của image ID initisolationlabelslinks Warning The –link flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using –link. One feature that user-defined networks do not support that you can do with –link is sharing environmental variables between containers. However, you can use other mechanisms such as volumes to share environment variables between containers in a more controlled way. Liên kết các containers khác service. Nó có thể sử dụng qua service name và link alias (“SERVICE:ALIAS”), hoặc chỉ tên service12345web: links: - &quot;db&quot; - &quot;db:database&quot; - &quot;redis&quot;Các containers đối với các service đã được liên kết có thể truy caaoj tới hostname được chỉ định alias hoặc tới service name nếu không có alias nào được chỉ định Links không bắt buộc để cho phép các dịch vụ giao tiếp - mặc định, 1 vài dịch vụ có thể kết nối với các dịch vụ khác qua tên của service. Xem thêm tại https://docs.docker.com/compose/networking/#links Links cũng mô tả sự phụ thuộc giữa các service giống như depends_on, bởi vậy chúng xác định thứ tự startup của các service Warning: Note when using docker stack deploy The links option is ignored when deploying a stack in swarm mode loggingCấu hình phần log cho service123456789version: &quot;3.7&quot;services: some-service: image: some-service logging: driver: &quot;json-file&quot; options: max-size: &quot;200k&quot; max-file: &quot;10&quot; network_modenetworkpidportsExpose ports SHORT SYNTAXBạn có thể chỉ định cả 2 ports (HOST:CONTAINER) hoặc chỉ container port (một cổng random, không ổn định trên host sẽ được chọn)12345678910ports: - &quot;3000&quot; - &quot;3000-3005&quot; - &quot;8000:8000&quot; - &quot;9090-9091:8080-8081&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; - &quot;127.0.0.1:5000-5010:5000-5010&quot; - &quot;6060:6060/udp&quot; - &quot;12400-12500:1240&quot; LONG SYNTAXCú pháp này mới được thêm từ phiên bản 3.2Nó sẽ thêm các trường, cho phép thêm thông tin về các cấu hình target: the port inside the container published: the publicly exposed port protocol: the port protocol (tcp or udp) mode: host for publishing a host port on each node, or ingress for a swarm mode port to be load balanced.12345ports: - target: 80 published: 8080 protocol: tcp mode: host restartno là chính sách restart mặc định và nó sẽ không restart 1 container trong 1 vài hoàn cảnh. Khi always, container luôn luôn restarts. on-failure sẽ restarts 1 container nếu exit code với 1 lỗi nào đó1234restart: &quot;no&quot;restart: alwaysrestart: on-failurerestart: unless-stopped (warning) Note when using docker stack deploy The restart option is ignored when deploying a stack in swarm mode. secretsecurity_optstop_grace_periodstop_signalsysctlstmpfsulimitsuserns_modevolumes","link":"/2020/04/30/Docker-Compose-file-version-3-reference/"},{"title":"[Docker] Docker volume","text":"Như chúng ta đều biết, đặc điểm của Docker container là chúng chạy độc lập, và không ảnh hưởng đến nhau, thế nhưng vì một lí do nào đó, chúng ta lại muốn chia sẻ data giữa các container ví dụ, bạn có một 2,3 web server nginx và mong muốn khi chúng share chung các file config, hay html tĩnh. May mắn docker cung cấp volume để thực hiện việc đó Docker volume là một volume được tạo ra cho phép các container mount volume vào trong các container hay dễ hiểu hơn là docker sử dụng Volume đó thay thế cho 1 folder của container Sử dụng volume có 3 tác dụng chính: Để giữ lại dữ liệu khi một container bị xóa. Để chia sẻ dữ liệu giữa các hệ thống tập tin máy chủ và container Docker. Để chia sẻ dữ liệu với các container Docker khác. VOLUME trong DockerfileTrở lại ví dụ trong phần Docker instructions1234FROM ubuntuRUN mkdir /myvolRUN echo &quot;hello world&quot; &gt; /myvol/greetingVOLUME /myvolKết quả như trang này có giải thích nó sẽ tạo ra một volume mới và copy file greeting vào volume được tạo. Nhưng khi tôi build và run docker này lại không có volume myvol nào được tạo ra? Thực tế không phải volume myvol không được tạo ra mà nó đã được băm dưới dạng id12345docker volume lsDRIVER VOLUME NAMElocal 09ac41f23520dfeaec2d2dcc571168a1a8ff185f633cbaa355915703b3fa6b4flocal 0a7f05233da3de18ae8d67f80b3d6bcda4f374bffd7c2d44b0b0914db976f835local 16f5fec934cc322c7b065ea89b6bc122c3fabafcad76ff69bc53ab3849ababc5Công việc của bạn là cần tìm VOLUME NAME đó là cái nào :v (sắp xếp theo ngày tạo ấy sẽ thấy nhé) Sử dụng VOLUME trong Dockerfile như vậy, các volume sẽ được tạo trong thư mục: /var/lib/docker/volumes/ và được docker quản lý, bạn không thể ánh xạ nó sang thư mục khác của máy thật được. Tùy chọn volume khi run dockerSử dụng lệnh thêm tham số volume khi chạy docker cho phép bạn ánh xạ được vùng mount bởi volume từ docker container ra host của chúng ta thông qua 2 tham số source và destination1docker run -d --name nginx1 --mount source=nginx-static-html-share-volume,destination=/usr/share/nginx/html -p 2222:80 nginx Tổng kết Sử dụng VOLUME trong Dockerfile, volume sẽ được Docker quản lý, không thể ánh xạ vị trí khác được Ngược lại sử dụng volume, mount trong khi chạy docker, hoặc trong docker-compose cho phép bạn ánh xạ các file, thư mục đến file, thư mục trên máy thật mà bạn muốn Tài liệu đọc thêm: Medium.com Stack Overflow Viblo","link":"/2020/04/12/Docker-Docker-volume/"},{"title":"[Docker] General guidelines and recommendations","text":"Tài liệu sau mô tả những gợi ý best practices và các các thức để xây dựng các images có hiệu quả. Phần này lấy từ 1 phần của https://docs.docker.com/develop/develop-images/dockerfile_best-practices/. Còn 1 phần best practice cho Docker instructions, bạn tham khảo tại bài Docker instructions nhé.Docker build các image tự động bằng cách đọc các lệnh từ Dockerfile - một file text chứa tất cả các lệnh, theo thứ tự cần thiết để build 1 image. Một Dockerfile tuân thủ cấu trúc riêng và có tập các instructions nhất định. Một Docker image bao gồm các tầng chỉ đọc (read-only layers), mỗi tầng có 1 nhiệm vụ riêng của 1 Dockerfile instruction. Những tầng này được xếp chồng lên nhau và mỗi tầng có thay đổi với các tầng trước.. Xem xét Dockerfile:1234FROM ubuntu:18.04COPY . /appRUN make /appCMD python /app/app.py Mỗi instruction tạo 1 layer: FROM tạo 1 layer từ ubuntu:18.04 image. COPY thêm files từ thư mục Docker hiện tại. RUN build ứng dụng của bạn với make. CMD chỉ ra lệnh nào cần chạy trong container này. Khi bạn chạy 1 image và sinh ra container, bạn thêm 1 layer có thể ghi (writable layer (the “container layer”)), trên cùng của các layers bên dưới. Tất cả thay đổi khi chạy container như là ghi files mới, định nghĩa file đã tồn tại và xóa files được ghi lại trong tầng container có thể ghi này. General guidelines and recommendationsCreate ephemeral containersImage định nghĩa bởi Dockerfile nên sinh ra các container “càng phù du càng tốt”. Phù du ở đây chúng ta hiểu là các contianer có thểđược stopped và destroyed và rebuild và replaced với thiết lập và cấu hình tối thiểu tuyệt đối. =&gt; Chưa hiểu ý lắm :v Understand build contextVấn đề khi bạn chạy docker build command, đường dẫn làm việc hiện tại của bạn được gọi là build context. Mặc định, Dockerfile sẽ được giả định là từ đây nhưng bạn có thể xác định 1 đường location khác với flag file (-f). Bất kể khi nào Dockerfile đang hoạt động, tất cả nội dung file, tệp đệ quy trong thư mục hiện tại được gửi vào Docker daemon như là build context Pipe Dockerfile through stdinDocker có thể build các images bằng cách đường ống dữ liệu vào Dockerfile qua stdin với 1 local or remote build context. Kĩ thuật đường ống dữ liệu vào Dockerfile qua stdin có thể hữuích hiệu năng đối với các bản build 1 lần (one-off builds) mà không cần viết Dockerfile vào ổ đĩa hoặc trong các tình huống mà Dockerfile được tạo ra mà không nên tồn tại sau đó(Trường hợp này thực tế không sử dụng nên tạm thời bỏ qua chưa đọc) Exclude with .dockerignoreĐể loại trừ các file không liên quan khi build, sử dụng file .dockerignore. File này hỗ trợ các mẫu loại bỏ tương tự như .gitignore Use multi-stage buildsMulti-stage builds cho phép bạn giảm nhiều kích thước image cuối cùng của bạn mà không đấu tranh để giảm số lượng các tầng và files trung gian. Bởi vì 1 image được build trong giai đoạn cuối cuối của quá trình build, bạn có thể giảm thiểu image layer bằng leveraging build cache (phần sau). Ví dụ, nếu build của bạn có 1 vài layer, bạn có thể sắp xếp chúng từ ít thay đổi thường xuyên (để chắc chắn rằng cache khi build có thể hữu ích) đến phần thay đổi thường xuyên Install tools bạn cần để build ứng dụng Install và cập nhật các thư viện phụ thuộc Sinh ra ứng dụng của bạn Một Dockerfile từ ứng dụng Go sẽ như sau:123456789101112131415161718192021222324FROM golang:1.11-alpine AS build# Install tools required for project# Run `docker build --no-cache .` to update dependenciesRUN apk add --no-cache gitRUN go get github.com/golang/dep/cmd/dep# List project dependencies with Gopkg.toml and Gopkg.lock# These layers are only re-built when Gopkg files are updatedCOPY Gopkg.lock Gopkg.toml /go/src/project/WORKDIR /go/src/project/# Install library dependenciesRUN dep ensure -vendor-only# Copy the entire project and build it# This layer is rebuilt when a file changes in the project directoryCOPY . /go/src/project/RUN go build -o /bin/project# This results in a single layer imageFROM scratchCOPY --from=build /bin/project /bin/projectENTRYPOINT [&quot;/bin/project&quot;]CMD [&quot;--help&quot;] Don’t install unnecessary packagesTất nhiên, việc giảm thiểu các package không cần thiết để giảm thiểu độ phức tạo, sự phụ thuộc, kích thước file và thời gian build rồi =)) bởi vì nó cónghĩa là “nice to have”. Ví dụ, bạn không cần cài các text editor trong database image. Decouple applicationsMỗi container nên chỉ có 1 quan hệ. Phân tách ứng dụng thành nhiều containers làm nó dễ dàng mở rộng theo chiều ngang và dễ dàng sử dụng lạicác container. Ví dụ, một ngăn xếp của ứng dụng web có thể chứa 3 container tách biệt, mỗi chúng có 1 image duy nhất để quản lý ứng dụng web, database vàim-memory cache. Cố gắng giữ các container của bạn sạch sẽ và phân hóa tính module nhất có thể. Nếu containers của bạn phụ thuộc các container khác, bạn có thể sử dụngDocker container network để chắc chắn rằng chúng có thể nói chuyện được với nhau =)) Minimize the number of layersTrong các phiên bản Docker cũ, thực sự quan trọng cho bạn giảm thiểu số lượng layers trong image của bạn để chắc chắn rằng chúng có hiệu năng tốt.Các tính năng sau đây đã được thêm vào để giảm thiểu các giới hạn này: Chỉ các instructions RUN, COPY, ADD tạo ra layers. Các instruction khác tạo ra các image trung gian tạm thời, và không làm tăng kích thước của quá trình build. Bất cứ khi nào có thể, sử dụng multi-stage builds, và chỉ copy các thứ bạn cần vào image cuối cùng. Điều này cho phép bạn có thể có các tools và thông tin debug trong các stage tạm thờicủa bạn nhưng không làm tăng kích thước trong image cuối cùng Ý kiến cá nhân: Bạn có thể xem quá trình build ra images đó sinh ra các layers và các image trung gian nào thông qua docker history1234567FROM ubuntu:latestCOPY Hello.txt /tmpRUN apt-get update &amp;&amp; apt-get install vim -yCMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]12345678910C:\\Users\\Nguyen Van Minh\\Desktop\\Docker&gt;docker history d978393ef1c7IMAGE CREATED CREATED BY SIZE COMMENTd978393ef1c7 33 seconds ago /bin/sh -c #(nop) CMD [&quot;sh&quot; &quot;-c&quot; &quot;echo $HOM… 0Bde55aff93a8d 23 minutes ago /bin/sh -c apt-get update &amp;&amp; apt-get install… 88.3MBc5a143208697 36 minutes ago /bin/sh -c #(nop) COPY file:6ffa4dcbbe5403e6… 16B4e5021d210f6 4 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B&lt;missing&gt; 4 weeks ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo 'do… 7B&lt;missing&gt; 4 weeks ago /bin/sh -c set -xe &amp;&amp; echo '#!/bin/sh' &gt; /… 745B&lt;missing&gt; 4 weeks ago /bin/sh -c [ -z &quot;$(apt-get indextargets)&quot; ] 987kB&lt;missing&gt; 4 weeks ago /bin/sh -c #(nop) ADD file:594fa35cf803361e6… 63.2MBBạn có thể thấy rất rõ, mỗi instruction đều tạo 1 layer (để đơn giản hóa, hãy xem các image trung gian tạm thời OB kia cũng là các layer) và tổng kích thước image chính là đống layer này cộng vào :D. Hiểu nôm na các image trung gian (0B) chỉ là copy lại image cũ, chưa làm gì nên chưa tăng kích thước, nếu dùng RUN, COPY, ADD trên các image trung gian đó thì sinh 1 layer mới làm tăng kích thước images. Sort multi-line argumentsBất cứ khi nào có thể, dễ dàng thay đổi về sau bằng cách sắp xếp các đối số nhiều dòng. Điều này tránh bị trùng lặp các package và làm danh sách sẽ dễ dàng cập nhật hơn. Điều này cũng làm PRs dễ dàng đọc và review. Thêm space và mỗi backslash(\\) để làm việc này :D. Đây là một ví dụ:123456RUN apt-get update &amp;&amp; apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion Leverage build cacheHiểu 1 chút về các khái niệm trong Docker và cache: Dockerfile bắt đầu với 1 parent image (từ FROM). Sau đó trong quá trình build sẽ sinh ra nhất nhiều image trung gian, ta gọi là childrent image. Base image thường nói đến các image từ các parent image (các image trống trơn, chưa cài đặt gì), và thêm các cài đặt phục vụ bạn (như cài thêm npm để build js, cài thêm composerđể build thêm PHP) được đẩy lên repo Docker hoặc trên local của bạn Ví dụ xem xét Dockerfile sau:123FROM ubuntu:latestCOPY Hello.txt /tmpDockerfile lấy từ parent image ubuntu:latest, sau lệnh COPY này, nó sẽ sinh ra 1 childrent image. Khi bạn build, bạn sẽ nhận được danh sách images sau:1234C:\\Users\\Nguyen Van Minh\\Desktop\\Docker&gt;docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; c5a143208697 11 seconds ago 64.2MBubuntu latest 4e5021d210f6 4 weeks ago 64.2MBNhư ví dụ trên tôi hiểu ubuntu::lastest: parent image =&gt; image ubuntu không có cái vẹo gì c5a143208697: là image con của ubuntu:lastest c5a143208697 cũng được gọi là base image của bạn. Tuy nhiên nó chưa cài thêm cái gì, base image này có vẻ hơi tù và gọi là base image có vẻ chưa ngon lắm. Base image ví dụ laravel-workspace gọi base image thì sẽ chuẩn hơn, nó cung cấp không gian làm việc với ứng dụng. Ref: https://github.com/FramgiaDockerTeam Khái niệm base image và parent image dễ gây nhầm lẫn, mà thôi đừng quan tâm sâu quá về nó. Hãy liên hệ khi bạn code, bạn có thể sử dụng Controller có sẵn trong Laravel là các parent image, bạn thêm các hàm (whereLike chẳng hạn) thì xây dựng lên BaseController, từ BaseController này sinh ra các image con HomeController, ProductController (mà gọi là con của Controller cũng không sai nhỉ =_=) Rồi, tản mạn về Base image, Parent Image và Childrent Image vậy thôi, bây giờ tôi sẽ đề cập đến cache. Khi build Docker, chỗ nào sử dụng cache được báo lại rất rõ. Ví dụ với Dockerfile trên, build lại lần nữa, cache sẽ được sử dụng từ lệnh COPY, bạn có thể thấy rõ từ thông báo:12345678C:\\Users\\Nguyen Van Minh\\Desktop\\Docker&gt;docker build .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM ubuntu:latest ---&gt; 4e5021d210f6Step 2/2 : COPY Hello.txt /tmp ---&gt; Using cache ---&gt; c5a143208697Successfully built c5a143208697Khi build 1 image, các bước Dokcker qua các instructions trong Dockerfile, thực thi từng instruction một được chỉ định. Mỗi instruction được kiểm tra, Docker tìm 1 image đã tồn tại trong cache của nó để sử dụng lại, thay vì tạo 1 (nhiều) image. Nếu bạn không muốn sử dụng cache trong tất cả trường hợp, bạn có thể sử dụng tùy chọn --no-cache=true khi chạy docker build. Tuy nhiên, nếu bạn để Docker sử dụng cache, thực sự quan trọng để hiểu khi nào nó có thể dùng, và khi nào không thể, tìm kiếm image trùng. Các nguyên tắc cơ bản sau Docker sẽ tuân theo: Bắt đầu với parent image, cái đã có trong cache, các instruction tiếp thep sẽ được so sánh với tất cả các image con có nguồn gốc từ base image để xem nếu 1 trong số chúng đã được build sử dụng instruction giống nhau. Nếu không, cache sẽ bị vô hiệu. Trong đa số các trường hợp, sự so sánh đơn giản instruction trong Dockerfile với 1 trong những child images là vừa đủ. Tuy nhiên, 1 số instructions sẽ yêu cầu nhiều sự xem xét và giải thích hơn. Đối với lệnh ADD và COPY, nội dung của file(s) trong image được xem xét và checksum sẽ được tính toán cho mỗi file. Mỗi last-modified and last-accessed time của file(s) không được xem xét trong checksum này. Trong khi cache tìm kiếm, checksum sẽ so sánh với các checksum của image đã tồn tại. Nếu có 1 vài sự thay đổi trong file(s), như là nội dung và metadata, cache sẽ bị vô hiệu hóa. Aside from the ADD and COPY commands, cache checking does not look at the files in the container to determine a cache match. For example, when processing a RUN apt-get -y update command the files updated in the container are not examined to determine if a cache hit exists. In that case just the command string itself is used to find a match. Một khi cache bị vô hiệu hóa, tất cả các lệnh Dockerfile tiếp theo sẽ sinh ra 1 image mới và cache sẽ không được sử dụng. Tổng kếtKhi xây dựng Dockerfile, hi vọng 1 số tips sau giúp bạn xây dựng tốt hơn: Build context có thể lấy cứ local hoặc remote, khi build 1 lần, hãy xem xét sử dụng stdin để không cần lưu Dockerfile trên máy của bạn luôn. Exclude with .dockerignore. Use multi-stage builds: giảm kích thước image qua việc Dockerfile chỉ sử dụng image cuối cùng. Don’t install unnecessary packages. Decouple applications. Minimize the number of layers: Mỗi instruction tạo ra 1 layer (tính cả layer 0B gọi là các image trung gian tạm thời đi) ADD, COPY, RUN là các instruction làm tăng kích thước images. Ngoài ra, khi copy cả thư mục, hãy xem xét các file thường xuyên thay đổi thì nên tách ra. Chi tiết xem thêm tại Docker instructions. Xem kích thước các instruction với docker history. Sort multi-line arguments: sử dụngbackslash (\\) để PRs của bạn dễ review hơn và tránh lặp các package. Tận dụng cache khi build. Parent image (Controller), base image =&gt; base image: image bạn tự custom lại, nên tích hợp thêm cái gì đó hữu ích (BaseController with whereLike) và childrent image: ProductController, HomeController. Tài liệu tham khảo: Dockerfile best practive FramgiaDockerTeam","link":"/2020/04/19/Docker-General-guidelines-and-recommendations/"},{"title":"[Docker] Networking in Compose","text":"Phần này áp dụng cho các file formats version 2 và cao hơn. Chức năng networking không hỗ trợ cho Compose file version 1 Before you beginTrước tiên tôi tổng kết những hiểu biết ít ỏi của mình về network trong Docker Mô hìnhCái này tôi không hiểu nên tạm để đọc sau, bạn có thể xem thêm tại đây Mặc định, Docker hỗ trợ 3 loại card mạng12345C:\\Users\\Nguyen Van Minh&gt;docker network lsNETWORK ID NAME DRIVER SCOPE36b98d0bbbdb bridge bridge localed6e03e4775b host host local5bdac30c1444 none null local None network: Các container thiết lập network này sẽ không được cấu hình mạng. None driver cung cấp cho một container networking stack và không gian mạng riêng của nó nhưng không config các interface bên trong container. Không có config bổ sung, các container hoàn toàn cách ly với networking stack của host. Bridge: Docker sẽ tạo ra một switch ảo. Khi container được tạo ra, interface của container sẽ gắn vào switch ảo này và kết nối với interface của host. Host: Containers sẽ dùng mạng trực tiếp của máy host. Network configuration bên trong container đồng nhất với host. Default network của Docker Mặc định các container của service sẽ tham gia vào mạng mặc định do Docker tạo ra. Tên mạng sẽ là PROJECTNAME_default, có card là bridge. Mạng này bị Docker quản lý (đúng rồi mà, tạo switch ảo từ Docker ra:D). “Trên cùng một host, các container chỉ cần dùng bridge network để nói chuyện được với nhau. Tuy nhiên, các container được cấp ip động nên nó có thể thay đổi, dẫn đến nhiều khó khăn. Vì vậy, thay vì dùng địa chỉ ip, ta có thể dùng name của các container để “liên lạc” giữa các container với nhau.” @docker-ghichepdocker-ghichep.readthedocs.io/en/latest/docker-network/#4-noi-chuyen-giua-cac-container-voi-nhau Cơ bản các container đã nói chuyện được với nhau rồi, nhưng để tránh bị IP thay đổi, bạn có thể dùng link để alias lại tên giữa các container với nhau.Ví dụ container A + B cùng tham gia mạng mặc định khi up, tuy nhiên mỗi lần up A lại được cấp IP khác nhau 10.0.2.1 lúc lại là 10.0.2.3.=&gt; gán cho 1 cái tên và alias (link A:Annie) để IP thay đổi cùng kệ, trong mạng default B sẽ gọi A là Annie =))Bản thân tôi thấy không cần link vẫn được, có thể sử dụng luôn tên service. Như vậy link trong docker compose chỉ có đúng 1 tác dụng như vậy :D. Thay vì phải tham gia vào 1 mạng default và bị Docker quản lý, cấp phát IP như vậy, các container không muốn, muốn tự lập vùng mạng riêng, tham gia vào đó. Nơi này các container tự tìm (discoverable) được nhau qua tên và có thể custom card mạng nếu muốn. Đặc biệt, tạo mạng riêng cho 1 vài container kết nối (ví dụ mạng front-end và mạng back-end sẽ được đề cập trong ví dụ sau).Cách này là Specify custom networks, bạn nên sử dụng nó và nó được khuyến khích sử dụng thay links The --link flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using --link. @docsdocs.docker.com/compose/compose-file/#links Let’s startMặc định Compose set up 1 mạng đơn cho ứng dụng. Mỗi container cho 1 dịch vụ tham gia default network và cả 2 có thể reachable bởi containers khác trên mạng đó và cũng có thể discoverable trên hostname tới tên container. Ví dụ, ứng dụng của bạn có đường dẫn myapp, và file docker-compose.yml của bạn sẽ như sau:12345678910version: &quot;3&quot;services: web: build: . ports: - &quot;8000:8000&quot; db: image: postgres ports: - &quot;8001:5432&quot;Khi bạn chạy docker-compose up, những điều sau sẽ xảy ra: Một mạng với tên gọi myapp_default sẽ được tạo. Một container được tạo sử dụng cấu hình của web. Nó tham gia vào mạng myapp_default dưới tên web. Một container được tạo sử dụng cấu hình của db. Nó tham gia vào mạng myapp_default dưới tên db. Mỗi container bây giờ có thể tra cứu hostname web hoặc db và lấy lại địa chỉ IP của container. Ví dụ, code của ứng dụng web có thể kết nối tới URL postgres://db:5432 và bắt đầu sử dụng Postgres database. Có 1 điều quan trọng cần chú ý phân biệt giữa HOST_POST và CONTAINER_PORT. Trong ví dụ trên, đối với db, HOST_PORT là 8001 và container port là 5432 (cổng mặc định của postgres). Mạng service-to-service kết nối sử dụng CONTAINER_POST. Khi mà HOST_PORT được định nghĩa, dịch vụ có thể truy cập bên ngoài the swarm Trong web container, kết nối của bạn tới db sẽ như sau postgres://db:5432 và từ host machine, kết nối sẽ như sau postgres://{DOCKER_IP}:8001 Update containersNếu bạn muốn tạo cấu hình thay đổi 1 dịch vụ và chạy docker-compose up để cập nhật nó, các container cũ sẽ bị xóa và 1 cái mới sẽ tham gia mạng dưới 1 địa chỉ IP khác nhưng tên giống như vậy. Container đang chạy có thể tra cứu tên đó và kết nối đến địa chỉ mới, nhưng địa chỉ cũ đã dừng hoạt động. Nếu 1 vài containers có mở kết nối đến các container cũ, chúng sẽ bị đóng lại. Trách nhiệm của 1 conatainer là phải phát hiện tình trạng này, tra cứu lại tên và kết nối lại. LinksLinks cho phép bạn định nghĩa thêm aliases (bí danh) của 1 service có thể kết nối đến từ service khác. Chúng không yêu cầu phải kích hoạt các services để kết nối - mặc định, 1 vài service có thể đi đến 1 vài service khác với tên của service. Như ví dụ dưới đây, db có thể kết nối từ web với hostname db và database:123456789version: &quot;3&quot;services: web: build: . links: - &quot;db:database&quot; db: image: postgres Multi-host networkingPhần này nói về Docker swarm, sẽ bổ sung sau … Specify custom networksThay vì sử dụng các default app network, bạn có thể chỉ định network riêng của mình với từ khóa networks. Điều này làm cho bạn tạo nhiều hơn cấu trúc phức tạp và chỉ định các options và drives trong các mạng của mình. Bạn cũng có thể sử dụng nó để kết nối các dịch vụ tới mạng externally-created (được tạo từ bên ngoài), cái mà không bị quản lý bởi Compose. Mỗi service có thể chỉ định mạng để kết nối với service-level networks key, cái mà liệt kê ra danh sách tên tham chiếu sử dụng từ top-level networks key Dưới đây là ví dụ Compose file định nghĩa 2 custom mạng. proxy service bị cô lập từ db service vì chúng không chia sẻ trong 1 mạng chung - chỉ app có thể nói chuyện với cả 2:1234567891011121314151617181920212223242526272829version: &quot;3&quot;services: proxy: build: ./proxy # service-level networks networks: - frontend app: build: ./app networks: - frontend - backend db: image: postgres networks: - backend# top-level networksnetworks: frontend: # Use a custom driver driver: custom-driver-1 backend: # Use a custom driver which takes special options driver: custom-driver-2 driver_opts: foo: &quot;1&quot; bar: &quot;2&quot;Networks có thể được cấu hình với địa chỉ static IP bằng cách setting ipv4_address and/or ipv6_address cho mỗi mạng được đính kèm Networks cũng có thể nhận 1 custom name:12345version: &quot;3.5&quot;networks: frontend: name: custom_frontend driver: custom-driver-1 Configure the default networkBạn cũng hoàn toàn có thể cấu hình lại networks mặc định trong Compose bằng cách sử dụng tên default trong networks:1234567891011121314version: &quot;3&quot;services: web: build: . ports: - &quot;8000:8000&quot; db: image: postgresnetworks: default: # Use a custom driver driver: custom-driver-1 Use a pre-existing networkNếu bạn muốn container của bạn tham gia 1 pre-existing networks (network đã tồn tại trước đó), sử dụng tùy chọn external:1234networks: default: external: name: my-pre-existing-networkThay vì tham gia vào mạng tên là projectname]_default, Compose tìm kiếm mạng tới tên là my-pre-existing-network và kết nối ứng container của bạn tới nó So sánh link với networksNhư đã đề cập rất nhiều ở trên, bạn nên dùng networks để thay thế link. Link chỉ là bí danh và các container vẫn tham gia chung 1 mạng default cho Docker quản lý. Đây là 2 cách giúp container có thể kết nối với container khác thông qua tên hoặc bí danh mà không cần địa chỉ IP (ta hiểu là các container tự phân giải được nhau). Về cơ bản, links không còn cần thiết vì mục đích chính của nó là làm cho container có thể chạm tới nhau bằng cách thêm biến môi trường. Khi containers được thay thế bởi mạng giống nhau, chúng có thể chạm tới các container khác qua tên hoặc bí danh như host AuthorStackOverflow vàBefore the Docker network feature, you could use the Docker link feature to allow containers to discover each other. With the introduction of Docker networks, containers can be discovered by its name automatically. AuthorStackOverflow Tài liệu tham khảo Networking in Compose Medium: Bài viết giải thích network, tạo, xóa, tham gia vào các mạng được custome, default khá hay. Docker ghichep: Bài viết này giải thích các khái niệm ngắn gọn.","link":"/2020/04/21/Docker-Networking-in-Compose/"},{"title":"[Docker] [Tổng hợp tài nguyên] - Update 2019-03-15","text":"10d79030e8222445804370796b90fca1757e50b73c71834cd286bd57952b394c3724c01d322b2db77d15950aee95f6e999e843e80a1ec38db0e2ee9c8d608ef1fd56ba2c25bd124e38476887c05c4aca90611be5cec169f137f20f74d0ad04c70f9436c2feda989a77e494e4b82eaa84c209172e637ef2cad00c3f5e835138c8a1db2f95fda89de82f830a61036fdd06a90b093b50ede8fb6aa4629d894cb710e3e46d2a3affc8acafbfb81dba28e3b82c23abfb2231f89504641a7d4663328e90767b12e2df707577e0e7904ed71d445a680c756dd844d36498a963cf36ea1f6ab7fefa31b239af58d7a7c4182dac60573addb2b524c46b8448eafe5524ba44251d0058f32507212c457befacd15e394b267e7200da055fe6a51de22e786217ca515b9b5084270b762dd74b822be4c29a383c47749b956fc19f39b12b3e270dac678a94d1ed834fbc8a49233393b77ecd9762703cd58778cbba0a48b828b2c067ffce93dbe4dccfe80ab008748e850cb808d09e353307433682599b7bef32a19a4e4e55ab38e78863064172aad961ffa36d7cadb2d00fff9ba32d7b7ee6a537cf90c11ad60aab11108c84654853bbcd91dfd54a5290dbd2f170b62f23387a30dc558105dced893c90ed41a90dadbe421b83e033134fc71e3349b0d14a192184dd6befe34785724aa11da2f3f897c7c0989bef679c669827fedd0486ccde935d6c8b6a0fd7f8ed4926ebe35b7fa96c351a2fdddf776943b39866b26a45a2a43ca7023584bd6eb07f1169fd83bc3b17bf2ef9dca02d06cae02e6a53037f623d84f4c515e2ee84f3e7d2f3b835ae845d95001f920392afe04ee70c3c122b70c4e019c3fc1d1aa7288271f81d25b61acf9a42256e79664f563dbc2a27b0f1fe24c0c090e457cc103866189eb8cd48544ce74ddaf1f05d8749335b2f47d6a2015e94170b4871e617ff7712ba099f923e42b91df20448330972f3bb5f13fc303200ddb15757259d76558b4b7f24aa91b01c0415917b357dcc92408ada9487e47e4e35a4b17cfb20f2bfed364f907966bc39f97e6229689f31d0c3fe675b0ed8af33111e52cf1f6614b8956637a94dfff945e024ee478870b28ac3ac0f579fe5fd5d2ac3be06510f67d3e08b9c3fe0c11358785069bdba87b40d70c0247c05667a7d340fc3c2be0d9fff5240c6f376b7e42579342d74f9849fd4a13e3f128f9c4593ac9722e2a43931e8152e6e0a1706e841c1b38da6e5ef1189e1dff7c9acb21109dba3db0679e3b66f16990f4ff94d473fd4b7f19cb29e5e942bab0c897767f5fb294a4d71537b971b0165392705b735733115edef03f9c0c612c1f98562b4bb24c9ffcf1bbc8c0fbe26176e0e80f2b84cef9631afaca8206583db3361d2acb9c0b2ee32859509d24907425cdab539d02baffa36157f4551715189851ce07afdedcf110be4b5b048db5b1ef4188b78512af4cc7df3e9ff5cd0c348ec9f2c2017e363dec51ac870911a460ecd4838397cef47d449503586011a5b75f7c72606bf6c538ddebe948e6063bb4e3031f94a6c5fb1f2597f6dc0d9b8964cfa781294182517468a6268de1658c47d187814301700ad9015452d75000e5c745520af49008d91eb24b73922cd9d169b5e7ccbadf69f946813defc9b05c37a37619af272455481b8b26137a64614fa0b1dde4b299231d4b972b6c790c5e2b36b0ddc549eb7e7caf3fc6c6d281c6b915ca499a456fadc1745cb773185f99ab1617c2e06ac05d56f5132956d5d5d00f39dc03e17a56a229e2761a3c54984f4cd41c830a95e1611812c3308495c1df0b1592fe58aa207b8200f34aaf5f516f99531bac64225453a5f4ec5a6a0f2ab3f60b187c5a17921edb990175639c9ba594a87330f158962cd9c6e5724acd965f44ba04ba4fc963e144f05caa80c4b45c2e2f7ed72357a7a8b2666dda779965688c3355bcce3ca93a41ce6d3d55d0ca64e84d86f1cbea3d2b0993dfae90a1025ff1f22238b33aca937cd0c37d817f6b75bc9187f00a77ffb361ea7fd0970109838848e95c57f8f9676f037408f86f841106848e50dc142d423567b5f29c736b294076fc4bf460f8459a04784be33fc1dff5d8ff11e557eeaf788cdd1722743c6e63c9699d90e9ed3945053d0a112aa8c64e82b5d48dae05ffc48c6550b53662fb7fb9e9de2b2826c59fe04d8a830bbda3b31fe44c0c1371427198a804b882a8b9f0829485acef308f8dfae60373bab6350ce82acfe8afcce12a40ab04d10bd04d171ae6cf21d637f32d7661d1ee09103d28d7b3dfd4b38a000a63cb9e7a5bae0e7c05e5e95b0a0a94bbe73e4b519352e110aaf6bb64ea60f3573fafab180fbd156dece2cb0d3724de78c458164f71e42724540e032295290016f2662b2dda00a21c695b71e7695d07f5e09e6a979b7e482d2e7aa2b6b6e27ef52bdcc318f4f15abe3394c97fa6e2ac1d0066166fa40309cfc749f016a9d0ce3f2ed154082d73661fcbbfa9f18c5178c6cee231cbd939f0e6831417094c145589af086e76cac6475bc1eb8b847421735c8b57eee30ba3084f8a555b4c1259cda47d9c41ac9155bfa0fa898fbe5f20b318ff8bcd3908add87e7449f5d14354bd30f70634e7f099c9e7021ac77f7c55e2006c7ae992fddd2e7a858d545042b44697115e7ff4910d9c47a8a93e8cb408b1b1fb0f2b746345a20fd4c72d94daefb5d360b3f101b2a11e94aa8b76cff12f5546322609e5b6e9f1d819d1c4f229990ef85c70e423461c9394e15c111d89fa0fa95197101a22e20e0a1a6e4f05664d15f28d554bf3765f8983e8906e7a1fc68e15b7f725e03092c7420b6bbabf9c92f8e36241851d638ea0d8c2592b031afd657ca07fa5152b8ea57cc9f4d44642ad09438696add873b6d0297e38f9628a5188dcfe3390aaf069ac9274a493ed77331fa7ef0c5334ed3a5d5d5dd9357a367d79f7c84518c21c98e630c514596e566e4ccfeeafd25a05c2f77a76c8cfe9752c5e4d2d4ae1bb510a598124004729f443b1c1e0cfadbb10fa2c6674071c3397c63729617add91310fba5afec15dd320560831cb2040ac859a0fee9ee88b5de52c2c7088d850ed9cabf3915549189797e952ad0e142a18c9e16a0bad70189919e58240ca7eb9e6f0b2c6f2840c6c8a6b63870848d41c5f3883f79d8a7963877c30625d2cdb87f65e04c208edafdedf1eb6d60a961ccab3102f4cdf3e6910ba1dd87c4570952d8feb0e0ae60b86b9ed57a2190288223ee83d26379d15184693abf45778c656826b1a746780f87b007c08e1343645425f7693b9233fe37a50c8e65366adce407ea4bd7d1a9977cee41e1b7a44e01047a169949a0d764253d6ad2ef8126ef333ca8a88c19dcca48684b775b41806e24724c8d3d6c40980d43d526d55fa95828c00c6c16068411bb5a728eed790c2de5a0ed1e843eaa3e90ad8b6e8827e323d89ddf7d43251b636e1a46abac93d04cd92161c3ba5dd3d93ac607a38df0984a1d51c8c6a351dcb4e19b1f707f17b63eb2e0e6043f74b8fb829046644e4221cdaba73fb6f5c2085f6ca4b9c3ec9e32d1168dea1afbb7c6cdae769439d1927d8a4f17c1ebf93dee523789712a18f0263fdaf42aa074258bb475d9adff926265348157f0ca7dc670d3ad7f18caba9d242ae8edcac035475aec815cb41eb2be4da433c150f848b53dc1441add15c00d32047dc9e2f3e91ce518862248d8ea3bf4649cf76e934a4923afa897234828d6a62660260a79f710a7e23676ebf9fddcacc5775d95a86638e02401c702c1b12ce2586d7ccb548cc0e752f8c5d44ddf67bfc28c5d20d4eee4e68a1e52f646fbd32292cf9a9a60630525afdb6a730e8c94d77f4e7479ac6ce18526442af5d7458c0d014e96df117de60416c50d98d09c2ad71ddd4ee20f9aca184ff888932b15714b2fba4f6f1963ad71194392e5de2710156cde9cff2b85748bcdcd3c270ebd46a17f5cc3803ea75b226c532393a64a678fed34be2a7ac49a05665f58f956ed9e21061930b5de3c27e2c4fd4f7312f010062ec830c2e0bb20b61a89ad419cd7956ce657b28834da04bb721fbd46a0ad7a44f5b89dad53c2bb41e7f98f2b4c25b2960ed92b4bb251c8421382cb21363d00843c4fae8d1f224e8c07d49fcc3a0419f032725eb240a53b50faf5fb34d842cd697bfa8d7fd20d926019b324a066de72996df46fa014c05b43e29ec9ed5ffefa3cfdc6721e287e2828f5a61180a34a2063bcf82e18ffbe013c9b1e0e9fc19b558a161a159a8379310cbbac93f8e97647cdd0208d833a85700e2708ec92837f21052023ea174494481ecf542d56a840b2a4ed6073e61f3641a5ff7820f20473740e0248371af38957bf8ba8412c760bc7eadc5a8a2de7a26d3540ee703d014ea8c0d333d3799d032a63d4e18213237462f3b76668a304545012f6cc8eef5775fb8512ed4586aab2b2eee2de76f1053602a36b3cbe0a08080a4e2df3a18a2838089df5e981a7735f8547b2962fc520459b81f9efc13fd983566f69faa9a71cc44e4d34bef2a14d7db9faa5a84d1673d05f2c952da619cda133c012fa6d09095c443d79027983b1e3bb91bff58ba98dc4ecab7a693bfbc154c5852c09a1daf7f7a3c1c2101efcfab7537eb431e8b2218bc114dfdbf631685008393c78a5bbc11662b255430a889ccd21797027744d85fba4d85f26c28599058a057e429237badb36b6a8d5054e868783f90d9da39b0d78643f2d526a192b3902eafbb5fb4f1182c9dcd107e5db7a4f4c249cc388099f5bcd6b2d8c35d31f99ff5d5a8a5c5c86edd1818cf4fcf34096c5a4eb4cc3f92ee018883d9d4dec38b170cd1170f887734f83d02294fe1805a158ad05cf91251e25a9a68ba5f3fbb66b5a373f6ccf9d94b0038f6539019e4868d1218f36c07aee44964a57499440ee7f7a35a198f179580368d81c18ece89302c7e5ae6051f12c3340bdc5e2e9bc2ab4bf9b13808273287d1b905e61e0a4e9609ccbfd39d716ff5ba1fac4efeaefd80abe0a43e898daa035ffa92e4c7dada4a34a01e70ab9e4de88560e9746d2417fda3efc69f86e62066308e13817236ff91f2df408a730663a86689f785af24271877e4080d01e7a2f414415370994ac3e4416093da7947a1613c54eb9d0abcb09f0588b71a333689fbfaa26f9916b5c38a050975ca389cbbabaecf92fe3ea4b59949e1b8f61e059ed0e87ef87b1cb77ec533c7f8b3a7b95bff1bc9936177140adfdbe4c7de50a0f7fe3b68adfdd00787d08bfb55bf42945ac0595380ab2cb2e58b8ebdde2fd0805b6bed93ca5d1067656ce726303f1e6dcb65f45752225e14823309af735604268f4a443fd3023b886a1886e18d3762df13a9456e7105c27a24a507a2813de876b3a2c306e03371a8ef8bb553fc5eb8e4d4f2fcba94229473244e8c89508e3e0e14b2e0202553b9dd7de3ed7c8f980f4e1228d302bbb57523f9a31108fe545ae98148307c262e92e2ebb7cd7143658d786791f5b1405233c820ee30dabbfd531d0c7f142ff10dd7aa3d7780bd31fd4117d51d4bb5e8667f33aab6376bd9738f3cf9133db0f422d04ca2bfc5eb04294bdd5b7d5d6b49634582de295b70565debd8252c1575142017857307046a75f9ef41a7bd16f5ebf1128fdd0c82eb23cb9a438a86404a6b1b3a5b730d96e8fd1971ab793ee399c40c3b8a0120af6189a8736d8ab6094ca583b958913cb04e2ed2b72d7ff8a2e18897ae4ea182d776f1156ebe02b9a1c3bbff419cd6980e09c08438d476bb7ebb51fa14db5fb8e762e7e4bd6a6d14564768c Hey, password is required here.","link":"/2020/05/31/Docker-Tong-hop-tai-nguyen-Update-2019-03-15/"},{"title":"[Docker] Use multi-stage builds","text":"83091c2cfa1f0c3be410cd7dd7d2979dbb9f6753ade6317559292d74cf418a27d0d30e1b8d68391a05c6cff9321ab27874c71b993f0c959c761c97f9638bdcd9c48f2e30b47b4eca44a24e2fdad2f272508786f6c95c53f9042d6748e23521a38548a7ae5a6c470fd14852d72c04fbce33997f06ff96d21abea2e0fcd1eaa38deff4fca77ccc8c2035e73ffab385a17963c3780bec982e85b5ad88b9bbe782b7bf3ca651bc84ee01ce091c11f068793279f659362b9588af41afab60cd8e1a183bc7799a784475a7bec1db8dacb751cfb9d55a66516e0f1b72d7607d77640a8667d52d7b3ed11d3aaf07a4e7dc52c438cea03d85b8c01216d5a0f4af40a6dd39b0cb5b95cc88aed48c55f6ad65ff62ab285fe5e684c76597ff61fd1d3840511fb03a5364fd3731d2443c1030b78fddfb23682253ee590d64de7f1963369806216ffb3da29abdb65bf6e9490bbd13619daf307e98702eba8be2392ed73e4706874fa13cd1c976e30e583d0ace50c0782debfdcff5183886d8deb230a139b1df2d1e7b98e29b4f1aa5125475e624fba7ab07c685a8056128605f9fe98c26dd5b3171834a54f411674f447865e097f00a3ae78c63f9bbb64a5f656c84209b215f69fa077076ffc4bbc4d43913f1f955c369044c1c856aa926a469182139cb6a04ad866f525d0d5115e5c861c360e6f9f718d17debffae00517da3f3664c17d01a98877a3d13a233cef0c09ec5312f51587969f2889838c36d575f8edd422c58c0b3252b49f0624aa129ce16897187f80ca8c6dc553c83c3a03a24f43cebaea3770b52f27030e7fdf2298271f83a993a66a979feb72e78eb7ab2c104cac561dc0233b461f361a8d9f6b39703b159f2cd3be18419b47a0f8b034c3c30517026453253a12e8a3c050fbf91e7edcce4e70484e9508d19f9ec2ea11b1adfe76a9b464d262d25ee9864a2052ef18c2b7fd30779b037c89f0c33e92c09c679bf57bef127a46bffad706ec16aa19482d29217b1a6bf916e3c18f2ab7cae7b56fed75a9a1b4a26d6e2fbc78a3d83e0e50bbf1b98bf42c6b6f003481599dfa5bc21acf3e295f3b93f255e316d723a5d9bb1485de4795d9cea9770cfb58ec4ce146a10d0fcc5d6ab5b92b1b07db9ad71cbfcec47f96fe5806011b3035304cfa0cf0703e669d92f38b285f36b171d1f113321b4afa893397dd67251b4ce87e8e928e16a7e207e3233123d6fdd64ea300e8a51735df07646739b283469f1fd60329cb12e179e46e93b3d9f0574ba789971e5d44aab3bb0d56dbe395481bbbb44bd9bfd33a84d4a20cefb78a482a95a28c8164adcd2396634cee41db19b80ad62441ba0b030eb0d0af8d46a5192ae59ae483709841e610a7828b6c3cd47d0436da831c45a819bc4b668ebdb15bdbe512073ae3ceed4421ea6420eff1ddbb447e487e058cfadfe08b54f0ce227cc1a58aa3fd2e97e04fe1afd798698dddbf74eda9d78d9af5f92cc5cd0c61165b4947c424c2cb1a0f3a2e991cceef1ff7abe5eb72afdf298b3cbf64d6b22bce207d7b0e202051cf5af3e1c3464bdeaba5e8aa91823e9657005599a7cb6509e6782b710017728d018861656b35203bb835b01161138c6e42ce4cc65bce314c1c38870c36072d9332288eb105d32692773cad3b007dff101d2e65a240b0619b63d5be7f1f35e287862c379f97f89209e2fa70cabf0d0f70d08dcab31868791d0fd8059926d431a71b15845b50916533a1eb5e12b88a5c4036bac678470f1856b06e22e25d095102bebf8b9bc06c54926af9ee09c20734f72134201980d50fd61bb2dd97ea43ef49b0d1b025023e2e441d3e16fee0e79ecbef68b2ffdf3e88ed7a14f9eb8c23c42301ae2d5c25d8c9b4c6c9dd3fb6c8e8d7614d77df6ed131e5052a3929bc2671ddefd8f389e472e22e870cadd5927857912d3e9f6efae0d01d969c9dfbe35ee28640e82fd48a43442ce784a791b1be9d9ac6e81cc0c326e600390e012919b6fcd4bee3d22da124b672ec6b553fc9137b405813786ef89a4b5ed4534e274e1bc86359d154c266fe900cec599feb447b6de34aae24b36fb07b03e8bcd125d3ebd81c96d250987bb19ae8ac53620943a67575c1c8ca83e369ea0b06431e4aabad482f3b3cb5095f39c0556cafbec1f340271c8f3fa44852091ba13697b1acb968ce744516a65a7734ffc0732c5c69b47eae70fbec709db6d212f38a9c909adc2acb617f57ad68907e7d99e3849bc9268da0324273007efc8c14b17dc60ddeb80a43f561829c17662f1950518ccf6ae57b0927a1b0a25c24b55dfeb97a09ecb93658f1f8dd0229d34f3c80b6517a324c3c20a73018c7ba0f26782c8e8a0abb0d9773ad7bb60c9779375a1e0404a7930a6432f8746ec2cd1fd7f8a22b80d93afde41e59b451f3abc674a2386f21e43fe4c564b63525f97542d44212cd91bca42071c2330a8abfba34122e2ac8b926183a699fd9a1e88ef240d2fd3f36cc2f642d245583a02582c8c2b8931a58df7b04c5b16911b84e8f62b4d4433f9ef06ef2a0c1f4b3f981e1f896070cf0caa4c57a02d012514ed8b4268e194a51cf908841fb046ba4109ca5941eddeb00fd787a5c7e7231065f1285c2145f704e3d486f51de344c9eb4a017defeb835bd1bf05ebae49435cfcf51ed802ab75af3a23f0a9c57dfa4ce09b46b1ee029a8cd1bea2babffcce727c7df65825375c64e15d9b3c1dc405f5b6819f519db738c00909d7797192e7b26cf667a07c6fe0f520673a41872aaa685c7648714c5264219f76b993a887b12eaddaeff37edc3cf7ead993b5ed755b0e14928025a2a58e4ca314eb14c17db5ee678eace745d82cda3deb70fde64808ab98d0d1762a20ee755b6da8d3d6669e320343244c6ebee126baf11b6b5a36ad62330f653edcfda1e238e2f57120169b9daa2c1ce3746db112fbbb9db14f57168e77f44ea04bf398e1e7da01e6634f3dc8207a91cfe258ffdbe02da6b9d48a5d1e1e2196a4d918ff7e373ed14683b9f7583e1adac77995f6a39efc2d2bff57ea4fbd071351873606e9269a500739741a60f17c9130b3a52e98d1c4b11c3868ccf15c21ef718caee7042ddd129eb01ffa1c558f1b1528f7777ee721980094a2c8201107581354ce3440819d36342781050b5504ad0a38148f21d0433bd49bde4e1cdb8de1e1b47b7b8e03ed48a6364e8f0c0473866daa4ba47a4a54f617baad6693ea440837c2b69221b0243066f35ecbfed264e0a99c6a166568fffd6a19a6af9f87a50d3bf1be4ef7c6111b912bb65127362fc1ab4c30218220cca2893b8075440f9f6f869f7002ee743a4fd9dfcbd0459e989af32c12fc42b00a41c12ae4112ba4bfccafef010680db560fcfcdbd9d4012d86249481eb525d78a0c511db34752d4c772530681be73a26294a053ee928b65589d459c9cd566fbd7c1427eea4cbe1681d7d19187a4b5b7cfb4cb923d1b5f728a2ec2afeb6489ed5d1530e9287f79aa1b4dd00e9532e5644c5dfbfb1324dea280125b71de29185b6da3701004b24bd50e2d02d02000e17c78e241caf2a5ea9f95151cba0e3b565ab8fae4275ebfcea02fd18515c7d48e3410716283c1339c1d0e772bc4d38b97168714efb66d9cf85bba37e96506f01ef1d37b261b460437f7a9f4ab0f768cda61e34f56847e273b79ecfcd61a32d453c72c3eed88c4c771f2993417f077ed3f520b8292490454219714c8b3531b97f4fa96758e322923c9c626cea163f271536d690b2249ff128cfb2555ec2b376911e2b2af5c23e844db59b21d44b0e25fdb5da78319483173d4331156acd65a60b4e2ff91ff0e94b38c7cce95462b9fbee0d65ae776f08fe032579a05e46608253ee09946600372f6e90cbf840b741d248db75b6f9852eb475e36c72ba874cb1c9f400c66218b4d426c686f8086f9ce55ac2e9f8f7cbba4e77b34fef208114b1c7ea81725a5e100178f8d6375e6c2fa36085f821bdd43dc7863fb5f21f945d35d67eba477e2d5d17e54468b177fa2857a0ee16c9e07e38ead0157fa70058768739d020face4559f6692245e4c8cbe5ca6234494c966e134971fe864c1cf95d5fb9890f24753795a29e2b223d9e3433698d4446db9b459b20b46e54d083bf17512905d14909be6ed6a7af25078f4dbdf064f2b40ed36440b2bbe14d8050ec7f0399785b1d9b60705e262f2c1905d480f60ec56434551a745f1553d914b13ec5f3313ac77a2a4da51fcfb44b1c97f0bdb282f737fae36d430b8a3f797ffca1ec17fe227de402615b45aae8c48beb6cd80cb6ebd8f5da9c039c8f98aadea76301dfffa1d0eda4c2ad9ec45f87b629fc267fa2c0143aea1ad684cbe7d1912b17765161d30073f83d9836885cd71753a2a9b98e2b51ccb4ef008a0efd1c6c22b14dcb7e343e76690f5fa36de5a0d17c34028a99fbababec22f0da3ac0e102a4fceadb813d16f84d55ee09e8f6462c952b490839b6b12ba0e57740316a30a83cf0dc316ff8a010627302d82b22d1e5c2ee04f3a3013f2df1480a9ad04a73e831faa015c1a94f9d2db387729279695bc0bc17968d8ad5e82bde4b3a9d24519dbbe8e2d6f395735ecae0f780a409411cf80f3f1a3fb7ac7a4831f6026cf1c6246f0a318cc37e44cadcb09edb4edfc72a4b9c05c620ba581406d203787238e3bf4cf459336794447c11be2376412d10b173390f0b481ec51ea2be90e20a57bdfa48661787d72c619c30f82adc6c5ad0198547e110e9371d3c112a05b1dd4abeeb3ad1ff74fe1d5ba6ae0ffb18cfe0a6ca4f608a4c2e5868a1153474bb394c3e3834db1fe634def4b4145b011b147d205c31db49bc2d1c97836a7e58c9ee041f80367a6f5f380371a08034063e0b9f8b40ec530ce2601ca968c4abb06730840c9b91ef83eb310c00d133714394231eb47a41d032d4202d670370012aab9f4c9719c2d88997f17ed3204c01af38cb5ae0ea6c88e9385d1ca789518bfe592ffde26ba7a613bfbeac20464bd243b278305c9440996c71f4096ab482caee11709ebe11d506211fb0b0d0a3909b8192af21455d2f0508736792aa14e42ac103ba8125a2aa0ea9c39637177399973afa087869ed6fa9d9752be2c54852c0dea08512145ee996aad83ab9a614e30fa75bb99806c0a934d3b45a95cdaf68fa1ca66df4c6d638b91bc93c69ae78d313dd307faed8cc1c30c5c974e55c1d7f1d22dbaf077d589f57ec1b06f3a35269e174b017c1cc2267b7ed8fe3e50ed889578c41771c38c7901d9be13ebe255d445e2a13004908717868dada25fa7d5fcb61c66bca9b9c6326d068cf3b1bcb3a0e55cdc919901a66908e65c686c4f61b86dca581b17795d7c25fb22fad661b4ed7c0bbf1ea6aa5130d5035e53fff4fc9c5c1958b106455a50405d389116cf69d1bbbcea8347db3b10bca406fefa047ee6554970401cd0af0cae4ab85554fd6677474cb01bc86b50342b49aef5db5afeba7985d0f334459b0baabe59c29a57060d5dd448d3a8e883d3793411dbb726f1d38e6089e2e0ffda71f023d46411ee6cca0feca8b1c466aeaa39ece077eebdbaf4eea6d0d6d85b24a796db2d77da7738c98cbafec46f849d9165c488e58d55fda0df1256a604dc8e8fb687b38470b3773bd8d5dbe08b673e5c898b067e4d8f89829bafd3ae3316e257c84e62579bea6d3e937f8a5d9f7e9b3a9b02a00ac0e3c7944ac99507dbee5daeecc376ee1a49e0e99b3d260a8452efec5826ce58898ab7ee08cbdf7a2f74f63370c2ebec70b3fa2609900edaf4edd554228f2fff64a6b79532b5845ac5da22a0c124d6ac85e73a218377fab0428a2abda3d6a2362a6249cd05cf6029b89ec2d95ccccacaaae7d66909762cfd90d775135bd1525f37e516c8009613ddd11baa74dfccc6562c9accf579305b8bac2f99811a215511766c33923b8ef6b4f945d787e39ad3e7c3d26ab1df1c2e741cdd9962e86d5f23fbbb4606c0349d7b2671b01097c6c129db06d95f9bca8eceb1c0be602d985ecb854d675574a198891c8e6c91c98fc407b545f7a151a317ffac2fd74d0a8204a80ff3eeaef222943d9c16c4af8e962be72d22bed38fb13f45aefdc75562c20a23f957491e169db62abe37024d373c55c5efe8ae8923c478b13e310ad3edaf8891aec63b99f2a4805c06459fd2aa95444c2112e9d7f63ddbae161cdc62e971cb69bc69ca9f95e8a11bacff88f78ffe9e1b976293438491e28bb700214e489205592e960ea61bcf5e37e32e081eb247efb054c30f33703e62e1a32b41e2e8ce5e8180262215e49da019e5546dc3e87ea5ebf58e94ee01bca02e2bb2b09a17f4e73ef83eea9cae24929050624ec63fcf2c31a0e75dc839bd8ec52aadb0219469b8b8287c99df2d51537f989fc13c49f3b474bd74fdec535d999179e91ed66d28d7d0d2e32fa59d116a63112c638006e899ffe804a2b3391f6352f5bc7b08ccaa1749497a3514b509261a3916128461a9572b16380683f5649730d750ba900e45d7cbc89d9d3aa8709405bfa60c4ffb93cacd20a13fbfffe0d06d18de84fa2764ac89fd905164bde7706c5b9fd1b7c6038596dd04068b99779ecb016363141fbafefc9fd6373d8cec54d83584c0976ff977cb699df93e7e372bd6d680624df560140c488e578d9b73a2881c4e999d13fafe2e3cc99ca663ed02b9152608fce78b2cd6a76aaee03f7a4709264713a2476d3f730297e11f16d6ab287cc2bbd9a9924b69446f43b0d67c4631b5e39e794f2b6e8b8cf1796ffd8107685e49b3a218bbcc76153495caa6234bd0b5af0dfa7e702e2cb1adc3e8fe09d9eb339c65760ed2f14b72489b3ac7255888d31f5892bdffdf05826c7e3c0528f1200f7727a252f5386242221a94e0157be1e21cb39ff50496ead6eedfef74799fb00308b1751cc148840a63a88f8019b6bbacbad2e6a2d2eababfb00ef5c7ceb378200d2751748ab8aa5a51b0c763d736845a5e93a8d1f20c1f57ba58a36744d26fb31b83d789ebba4b057b42861df9e480a4e510cfcad9a38cce1e11d2e83503db3a9fb52615cf2b8768558171a0ccf2100c43144642727f887e61b40ead28190fb70cd74c1a471628af597ba6c65c2a44e99a8731aacbce9186a3450987697de635379971f6c59c1299f208dc803b992541dbee885683459b992401714e4bb3236a417e391cb79dee43b29382b76dcc8f10c1826db9ef83ca3c64c8e60fee2164be22789c45adf5aee912006105b42a3f40af4e28274766008a1d9fe6e26b4b3c462c3d9897ed7c50d6375672ca94c08dd6f0b04db41f4c6bda33580c530c98405a3bc42038f112392d4b4135e07b7b4bad1a5109e6f17e15ee70074b218d0e0dbd28bff751098bb095a3a81ec0fa4b19db37ac3b994352e8f8400189a7f26b2d536306717395f64a8d9408480356b7e9a71fee450289afd9454a8bf4c271beae9f7376ba53a02193fc2c332fcffe47e9740d081f0767523c47984ded3d71fb718b0881c63a97f32d462a1943068a280eb15387330a674e6a6f9bcea1990d6b5a67b53fb6d644c2292ed43dcf55a231f1844893738f69c8dc0bafac38cbdc91813bc8134afdd5ed5b2e9e69f367836dc7df81fd99a4c44a4e5fd0c03ed97b574bbb57cfe13355cdc7e608f7db2b413936a5a0136691b79e35967ea85bb0b866a6176150506eb0c65ccaaf72982f1bb7f2d845372ee4f48b163b049167308a2508264e88a3ba770aac005df4f1d98056c0d95e7e952d6b0d5b0449a0f26a61d8f2cae27dcb1e5d3aa5bffcb55157e6f4497c703682212353ee2001d592847bce54d7b33388cf1b591374b3e3edd3e9f07245002494e897b2aef898ce4dd50fe3bbcc42e229b7e8cf5b21b2e23edfc78b03c834cc8628c1d33290efea1f7fb596885c049fcfad05e850870d0914016911d301d7d930c340ec40e61411dba841e43b2e8e9e031719bc5184c9b5c405ed2455782d1e62eea3d8a93e91c3e8a1b0239f488df5d70385e18e69f6b24edcb502bccd20fbc3f0b51afbbef3b0fbf7e0246223304bc313d59796684bed058dd7ccfe965a7df5e620383fdc7b21018993ee2d83b59eb3b3ae53fec198e3b07a6faf4890c8b0ce5869ef04713a7356c751a6b86b870e9bb004d7616ff8279ea3526fd337538198770d96bc3727bf79c66526e48edb19ecab8bccf3d2c592624f399e0aebe01e63811b03ff434663b87df55fa152d5c5c042399f81c334bf9fe6abd6d59b2d92668fccae5a4334e5cc36c34cfa36f89db0849148af62c41902e23b032b6a06f939cdffa237fc21d0ecaf126d3319a349af54e11d61083bc73c27a15aa2cbd3879cab91d7e009025ea5e5d4efaf539e6375c584c831fcd651a28b736c513fce699fcaa5187bd9f00af6a8992488f6c7922f2755a0c0ca171d8ff0b919bc25a4f77ee8044dfdeab9ac2032c32143896425033d812cbaa5b023f83e77e033b9d8e7f2b3930f1dd1f68eaba905462a3961e60d73bcc2c01b320bca055e1a73c9251529c2210fae22c6dbd3022b9280d6bfbc67d1cf6d44a10646e14aaedaf6b3f4971599a33a5f884c67eb4ca02bb6d1541e5d63199e4ed0193eb98adac2e5769544db866d4c8611d0d6ce6421d06f6963a8f40efa35f0c782c325192ad9f869e0da514929578398196d5639898af79d2e71615362306963e18882ef10f811c1a1afddf9f138fcecb4b6e2a085caff132ad8b9dd28eb39c8d69014e1ad8b485588ee1b48331c5d13fc4d552fc6e567111c43dec7c069f78f140f364fc6f36910cf5a24816609dad7518eee19b2025493d2c6f6abf2e66fb4478daec990b57989db683e10746098be9532b48b94cdabf88d61e70df5734957c5355640dca9ad9c1495e594c65b7cae7fb8e3342e3136b58ea0b3cacc061b2b8ddf210c71604ad9da68c3c4fec717d37c6b0262a445544d868b676d9d6ac0ba5597ed8f318d59608af3c25ab46ce95700e0165d27aa1a34893c29f504cccf1bef8592a671059f37b3b058eb498e91b9a41e7e3fb790ac1954cd73f04281a02c2e44894c25bba95e1ec19aa5793988dfd955559b481a346d3e97685feedb1ed3b791f3f6aaa9e305ba5e001ffcbd9bf064b0e18439351568383b2e5361a90cb05b02cf442560aa0e3cd0be94233d74067c1c21ecc9093fbd9c6471e3864da39fe035ad583241def685662ba8fe2baf538d4495bd7da19880d98f653aaf60e8f15b053450ecce4ff4860823adf6e8df8114321392f11c41d8a233eddbdb936612e97e278ebe04f292d924e145e2eeb9bd53cf512c2cadcdd31661afcabb7dac00cc93ab684215200b005fd1b3aaad73e2c90a104ac905ed26f03c35127d35796e1768d60b75e59a87b609a48b058c41672972eb1b71eb046c222df6544e14aa5b7da19ac7b50a9c20c400c4d027de6b334568a67057191077d20492e28b42c22f3087c6bba19e4d8d69fc8cd4c1bc8b67f1afa1ff7f020955ba77a00b2d7c44643774db08d7e5ffb8c7e700a6e821339b7f43ebe81be903a9b8f6a3c3af41a35e53ed49130517217e5438c5d1a70b4d83325e49bab0eea0900501e7d0fccee3741bcfee1c6f411a8a6b1dfadee34ca279b1b0eb492b8e666c007451b6195a5f18ec31a2280c8c7fdb1c73703c8ad7ccd17ad4dff9aee97d63e54c0f696838242c478e5446edf94915a2686eaec061def9a6abae2cad9b9f0c32c95cbe9cd1c4a33aae1b36383291ec9959b6e5f5ab93ff573e60ce3ec0157031f0a5af95d0954c865452e22d4efa5ff7c5fb9e069c205d4af244776fe25fe7bc12feb2c20e5f3617c268c37a25d83577af490e310046450839ad09e1a97cc0d7b53a27cf8f3cc03fddb4073ae79e52275f8ef951a98051a168ea8a22515a3fbd174d715d043d304e10890737dfdb93b292d2ae19908d335a2d8c7d4c76e32779aef60bf6a3b2ebfeb26ff2e67c14eaa546044844452cf133618cb8450056b67feca2dc679955f4883eb19ef683becf02b07c88c0afae14631a1f27a9001610efcc2a9f568509d3aebbc2ef7f764cd05bf4e1c98121cb2517ed809c9836073ec1a4752075bbf573fa20afe76390cf9069e998b4e00c06763d9ada2e8ca6c5e70e3972d120545ce1fca53e391dfda1932ea0f7cf03ac3b600a4fd4a3c4d4dcd48451db655225bfec6d720f8a90ef7736cde380a6711e38a85049685873b249eac757009600987447c882dd419fa1771f8a330eefede6baa0efc3f9283f2c8e31e0659c8e6efeba9834cd93c5bebaa0a0ba0b9184512949af27ce3bdcb8168a983043d12d1bd32519b3d08f2ddf2762d281f9bfd287bb37c9821b2eaa8b87acdc5a3dbe95008952f191bc1337396e4289736f05fdd1e33db490549cc5a361b99e186d5c3a84f87e6d339aa058225716c565fc96cb6a56787b9bfbf8cb66f310d874d56e504c35da84b42d2bef826d0fc045a78fd8a80ca68e73d6e607d76b198e1d4401550b3cc1ebf9a9b2219299942e1e9d5ab4203c5630575a8fb9f3c09889b7390835764a068de318309e3347d1f399edd81937e9f64616bc5492dc01f9bcc69a7610ad3da4f908977c1796dd620851dc4433cfac51335a927ab3f1d715738a3ec7abb08dd0cadeda7147736c0358674a7ad9e0fa510459caa6a85d80f5a338738846a8ce743463177455385c9f27f6fbc964bd3a395bf866e794b1f54b3faac3e6940e0dc72f9f875162adb3a6e3fe5291abe28694b73a08650548743908d7d5253418065658dd3f8e72d4665586745a344e9121f46ecf8b51af653d1c418ff21946df80ba59b7bf7bacb96385721723a957e9402057cd8225b1a7674e77e121ceb0a2f02dd6df85590a4321c923c7634cccba0e6f1a23ad8162e4f3b2917d340f9df524a1e1376ae46ad87e5ec543a75590850ecbb2ebc1a519465dec4bc27ce8c290771755e1570e38a0c98e3f735cad29de0f52699d9f2ac160745f8eda3da7d30a00a2970b85fb24ac55891c3695cee2bfe7f6b5fc6110e2bdbdbd87363df066bb141dd7b85eec9582d139760adc65503725763662b0020e00fe3ecc4ee0f030334cac362e7dfb4a5668e1a57d9c99062782e7f962c56384330289e950f37e8ca14d5d1a0e8beef65f2261e6b585da3840d667587d57c5a3f93b6802c9fa10a385c7da084b97cfee3daa1573e785811a99f0b0b84e31959254e2d3252025721a6d0520edef99614c77228d2e3a28a04738760cc117448f1b58e54a5f81bb87737eab76bcf5965864512ac8ab54f70a1625860afb68d77660ffbe946f9b045efef6bb3320bb1c319bf9dd04e3848572ce0996a05724413f06a7ba9749866194f388133f551d1ac63114832ea81fe12383e282553d3f79850466203c5f8bd6d7cab5ce2acf89e653d4e11a502ac96bfd6b435251ae62e74a0c3aaab27bb64925dcef691fce671152b4eaf63eebf561f34b0d797f69f3dc2ea8c30ca4f12f83837b6e5b7e3b958cae879773ff85dd9cffef0502dfc909325ca574e79cddeee5a5039a61a798b19da0665c0c65c4b2b3a3fb6706f87272d649857b540b5f96b85eba1dc74e47290964bec1beb39e0b66da807803184c1b21a9ba22625de3c4ef2170aed3f44034798509a49ec256d4bf2499778b59b9cea602a57aefa0fd2c0b753584809c1f498464cccb57305dd9d13bffa6172ffc40af454b64ac52cc29e3d607090fde124f6eac037f4d834157094c0125dc76d63b33f9a7b07d6ad740b6a669ccc2875fd821a5ecc68afdecaa3ca239b3067cb00f70b27f6dc78ef1c5b1c0334933de61c3dace6d9efa6bb90a4bfcd0efb705d079eeb55b5e6edb91c92e9e2188306c2e019887e64784d47207c8e24e25f59797c372f7f92ec41b9c101e5e7e74916663b0b7d90b4e26f55725093ecb4d401d03e7e4102a7785873ebb1fd76b2c404acf4e6d3ec911ac1830d7bf6b7f60706b0104b71b97fbe5862bf217395133dd3d234640c8311d7f8188b470a1abbee99576d0a5c8a57748378d744f0bdee0d2e5ddaf0d1b33a4c2a9c67a79dd76ff3c10f094fc0e5eb842efba54f12e2d81cd00b8e0e62d0ab4f63ad96d2a21d474f5ed6c451b57a27d11b1cdbf999f9a2df0a514f6fc6c7ebf53068177dc6bab3e70d0f593b4b07b4964d1688a986dbd04f1372a60ac2ee5b0c81ab4c946faab91e344c016650c4aad29f27e84f80554ace66390fc202ed20c8e0442d559094c6d385f08db0ca373d11cd296ecf25b9ca1b89cfebde7ed21b533382cf9c68613e2840b9a6f443ac49fd8d1cd7933069617e0d38f42455bfc82d2b757e13b1668cbb971ec03f954503a92f86ef0c787787fcd859117875bb41f55e1e53d51a0474cbe38d019b7b60a3550005131c366402df926651bcc85b6305d25f8ec65861c847262b25dba2951eb292456ac243cd980279a063555d61fd3197c6efc756f73066ab8dd8574d3e08acad8c5835ed0c9fae375063c420bd6a1d6e4d88c7035f409bdcd4fca6e00bb805c2b3317a0851fd8c329eaa1927901744831ae9ef19e7d14c1a1f990ceb4426149fd31cf7ef51bd11b176fd415956b55020ae79b810bae21202614999579adf9416a78352f5e8c53381fce6c7f08c17f8d4ddda2d6d576976df8a91af4ccb0f26c98c7e0563352e6e60152b6283d9b2259e1120f3621139b2c833d64e0779380758f0701c0480e8c0e876f0b6e399f1f5d61dee82bc6e4b5c24a147cc6d6e59be195a90a59adc2ac971dc7a15f6a31eb24c176c0dbcb42c51de06aab46953d7a1f063362128fd31e6108586210136e43c886e0f2e25b741bd20ed294cc32004e97da5db7c4ff08df02aceeff222534ddf3f8d9cd1d368481f3945b72d651c6030cb150be789988ef1cb46d36fdc7af62902afbb66c0fef6bc40561fe828117fe3d29c5196f22caf9d4d43ea33e5e254d60bc97a125e7f816e5eace67cc671071ff6acc0e64846428ca31cb77d0b15d473c774a34446cb15b8b524a5b2f619e9749d0de33805df4c230d9eb0f9aec17f04aa58c9956814816200da9053fea6942b7249ab3c7ce8c54b214d9e017c971142c65692338925d07560e1c2fba6d8644a12dde4d63f7df5e0022ceddc6cb06d409e3f163f982cf3eec0c33b5107fa799e2aa1762ce3d19b3164885f1bdf8edadc4ed59a2c7e3b1029b74a9a5ab0342c5f1142e06de40aa4c6a4e08ff03f9ce6bb848ea2f989fdd2cbdbb83d211ea60d0c2741ec07334d92092f91dbbf77b1791cff6453d1f95c42be1c323070dcc436184bb65106c56952b2e9e95a07dd68a92ecda8e4053c995914bda0574e4e5f13c29c7ef335e2e2147ac5b9c349b4ce64261ad51f6d775d83997f04198f1635d6375e387280f3bb6a8dbc62f8e0d0285a75c5a0131d6c5edbfc57c64ac40fe5953ce8a6ba4d7f843bae04532e42b9182e3dfad5d2995c62c4170336f06b17bb00dda67eacd3a82ae4f6506c9f12a046303e063db1cd6c7bcd6a32167e4e63ebf6225b9f668be6c9b426c1ebf4629d8ab7311d3a067523ee847c35a5f4f97ece9beec7318d4c97d25806d991949ebeb1afd04e12ff2d5fcb09e24bb80f7e92cdfc6194718b0d6ffa2b9ca0c588b2023144ac4f8e38879e24b188e73c5cf68f4997661e65c3588a94cc7063724c89ad34668954445cbc13258d7b274ab4aebd272726b6450a01729cfb94d353c42dbc1c2ba41d04ea56c81f057ac44482f6b950df4cd6134ee7d9400e8af1e019d690da532752d0bc5acddfb22e21284f30e4b06223c05d9ff431cf0f7c85369222532b88f8033b31c5f53ddcad5d2e825dcdc4cf70f54376dadba4789c873fce59d2839f504a0c052f3b20cecce86bafe46f5de1587362110a5e731799e4dc3918113aa33f8c2c6443699b800587000218a8ac08a166027c4f0eed1aaa759cb97439792ab465af55341d92e5aaf710c96117baf49bdcbef2c15affe009902e7bf842fdb611cc271bb8c39986849b570d4262e16c26b2632b7bffaec4593ea75504568ef43c1af6e9c510123088384d223bd754879e0f6d6f7eb2ebb21baead977216f62a576e65db4a4f168008edf77fe1b26da273870c51a59f10374d7a9268478912bd12bf1a16b1e22be62c07178116b3684846ed065ca33aeea1ce09ad7c8d5acd9ae2a7ee64d6908fdfe0aa876fe37d90c501d77268e4efb28a725806d533381c9a194c60eec78edc45ee9a773c0667b70793a90d72fa525d8ebf2e8bc0bf6a14e58e42b93cd33dccadf14587c31f3840afdf431ed1d95a67286071d8196a4ca48fc70eddf84f5382d51fe334490df2da67fd64331ca12461fbdd1cf9fff0c8fa6d9dbbd166335b60952ef354fd4fea3ff3f60c32555f952bf56b46eea0ce1f6b208d79e409dc57f269e084ef7ade0e394c3114377d6f7679d0bcd9395682b9b5e01db03d6d4e93becb8f279783b3b55e523c9ad0de42d4b084fa013d2518299ee14ecdd04bd533e385df65a912769f4751f511d086ea5e1201a7f135068f8eee9a944ab2074193dfdd2f345ec671ebd2c139c6da4b2bb235ff5ab60792c98f1b0306f7ad7ad1eea113d06f83f3c1d75ce0e83fb3cd9e22ed93e34ceaba288c4a3930897c31e689dea45995fb6801574b8a2227c76629c5d06801157cc263b8729d555948d57aa4a88440196fde379007d3b501a3288136ac89b0300ebebb43c21d678286e1ce28f52b07e8dcf5fd5127ea8727badb46eae3ed45dbcf1d720e34aeaa3f5cb3355055490e0c71b023aedcdc4ac7dfe7a0bea2176cc040a04b9ff9232d2fddad048160790a4d797d955ffd4c76118b1f05820be5b3326e7e19599707d5fa5e6a81462750ece6f2855a08995eee015202941de03c0642ffc19c5fb48de3542cb5aa62f3eaecc6592348c2cac6a96fe883de90ee966f348f2cecc7c8d7ba09f0fef9d4ff17ba6d705d0ecf88d3a778a43f4d398651130f05847268a2b1179d17e11e5a201d128c838dc7bc40d7c7480834207c80475839d7bd6c73880f9dfa1a850cec00032822976cf787e2c2cfee6408612267e0e0620545d388d9ae79b2c591ed243db0b2c55730ff6753a50f79a2857fc4ea1f85702ab6c0e10cd14f5e1651b0bde3d84f929d75875070f13c8e2f131fe60d876524c604c6109687680d526a9f1b0e9da160fe93994a6b5da8edb8ec449b724e44c5f9fbe23b0ff61cde829edad4efb50c76dad73e16398d44206d7481d189182cdc1251ff8126d94c17bd020536255fc5548ae8d36277e40bcf2bcafdfbc04075719281040d2687f4bcb7c2f32d164963420649e63cae15ac748fdabd2731f215b374f35005b576040ea023a3080a411760887cda9e4d1f85594ab9079336a121042410ed18957eb95107ec2db52e4bad96439c433f2e7a30115c6bd5b50cc78390f87bae42dde57e49f0c65ee5671edd3c435ca45d73155dca5d35139b4ee1501b0985991f003e397c388e3561338b1c082ac9594d32320aa7aa5dc944d8834a952d5818f6d43798f23b254d52517b584cca50f245892681d432386e874bff2070d1d3faabf7448efbccd9819b84049fd95c3a17d6a26f1cbad998542af3350433f04d85491afb33084da1f86a710f80e7de6748880450a2e3127a1a84b50520d1632160ea9c024576c6dd4bfd63441c0af1e25c47157c1fa2675e44df1ab01dd72b9052ca1dd111316d2e6cf0c607d86c519c6a60b99d8485100dab7a93a87f31344090e2e07eb41175304968eae7ab37a5eddea8e509b48982737b074a94704d7f672e081509b2c769f134db9ca6347a9ca45134595c0b9f52d17a113a53ed64f100c73eecfd0ee1e14f779857a86dee251291ae190d2d039ccf460f68c3126335c4f024346d196a77fb53a20189de48682bf5a63438b400590b4ed2fcd9272e42ae3db695f706a95cd16e60f48dbe522619c1a0a57fed2fa6de92540d3a3eb8a3b3a54003b50f92963db80362b5a34c177fbceec4cbf7adacc6d5aa5120273032531e145545137c0f7feaa4ad201eb0a94abfe6bfd02677f7d13a274cf81aaa233b27ba601dfa15a085140235a55ecbcb148af9c9eaed8634bea88626ec88ac68d163932a78f63703843c0bf78bffd75970abde633c3869119ac57089533426e7a1df368d7167e89b07bc1d27a2f684d46107bc24c3b2aa9f61dd1ad67015e6956d169fe47817f439bccbbd475087f2f8b0e8e40642219e0eb044074bee922df9de8250fcabfc719a45353062095f0966f359da9ca3d44101e34654c62d66901cdca5f8fe413ab6a18e2490ee5ecde09795f07b7bcd6e993c68cdea15c38c266ae9591ee8f7c4429834e2cc87906fbf89bf90ca36a5fcf3784ad26e1d2d148c47382f291652430ba3518a624e5c8981309f9508d685f2700a810e622c9c60634e072a6bd9b68dff2197ee9e4f723ba69fca75edda9e23481e862fa482d1f891a8da61d0c823889c808968d13c3945c39fada05b159b055348e0b29a7d7a24f598c9795223868b0a647b0a8f5178eea0cf102ae489984467d78949956e24fe13a3e35c2abf91f678fafc3f3a58b8b6f700e1f125088ad18fe13047080914aaf8e6ed47d26a62c38f4b9ce9e61788719b0111e37966e282595b3103f839dba4850244b532a82c65b273d8023e77f9d100549616f2c1340c468cb8d82c8bd0b7c5b09cd276e94902740acba240d531cbee330df29e3e8ed4bf4329d673e8b72c91ad9e397a009aa6717fe713847e9a4e9f25f64579bb14998717bc0c0fe56317d14356a1f0506bdaa912971da3abd203617485192017bc99f8aa4fb07e876d5daec48c49bf7a378c3fbe2517f481a2f799ed9f71125142d04e8e1b864ba3f466c15bb1f1aa677064b856bc536cb8ca01ebdbc21df611e9c2b23743153d827e3cad1e3903554698a6ffa06442b45d9fd75c0996029778d9c196e3cfa5b4d4c679a1db978f5a754e095b9025bc79e3fff40752007422d9a2e7e56e3ef95e26d3c90512bc531c72eb33cbb6d52aba5da169b92e484735bd717856c16a55900c332593750d1d9c2eb352d37ef579969bedf30e178a4233cf3cb73b5764f392af29730e14008f3e84c285ed7b18d78c96f71abbb4bef02075999ac2116353a1d21bb4938b0a306f2a0f8adab1ccf6f82115712ebfefc878092b8651d79a759d3fd39a2da78df50e3223132f49e7aa763fe78b983640c073e446c52f766ebe3228154f92e8220f93d650ce710c5463b617bb3f5ed2dd6e1ff0a8cb50164b04ee39b061d2e77bd996fc549a6b1e315fe9699fc50101a08491fe3a68b3e33bbfcf23845808db564fa10b29a96b0515cd30635e3414f433689650b3cf83185b98c7811483afbd8122d855c8909332139fd20fe0cebf146fdea8aac5f523ae9075c5577ff08c808f32243be8ac65e039014cd48f674230cb3b7dfa63fe88138976de82f725fde192ebd52d584f147eddaeec1c7b1402d2c330482ac56c8c7b8808c062a3a9105ab495b29d78b2b9eac826d3d2c8f5ddac959bf280c5632863a5074fbc01b4a90b68d990827a0d5665ea13563af5b007987ff41d0377ff5121795abf5ac10e27aacf8cbe6017fd12e5bcc6ddf7ddf62f336820a5c11d0f7785f26325803b8d730ca992ee986582bef98c0ba7c6f3e54f5993ff5e29e1c8a4e42d65644d82b751097d63cbc3c49474a805f186ca641ac1dd7e32a2086308b9791d7bb3b0dbd9e56fdf50169072eea594ae73b548ee0d6bd50ca338342d98deb405d6e498cf605425dbe4c6bcb0166f4a1f3f12ad09b67961615c1b9ea030b8dd18a36ccff1859e68ba2687ab48c1df77eca76e5b4edfa363e64ae168d1b72f17fae7dc6bc36513ac4fe278348d20adca811e1ec9e1029d1492ba844c84399763530bda117311ef448e4396eea63325add42901b184df171b83021283935872ac671b2f1e0cf6985feaf86544a01e5f08af051ea9d03fe1e0795d9a853b9b9c017712c7ecb137ae4f8ff5d392565ad939f868716393709c7ba5c3b61ea97abdf5153be8d2ec5872e0c97e577ea1f5f3a79c7cc57793af6805b1ac3e58e47f01cac6ed0dedd25a61b14c97596110c7ec54f65bd56170143325c907a9078423a2f15fed57d1c31d8e8b8a3308e46035815030a1dd471f5b5e6408f96ee6c1c0a379c11501e4a1427d594d963386ab052b5848d82ca3dd87e76c4fc82f0138d071f654cdfbb0d3402acd46a9470aecacc5a8ab60f6770ee5f8e5279c2d910ed52c93019d2973ab98d0b374ff07119b7f259fe5eed48f042fa1283d4333d30362b8c29d79dca742240f8a900cd1867c2c657a5fdd2958c0bef0d4ae8b45531ac8a39d8fe81d283009cec795d0621fb95a093d6aa916d0a078ae490aa41fa8ea6f44b640c7c5de067aef6b722f06e216fd515d1c5f8baa3280bd60329310d0fb6ebd0912f0a1fa23faa76f4b4e1994e71bd61dc2674bbe058cd388faf22c1136a9ebecef1cb61dea9b68e659b7d5a26e5af05f5b87ab2873e637cf898d8330f59c2d7cf16c5ab870edc88acf96f03f174f46bf30a3f1574ebb21fa5a1f60dd738c01d868e0532eeccca60e34efab2ecd72a39c10ceb19ce59926d3fecfc37375f5d42816b6fc193373f36b5753a88363719407813ccf76db6170f54a9c534cfbe2767aa3fa05631ab1ae8fa9cb8b194c0b9579419233a89130419010e5e53b979f29bba07b209bd282492cb5c11078b580411c78211ef124e4e901d9e9d56dfae2b2e26111c95c6e36514042ef2f986738401a1f86ecf65f66e1507f55628449a85f32598c2e8b0ebe64e289fc7f44db378165e6afaaf778592278765afbb4acd0d79fa3cd2a3a81505b979ac07ff2a217e5465df3a715484daaf9e801c0ae4e237fa0fcbf2ff34ed26a8a634e0f2771db80fcca5d51f04d219d090cf589855da14779ae6fbed6c9415d9fc18b521aecf3be700693fdd7c68c1ef8103b577a6ce51f3268720a3eaf241d030aec4e4d0bc2c3ef05d31c6b9ff830adfd7449f61e62d1aa5f7b8b6248533f232b4453ca21a1ecd0057df8dd8952c8596833ef735a97df3f21f5bd237a967a0ea3df1e1a2be48f02909749279cc69c6a4856d4df6f3f44c67dca73a37dff7727aa123c34a0aa6d415778ebfb45457d2556846945ddeca9b3e99df65f5bfc196609a971fc34f16f573e13d70bb51dc528a0f7470ef2edd2f72d50e51112e6c48bc75ee88a2e429cd9d624eda54f170a3db4a98be718980002d050be08a61f0495b4608f88d21420a555c8be82f09b2d042d2e64ec7e9f6a87c598ef4d2759342c57bafeede026074913a765bb1e625e8bdb05cbf9f89271847ad171ace169e5c5552b55e8ea961afd6048ebdef4540a800ea50f7ad790237cd474ce37b0bd188400a549cdc54a67974e3802c62e41be9df33762868540f6ffe2c85644b906c27463b40dccb8f38ea0d13243ac81175d78c21ff85bd31612572819fc7acb75009870871ad1934cc0bdf87826e225582765ab39b72e8cc48e4cacb97a039a410d8fb41c45cd32aa5df860ed325e73937b8ed75ae8314f43c598a2a0105bd2e93fdf03e91fefc0d22507b394f855373bbdb1feec38e6a41658017151c0c9448a93e9f23458804ff6cb0ff7395f7738243d74971786b0dd918a171072a7d14edd25d6ee4bde0485a9ad52bcc24df866a3258f0e3fcc41283ace3008e5c727fc59270da6fef32c5f24a0442b2637d4852d5447650ea5c0b02211c51f2a2d29dc498fab5cbed24b9eb60eac5cccdf0f572d59ce516c2f5fc5537c57aeec7ea9bfdde511e5ad666bfb4044238d9274f5e65355751647100d136533f4f4a17ceb2172de676b0d3a723eb5bb8dbef384c63f98c0e68e3016c8ff774be48a31a0fe4ed9696d7caf0f50453598e6281dbbcbe002349fdea2bb269db2479776a5cdb87fc68eee3af8891c1f105e02686a60b5b87370c1ffc46661d9efaab23abd6d75e8b9a4fe3d50a45b6246f7ba8a1d0bc77fdae131dc5677c51dda3be53c371d13c747ee2b6d9791b208cdfc347c53d47559b88fff39e3357d96629775d7842ccb66fd672e6ac5a982e7fbc4dceb7350196b1d6bac908d38bf7865a26806cdf386118b01e0ed1ebf9dafb295bfd405f41f9ac3412927dddd52cda2257fea3defad48550814359e03c26c9c46bc7d2e6397010d246cde949e2580625bef95066383130452abc7961139962e341816873a8fa1e85e01715f70124d4f94ea4f3f6b92f7e1556c20185f97f69cde6cfcab797f9c3a6c6523701cda3950c3c9486306c15f37e130613269cb59f254f259bc0634c45d21b447c450d9cb5433bb90c88780a7d3be6b3125c7dfd59de439711c8c7ef6d75aa38d5391c41567d3e23e967c933d754ccd6b404033cb1d1c24abc78c1ca26741cf8d5a4a1c81f4ed3460534f37711b7f7fadbc94c1264e18d4e47fc2e8afed73a271b029430e226779f8737ad5e76751ae1123a960d9b0e2bdc94a6bdbb523acaa1404ee20e97f601e39457913bead806b8a2ec31d156d408082bd6d774fa6a05ad45a365ed2553e5f148955b636c6bf01a34d20fa07070d22d178e54ceaedf0bdc334c2f29a429ff607f53aa38b99944c1543dbdc2da01f73f443e9e3c592440e47bbf080220f58d9e80629a5d1507f01096fa6570da3967120763dcc2c410aaa99579639074a06e39f1a20f1dfcde2f9e03125d3399059f6497e618d655f8c8d0a9754621faebfb526f805cf8d65590cacc6f8fda203faa6414a83fb8d6accec9f05116d8114764e5cb01e0ad805bdf01283d1ee60dd52e3ae70d66e126231dffdc69630136a9e76a822b50f2b182d460fc8d13f1624b5d0cdfac4b7885a403ce56d419b2e7864c4e3c4d05d3521ad3cb550de021851f7142067690bf4edd8522e9688e5e215463c24d64fb66ddddb0bbf6a54f7c6b9d6e801bb04191d13ed4990194d93a49cc376a367491a3a0f69b0a562f7d66f63a6442c4681c0fcb54d97aaa5582aa5dc5e15d073f03172d1a44110de7286227580b60b32b84ab3e5a1c7cb4013f400430646b92ad1855e62ef5420eefe6fcaa71af8696be8bfe92370979456ade7b166568aeda5d675b8d7588b9871e5afb50cf51319f813b0efd1a25fffaa414f2355e2e78131e5b25252dfc22379b834583bb583e6043172b666d1346a433c2d6ec9971ae603083b5165512ccae05756acca6156537c64bfe398ae5b1719b84480a997fd2922502a81548903f6c170ccfae0e352178451aac54df30dadce929d1310c682ad4a5fbb9afe37a7b5f44871caaaefb34c0a30693b68f41ab542cf87b34e5c33ee00f734bbac67fb1f9689219380548cb8e1a0e29c25afad97f24bb00067f974e96f9221a1fc30356d40c15d34f9e9838692660ce413d7729e24ebd8049a9bb8ac546b608d388429dd0839d579d59ae1542da28a35ccdf97a555465c65152e5ffd6cc25b79941c64a9e08690acace936c42bc920621e929f19da18ee05bb806929602c1d12bd9638558397906214204805d43d83b82aaa3905cc75f416f3d84cc507ea51416e9e35f72d1bc90946704a764621bb82a869405242deeea42191b28eb39eebb24f411000934a3c7d158b6fe87af34bfc3fc5cd95a88686492afc5024e146dd46fc5b565678d30daeafd5f1f591432bccbaf151ade4e9480b78fa81c4827d5b20d2332a9449ed3fba277208eee4a8bca5f120fbec68eb3873611efc82cc73173fcf331eaf41d22df16248460fb1fd108cc4fcdb988f2fe4d52c76015bc857630860e22e2a02232fcd40a719fb474fed037da63c275bb8be2e99a58910963b6c268240b7fc3b8becff4a3bf860aba5ccd71b4232b1377b015cb0ed79bb89bd0dd2859ad93bc0c76d373530358fae97d745e0e981ea60cfc1273c5bd7e34ffa9d0d0a4e3bee5066a45fa482a343a6b511f119a2e547059e8f8e8c5a6670e69a67df4954dd226ef79f4b1c699e01a28f23786d35ce9db3270b55fd56238af4c6d0c8f2f3158484ae21a20ccf7a51a8861c00d53229f1a9668ca496440649ccf1a359aae59dd37a3dce713b7b48e857dc24103600ab1ab2ab485838736b5a225260db92658bf9530be07e5ee80bc4d8b66859a5f7972e4ac3fcc5154ba76ad72f5af84a2ab55fbb8ee8fdace07ee60d6d7d6006bb5a8e22c41e23700ac1d79dbf6eef5003b507753e586c0abffe4c6a27ca62beed91d9fa55e1ebd4614b9a835bff411b23a8bf85719cbbc2ee329848a2639c0798517f1be3b05f05d42ace06cc5bbf47319ed9e4132b8d9de8a1210306e7a935e6f0c6b3b0bdb202a02c37a42f777bcbfdb3d5e619cdd80ab192e4754c5b7739816d07bfda0f0d8278f02036114c59ce8f72107884f7d1bafecc82572097b11b65a715f9a57779dc5efe0d6ab80edd5da2208db74f3875d6c2565628e9a14f76d1aa51e15730a186a625f1fd09b4397a9b95704e24a97573e419ddb7b702a1711a464f416e53f9470c07774ce2ca96ca8fa70fbeb7f68db70f87f999c077717c64b02619862f391ed22f225a508572f0911818d2ec9cd44f6f40434f7dafaa0106ebad349ab2c4ca8f7e851caabc948d50f5e6d0a31ab21cc479748be610527bbdb08c5d1a21c17e3249d6bd62453739309bc564e37604895982d7333718f6fffa45a7d542487bbd800162b2bd2e00f4d5f1a5ff544d3d22b3abfb111c59a912fc1846626d632967a6bea634e58fd96b87b62bccdb0f6985009577d9e400973cc54b6bec062b225cfa39508f7c4b19d51c441c6d97936801c865024232a59dac4357c92ef610d702420babb642e6b3c1f83523463101508fee060f9bce1fce8a10b534b301a2cc236bcc20194c46ae441d39bd8388202e3be7c56ef764183352d4cc06e9c45ef193b925df9912766626469c1b69249e7673e80fdceba3d91a8bb898a05d563cd8363d9fb83aef2ff9f24af5a9b2d9ce2b2399ed8d67a2240974c4b1685fd0eff09279645eaf7d5f9328fffcbac13e8b29567b6e19fbca853f9fd107d107669c84c39ee44d27e7238b3c87606c2c94df90a3e29e9d087ba2042553774a2e4e6d709460ce045c0ff1e96f80da2418546bef7add44adfe32d89cdfebb253a59d5f06ba5d3c72422567bd68c8e7c53ff47a6ae4de873b5de71fe42ecab349bbb20f45bb0df56cde3faa5a93409a3a8357f1f8e66ff188de6aa2cdab7cca70b432817abb0a5b28363ca6fe2dddf9f5e951f7bfeb3c146dd5db2dc36009dcc8cc4c2328b796ac46b170f7c288717dfa108f56638c6b2ca7980d62424d0834da6c072577d75fd3862ccdc56b11d09b52b5422e8ed370d274acdfe2f5e4910c4ecf2da8d5a453fde69a6a0d5c597c8f74590e321e96d2ba1f88806fb22b044f2eea4d36875717ab405ce0836bbb457cfaf2fafcb925ec63e7cbb3da53ee1169b7eea607a6e80138cfdfa6c7f8449d351ecf9bd91c3d83ebe6fbffc62d193e9c55c6b65d10d8aab68f6b8abf6804cebbfa37a708c4c534fc89029cb94c0443cd1bb1849af8eacc7d371c279797c58f479c5ad6a8902ee0d3f215090aa4a9568922185e2776b1c17d75c6e899bba4085d0597c1605227aba1fd6f313a4f0c82bde3866c521ea015aeca474e446ed17dcb1c5cf58c9a8b355ec7278f3ab9feacf35a51fd8aa5d484b064c745e29d83d175d36ce776ecd09fa55f991cfc463204c4ecd04d7910f4477bedf3529672f75e41d38edd37dc6d437a3f9bb3abd7ea52a193e57687589dd255893eae28e94b5a93e381be9c9ee2ad04be0cfb20491570375b34bf89befbc01256d83b57b2bc47cd6cfef10cf3d87b8cdc9521a0de0abaae2d75f68dccb6d8e3a36bc9c1a4070024d673da2c3137ae1b313b40545e9ed39814b85d39d54c9d28a381bd9409a5f3f91bf0aaac1cf17402cf5f31fef0afad34fe4b3af34dcc1b6b614d3017073dc3862c339b354efb8853fb76b5c8bfef1ce4d5132e4440bae791a799659fadc44a7c23408344bb27c9df81daa86e7ba1b366605972006c411c105bdd62e72250fc6b5dfec28f2e1421d684c9be7652a2312adc6d3e420692a763d40ba1936a789b28731f3c27edee1ca5cb6fab645ac0ad85887f7a44b958ea561202599d15d97d89107a15087629960d2f9f1e503ba816a0d41ec7115c967ce3211fe9d1663e545387d6363f7f8aa9e5d12796a99ebb0e558bf8379a37d6488ce15d0b8d13bf8922804cc78e7bad605cb58e0bef09812065c6a449c4b6417070ba9e1faf4edead5bb5f4a61ed1eb4c72c23df4cb13d35ce89cfba43785251e805e114765e27f2d33d9857a462671359ee352a05d362210a977fe753d04d409c6c1a6a185af933ce71732ed9397d7531409e72cd1b69dc5ae46fba4296afba79e036969d060c15fae76494bc2c1808e9a99ba7f7b1894e1e188b00924d79e06a38a5cffa4040e446b5121fbef777a8628507e36e2171f921524ed9e2309277116c83368f4bf1ff4b98dd76b00a7046ec2bf84dbf704dfaa9ec9f7a85f2f9081278ba7e05527e6df2d9e3860b0efc7cd05007c399e93ad08e1e0e4cae82be8ea774bb8838967fa2a1712ec180c97be3c6849a4192a10722d56347a3db188d70fa0783aa1b49bf05a94bb20a545d5c0537ee7107fec76f12f696c35d2c03614250e1e625e1d850835b417d5267912116797eb8b6909227ded13b0762b99bfad9fdc87ccb9044d662b16898e13616b213fb56dc87ced827bd7b5315a81b54d627141665d8316d9ee8a9258129d81f970f7fdbdaeed43397f9339a6a7412be987457ae208cf57de22e1f8ff808f8cfbdd88f77410ce4e7ce8afbff8bfcfb17f95bd22c5865a895c6208bff02c8ceffe53a1670827e1704fce0a092e63b28315f5a534ecd9af7407be0410b0358b200684190dc65a1dfd479a0bfee348d5da51fb84a189a34c1499692b2894a636c4f60b443d1d870f754f47941c36e6dafe4633f195d2cf708606ace0a367816be9125a27fe74ba03dbf97edfe40f190c65f17693fcef7483c2cc82194f3535b9e0571e361e156955f5ba432ca2239aeb22cad20d39c89768eb5c69c179322b6f73aa3342625dd85478f59dd714f4dfb00ce4ff04ae5dd4ddf1cd078893cc7363cd2520350ce576eb14a9d0d3cec8b53458449b915d830129a71d774305ef408d87a3d7d6de9e28278d23e7d94902d9538f832a43e3a194b5f395d934e7faf013c776ec7dff14539066355ba2b19edc107ef04d25910b1f65196afddec735b66de99475ab4f243b5467ad5d16a1f7903530124b3b6695d2b3167dbccf319893ebb1fda1ba76973dea41f5ef6195cbeb6b1df659f310846a2cb3f7eb03d2b1fdb0fc6db1ead09e2523d23438a39ffd2fe792f171738881e6b9ce0c5208391e994b5c0f4539e9198f233d7feb542a8cef5b5c3c3df0da4fb70b60b42007d80ef6be560c468f2af4ab5a77e52ed70775173c66efad978a5d1b272e60558365e4e5cd59328e9aed4f06d553127f24ad405d3b700361aa8ba754ad65b1af4e218e461bda9e8092fd0844f44d8dac1820980560fbcff74dc04044c1cea62d9b2bb4d9694b1ef88685941880c3aeb16cdb62f8c741b71dd2fcb67525ccba96571606d96ae8137413f977aa665baaf4dd701f5ee5397d810bc30dc5f810bfac76c001542240d381ba8face96844bfa77579f9de21703300cbfd4543e6e18319412e9a565969abac547d76c02ecb606c8a7562f032f0f858960ea375aa1d48839a03570876d59d2dfd5286537285059a257a60bc430ab42c6650d1b167bd12835cc83c71cabe76773b0b12ad437abdd1e3a7e11e07f490a2184496b1aac0964883678a76a4a80dd644de1a75da8ffc99017f132bd8cc0e863793c624c4ba10b759ee4209aa5ff8ab78308e6c5c9af0212223152e8a6cb0f5956288638add29ff2e2ebc22b56b674775bf3f5df6d05d155f252d37d0d857aa0126e22ab8937021fae870e338a47b1d0bd454296035b53ce24eba79c2a15510bf74c14ceba90e9ae18febd5e69bd81848f9cab4939db508e885a706c29774d2547c32b17c1ed8bb73a6ba47bf67c77ed23854196943901572e82caa89ab3ff2131f192f8ec4adc5fe23fe20207f7aff43f1513a6989ae298d6dc5b0cfcdf10c6a0a7aa394a7b969f327a1fd5ca63fde99bb6f610ec0f5f0916c91c2e7ed1f43ea095da8d3a90848d7109b648c5bd95eb2c930868d47f617ff988f4c4168a255150ae8f6ed3fdf908c0697b5bc70526e72f73b9e97b6bfe902fbb68499efc436f1ff4793951c67b2bdc87e4999c6572b751b30c88a4760450a14c5bdc9c09e7b73d60f91570f4b41a3896788d817cb0b7310832fe67e4db6e9ce0dd4e233be5e8455d40edb86194a6a2dccfe15bc5087477ce0d570a87beed457f771af8f63946028d1fa6471e18c500ea46b2ab0a613cc6e3b5617ff421833d2a98738adc439dc1980e449b4878cbda8db3be372210295cf05459a4434b85222825728e91508dea4c710f4feeff4654b5c2b225bc32381a9c402a7d985060a718221b0b9e2ce32ba2d4976af7990b04663597586d85698b3191eacf4a0156ea38cce211fb7adad5b83f1521947bc3f97664aa1b794dddefe15cc053c2f3323e6ad53087713cddf9f17dcbc1b54b851cf2bffeb00312118b484f68a914bcea6bb3951d5b0825c75485cd49c2f65a4a0cccffbdc8671a35c064e24668efd76e62eb48ba890b41b08706de8f1120d0be84675bb9e4f49574394f1176a67d4b8bfc66b9eb0b1472f6e12e05aeb060a278d892396211859686bc70692dea95eeee060861741ca59f543bdcbbe72da283ffe0613391c0dc3592a2b9a0a2fc5a4b4d6694c86e631cb6f5f5af080f10ec2ba3495a5177494ccf7966fd2950c0bc6719c5af0dedd2a95f0c5e0b80441ca669261293cf380afae85cd9692812d6bccd86eb3b1df74bb577b6d131617729541b919c9c2aaa83e19b022be143d17c75859c6d1b01b83f62596f816886698a0f5964f6f957e8fd26777ae850fafdd2d896cd5c85e9b6240628cd41b48acd78c60e5b15644e4ba0bb22d4cdf78d2a8e535d5f6749ee151d87ae86833e1db25eff1e097957f2ab257657eed9828f17f5e995d30b5f9f0b4b5bd2e4b9a24184bb4fa6dbc5dae43bf842fd0ecea9fe49dae2b5777f9e98c1ee515caf540d9d5e55ec3a3e8402047273cf957dbae6b52e021e76147be7c4414cbd3e5f8e2aa5860185128fa111fd011088bbc8878da9d1b74fff099455d017bb886c986efb92ff56f832ffb16a3964e100efd3d34a41bae86c7a07772e497a0b61867630835f7a7312f51f48fe6cab1bc2ceea0d10d5297e41a25e0e919f2b20f1157c2642e7bdc512beb79150dcaee2f7bc000ec2d5d5bb00d98d32deffcc7ef9bfce0f5fc3081bed107083f832c806399b5ec396aace51f58b2e3540e844f11e28e6f33201bc47c4c6f43f0922d617cc7cbbb722a01c2254c5d049c33bb5244b510e68c464098180a57208b8273c121fb3609927b190c1c96909e2aca17cfa6ac426f25a1872744afc14223069af7048d947597d3066da779d3983083754e717aaa93b8db12275fab1df7efa48e915dac987cc243a5ed6dfd8fedc4f54f6af07e6690bc4fef9956c4f8f9d137a1d077887566a5bba02e581f9726d42ea135d05a82b8314ce32cb064b8d8892e5498a2530c9ac6aeb8d402aa7b6b76c185f54af5585ec11fb429072b1a1f41a05322f265defcd4f74d4d88deba1c0c6894c838a4b20ce128ef5ada69d5ea4926f65f6e507e5c81a4ad761ed09700a198c8ddb964f3a43bdd7b32b72fd99ac68be6ccf2fad80257c99cd95e219abf81b46a91b859fe2a959c284064db13c6d5a5b9ca67a466714ff2eb7d297e09a42cc604e82a60fe447cfa32f65f4798782b346fb10afa033240fa749e115f42e706567b80f718ba670ced166dbb55d400566d1170ecd6d92dee2e368f5c7c6cd58a3d4cf4dba33a6c14dd6eab2db854f4cb780b38383639cb0d193b85465dfb090ea194d518189fd63e1e9847f0bf730ecbfca404763dfaaef81f6ba03a9896224ceb2008f0bba819798010f81670d3b9860e21c80b39f0eb40e0f6a4138879489eca2a854fd140367b3b1ba1af5cd182fe503fcc15bdd5a9edfe6d76c6e9cb89ffe86d78ff9a02879b4224e66566dccf35f8d963ce3d95f3d0f225d926340955bbbd38a7ee6ab87c2002c22e8721a7110613a711bdb72b10207504e5c7542c815fafc4136f756d26ab5bebb49b2abba6575d5482655a15566ad962ea80d301e85b6c3e761915f901ea01970269d52662bfad48fd85032b839f1cfb3281983e09d63e631de4bcf560cef79511c75d6d7bd1e4a5d997e2bb9640a533b8a425ae20922f4f2fb13fbc46feb3e513edc3ae90d68fc0c46986297f02075a375d662810eb73b4eb428a70f1fa99d502756587f80b621c59dea8f1e90dc40f8ebeefd792a42198c2f9fe24418961e83b7a94399df8aef91a513ca1bdaa77ab4a9791382415a30e34d849798f626fac50a154ff1393a05360b6136831aa9f548aa610fb2c9cb553098a3af3bddb5f87f075706127e10c6dbc6c32ad8666274ff593a87a9e2acc4f1abd92cdd858b996f66eb1cb2c5faf7ad10a999cb4436022d3592074b78aa23f5df7f79234fe9470104cd779bec8ce8455c0649f3fd2d8dd2b956152984fb87e8affcbc31e2af287b59b790189c86f8734d8c6bd3b550d6aaa2417284943d138fa2fa1f6811020ac7b8d7f11e8c81e816b8100acea7c35b930ac668ce7c73b2e741749f8c1ccae293cd7c5648f934ca869d0b8888bf3aa5462e79a2b1fd785cb0a028835186d4569744165d6eedda229ce4396725a2792aad3fc66e9a78b5f8458506e3848760d8ceb9d04b8f46c27b7294738a94b31ac4aacb54e10f47070c9f5283597c9f160a799a7fe7fd341b36868a1c62a1c981cf78864c03abab43a003fd8772ce8f933edbd2308aea6fbb96b8418a34417cccbd60894cd7576acccf4e92eb203e9e5bfb35a4b6756dd3a3f63e25d2f273928c90e6512a92c3eae08b56734659c8e313722cf78b248a7ff9bcc6cc0b87b93e3a260f5d9d1c4910f9c2bf0eb05fea4ab76725fcb9c5e07fa3383477318e5696349247d738cd65b58c254e46afc44fdef6cefedb75819ad9f83e8f696eb6659e7c2e08c346ae90b94edaede49916af9e7227a8e0a4adb0403e2565b616e035e910627ea27bc699390910be452dd0a90219450a853d9ea147fd8e60a271955b5dc37ee056cb03948aecdfcd20a0ea05d9e0a2e3feafe33b5990ab68fdef6d9a47f857cdfe800a47dd87d0d2e803fa11b4ad2276686c4bc3f72e7a9809c3f734f3d073fe2a94a61141db626bc4a7bc1bcc852c85d393c75ec77529157762be44cefebb4d40317a837fb4b9ba830692f5abb1188bcd046b5a2b3cd7f237fc2d085d92e0184e64fb70debddeb6e3d58dc614bb7d249a9a1613dd1e30d415f040b806cf629d7174836f8ef4d6e291770316dee66f9a4dafb8b62419545347de8f1fd613adb4adb82f6d38ccc019d57ce5eb4e283f4843b766f392b374b9f67da453a85e549096f62b27e2dc5e7843b90c45eff263c6ecf6cdc2977e90aee1d0334245b7d8aef3c9871474aa2f274c026f51a7d696ec7048df665208a15e931394bec9958fc14ff6fb2ff8f2c50b6817da832d79c27b5b096d13eea524ed0cf8a0c80b87fe8f47117602d2553ef604631b8ed77efbec08ae1d714cfd44260917d6b20862ebf28b269709e1a2d2014660eb22c71d56ff28f0835a4f98c8f2b726f638a02a3ca15faa034c2b90d15c1da9d1c61cf05ab6f2a950ab272deaeb391f3e27c6cca19e79c215c4ca009ee217bc71edaa891af8b57d47b5f60f940c1188eed7a6ec10385cad76d8c048f815cda66014e85b5a1995afe99cab13dc0cb36925c1818c49238eb6470232340b4c5ec4f4b014c192aa3dff9352a0bca1c6050b82faddedd0a77bdaea5e5c0b6c1dc106f5b546eaf939f5f16fa5a4728086a2b956e0277596e1d67e8aa8ecbe6ddf2590e356cd32f0b2efd1ed369f24a993895b260e187e1f68d05b090cc0c5e14b7c77894091af795da30e9d54c9a52efffb3218fa841b102095cf711615ce3a63386b38151a2a4cfdb14254f97b4a7651f72c4d7d8a14de46c041d2d29b46138aab48ae46f23e79bcf8b8010ce6d18790818e6221764ccf90c62dfe2be6aa9444184f58b9b6025431308513f2fb2249cfe6db6585b8e19d911c2eefc48f1a9317b0cd535c563c5fde4619ae5f71b7a44bcf15440c3cc6ee7512c6b0845cc7ea8dedde7591753a376948873d60f59978a8174d37aabf6a35e7763c24f14a5296617a345c607598639333e35eafb26ad43ae0619c84c3080f7c5c709e3fbb2243c9fe9e408ec7ec7a83ff99966b4b65ebd5b924456cdd7e5f6b83f0298dac9f1d9cdfd0f6681af360cbc093f55aea6c114e0299bcff191f8d2b336d7b1169301ff1fabc9d4da990bba003daefadb7a7ae66c4b05fda008d5559ecdaec2ff507cec2368036b277927cd294226352da416ad439cf3fac9ae765804972881bbc84c9a48e7e96f78f6892dd202746a687b5e4d1d03570fd1b66ef74fea40a8fa4b9b3b425bfc88d9399445cc756cc9b67549a5706296065e1856d4ecac7b39c4447d594f92e84fd07cdb0d445e97d4359e463105e6946279e678a5f7e7a8b1d4b3c3df8907024ce49ce4d7168055239d4743b8193b67db45f212de850057bc193babe03e4113c7fd30bbc7fb5098bf6bd886f2a0c1bd189283b10c4adb416e984b16317267af4665dfa544da46d1244dd9207c0c11b55cc2b701627d12d7310e45690c168376977f1bf09948f7f8e0f4aa9f1ed6c2c7c3a3a7e42605c3a455b2f01314f7a509f8e167745bc82786b6794e0c62e78cac33fe7977b6c75fefe3c9c0100a6c2f1d78ab2b43268a697beb10ef05928cf51355d29dbdf21dde2f284e0cb90d950585e1c29a7e9829722bfa29ea5ad192171a79614686c15e2bc1a1fcf08f60d3ed61da1a804aa6167c404434ada695be7f55613387647922222a04b75bc57e959fe1556a1d762893770a8610fcd082954569f653e487f3d5cbe8abbe97bb252f50665950de49806f4c2ec426b8872bdc35f5a67570faa6107d83c24aa9a4694ac3f47291282e2d04ae4db017b0f23345c0d696dc15c2ab38db448c20fb703aedc5d92efb43ed2dac685f29b5eecf4248b553d9883ca7715f277bea6ffa6988e96f8ad230720d27fc0ed69ae39b3c8202c5080f61237534b0caa6ff668c1fbf2cd9a9f26bfd9e0269b34e469834d164736255b028c0b0cfa15c80b76c492cbf23c84fe69cb98e1e50958374b8194ae8e0f5405c4785d5506819a056b43e85227f084a06c7b2235fb2ea153d4cb9ec5f50a35829004e02c16cce54e7c24c510cd21c6bd209ef69df229609e26a86f824d7d6c96a49e679fefb113eecdf835de0e417d1750888baac0011d788af13db402e0b3c7f89aca4a00bdc6dc283d38a5c26141263a7aa51b4e9f66e2705df5a7bd85aa7c623065e4b22c1b000bfe6a2103573008f81568d019f71c4525c9da62cbeacc88e05e6c99c2e820108c676fd58440f117890bb0497d7a0107981167b51debd2026b029415519281a818825311824455ac3e82774f9b78be04d249ab48da0192847135c30926fd3adf03be1e37bd41794a2bf1a41fee6541c020bac04a363d8973f2c240500788ce6350b2b7c4dba38675e9b080ab40f15e037f7be1b0dfd35842d661252bc47dcfe46b5313f544c1ebf6fd2b242e0d518547a9fbf9bf1a10397792d85727b7bae43f07fa1da70deb634db2d174981094b475147183c433d6d4516472ca748567c011b4e83e46461716c1c3118b910c4e6060b1f56f43b5f307024bc7543cbaa997ff03fcf77ee2011ffcaa16eecf33571400b5a13a3f03407b6acfc2e5754ba8f6bf2c23b0bd70e415adb8bcf0a5125142d77dd16c90845dc9561ea6e6dd113b138f091fc7599b263a0b133c410c594e960471428cd3c1550c1d5abefa19b9476d7d80bf105950fadc5d4f4de8e6e699bd6f19716f87569ce952f0d5288902e32f0e38a0f72bf5d8c67b306ada715e4dabf63924e33a0351521226d4c1dd0dd05ff7893b6776c1c2f52b4cab9362be86a823b66c8aa2ff289b7f9759c19c379494e5b0a0b835f98c0aff34a14322dbafbcfd039395f47ff0bc22e98f3348c8a625714d227213548a83fbec553df5405dd8f76008400fe52bc08cd0e4d1bd861afec6a0fdc14b9fff43d27cda96c5ada85f41ccb1f3259e37807f3aca62158345b1ecfa2358d1dc8cf2e24bf86bcfd13742b54ee30f6fade6da0b5f5d97dc64ec5acc7d Hey, password is required here.","link":"/2020/04/19/Docker-Use-multi-stage-builds/"},{"title":"[Docker] Xây dựng docker-compose.yml file cho project của bạn .....","text":"Nhật ký cho quá trình tự xây dựng docker-compose.yml cho dự án “Hello World” Laravel. Trước khi bạn bắt đầu Bạn cần có những hiểu biết cơ bản về Docker và Docker compose. Kiến thức về nginx, cấu hình virtual host cho nginx. Bài viết sẽ setup virtual với hàm phpinfo() trước tiên. Sau đó sẽ đổi đường dẫn root sang Laravel project để chạy ứng dụng của bạn ở mức cơ bản. Hãy bắt đầu từ việc cài đặt mà không Docker ..Khoan nói về các ứng dụng Laravel phức tạp, ở đây, tôi chỉ đề cập ở mức độ cài đặt Laravel project trang chủ và có thể migrate bảng user có sẵn. Hãy bắt đầu cài đặt ứng dụng từ việc không sử dụng Docker. LAMP (Linux, Apache2, MySQL, PHP), LEMP (Linux, Nginx, MySQL, PHP) là 2 cụm từ “tìm kiếm” kinh điển. Nó là bộ các công cụ giúp bạn cài đặt một ứng dụng web thông thường để hoạt động. Về cơ bản, mọi ứng dụng web để chạy được bạn cần tối thiểu 3 phần sau: Web server: Nginx hoặc Apache2 là những sự lựa chọn phổ biến Ngôn ngữ lập trình: tất nhiên :D, bạn phải cho web server biết là mình dùng ngôn ngữ lập trình nào chứ. Database: Nơi sẽ lưu dữ liệu cho ứng dụng LAMP, LEMP đều chính là 3 phần trên (Linux thì mình sẽ nói sau nhé). Trong phạm vi bài viết, mình sẽ sử dụng LEMP. Khi cài đặt LEMP xong, chúng ta cần cấu hình 1 virtual host để chạy ứng dụng với domain. Trước hết chúng ta cứ làm hiển thị thông tin PHP qua hàm phpinfo(), sau rồi chuyển cấu hình cho Laravel project là ngon :D Bước 1: Bạn cần thay đổi cấu hình nginx Bạn cần để nginx trỏ tới host chứa file index.php. Cơ bản nó sẽ như sau: conf.d nginx1234567891011121314151617181920212223242526272829server { listen 80; server_name localhost; # Cái này quan trọng nè, root của project root /var/www/html; index index.php index.html index.htm; error_log /var/log/nginx/laravel.error.log; access_log /var/log/nginx/laravel.access.log; location / { try_files $uri $uri/ /index.php?$query_string; } # PHP-FPM Configuration Nginx location ~ \\.php$ { try_files $uri = 404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass localhost:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param REQUEST_URI $request_uri; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; }} Bước 2: Thêm file index.php Cũng không cần giải thích nhiều. Từ cấu hình trên, ta có thể thấy, bạn cần có 1 file index.php ở thư mục /var/www/html là xong :Dconf.d nginx123&lt;?phpecho phpinfo();?&gt; Như vậy là khi vào http://localhost, thông tin PHP đã được hiển thị. Phần chuyển cấu hình cho ứng dụng Laravel, chỉ cần đổi đường dẫn root, tôi gộp luôn vào phần 2. Suy nghĩ docker hóa LEMPDocker hóa HelloWorld trước tiênĐể docker hóa các phần như ở mục 1, chúng ta cần 3 images tương ứng 3 phần trong LEMP ở trên: nginx, mysql và php-fpm. Bắt đầu từ cái dễ trước đi. Database tôi sử dụng MySQl, đơn giản chỉ là pull image của mysql về thôi, không cần cài cắm gì cả. docker-compose.yml123456789101112services: mysql: image: mysql:5.7 environment: MYSQL_DATABASE: 'laravel' MYSQL_USER: 'mingnv' MYSQL_PASSWORD: 'password' MYSQL_ROOT_PASSWORD: 'password' # Volumes này đang sử dụng theo dạng biến đó # Nó tương đương khai báo VOLUME trong Dockerfile, sinh volume dạng mã băm volumes: - db_data:/var/lib/mysql Dễ nhỉ, thế là có 1 database để lưu dữ liệu rồi, tiếp theo chúng ta sẽ pull image PHP qua php-fpm image docker-compose.yml123services: php-fpm: image: php:7.2-fpm Tương tự như database nhỉ. Nhưng khoan. php-fpm không thể đúng 1 mình được. Nó cần nói chuyện với web server, kết hợp để xử lý các request từ phía người dùng…. To be continue! Web server: phần này là phần quan trọng nhất của ứng dụng web. Ở đây tôi sử dụng nginx nên sẽ pull image nginx về. Nhưng như tôi đã nói ở trên, web server không thể hoạt động đơn lẻ. Nó cần có file cấu hình, trỏ tới host của bạn, lấy code và hoạt động. Do đó bạn cần phải có file Dockerfile để build. Dockerfile nginx12345FROM nginx:latest# Change Nginx config here...RUN rm /etc/nginx/conf.d/default.confCOPY ./default.conf /etc/nginx/conf.d/ Config mặc định sẽ không trỏ tới host được, do đó chúng ta sẽ sử dụng file conf ở trên để thay thế default.conf của nginx. Bạn nhớ thay đường dẫn php-fpm bằng host đúng của contianer nhé Lúc này bạn bật ứng dụng lên và chạy, docker-compose.yml sẽ có dạng như sau docker-compose.yml1234567891011121314151617181920212223242526272829# Sử dụng version 3.3 cho nó mớiversion: '3.3'services: nginx: build: ./nginx ports: - &quot;8080:80&quot; # Thêm depends_on để nó start php-fpm trước khi start nginx, nếu không sẽ bị báo lỗi host php-fpm không tìm thấy depends_on: - php-fpm volumes: # Logging - ./nginx/log:/var/log/nginx/ # Volume đến code ứng dụng - ./nginx/index.php:/var/www/html/index.php mysql: image: mysql:5.7 environment: MYSQL_DATABASE: 'laravel' MYSQL_USER: 'mingnv' MYSQL_PASSWORD: 'password' MYSQL_ROOT_PASSWORD: 'password' adminer: image: adminer ports: - 8081:8080 php-fpm: image: php:7.2-fpm Thực hiện docker-compose up để chạy. Hmm, kết quả xuất hiện lỗi . Tôi đã thực sự lúng túng trước lỗi ngày và mất tới 2 ngày để fix nó. Nguyên nhân là nó không tìm thấy file index.php trong khi chạy php-fpm. Sau khi tham khảo 1 số tài liệu, tôi mới hiểu, dù nginx và php-fpm đã nói chuyện với nhau nhưng các thư mục, files của nó không được dùng chung. Vì vậy khi bạn chỉ volumes file index.php cho nginx, khi thao tác của php-fpm không tìm thấy file này. Tất cả các services làm việc với source code (nginx, php-fpm và sau này xuất hiện thêm bạn workspace và nhiều nhân vật phụ khác) đều cần volumes chung với nhau và volumes đến source code folder. Và rồi kết quả cuối cùng file docker-compose.yml sẽ như sau: https://github.com/minhnv2306/laravel-docker/blob/01cea0eb1af8007e6e32ba4c2803088ac98dd3ce/docker-compose.yml Khi đã volume cho php-fpm và nginx như vậy, ứng dụng đã lên. Level up cho ứng dụng Laravel nào!Ở bước 2.1, chúng ta đã lên trang phpinfo(). Bước tiếp theo, chúng ta sẽ thay trang này bằng ứng dụng Laravel. Công việc đơn giản, chỉnh đường dẫn root của ứng dụng là xong. https://github.com/minhnv2306/laravel-docker/commit/35c4920de3ec51a91c5bcc59b4014e743181b6b3 Như vậy đúng là xong thật, ứng dụng Laravel đã lên. Bạn đã thử kết nối chúng với database. 1docker exec php-fpm php artisan migrate Kết quả là nhận được 1 thông báo thiếu mysql-extension. Như vậy chúng ta có thể thấy rằng image php-fpm chỉ có những extension cơ bản nhất của php, chưa hỗ trợ mysql-extension. Công việc của chúng ta tiếp theo là cập nhật extension này Để cài thêm các extension cho php trong Docker, bạn sử dụng docker-php-ext-install Dockerfile php7.2-fpm1234567FROM php:7.2-fpmRUN apt-get update &amp;&amp; apt-get install -y \\ vim \\ &amp;&amp; docker-php-ext-install mysqli pdo_mysqlEXPOSE 9000 Và lần này đã migrate ngon rồi nhé :D. Chúng ta cần nhiều hơn thế …Ứng dụng của chúng ta đã lên hình, đẹp đẽ, nếu nhìn lướt qua. Bạn có nhớ tôi đã nhắc đến Linux và có nói phần sau sẽ đề cập. Trong các phần 1,2, ứng dụng của tôi đã được cài composer, npm sẵn trên máy rồi, ứng dụng mới có thể hoạt động. Nói một cách khác, tôi đã chạy các lệnh này trước đó từ máy local của mình: 1234composer installnpm installnpm run dev Nhưng như vậy thì chưa đúng lắm với Docker, độc lập môi trường với máy của bạn. Chúng ta cần 1 nơi tên gọi là workspaceđể làm việc với mã nguồn như cài đặt git, xem mã nguồn, cài cắm copmoser, npm, các tool quản lý mã nguồn tương tự. Hình như tôi đang nhắc tới hệ điều hành nhỉ? Đúng vậy, chúng ta sẽ tách biệt chúng ra thành 1 container riêng với tên là “workspace”, nơi làm việc với mã nguồn, cài đặt ứng dụng. Đó chỉ là 1 phần bạn cần thêm. Bên cạnh đó, bạn có thể thêm thắt như contianer “data” chỉ để lưu trữ dữ liệu cho ứng dụng, container “data_test” để lưu dữ liệu cho ứng dụng khi chạy test. Bạn có thể tham khảo thêm các services tại đây nginx application (for storing project source code) php-fpm workspace (for working around with the all project) mysql mysql_test (for running integration test) mongodb redis data (for storing mysql, mongo, redis data) data_test (for storing mysql, mongo, redis data while running test) logs (for storing some system logs) Tách biệt các biến ra cấu hình …Để tăng độ nguy hiểm cho bạn, hãy thêm biến .env khi chạy docker-compose. Một hữu ích nữa nó mang lại là giúp bạn dễ maintain, thay đổi các tham số mà không cần sửa trực tiếp trong docker-composer.yml. docker-compose.ymlLaradock1234567891011121314151617181920212223242526272829version: '3'...services:### NGINX Server ######################################### nginx: build: context: ./nginx args: - CHANGE_SOURCE=${CHANGE_SOURCE} - PHP_UPSTREAM_CONTAINER=${NGINX_PHP_UPSTREAM_CONTAINER} - PHP_UPSTREAM_PORT=${NGINX_PHP_UPSTREAM_PORT} - http_proxy - https_proxy - no_proxy volumes: - ${APP_CODE_PATH_HOST}:${APP_CODE_PATH_CONTAINER}${APP_CODE_CONTAINER_FLAG} - ${NGINX_HOST_LOG_PATH}:/var/log/nginx - ${NGINX_SITES_PATH}:/etc/nginx/sites-available - ${NGINX_SSL_PATH}:/etc/nginx/ssl ports: - &quot;${NGINX_HOST_HTTP_PORT}:80&quot; - &quot;${NGINX_HOST_HTTPS_PORT}:443&quot; - &quot;${VARNISH_BACKEND_PORT}:81&quot; depends_on: - php-fpm networks: - frontend - backend... .envLaradock1234567891011...### NGINX #################################################NGINX_HOST_HTTP_PORT=80NGINX_HOST_HTTPS_PORT=443NGINX_HOST_LOG_PATH=./logs/nginx/NGINX_SITES_PATH=./nginx/sites/NGINX_PHP_UPSTREAM_CONTAINER=php-fpmNGINX_PHP_UPSTREAM_PORT=9000NGINX_SSL_PATH=./nginx/ssl/... Cuối cùng tôi đúc kết được gì Bạn nên tách ứng dụng thành các services đơn lẻ để dễ quản lý, nó cũng là 1 phần của best practice cho docker Tất cả các services làm việc với source code (nginx, php-fpm, workspace …) đều cần volumes chung với nhau và volumes đến source code folder. Bạn cần có các services cơ bản để có thể chạy được ứng dụng (php-fpm, nginx, database). Bên cạnh đó là 1 service để làm việc với mã nguồn, cài đặt mã nguồn (composer, npm) với tên workspace.123456789docker-compose exec workspace composer installdocker-compose exec workspace php artisan key:generatedocker-compose exec workspace php artisan migratedocker-compose exec workspace php artisan db:seeddocker-compose exec workspace yarndocker-compose exec workspace yarn watch# For testingdocker-compose exec workspace php artisan db:seed --class=TestDataSeeder Tách các tham số trong docker-composer.yml ra file cấu hình cho dễ quản lý và thay đổi. Tài liệu tham khảo Laradock Laravel Microservices - Framgia Docker Team Declare default environment variables in file","link":"/2020/04/30/Docker-Xay-dung-docker-compose-yml-cho-project-cua-ban/"},{"title":"Docker commands","text":"Bài viết tổng hợp một số lệnh với Docker Nhóm lệnh xem các thông tin về dockerDisplay system-wide information1docker info [OPTIONS] Xem trực tiếp phân tích dockerĐể xem live stream phân tích tài nguyên đang sử dụng của 1 hoặc nhiều containers1docker stats [OPTIONS] [CONTAINER...]1234567$ docker statsCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSb95a83497c91 awesome_brattain 0.28% 5.629MiB / 1.952GiB 0.28% 916B / 0B 147kB / 0B 967b2525d8ad1 foobar 0.00% 1.727MiB / 1.952GiB 0.09% 2.48kB / 0B 4.11MB / 0B 2e5c383697914 test-1951.1.kay7x1lh1twk9c0oig50sd5tr 0.00% 196KiB / 1.952GiB 0.01% 71.2kB / 0B 770kB / 0B 14bda148efbc0 random.1.vnc8on831idyr42slu578u3cr 0.00% 1.672MiB / 1.952GiB 0.08% 110kB / 0B 578kB / 0B 2 Nhóm lệnh xem thông tin images và containersXem danh sách images1docker images [OPTIONS] [REPOSITORY[:TAG]] Ngoài ra còn 1 số tùy chọn hữu ích cho bạnList images by name and tag12345678910111213$ docker images java$ docker images java:8$ docker images --no-trunc$ docker images --digests# Filter$ docker images --filter &quot;before=image1&quot;# Format$ docker images --format &quot;{{.ID}}: {{.Repository}}&quot; Tìm kiếm images trên Docker Hub1docker search [OPTIONS] TERM Danh sách containers1docker ps [OPTIONS] Nhóm lệnh thao tác với images, containersBuild image1docker build [OPTIONS] PATH | URL | - Ví dụ1234567891011$ docker build .# Build with URL$ docker build github.com/creack/docker-firefox# Use a .dockerignore file$ echo &quot;.git&quot; &gt; .dockerignore$ docker build .# Tag an image (-t)$ docker build -t vieux/apache:2.0 .... Xóa containers1docker rm [OPTIONS] CONTAINER [CONTAINER...] Xóa images1docker rmi [OPTIONS] IMAGE [IMAGE...] Nhóm lệnh quản lý images với repositoryPull imagePull 1 image hoặc 1 repository từ nơi đăng ký123docker pull [OPTIONS] NAME[:TAG|@DIGEST]docker pull node:8.17.0-jessieSau khi pull về, có thể sử dụng docker images để kiểm tra image đó12345docker pull minhnv2306/docker-npm:v2docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEminhnv2306/docker-npm v2 6a1446855f51 19 hours ago 404MB CommitLệnh này tạo 1 image mới từ sự thay đổi nào đó của container1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Lệnh này dùng khi 1 container đang chạy, bạn thay đổi gì đó trong container và muốn tạo 1 image mới. Nó khác với lệnh tags mặc dù cả 2 cùng tạo phiên bản image mới. Tags là tạo tag từ image cũ, không phải từ container như commit1234567891011121314151617181920212223242526272829# Ví dụ 1:$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc3f279d17e0a ubuntu:12.04 /bin/bash 7 days ago Up 25 hours desperate_dubinsky197387f1b436 ubuntu:12.04 /bin/bash 7 days ago Up 25 hours focused_hamilton$ docker commit c3f279d17e0a svendowideit/testimage:version3# Ví dụ 2:$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc3f279d17e0a ubuntu:12.04 /bin/bash 7 days ago Up 25 hours desperate_dubinsky197387f1b436 ubuntu:12.04 /bin/bash 7 days ago Up 25 hours focused_hamilton$ docker commit --change='CMD [&quot;apachectl&quot;, &quot;-DFOREGROUND&quot;]' -c &quot;EXPOSE 80&quot; c3f279d17e0a svendowideit/testimage:version4f5283438590d$ docker run -d svendowideit/testimage:version489373736e2e7f00bc149bd783073ac43d0507da250e999f3f1036e0db60817c0$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES89373736e2e7 testimage:version4 &quot;apachectl -DFOREGROU&quot; 3 seconds ago Up 2 seconds 80/tcp distracted_fermatc3f279d17e0a ubuntu:12.04 /bin/bash 7 days ago Up 25 hours desperate_dubinsky197387f1b436 ubuntu:12.04 /bin/bash 7 days ago Up 25 hours TagTạo một TARGET_IMAGE cái mà tham chiếu đến SOURCE_IMAGE1docker tag 6a1446855f51 minhnv2306/docker-npm:v2 Nhóm lệnh thao tác lệnh trong containerChạy lệnh trong 1 container mớiCâu lệnh này chạy 1 lệnh trong container mới12docker run [OPTIONS] IMAGE [COMMAND] [ARG...]docker run -it minhnv2306/docker-npm:v2 /bin/bashNó tương đương docker-compose up, thực hiện build với 1 image đơn và chạy12docker run -p 80:80 -d --name php-container php-imagedocker run --name mysql-container -e MYSQL_ROOT_PASSWORD=secret -d mysql:latestVí dụ trên là nó đang bật 2 container php-container và mysql-container. Bạn có thể kiểm tra thông qua docker ps Chạy 1 lệnh trong 1 container đang chạyNếu như docker run là chạy 1 lệnh trong container mà chưa bật (đang ở dạng image) thì docker exec lại là thực thi 1 lệnh trong container đang chạy1docker exec [OPTIONS] CONTAINER COMMAND [ARG...]CONTAINER ở đây có thể là id của container hoặc tên. Nếu là tên container, bạn cần đặt tên cho nó, như qua container_name trong docker-compose.yml1234567version: '2'services: ubuntu: container_name: my_ubuntu image: minhnv2306/docker-npm:lastest tty: true # keeping docker runing12docker-compose updocker exec -it my_ubuntu /bin/bash Nhóm lệnh quản lý tiến trình containersStart một hoặc nhiều containers đã dừng1docker start [OPTIONS] CONTAINER [CONTAINER...] Restart Một hay nhiều containers1docker restart [OPTIONS] CONTAINER [CONTAINER...] Dừng 1 hoặc nhiều containers1docker stop [OPTIONS] CONTAINER [CONTAINER...] Kill 1 hay nhiều containeres1docker kill [OPTIONS] CONTAINER [CONTAINER...] Vậy kill và stop khác gì nhau? Nó cũng tương như kill tiến trình trong ubuntu. Với docker stopThe main process inside the container will receive SIGTERM, and after a grace period, SIGKILL. Và docker killThe docker kill subcommand kills one or more containers. The main process inside the container is sent SIGKILL signal (default), or the signal that is specified with the –signal option Như vậy lệnh stop có vẻ hữu ích hơn khi dừng một container. Nó gửi 1 tín hiệu SIGTERM tới trước. Tín hiệu này được gửi tới 1 tiến trình để yêu cầu chấm dứt nó. Không giống như tín hiệu SIGKILL, có có thể bị bỏ qua bởi tiến trìnhRef: https://superuser.com/questions/756999/whats-the-difference-between-docker-stop-and-docker-kill Tổng kết:1234567891011121314151617docker info [OPTIONS]docker stats [OPTIONS] [CONTAINER...]docker images [OPTIONS] [REPOSITORY[:TAG]]docker search [OPTIONS] TERMdocker ps [OPTIONS]docker build [OPTIONS] PATH | URL | -docker rm [OPTIONS] CONTAINER [CONTAINER...]docker rmi [OPTIONS] IMAGE [IMAGE...]docker pull [OPTIONS] NAME[:TAG|@DIGEST]docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]docker tag 6a1446855f51 minhnv2306/docker-npm:v2docker run [OPTIONS] IMAGE [COMMAND] [ARG...]docker exec [OPTIONS] CONTAINER COMMAND [ARG...]docker start [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker kill [OPTIONS] CONTAINER [CONTAINER...] Tài liệu tham khảoDocker CLI","link":"/2020/01/17/Docker-commands/"},{"title":"[Feathers JS] Tìm hiểu cơ bản về Feathers JS","text":"Feathers là 1 mã nguồn mở phục vụ việc tạo REST và realtime API đối với các ứng dụng JS hiện đại Feathers hỗ trợ cả ở client và server, khá tiện dụng cho các ứng dụng JS Feather không phải là 1 framework, nó chỉ là công cụ hỗ trợ (giống như npm hay yarn) xây dựng kiến trúc code. Về cốt lõi, Feathers là một tập hợp các công cụ và một mẫu kiến trúc code giúp dễ dàng tạo các API REST, có thể mở rộng và các ứng dụng thời gian thực. Với Feathers, bạn có thể xây dựng các code service mẫu trong vài phút và các ứng dụng sẵn sàng được làm ra trong vài ngày Feather hỗ trợ các ứng dụng làm việc với API. Các ứng dụng web JS không sử dụng API có lẽ không nên sử dụng Feathers 1. Cài đặtFeathers và đa số package làm việc với NodeJS v6.0.0 trở lên, bạn cần cài NodeJS version lớn hơn 6.0.0 để sử dụng 12$ node --versionv8.5.0 12$ npm --version5.5.1 2. Các khái niệm cơ bản trong FeathersChúng ta xét ví dụ khi tạo một ứng dụng chat với Feathers Js và React sử dụng mongoose. Để làm việc này nếu bạn không dùng Feathers bạn hoàn toàn có thể làm được. Bạn cài đặt các package và cấu hình chúng express mongoose socket-io jwt …và các package khác hỗ trợ khác …. và bên client bạn cần cài socket.io-client. Nếu sử dụng Feathers, nó đã cài đặt và cấu hình đầy đủ các package đó và bạn chỉ cần gọi nó để sinh code, cài đặt nó với 1 lệnh duy nhất =)) 1$ feathers generate app 2.1. Tạo ứng dụngBạn nên cài Feathers ở chế độ dòng lệnh để sử dụng các lệnh hỗ trợ 1 cách dễ dàng 1npm install @feathersjs/cli -g Tạo thư mục ứng dụng 12mkdir feathers-basicscd feathers-basics Sau đó nó sẽ hiển thị các công nghệ bạn cần trong ứng dụng của mình, bạn chỉ việc tích chọn trên giao diện, khá đơn giản 1$ feathers generate app 2.2. ServiceService là trái tim của mọi ứng dụng Feathers và các đối tượng hoặc thực thể của các class để thực hiện các phương thức nhất định. Các service độc lập với nhau và có thể tương tác với các loại dữ liệu như: Đọc và ghi dữ liệu vào database Tích hợp vào các file system Gọi các API khác Gọi các dịch vụ khác như: Gửi email, xử lý thông tin thanh toán, trả về thông tin thời thiết … =)) Hiểu đơn giản, service có chức năng chính là nơi cung cấp các REST API cho ứng dụng, bạn hoàn toàn có thể custom để thêm các dịch vụ khác đã kể ở trên. Các phương thức CRUD mà 1 đối tượng service có thể thực thi. find - Lấy tất cả dữ liệu (có thể thêm các query để lọc dữ liệu) get - Lấy 1 thực thể dữ liệu dựa vào điều kiện duy nhất của nó create - Tạo 1 bản ghi mới update - Cập nhật 1 bản ghi dữ liệu đã tồn tại bằng cách thay thế hoàn toàn nó patch - Cập nhật một hoặc nhiều bản ghi dữ liệu bằng cách hợp nhất với dữ liệu mới remove - Xóa một hoặc nhiều bản ghi dữ liệu đã tồn tại Tạo service Để tạo service, bạn chỉ cần sử dụng 1 lệnh duy nhất và chọn tên cũng như DB sử dụng trong service 1feathers generate service Sử dụng service: 123await app.service(&quot;messages&quot;).create({ text: &quot;First message&quot;}); 2.2. HookHook là 1 middleware có thể thêm các xử lý trước khi hoặc sau khi thực hiện các thao tác, các phương thức của service. Nó có thể là thêm các thông tin vào model trước khi thực hiện hành động tiếp theo, xử lý lại dữ liệu trước khi trả về API, bắn ra các sự kiện …Chi tiết bạn có thể tham khảo đây Tạo hook: Để tạo 1 hook, bạn cũng chỉ cần thao tác 1 dòng lệnh và lựa chọn cách thức sử dụng dễ dàng như với service 1feathers generate hook 2.3. Realtime APIMặc định Feathers services sẽ tự động sinh các sự kiện created, updated, patched và removed khi thực hiện các phương thức create, update, patch hoặc remove. Real-time có nghĩa là những sự kiện này cần được truyền tới các client đang kết nối và chúng có thể phản ứng lại phù hợp (như là cập nhật lại giao diện). Để cho phép giao tiếp thời gian thực với client, bạn cần một phương tiện vận chuyển dữ liệu hỗ trợ giao tiếp hai chiều. Kỹ thuật này trong Feathers là Socket.io và Primus và cả 2 đều sử dụng websocket để nhận sự kiện real-time và cũng như gọi các phương thức từ service 2.3.2. Sử dụng transpotCài đặt 1npm install @feathersjs/socketio --save Cấu hình trong Feathers 1234567891011121314151617181920const feathers = require(&quot;@feathersjs/feathers&quot;);const express = require(&quot;@feathersjs/express&quot;);const socketio = require(&quot;@feathersjs/socketio&quot;);// This creates an app that is both, an Express and Feathers appconst app = express(feathers());// Turn on JSON body parsing for REST servicesapp.use(express.json());// Turn on URL-encoded body parsing for REST servicesapp.use(express.urlencoded({ extended: true }));// Set up REST transport using Expressapp.configure(express.rest());// Configure the Socket.io transportapp.configure(socketio());// Set up an error handler that gives us nicer errorsapp.use(express.errorHandler());// Start the server on port 3030app.listen(3030); 2.3.3. ChannelKênh để xác định sự kiện real-time sẽ được gửi tới những client nào. Feathers có hỗ trợ 1 số kênh mặc địnhBạn cần đăng kí kênh để ứng dụng biết gửi các sự kiện này đến đâu 12345// On any real-time connection, add it to the `everybody` channelapp.on(&quot;connection&quot;, connection =&gt; app.channel(&quot;everybody&quot;).join(connection));// Publish all events to the `everybody` channelapp.publish(() =&gt; app.channel(&quot;everybody&quot;)); 2.3.4. Lắng nghe sự kiện phía clientKhi server đã publish sự kiện đến client, công việc tiếp theo của client là bắt sự kiện này để xử lý phản ứng lại sự kiện cho phù hợp (thường là thay đổi giao diện). Có 2 cách để client đón nhận sự kiện này Cách 1: Sử dụng socket.io-client Tuy nhiên hãy chú ý sự kiện bạn lắng nghe và bắt phải bắt đầu với tên service, nó có dạng như messages created 123456789/* global io */// Create a websocket connecting to our Feathers serverconst socket = io(&quot;http://localhost:3030&quot;);// Listen to new messages being createdsocket.on(&quot;messages created&quot;, message =&gt; console.log(&quot;Someone created a message&quot;, message)); Nếu bạn custom lại 1 sự kiện, bạn càng phải nhớ tên đúng của sự kiện để tránh bắt nhầm (mình sẽ ví dụ ở phần sau) Cách 2: Sử dụng feathers-clientTạo file chung feather.js để sử dụng chung cho ứng dụng 1234567891011121314import io from &quot;socket.io-client&quot;;import feathers from &quot;@feathersjs/client&quot;;// Socket.io is exposed as the `io` global.const socket = io(&quot;http://localhost:3030&quot;);// @feathersjs/client is exposed as the `feathers` global.const client = feathers() .configure(feathers.socketio(socket)) //incase we later have to do authentication .configure( feathers.authentication({ storage: window.localStorage }) );export default client; Lúc này chúng ta sẽ dễ dàng lắng nghe sự kiện từ server 123456789101112...import client from &quot;./../../feathers.js&quot;;....// Method 2: Get firstEvent from messages serviceclient.service(&quot;messages&quot;).on(&quot;firstEvent&quot;, data =&gt; { console.log(&quot;First event&quot;, data);});client.service(&quot;messages&quot;).on(&quot;created&quot;, data =&gt; { console.log(&quot;Got myevent&quot;, data); this.props.dispatch({ type: &quot;GET_NEW_MSG_SAGA&quot;, data });}); 2.3.5. Custom lại 1 eventĐể tạo 1 sự kiện không nằm trong các event mặc định của Feathers bạn cần làm như sau Đăng ký sự kiện mới trong service Đăng ký trong class service 1234567891011121314class PaymentService { constructor() { this.events = ['status']; }, create(data, params) { createStripeCustomer(params.user).then(customer =&gt; { this.emit('status', { status: 'created' }); return createPayment(data).then(result =&gt; { this.emit('status', { status: 'completed' }); }); }); }} Hoặc đăng ký trong Object service 12345678// Initialize our service with any options it requiresapp.use(&quot;/messages&quot;, { events: [&quot;firstEvent&quot;], async create(data, params) { ..... },} Phát sự kiện Bạn có thể sử dụng service để phát sự kiện ở bất cứ đâu nhưng bạn nên phát sự kiện ở hook 1234567app.service(&quot;messages&quot;).hooks({ after: { create(context) { context.service.emit(&quot;firstEvent&quot;, { status: &quot;completed&quot; }); } }}); Publish sự kiện đến client Khi server đã bắn ra 1 sự kiện nhiệm vụ tiếp theo là cần chuyển event này đến 1 kênh nào đó để xác định client nào sẽ nhận sự kiện này thông qua phương thức publish Đón nhận sự kiện phía client Như đã đề cập ở trên, tên sự kiện đón nhận cần có tiền tố là tên service (nếu không sử dụng feathers client) 12345678// Method 1: Get firstEvent from messages servicesocket.on(&quot;messages firstEvent&quot;, function() { console.log(&quot;first event 1&quot;);});// Method 2: Get firstEvent from messages serviceclient.service(&quot;messages&quot;).on(&quot;firstEvent&quot;, data =&gt; { console.log(&quot;First event 3&quot;, data);}); 3. Một vài thứ hay ho khác Hỗ trợ authenticaion với JWT Việc sinh và kiểm tra token với JWT đã được hỗ trợ sẵn trong Feathers, công việc của bạn chỉ là gọi và sử dụng nóhttps://docs.feathersjs.com/guides/auth/readme.html Feathres hỗ trợ database đa dạng. Feathers hỗ trợ ứng dụng của bạn làm việc với rất nhiều database https://docs.feathersjs.com/api/databases/adapters.html Feathers client Không chỉ hỗ trợ mạnh phía server, feathers cũng hỗ trợ client với các thao tác cho trình duyệthttps://docs.feathersjs.com/guides/basics/clients.html Tài liệu tham khảo Home page of Feathers Create a Chat Application My project with FeathersJS","link":"/2019/07/05/Feathers-JS-Tim-hieu-co-ban-ve-Feathers-JS/"},{"title":"Happy New Year 2021","text":"Một bài viết khai code với hi vọng năm mới ít bug hơn! 明けましておめでとうございます。_Go Fast_","link":"/2021/02/12/Happy-new-year-2021/"},{"title":"How to Optimize Images for Web and Performance","text":"Tin tôi đi, bạn không muốn Google ghét trang web của bạn đúng không? May mắn thay, bạn có thể giảm size ảnh của bạn để giúp cải thiện hiệu năng của website. Một vấn đề với việc định dạng chúng là khi sửa đổi thường làm giảm chất lượng của ảnh (điều này có thể làm người dùng ghét trang web của bạn). Nhưng đó không phải là thứ tồi tệ, miễn là bạn không làm nó nhìn quá xấu. Một vài tips sau giúp bạn cải thiện việc này. Images make up on average 21% of a web page’s overall weight. 😮 Optimize them! Lợi ích của việc tối ưu hóa ảnh Cải thiện tốc độ tải trang. Do cải thiện được tốc độ tải trang, SEO cũng được cải thiện. Tiết kiệm băng thông. =&gt; Nói chung là làm cho việc trải nghiệm người dùng được trở nên tốt hơn :D. Các tips tối ưu hóa hình ảnhTip #1 – (IMG) Compress ImagesĐừng để ảnh quá lớn lên trang web của bạn (trừ khi web của bạn là trang lưu ảnh hoặc việc gì đó quá chú trọng vào ảnh), hãy dùng các phần mềm, chỉnh sửa và nén ảnh lại sau đó hãy đưa lên web. Các ảnh ở đây ví dụ như là các ảnh bạn chủ động đưa lên websites, ví dụ như banner quảng cáo hoặc các ảnh từ các bài báo chẳng hạn. Hãy nén chúng lại. Nén thì lại có 2 loại: Lossy: Nén có mấy mát dữ liệu. Điều này có thể ảnh hưởng mạnh đến chất lượng ảnh của bạn, nhưng bù lại, nén được ảnh với kích thước nhỏ hơn Lossless: Nén không mất mát dữ liệu. Ngược lại với cách trên, cách này không làm thay đổi chất lượng của anh nhiều, nhưng nó yêu cầu ảnh cần được giải nén trước khi render Tùy vào mục đích mà bạn dùng loại nén nào nhé. Tip #3 – (IMG) Optimize GIF, JPG, PNG filesTối ưu PNG: http://www.websiteoptimization.com/speed/tweak/png-optimization/Tối ưu JPEG và nén: http://www.ampsoft.net/webdesign-l/jpeg-compression.html Tip #5 – (IMG) Link Thumbnails to Larger Images Phần này khá hay. Vì các ảnh kích thước nhỏ hơn sẽ có size nhỏ hơn các ảnh cùng nội dung nhưng kích thước lớn hơn, do đó bạn có thể tạo các ảnh thumbnails để hiển thị lên web, và khi bạn ấn vào thumbnail đó mới link đến ảnh gốc. Như vậy website chỉ load các ảnh thumbnails, giảm được size của ảnh. Demo: http://fancybox.net/ If you want to place large images on a website, the best option is to use “thumbnails” that link to them. This allows a user to decide whether they want to wait for the large image to load or if the thumbnail picture is sufficient enough to use. The biggest advantages in linking thumbnails to larger images is that websites load faster because most thumbnail images are a lot smaller in size. Tip#5www.monitis.com/blog/30-tips-to-optimize-htmlcssimages-for-smooth-web-experience Tip #6 – (IMG) Use Proper Image Formats: Sử dụng định dạng phù hợpVề cơ bản, có một số định dạng phổ biến nên được sử dụng: JPEG, PNG và GIF, SVG. JPEG JPEG là viết tắt của Joint Photographic Experts Group và nó là một trong những định dạng phổ biến nhất được sử dụng cho web. JPEG files là ‘lossy’ (mất mát dữ liệu) có nghĩa là rất nhiều thông tin quan trọng bị mất từ ảnh nguồn khi bạn lưu nó trong JPEG file. Tuy nhiên, khi nén bạn cũng có thể tùy chỉnh nén nhiều hay ít để cân bằng giữa chất lượng ảnh và kích thước Một vài máy ảnh kỹ thuật số có thể chụp và lưu ảnh dưới định dạng JPEG. JPEG rất thân thiện với web bởi vì nó nhỏ. Nó ít điểm ảnh hơn GIF và đã từng là “old king - nhà vua cũ” của internet.Từ năm 1994, JPEG đã được coi là tiêu chuẩn Ưu điểm: 24-bit color, với 16 triệu colors Màu sắc phong phú, thích hợp cho những bức ảnh cần chú ý đến chi tiết của màu sắc Định dạng hình ảnh được sử dụng nhiều nhất và được chấp nhận rộng rãi nhất Tương thích với nhiều hệ điều hành (Mac, PC, Linux) Nhược điểm: Mất mát dữ liệu: khi lưu ảnh dưới dạng này nó có xu hướng loại bỏ rất nhiều dữ liệu. Sau khi nén, JPEG có xu hướng tạo các artifacts (hiểu là các thành phần riêng) (nó sẽ chỉnh sửa các lines và shape của ảnh) Không có animation Không hỗ trợ tính trong suốt. As shown above, image compression is not that evident at first glance. But if you take a closer look, the JPEG image is not as sharp as the original image. The colors are paler and the lines are less defined and the picture is noisier. If you zoom in there are JPEG artifacts like any other JPEG files. Đọc thêm tại: http://www.ampsoft.net/webdesign-l/jpeg-compression.html. GIF GIF là viết tắt của Graphics Interchange Format bị giới hạn với 8 bit cho bảng màu với chỉ 256 colors. GIF vẫn là image phổ biến trên internet vì size nhỏ tương đối so với các kiểu nén ảnh khác. Đây là lựa chọn tốt nhất khi mà ta muốn có 1 tấm ảnh động. Ưu điểm: Can support transparency: Hỗ trợ tính trong suốt, minh bạch, rõ ràng Có thể tạo các ảnh động nhỏ Chất lượng “lossless” - chất lượng có thể tương đương ảnh đầu nếu ảnh gốc chỉ có tối đa 256 colors Sử dụng tuyệt vời đối với các ảnh có giới hạn màu hoặc có các khu vực màu phẳng (1 màu xanh thôi chứ không chia chi tiết thành 7 màu xanh đó) Nhược điểm: Chỉ hỗ trợ 256 màu Nó có định dạng cũ nhất trên web, tồn tại từ năm 1989. Nó đã được cập nhật kể từ đó và đôi khi, kích thước tệp lớn hơn PNG. PNG PNG or (Portable Network Graphics) là kiểu định dạng được giới thiệu gần đây nhất, do đó không phải ai cũng quen thuộc với nó. Nhưng PNG đã được chấp thuận như là 1 tiêu chuẩn từ năm 1996. Nó là 1 định dạng ảnh được thiết kế đặc biệt cho web. PNG, về mọi mặt, là phiên bản ưu việt của GIF Nếu như GIF chỉ hỗ trợ tối đa 256 màu, thì PNG có thể lưu nhiều thông tin màu sắc hơn. Nó cũng có 8 bit transparency PNG thực sự được tạo ra với mục đích thay thế GIF mà không cần giấy phép (kiểu tự hiểu với nhau ý). PNG có thể hỗ trợ 24 bit RGB color image, hình ảnh thang độ xám, cả có và không có kênh alpha. Ưu điểm: Lossless, do đó nó không ảnh hưởng nhiều đến chất lượng ảnh sau khi nén Có nhiều điểm hơn GIF. Để bắt đầu, PNG thường có kích thước nhỏ hơn GIF Hỗ trợ transparency tốt hơn GIF Nhược điểm: Không tốt cho các ảnh lớn Không giống như GIF, nó không có hình động Không phải tất cả các trình duyệt đều hộ trợ PNG. SVG SVG là định dạng vectơ có thể mở rộng (scalable vector format) hoạt động tốt cho logos, icons, text và hình ảnh đơn giản. SVG tự động mở rộng trong cả trình duyệt và công cụ chỉnh sửa ảnh. Google lập chỉ mục SVG, giống như cách thực hiện PNG và JPG, do đó không phải lo lắng về SEO. SVG theo truyền thống (tất nhiên là không phải luôn luôn) có kích thước file nhỏ hơn so với PNG hoặc JPG. Sử dụng hình ảnh vector SVG bất cứ khi nào có thể cùng với PNG và JPG. In a Nutshell PNG, JPEG và GIF là những đinh dạng thân thiện nhất với web. JPEG và ảnh tốt nhất khi bạn cần giữ size nhỏ nhưng khi bạn cần upload nó lên mạng. Nếu chất lượng ảnh có thể mất 1 chút, sử dụng JPEG. Nếu bạn muốn giữ size nhỏ nhưng vẫn giữ được chất lượng, sử dụng PNG. GIF là 1 sự lựa chọn tồi, mặc dù sỉz nhỏ và load rất nhanh. Nhưng nếu bạn muốn các hình động, hãy sử dụng GIF. Sử dụng GIF nếu cần ảnh động (nhưng cũng nên nén lại) Sử dụng PNG nếu cần chi tiết cao và độ phân giải cao Sử dụng JPG cho ảnh chụp thường (photo) và ảnh chụp màn hình (screenshot) Tip #4 – (IMG) Strip meta data from JPEGs Một trong những cách để giảm kích thước của ảnh là xóa metadata khỏi các file hình ảnh trước khi tải chúng lên trang web. Dữ liệu meta hình ảnh (hình như còn được gọi là exif) được lưu trữ trên bất kỳ ảnh nào và bao gồm: ngày chụp, mẫu máy ảnh, flash được sử dụng, Vị trí GPS, iso, kích thước ống kính, tốc độ màn chập v.v… Tip #7 – (IMG) Save HTTP Requests by Combining ImagesTip #8 – (IMG) Use Styled Text Instead of Graphic Text Graphic text (tôi tạm dịch là đồ họa thiết kế mấy chữ text), có thể chuyển thành ảnh để hiển thị. Không may máy, nó làm chậm thời gian tải web của bạn. Sử dụng graphic text sẽ cũng làm thêm yêu cầu HTTP request và tăng page weight. Thay vào đó sử dụng style text (CSS chẳng hạn), loại bỏ được các vấn đề ở trên và bổ sung các ưu điệm, như SEO tốt hơn, chi phí load web thấp, tốc độ cải thiện :D Khi bạn định thiết kế dăm ba chữ nọ bằng đồ họa rồi chuyển thành ảnh, rồi hiển thị lên web, hãy thử dùng CSS xem có ổn không nhé. Cơ mà CSS phải lúc nào cũng ngon đâu =)) có quá bỏ qua, xem các Tips khác @@ Tip #9– (IMG) Don’t Scale Images Nếu bạn ngỡ là khi bạn sử dụng thuộc tính width và height để chỉnh kích thước về ảnh nhỏ hơn thì bạn đang thu được ảnh nhỏ hơn và tiết kiệm size ảnh. Nếu như vậy thì bạn đã nhầm, vì bản chất nó vẫn cần load ảnh gốc và chỉnh kích thước nhỏ lại =&gt; No nooo Thay vào đó, xem lại Tip#5 nhé :D. Tip #10– (IMG) The Fewer Graphics the Better Cái này chắc ý muốn nói với bên thiết kế đấy mà. Thiết kế trang web ít ảnh thôi nếu nó không quá chuyên về xử lý ảnh. Một website không nên có quá nhiều hoặc 5 ảnh và mỗi ảnh cũng cần được tối ưu rồi. Lazy loadingLoad ảnh theo viewport. Thời gian load ảnh sẽ không đổi, nhưng cách thức hiển thị ảnh ở lần đầu sẽ cho trải nghiệm người dùng tốt hơn. Ý tưởng của cách này là “load lười”, nó sẽ không load ảnh gốc luôn, thay vào đó sẽ load ảnh khác như ảnh gốc, kích thước lại nhỏ hơn làm người dùng có cảm giác ảnh gốc đã được load. Sau đó mới load ảnh gốc lên thật.Bạn hãy xem xét ví dụ sau khi load 1 ảnh background 4.8MB tốn mất 27.32s để có thể nhìn rõ nó, load xong DOM trong lần đầu tiên người dùng vào Đầu tiên chúng ta thấy, sẽ không để ảnh quá lớn như vậy. Chúng ta sử dụng các tool nén ảnh lại, kích thước ta thu được mới là 2MB mà vẫn đảm bảo chất lượng.Tuy nhiên 2MB vẫn là kích thước lớn, do đó thời gian load ảnh vẫn khá lâu, lúc này chúng ta cần áp dụng Lazy loading. Nó sẽ là load lười trong lần đầu tiên vào web. Chúng ta sẽ tạo 1 ảnh mới giảm độ phân giải của ảnh từ 7372x4392 pixels còn 20x11 pixels và kết quả size ảnh được giảm từ 4.8MB xuống 900 bytes. Ảnh này chỉ mất 550 miliseconds để load, do đó chúng ta sẽ sử dụng nó trong lần đầu người dùng vào web để có cảm giác như ảnh đã được load. Sau đó chúng ta mới thực sự load ảnh gốc lên. 1234567891011121314151617(() =&gt; { 'use strict'; // Page is loaded const objects = document.getElementsByClassName('asyncImage'); Array.from(objects).map((item) =&gt; { // Start loading image const img = new Image(); img.src = item.dataset.src; // Once image is loaded replace the src of the HTML element img.onload = () =&gt; { item.classList.remove('asyncImage'); return item.nodeName === 'IMG' ? item.src = item.dataset.src : item.style.backgroundImage = `url(${item.dataset.src})`; }; });})(); Và đây là thẻ nơi cần load backgroud image của chúng ta:123&lt;div class=&quot;asyncImage&quot; data-src=&quot;/images/background.jpg&quot;&gt;...&lt;/div&gt;Hoặc1&lt;img class=&quot;asyncImage&quot; src=&quot;/images/background-min.jpg&quot; data-src=&quot;/images/background.jpg&quot; alt=&quot;Beautiful landscape sunrise&quot;&gt;Ngoài ra bạn có thể thêm các CSS để hiệu ứng chuyển ảnh có thể đẹp hơn.Bạn có thể xem ví dụ tại đây. Kết quả ta thu được The benefit of this is fewer bytes to load on initial page load. Often not all images are necessary to be displayed in the viewport of the user. Once the user starts scrolling we need more and more content that can be loaded in. A good approach to implement this behavior is to take a look at the Intersection Observer. Tài liệu tham khảoTài liệu chính Viblo - Tối ưu hóa hình ảnh cho trang web Viblo - Lazy loading Five Ways to Lazy Load Images for Better Website Performance How to optimize image loading on your website Một vài thư viện liên quan đến imagesJavascript Viblo - Giới thiệu các thư viện Javascript hay liên quan đến ảnh Croppjs Laravel Intervention Image","link":"/2020/04/23/How-to-Optimize-Images-for-Web-and-Performance/"},{"title":"JP - KN301","text":"8d229d8e47333d3f189c47d25637efeb5cb93a79968515e30e77e9ea060cd38b369142d174715c10e854b175b846cd04fb7976f5a1d2272f790cc55ec0278e48a390b57891132049dd0c9dd4573eedcae22b8f878a6528ea3d4d05fb7e0e071a6a52c7cf631fa72e1131fe691b414d06a38460c0f310cddd0511f677a19bc5ddd3e6c056e274c5a56aad5c1d87c210fc1acd672e6a5a9cac673c50d962245ab7ff5e35be15ee7488acb232e0dc07a84fc190140b738b8af113c150f67d0e37729bf44ff3bc2e6be3375d03a9081bbe249383b982f6743f922e409719fa3b1237fd8f52fcf80ac1c6c2070a415a530744973ada4fa127c80c25c419e237b4c6f915995241f51224774bc774ffbc11d4e71c2eb8294497024fe918d7dab92892aa75e838edaae2a7928e38f9941bca2ec663472032e7a5e6fb310f4661cf5ffb6e4e223bd1b8c33c2716d46712f21095591260726e47d3f1f900d511983d7618e7b9c2d98cf83c864439bea55bd79931f1f74b172e3b29071faa6ae0cd4e3fc6fe95b942b9070a2e24df3734b7a6c5e0848da5f69503b76622b249b662e82939b80018c89f338ce6c189ad9f4c3a9714da9e43d77a73d0ec8467779150e55cd8d195fd3b76050f84dcd7c2bf4062091bf606e046e0a41148946ecd88a2c9ea57b4f8ee476a9eca41e90dc2919946c97786a456eda03807208b5336b319a11e2b96a32b3519bd4cae287f5b74704ac9cc7529a2491540e5435d97a4111a1f97f76995225cf0b297924a27e0bf681f25d5d6349a2e16fbed69b7f9dec95e8d2f27adb75169331ced09bf8b8c5565734f198b9b26c0a555faf5dcedc919a71bd9e35fd5bb219f42e7c8c70a5e223ca102133ec25e8934b30d3d87104e97fca791c172e328671c0e7311aaa8eafacc03f437a79ea1448ec3d4993283655ae7b91e2cf846acc975a45e5be355e8921b0ca7bf37a14684bdac609cbaba9c2b48f0783807f7d06998b2884425366386f1602b6237721e6226c3044cb7f85380be43628b82c2b3bfb992f62576910e5288003f64d838127362926d426442a783cd886e1a80aeed7eec72faa2697df7e7f311a602c4c30373a430bd73a22b3f9ce0ccb422cb4b4b6a74169ea4bdb6bda339602671feb6a8cefa237f855c63bee5ef69a5083ff295707d4c6022bc4ee37165c3b1146a8527f2595eb4378f6be781a62c0a46b8bceb0ae4cff04c171ef9dab92c80b87dc119ff04fd7563b69885f330e5d6c4cb48f7d43f108a31a3c7a9fd581bcb4c54257a5f581f69e1d4246f11493831a048463d7344e014b6fcf896ecfcfdc88289e8ae7d210ee92f3128ebb22c0ff593acfe53fe559942e3f7a157a2b00c028f1b50cc3adeca54b8909f213f67110dac9d36a2605e14101c8e5638f93e769b18580049c529ec5766f17de87d13e656023fe3f90211d21858477b9a2b7432c00a8bc5247230d8a9e626e6403dce1e983013ab1d3bffeb1146d82db5e303b796d00955ff756ce76e9f32203b7b47a11648d1fdbe3e003523d688ad8b88e6051cb589518281d184e8860f9ffbaa554118cdbab6f0e1c17d42c91dca0655cd8c50d466eece505ce0331751db49f6f2b422943a158f935dbd5c7c2055e36564f4667a01403ebb7efe252e9d797f53531510c2d6d60e3b3c05fa898e62300ba238c375c3e0cc92c336336019a7269d8ab95f7f03ac6ed947b8b6757a2ec189acf6912e79ce05f09fac6a98fc9def3620245f9ff92338e0947b4531dda05a5ca4e612ca56f367aa98e893e506393ae96e5ee4a3155021b328b2108d143d44cf0bed12c58630b643fbdbd9c31a20b4770fdfc953d07a07235944519aea3944f7290b239f6ad14cfd5c5560bb0faa3e8f1e1496b98598122d08d750e45d221085655cbd5065aabdaa69e0d6305dde284dc2bd14f5803b721b2e2d71cd54a7e4612a5610a68be6adff7ffd6725183bd7919ecffc83449d9dc9fcd23be67832a7cbdd384df9b92ea4768e0851973e635ca877b2d366c586786ed34b6a6757605261574044da695a63f019b43ce08fcbaf98d85864a9c54c70ba392a54587580707045146436e5fd26d171c82c23d782cb808d4580c9d16f89331eb2096fbdd6a44ab160293793e464acbdb984584286bf8a7d9713c95430baf8ed09c4746be7a88a3edfb78411213fee7430bd7e0d9c3d5aeb1e3deeb814cb3a47e3b7f881260b66976c08259f424934660d332609d7ad22fbe8b6865406ce4a1ba50957288a0a7a0553aab4bca09611a792b2f4c50cd9b40f53ea0b417d6e5da5492ee40a230ef74339442185e7158970b6fd5804d503ada4c91982fedeb24e0f729f37d461283cea2b35e4d23b058d961df6867aab22b17e682ceb2586874730a6302ee38bad62ce9e88de4faf5837637d8c66c7027cd09430c56dabdb1fdfd48287efff859ba2983420f9991f0009c50d5522db8c0318f5bd187f949808b7974e975d832efed1dec36fac78cc343a9105db953644449cef158a852a6556dd9406078effd8bda3d43b2da410742db6622e4888d5e48f714559209e203074b5cd60d6027a14ab1d066301a57856d3b12ae06a1616246275eba63470b361cf6b5df19e1e283be1ac0d9e80c130d20f197e133f98043adac2b3c02762cbd4e1d5c7495256bf3f881a6c2089d5928f1d0cf08c1dda217cdec7001c334fa77f489aa2aed94ff5d41d84349f1a1ef9c9f09795a3a10ea83148aa64b3bc6577bf5e83ce707b8313ec8096d9f3f2e2dad639c74293c31c834efbe1306cc6437fb7793ae891febabcb7b4ea00ce57de7fe9ee0dcfc8ea8fb49d7a4e6773b3fb66aa4b8ac176798235f9c3b111016b4d6e4c9c7572c68d5a3ba899f56cf0851bfd60980f4d226ee69758bd266bc547b58eff0a39a0a1d89ece6071180b0b7300f8ad10f78c5dc7b0b1940753851a2a2a8b6a93efed7e4cf57962e845bae925cacfde9d6acdef72575b8b15a899c2c956728df7e40d25322bc1f20df932a0dd801de5e213fc289a44711e21ce21cfafddc4387e4684c2c6b6cff6b90a8cb2ffb7f0b712f7742cd94564708596810e3dce77f50084ae0603b58e4ca81bf6034e0811dd46514f01c1e215d975cab79a5ebd26b82defb89993e99156231b874a896b6681387ac4fe4ac59b4e157b95769dae4671deccc3b19a062e1ef8e049e820f3988fdfa6d9105bf8e2efd067afa01701d4d68d601a904629bc7330fa7e20f2788c722a95ce1268b00d0c2261eca9022feb13ce74bc7db2ecfd4337583dfce0574bd0eceaf233dd8feca913ab61733a09d95b8d5cf659a743e1d1839a98961e533d7cf6e7990f2e52be795b01be2fcabdbce234a3d28a011f85a4a925ff3afd3166576d12ad32ea6f7fa37dd6526e4df8c03175b4c148f5c75a2d3275c83c42da57950f6d2399fb71ae18b473df831026c13dd78c2be117a7fc9a6d78c08ec7003c9eb00207c99e6bfb9a6b517af1092db23ab6142b3254c48f4fff91d53a9053050e17cdd4caf2f4675946ee11f858d5e2af5b8a6d7e2ef872ab9c4f36c8ecc163d48c506d773790c61f03a562717ff3fe192371d8d066b002ef0949effd4fae0cc03d4c2d4795b34771e3a19c88335f66e6eb7b1b1d961dbda2d7bba7c80f79286bbfee1d5a173f15b411e3031f02dacf0da01fef72cdbfcb953949dd5b6640d34b00fc0d04bd62d12cd26d325bf7236cba4b0c0c2d3aab238836ecc41f6a5426c6377d7da0e66f2ac6b6737493149558d6a92c02dc7a328fd476927b0705b39e19094735cd28a380bb9057f81de7193878685713c09a482115e5c82eee08bb994206fc5a902fba04f6a781acca8bf9e93e52d14a453c85dce557e4d7b3a3146ed7bc8df39bcee3ba93f6b950c18b4a5e581ff66671cfd5ec8782c75a01b32e5b9e21ca2912df46d2f33b47f1a6a9501ec5eef00e3e97a1d4e3787d84e579390f20a32ec5f947a01265b832024494c3a0ee6d0d64fbc759570581e2082095858a86c6d646f7dbf1fb251f9463587b8c77777445362aa6701257d4a9696dfec864feb1a4ba01ae8830ac8d483ecd8f396a5532ba929e846797851dbddf375fc23c2257a5a0fb4cd41d46c7b1ca5814d25df4bdf438983f27fbe85fcebe1db72c06c220dc39907e498bce0f86e68c2d590ca8b722c06cf4cd7e02f7cebd5ac8777791c89a132d04e445688227bef636c8821b7cd5550a1940d02b0b43b4e455484547b16694c8a21c97bf1160abfa01efecbcd380e3fbfe289143fac40cf39114749ef1b0caf54ddc07c87042ba1db997586b07f24ade5024e974e85cf926342c2426c96b1c412de045b27d9c4cc7282eda404055c17225d5c019b7145a6455cb14571c9abf52e51b9622cb0ead5fb5b0bfcd260b95fc267cdba83fce96d6565b5dd7611ed39964527501559298e33cb47c8cd189597c13c4b7f0d20525fec348ccf2e4944dbec2830a89b8964612359190978ab916514e9bb8aa9808bd6420e667be1a7fb3e80ea470cb4e8b1f240cd2d234391597c902bd1bb06d7f2b93c9556a9da672b49e3d0f0193afd2c3312d5527dd05d87deceacb945dfc6c5243b16635dfc8073b5f26e954a3b90b7759d0a4500da96b274261742db535b5c8010c72945b87d584832a841f274824950919fa2b0e4fb7cf4a4488bd2321daa6d163256cf2599039d30e9447c9876a5a1670596de9c8c3a9410ce5f5101a35877ec665bac96cb502ab9e9bbd0999d95acad889ffb2327b4473cd630a014672dcfd97984a49b2220cc833d759037c24520052e24fe43cda35c3662aaed58f4c4a0a24177d6b960b4796450bf49ba254c4c00bef6f8570b62e391cbcb40bf8274cc8e3a2c7cc8095d6256686bdbf566495e446e20c1a20bd72e4febdc2d9deb7c15b01de8afec85fb6a3843ef49d3f21be0cdef10de102fb315f991ad3f7c2732caec0f5a9c4f06480d8c145aaeed4d96a890a62af20111aebb658d604464d2170aac249ff811a28581212f3d6a9caae652cf85ab59a03dd18b48621d55d4bd67cd4967119b38c61e49386919996ea48238f525b28b4a6294cf182c7ccb261d75e58e58b3c60c65afbc6e72ab5a24d533b42889dea3b5eaef80ed0457ac87844d92de786e331bbc0bdeff7d041b0c94697c37e01dc8d4c110d52d47a0ad8ae39d388609a9b496cd2166684637e1b9b892564f2df050c36aecf9f22fd81a1cc016945c03f8e5a7dc188805073056f386fc94caa2ea8f5956a780d63b678e273a5908238aa7b8fbd89fd110d3d38e4ad4bb2b89a6df0de79934634119fc96da614371611a2a867a31e49c1583520bb79664f0123b01c6705ffed2bc22255d9576c26f83c69b4943bf85e97fe1d3dd6c400452c3ae30bb576159b46e25b110d185ad86e6412edab455fec0b85a2921b61a0d4a1fcb758db48db406fc3fc8bbc1ace6dad6f0f85e774edf1d535ae48be0ae70fa6002072ba17e027b19d518e65bee21776b38fcbe82ef306fc132d4a383dbb6728ca488a0ba286c570171c914059853a9a4d5143f413bc65df067eed4a4dd00736eddb55709e82585857454409e657e8384a8086c1984e3b016d6ee774b53c3fa6d52fd921be6630b4eeacb7260d797e5204f34c01d9108729bff8de693467212a3f10f5c3f2c94a3099b4bb7558e86bebf7598bf80d9bb2218168a03c421844fbdfd1a40a1fdda02205670e8e9b3ea5f455623344b8ea47ae948e1a02187144594974a0991b908910b2f92b8b00bb734bd444bfeb6f5ac2f26560eefd49a6a2ab3fd351f852de3238a11002c35eefc752acfd37c30b8b290858748564ded45486465bd07ef1b6393994035e1b324fcf54e9c8df8619ca93b1da13f809a7fd45460529ab48a523bdc2cdf6dd830fb78ff41027bc23bc59479bc01548076c260799977fac892dedad85f4cef98e0e367731cb629ae3e532693c28575ed0faf7aecf130ded324f7d874f35c0c88dbf204321040d758f3bbc021f2408c4480a295cd86189d18f35ddb98c6b23a035f20c8eada09d59b501a037797e3ee5ab95478ac3417cd5e44d93ed86000305908f7ed6bfc44e704a77cdd3883f7901321684323b9cf1a517b0bae34569ac524cdeb4eb61013f5a0652e0680b5bc01c0a6c041f7d110c434e2858c576d249e86e6e2bdd4a0202a3a23f33c0dd089eabf8e2cd3c4b3a1c16274f651caa13b91771c9682010b585069c3bc606f23e603772269cbea2b171afd93a5e9e2203960e74ea707433dd7abe9bb485c89db7ee3892eaf45c74d2164aaa2f0cac470acac193817d2e9312fdd4899034ad4e1a417bd645b4b73d433871f524f78f96276a8c18df5e8f17ca8f3906765071015de40069cc1f1917bea1151d1302f8eabbc71733ebfbc1ede394756b9d12817786bf88e78eaed968f3896db399da510e2d7d0e618ca2d7a43bf3c78c9df7a161007ab7dc2256eb49cde6d44ab1dd30b2b4a756987066e62dab0f185ea5c851519eaf75242fadec45119d4593212b1a7bf643683f1e7d78c35d40e57f350f7d850dd9032d8e66de239ac1eb387789771d309170c2edd53d929529c5b4386b7b9e59f6676702802c068ca36d3d3aae4df626646ce1d88aeef8c2c17df2b5df5bb5f01c4d6884abac784911a86c8ab7ee7e8339233e1343fcd2e8027d116be3a9b79bb4fd2d56321acf11cb9fa620ed880366157df9f04d843cacf79bdce867f885769c08e801721c6fbb965686f9f1f8bd11c49df4dfff299436606e3202f01ab405b40e830fba8012a470acabeefaf715347be6e24c947687d1c74bc216c2825a85def1b77cf50ddb081ece40a9005b76653ab754caabcd9de2345781513ae067f8270118142126429672451503f8a41632b1a9e2a73b94e4e507a22b4323da605b5e07969543ca053860f2342f8535691688ba1341c65b8aeaf1c37d94e03554161a2d1cd500d2e2082cf8b387bb8552733778a96f5ad9a2ad50caef997d65f0a40c329e9bfae1db66568a6da69db375bfda1f633d325aae479132e83ab4a3f9b04304e41b8dcd37d2ae5bd44b89ecd93c9ccf1b88085fa0561948a81a266813a44c62e1b1fd7dbcf16abbd5b6323434551a8988ceb6954b32cad1099d5c99ae338a1e5c4094d80f9e8d4a8040fa26325bdd5fd796159915d3fb4dfb3b28eb0a16a1d7523c7731ee8e9a5a81f6f374ac4aa5eb3ac5b17aa23724dc056104cd8ab8d71363c20596a1a36243f4ab94099f0503820d7d588d4b743568bc335e8d834a6e57173870f5e859dad624962dc0feb929bc176a5ae2ae0fb80baf75c2baa86ff3f49b13b7b8ef7873827af7860ef6bfa29d6fb25bfc146587c4a5886a0c4c1c0898aeb7094a0d7225ffe4d8cb6e8e9709bc3c8cbea21a7a258a7012e1c914c9ee324da79942d00e0b189844a67a894826be835603052cc055ffe1a4e1f47d54eac1b000858622907599ed34db68fd4aadab8d3e095880b266a7bd3261e12b950db8f146dd497251bfab1bab2fac372042e10a1b29897118fd0842f75e568fb4bd185185bc867b123b2d53bfedd91768caa2f0cf89efe07a16d56aa0bd0e29a5bbec314f9eee97466b001d45eacedea9c9fecc664fc1ca6437b383c9a3f14d429ed041e44a36f1ca18f2ee9eebe7b7b2fad4470b886e5a35eaabec9db80fd59118f2c3e367a03eb8581a21adb398bcf911fdfd46bb6ac821bd5b665cbce87f887eb4baaff0d25bb3af403f94e72d544573b54d73b69beaed57291070644e8601de17fc37bcf20976155c102e19ae39bc64cb37d3be8613d603d3916fad13845c1e7a1d3f8940d013ded98881fb7bfde2ff1688877807a1ba035598a8a75c823f036fa88fefd91ac3d9f5800f2f6b014406dbbe848343d5b3102299abd336b8d5d550ab2187541ad17e3a8f0a5c4baa0943b2e97f90b62be788fb9942681ab07503606053298f6f14ccd52ab6f2819d16b670020c2bef74d2da21c884700673455543eb8bbfb9a572caf1197719c5b24f8ffb56162fe4d7f62f652d4c1c8898a83c7242e578a8774915f04b973d8dcc089a0925b2abf002076d1f19b33230e01524ae4e4637fa181f4302ca324454f0db32c6cf79bf4ac4d06a2bca2c122fd78284b4286317a2e925f6b072e8858356605013d838a6b53b2704ff41d3cd556e0ed3c94558a5f735f57e32d94f3489d2df5be9bb574637e858fc7e25b593cb65819d493e5299d19957632b12cf188e426e9941976505c83ca77c8aa4c6e376a7cc45c85de5c4520131025dadd41ca848ec5b5ce8e6d7a8c85c92f771ba1e25e1900936de859a193f6046275c8a07421578ad4cf1ad1f0017f1c314daba88ae05893d849b883dfd46831d9d951f4a285251005c180fe3e9e7af09ba92058ff46fd64a00a914c54ce12eaaefc9988d34b5e6e2e2efe64f8313d04cfc30d05b8639a7606e446a72337a7741a0ba72b7bfbf70cb1fb67915e858e78b896fa4cd17d8aa3b0d0c9a7fc863c02205c5846f9d6360ad22a42b81cca66916afdffb75c8f521964bd070f18d93c45b9fc01c7ee1cb84ad51fd4ab4cecb94f177749e26cb41b28245f65b58f41e930faed97f8327a52b15e4d92635e84c359e2e2e8de85a086e0b26a64e76017e72f909ee78462de7511ad01c4aa1ed0a0e33eaaf1f949a93fbe4c9000f4a964f95066c5087491a69afa640978adc9eff747d87c03316c46b4a2a1a0cd1c3a5a079dbc59ec33646c3925b7c1a225fcbc61d4a13c9b48e57582fbcf2e67d882f65df4197410daf52b1afbcd7352bdc121516fe461656b3d761811971cb6baa06d2c5d95c4d6124b3b9b56b510a9c921d356f079c262850071629503fcc335ae406beb5524dec92075ba99cbd1a880b98694a098f2f5b6598e01609b43247b339af3e247ab47c456626c63cfcf0b002beb6fc78759d4a0775405ebd5de19c4bed7de6d7439c315acbbe3d1dd2cc85740a05f7dbd084c6c86e009d2b1d24596c0c01cada668b5df4d780f865b5bd020908db6dd0aef084194911a16f593bdb420a0029f94c4c8dd4142fc5b7ae0948b5b6c3e2624a366276ee0bd159291c3fe3e6b28ae58faaa2ff3f47557032e2de4583cfb9881d9e6d19510b269a43e12773c1669a399d2cd9dcf68a6f7c959bccfe9b0d86098a9490b9e3cd49c5bd3b84a076af506e54acb680d191461522931081689e15bcacbc2bf5942e14f3cfd341244e781aedbc32401457afcd26c575ca4006eb15863e14e3a2e24ecd8c5c1350260b1ac9b7603d9f0604f12ca3b72d5e0bb35e4d723a2d0c222ec17ca84ef65af11eb4fdf5dd886c04bda2f29b5d89d7f16b2d7d3baeacde0811ac503214fc6fb74944828bd9a3cfe1a3ec5cb72b85cc39418eaacad4e6946f12907b6d7c2fc5b9bb1c49ac9d53e8db5f085b4cf410111cf440299ca350bb530cf14dc983d957cd5beaec849158a145537d497509fd620e06541b27f2d3906c19525e43786ddc9688097b089365f69f2045e2edc26070637f297eb994398085fdead9308f151630130019b6a1e2b33399ac676cff6ca58ec5332c2ce0ace330d8a34ee62e00d900ae46ccd1833d373072ce870e4cc08966bf329c0678ee0680bc56229554aaab3960b4a3830f7804e5b7425533b78c180f28bee4144946c381cd60a0501672c280d95a04c315716825a4d06c5097282b23961baed24d4d17097fafe8fa9d9d4f626c679c5b5f184daa7bb014fd464eda7899d88775940c903c3b7887ec95046c6885bb47eeaaff73ed9592f5b5ff38238f0d83de8b0438a02f865a3997434ce82eb277383218491c5698bc5503fd7a8551b11ab3c1ef30ab42464314ddeaf5521186d28fb14bcfcd1d89ae3563b1c160b8a80739774b35b10b3aac5dd138e6ac1d61c0572793cd0e8b762b0218c7f7b60ce4cb7e4c906b2ae093737d9a75a0774c601b9acdb568844d21a80d0ddd6376e5b9be62a3988f180de118b3b9e6082caf180f9ded9d36a34a62594fdd0c7b08026e0177f1cc8706fa232c177588664694166cb9bd48c04c87ba22e4c963061e0d8682cfdbf77abaad54c04a596b4230da3be1eded2182728753b620fd407288c6731df80685e7be0b2c07d98eb8ee0578d7f7b8ff2730e3a2cf8e49ff81582f4b456709c10e1dc36a33030743e87e9cde20636a80f742524ba01309454bbb757fb3fc68600c2f1fe03aa39b9051975e911ecee9b9a45e1a37a551a4020dd247397bc6bc9ef698b40658f61f2f9e6cc65b7a1a57bef8a4b19f36ebdddc9d18c21bac202db787e642dc890230b8d17cbe879876bebe46989154fad8ae6673d5dd32fa824da2bf8104dd36e26548ba845cc9352f456a8e7db2d77bf6f3d4d565ac30def56cf1329107f63923d6805c0dfc441c1fed5eb849c69a4213e97f94b989a7b77caf1e97f79af3a4e0720f88ad663b7ff98888c89958b3b7e55a7ae02ba2801ee92f3c506a46ba0989acae9021551a789911b6031d15868f811441b41f44040a72490185b996ce005dbe48a523e728963d3d05c68383ab7892fc864d6dd79b2c86e5da998abb8a43efbc9b983b9ea1120ec187b967b34c78ac11643c739662a9e8a282019eaa54f92ae419de84aab73951b815b2573a2401b1411cb4f3d05a609c42b6338fb02b99bca20570045ff80972484cc49778c48374616d64713559a85c8f80269e4c3e64169e1c82d47f1242de7cd365b73196727cba0c10f0792cd3c7091a0907d9697c8217df7e4495fe7e5e579c20ac1cb2046564a7df41d92d3012081e37a8ed4a9332e5f8481a11fd32edf817c340d35e11acf5a4681be73591b35a16f80dafbc4b678f3da4eac2c858bd9d781f8b48841955db01a15e1910b26ba68efe499aec037f7629ed35b3cab1a5b945ed38782a9682f00612383daaaad95b123f79739d056a4905b7abdf1415b9558e0b96ab7326a0e641120ccbe0bfa65271145128060ce4dfca4ec32d284afb5b03d4b99763d7475a9579090f9c7db4340ec66b93f406d04c268a383042bc5fb57c2ac83fe7fd1367f6c8b2c0d05a9a42b8da45c313ba3afa711a1eeb139547b06f8cb006a7ef2dfeed4bb535599d67567d919a544f012cc4f494217a1e2c8dfa10dc5ac2cf227efebaeee3105227c3207a1290b81ad95e964762b8050393501b91538cfd023ef29e5a298ae4ba164fa6879f598b15e1356679321fad9df79fb16ced5570a490325c76a4ad2b64c9a207812bd2dec75746a2e780cf62091a67ad7cd14ad6e8d6a142bf88010ea0c76eca1b358163da9546fb664a095ff26b292efd21f1b065d60f257f9d4a316d47af816821d66b5b81126b27852d2dc1d6a70c8ad675ca5ded46d6dd83f89b19d0874d9c7a491607c9f131b0d750955ba2546582573cbfc46466b8824e881174ce60cafdee18c7c6b47ae98d997841b6042709770859e21848d360bc2371d125751d831ea75dd84c9fb903513aeb76416431a79db352976988398e26eddf8f0eb9d0d0f0405dcb1ccd08d15499391ca3678b369ef7668883b3e31a8f666fe96fda7e3a3d207229222583fe6d21d04fb7e3d5342d62a94422d6c2c8983d54f21e339d17ada11bfc27238b16cd23f8d4ccc1ebdd26eca0753d022dad2c0242c2fa3ecded1ef50eeda8758ba0008d91275c16a8838f0e4eb1a6c35316f1d2e06b578e6c051ded72042daf1ddda88ed3f1477e5dc013a33a2c0d39dfb8dfd14fd4d3f8f17a410fd0c215648418f92bce63aca7e2fe16c07b5fcdd0f56778c39c0b8fc3ae8902c88101302bb0bcf44ccceeedac7fbb3af2a3c21cf8bd04668a832a107f095a4b95db5906aad8b46c8c472ac667f17766469d4349c1014ab56c4e3530357721054e3c0fb2f441abd615d1dad78a4fdeac3a822c146bc2777fa668b9a06263bd916fb1f06b73d1f21fc2893cc7831f482311ff07a738ef3a49216f08b66f35dac5d5fecdaa16417b4451deb4d1d483b9047e58a3bc61d997cae6e5996b32d0209fbf1755e058ddd30e881810a676adb2c2947071b4058d9303e66d953bfed4b4aec2d251336e030e2a292782ba48f00cf530bcc999b646be81542dee17fec72d67fa6c6c6c005392fd85f7ee0a76213f473e6174111a63b381b7daa0355bc559e984fd90a526ead8e9ac774a3049626c15b32b68ad001efb5a106118cf9e91519f2a9a3553102e4ace0a05c1ab94d420e02e95907703b9f551596b6aec14479c5edf635a602a8d533d5f15977d2b53013678b6149f1484ea3d121d6226bca2e633da12607e6d4feee27438eb956d24f72c8371a811ec3ae5eb509534fe3836ebe263b0666c4f95d987d8ad26c63e65458401fc9f67497dc41510e49c8ae93a4ab936a38e8b76c89f27245ba7d6f17694ddd076bb5b1bb55cad0c5f06750e1daf927831b7355787207666311fd87d815a81e3b889336fac1be935004b1b6ae7c13a64f30b1d51ff64289c7807263cb4674544ce6e20fe2054368435edaa16e04924b53bff5297e9b028a957a60ce7948f2365abf4cbcb347f6fca119dfa88b40681c3481e1d7cd9bc8a744fa8bf37bb69dd8e86f16efa907910eb3a032393de0c01aa05e39ccbd48dbe3946b0e7c4dc004dda723ab8213f11a862c78bdce3368c3ee5033e263c08f970723b7d6fc50e82fac3355f8d10d12ca9acae9c271296622e7144f53b19c3341052c3b1a9ccd0d5e5d26c5e412e6c1fb7e74fbf9c382278a05cbee0131c91f1cf653a82a5e4d5ca062db10c872d6e48dc03289dc7fbda4b86c28a597fd9fe8a19c658cd25d1809a5e87a94afcb293dca16aacf27a883f23719f1e52b5b7c12d2f26d32a40f8e7cbfeab96a9e32c70a9172e0f4b47dc653119ed0c25c93bc930f30cafa69bd994a0d5f459abb300e4f241b60cbfa7318cda3336adec35354e09008c8dbedb72c23765f7d497b3ccabc05f372eeaec52678667414ba02f7599f76659982a5b439247a8f4fd62e32c1c21ae6b0f8c22fd17a3be952f5c549b0cdd2f1e4e0507cea2a4555c9c7fdedefa348e327153ac511fa584667218174f128d14e3770ffc862ef3c50c1d5c39e181ab293bf94ec8041b2ebd3b79bbe30a057b32cdcdc3dd6651ae6790d78115ad2820c598668cb011bbc8681a01effe4b9bc7fa6f94a143be9a0d5b51a0e23767ed933ed0c4880e6a3e2f0691b12b0f2297c3bd1cff6a981a31aea82f36badf07d966d8f48853e09be9426438db88ea08e6e9f99b8d9ee8e76fb0a3bade8b6d8f1c4bffdc701af4f963997887f1499f74b36e3669858a9e7af4b0fe30e4d80f3e331323d633dd553cbdd9298d616c3491e766ac2787a1c073e5331f414e48c334bbc4dc61a05b362440676cfba433a0923109912010c1965f7db495b3c286b1a6fa71498c31203f8a4b205096401c9f6cb81f4ab5e4be2809e71b92ac228fe7f69b705becd97b4c4b0c92732e83c4e55d0a2e3e7e776984411d5900580cffbd30334b5abe12ff213927961b2f7e64b78a2e683b98a85175b97dab3cc523f7bd7e7bfe0ff5fdb99282e3a0fd5b4c2e61e94b4d3d8069ec3808ba1c3c2ba3eb597642ee7ee4c6ea5a22bd595ca21358b659f7b6ba352b5356fdd5ff0077766654d3e2c0ec2962af8cd9661c781a35802eebda09462c4956c6072edeeb427a35ec536a59d9db946e068f8086d396f53d590ffbda832935b982eef33ec878b3449b5c81c1b158f65f6d7c4da8ddd9b8a0778cbd99a96f19fb505f365aa23849a6e82c66bf9bf19bed1d3f80898c54bd338955637d03c516284934b8a1add4f51fed74af2e9ed749002fe39ac6b228fc90c70f0b8e3d54dcf4eb23ea08c8241893e6b8e8e5fdfe3101c57c002e2ddb779b11b47ea86762620370dc7a4c10e1ef3dfb37b328bb15c01c87146efe27a943a987456c7d5f3efc372fecb6aacfcd6bf94ba09f0b6ca501f3b49b651f270e696644aff443879ccac6958538c56c456228c781ded504c245207c743cf29698c7c7117e49486f346bbab86c94e4d9d4d1698908ef5242a969bc5c883cf26f810b67995e2703152296b6ffbc12b55e88f24eb1304abf3c191a9d3e591a83a8f882e5c541f85175686712e2c9db7db130f3283be606291b820968fb8f76f09d86c9dcb915d7885c7dcd6369399ac2bde01c585441e0f3e313aea0f2ebab4846e982bad325134b02bc7a5a77bbc00396b912e9f2427d1c643f22decf29c50f8bd319a566693e749d50fb6c439310e673b1e103c87dbcd43d5526c67a3c4c7a2cc0c93df7b950d917ed48507f975652c977f912facac4b68e53577fa065531f3dc6d5b3b72db966133c4349c90a7fdd2cbdd3baf6021f2089cdfe45c7b51a6fe70fff79ca5599ff138eb284856021e25c5d9f49fdf3cc1a61f8592c2b92754db599416d3b4272a07badd8fb405664f56f46046f062a7ca3e16ee393cf4ec1ad387b95920495c1be13b175f5d25d1f45b62a1b04dd77eb6ba9bfbb1d7f98ea04ab48f0e47caea22945178ed0da03b48137e44f811cd421227a1fc1169d3d0585d16a98ca59c66c489b54aaa82366ba7c4226d7f14b3d23cc4a4d326a9275179ebe7d8397f366d22aaefc9f72777576d5ba9a770675f4c25ef3457a79935cda6c78bd6c9c3af4d72aae153f0f3f59f5ab11a2 Hey, password is required here.","link":"/2021/02/17/JP-KN301/"},{"title":"JP - KN302","text":"8d229d8e47333d3f189c47d25637efeb5cb93a79968515e30e77e9ea060cd38b369142d174715c10e854b175b846cd04fb7976f5a1d2272f790cc55ec0278e483a2c39a40e5b7fe7d9b83a74cc3725bd9bd77937b0638698b3a751576ccc52e503f51360a94fbafd172445ccec499935f075b1a7a224844befe5ac245eae6315d7945428dcca7205555296b1b2c55d61b2259cbcb250c7aaf0b7746990105f92cabbf0471783e778f1883d55ac4250885e29fe0a243b0313a65d1c182ad68d69806fbb7ff6d1c69e67771f29c414e6fc538d8c593607531c74c6fe33c80ef9e70898dec09aff563290f91a9bd54593c611a3344f570e565fa2314ed585dded70038d54e52d32b584e84f9a5a1e17362508e02328bf899d3557dbf95176476e0b2e2b6bce65dac699d47ae6429659e35c5700c0e37fa7ec0b77a2f7e68d643394da3e1b590ce51ec7ee63a626ca071461889bb1e4f4e0fe006f230d3687c52f65cf99f289029c1f585d493d2bff40c5bcb4af156e2ecaead600f85ce121645cee13bbaf0eb35dd74b2375c65f04bf6e1c0d42386b5e7dec4809b509c0fc76333579dd84f517f03d62e10d15afc54963aeba126b4528aab090a5a0fe2f2d05e3842e6d94c83dd99398d7337bffff3a825d9b4cffa25b1e080a1bab4c550e911133d46d5a1df34a82ee1b827de042afefcfa35dc8d8586faaa131efd89ec8038689b94ad80971316ebd76b8770b25257fc9b30459d12a3f05597ebc7416dbc9bd8a4b4039000e2e6eb879ccab0873853609c4b98137c5797804a359b5c17c5851fefc7133ce9d6b8d725a1ba0a9772b788df62eda78ba8a738cfb948ff376d354332a46faa08fd7fb952dc084a2125439478defad018207dcbed3881d4fa79b4e9cee4aeda6467e472e91ce529a315ea0052d2b7c3e0077105eed84257ccf96cc4640389b39c380038fc5548928d545c4ba136d55583ba64d1b39acfc5ca556b7bbf384a35b9e285b4199137c732901bbb40a5c39e3e3dbd9e1ba164015bf2dee550874ceaf514dcccda8d0f7017e1714621bb8bda2cfcdbb8825c4e289a142a4792605c2926a039fe4e24b8bd472f1ab03f46fbd6f0164f397b69d9185560fdf4b02ba221efb2ba0cf663935ff954df0102461913093c1e059ead5ee04ce4785596188214b1428c1405562501ecce47129f658fecf8643965d1ee2e2e128f7dbf2e6f8a7fdc0e0fb481bb8454f49761bef979eebeece4b2f0b61fa27ee2ec119a02901f57246878cb0022509f541c13a087bc1326b75237448ab02f8d12eafe818ba5b500aa797caf0aefe80a6ffe2c0f7fc7b08c7da963f2b0d7609eebf30fb3c2591770cb6a13d17305b45ce6625a3dd8a02b16eb050915221bfa31cbf7f5d1be938febd2dd110b7f18a4c99f0e322cc88392d6aacb29008682ce9b1fddcc72572134c59554c7674482e37b81c87bc91bb31754e18f47f82b0dfebd9629044598c8f9f33483d7b0471f9605e6a1d48a0df750d35ef5c09685b01a25f1eb68699d08bad14b08f508fe7c83ebf396b7851776caf898590884c9e063f6b8aee5116c7e23b86ab5e59d80f217b8c3e30105312b068abd1b6773ae6caacf40a8f491919a4868b2a21e9cf46c0ff7b022e6d2d57a9f5a57aa3ec0e0fae53db14008b95e3ddd6a454103061d11da6b5cf20cde8da2ebdcecb0951eb6aedd9a71e71742f6429eb63efe02cc063a2000e380197b2429340b019dd40be8a3af4254bd6934706c591a96f2ffcfec798324900d60de9e2f5620da41c607dcf5176fb451b6c6a84ee30a84616b1e1b5859478b18366b0fa073aa7ad911472d131fe495eab7c20d47a24ad1ac9489bb2b659ab5e4713cf6c388bd46e2d0973610116a9c6450797a9ab529e61b7025942ca475fa836d17409828d3240d09ed41bbbeb5284c16732111520f0517564a6840c250586ad7883ebad914f7e7211ccc6c556891190659ad91ba820b8aa411ddc984fc805b070ee4e307136829de9b8cb981ba008ca7fa11dd564f6d1cec6e91768073ba817f06f5440e8827d091c65a9139276b8a0208538ab339466c1b7c44aa3857f654904e86a69b63b6b641aaf8e9471015ab5bced063cdd4c094d5a567564d21352658a0ed53466fe56a3be78a4ad12ea911729fdc639a7079714390a48cf2b6b69150b6fba029d3618eb5b28de525a5843217bb74d640ea056d5e0479376344c3f46735c4a3991160ac73eddff5cd631a27e9882142fcbfceb5c2c65ae80c2d2fe07e1601b3f75703e9b9bd3e01c3bf76ee0c0672db0c46f0dac4d091861ee2a2a6c571a39f483c143da142667e4c78d0db90f242be3b4a4860893723d72c1806c513f8fae547f5140f766db4d3787a9abfe8a90edff0de7b0ddb2f68c95d667c5cc30d1203c0b8ce0d9abd45d279a5b515e5acf0b5118d97a32cc46d917b86733582cbf0654c8bf23fe134a7d9c95260aa6cd5cd7466e392af5b6bdfa5206c3387f8556f00e94bcc1d858e1f2d6306fcf18657cab5d803fd7eed97cb25a9fe9c9b00607616511994ed6c9437013936c7a9a06d60edae9ccbdbfb4c2d2e8f26d5ea94efe6e78934181f8e78a80249670d3e39b87b8911caa238ce2bee37233522d6f701b82b9aacf65e8dd2b85e6d93dff3ee43f6e13844f57b7eee2638f27e47d3a77a330509454b5dd2f8575340dd3fbfe348635498c50d88ab99675602bc0fa1ec12f23e0fe695e49e27a5a3ed9481742e5f84ee8867ec4ae6c6c4b7ec70c9d057f5fb0c8fd7b1acf39510234c370ecd5f873023cc027ec55209cf201ca94e80ceade90c83e85ad18d048cfa3dd45efa890b825d34c04b944a63d0625b43dcfe16fe7a453958fe8e24639a1215190ecdf0ad49ed7cb228fc59af7ef1596bd0e4b2ff33d962935b823d1a81c9ff6cbf83ec167366a5de7d264ec6891962a85c7f7337b8aa42fba666aa2da64b2be9091fb7725d3a8204abb48fb7eb3b6e1fecf721a8647b897761995b473691fd8ce7ec9171853825e7fd9d960ba86c997736c96e2cdffcf23c3f7ceb7e26d4576529c59f013198a6b1942f2418e80465347870a65bde03ce0c4859df2e80797f56649297a2502853f7bf273a068e742bbde3fd0fbb7ca269d99ad4ff5bb90ef4669cb5b05ad7f943001e2b6480638afb0331c8af4d710d2bbd826849800d2bba6d97feab8922193de35400fca393ee357ca0831b0d53b010315abdd476d7fc976d3f94f6c8b86b8f8bdaf3dbeb2a81d629a152629515c4bb5aebb95d835ec5840c2d1dac28d1b0d6454ba193254fd9d32ff00eb80059d46acb88d2fd3e5b6d9a446002ce2ad38eaa4107ea6347d004ddcc6517be39e20e4a755b2ba3ecf6fc6c22ea2a5f59bd9fc1346a932e4cbf7f05b5ee36af3878ccc1895b3043e2093914a52d9f0b73cdc3ad4e4ed15f653d1a521f6837e1dc72af15880cf78955db14be3767a51ab79caf8cdba5fbe7487014403815c0a3344990c3f06ab59e1d8a1848d0f438714e25b904dea2498c37e2136e7b1c622ee9db5510486d51079a367a755e4ff1229ebad820d253476c39040e9cc1e2de71d2af5fc2f70e1dc4fad911955e411913f658c803aefa95e6fbc55366eb1880411e77531b3aad3696e73cbdbf2e1f4c76be5d7a86f4ad96d67686ef3ede2bc15ddf61c283067b45e02b2e7ffb64153631e5581e14bea1a5ce0facaa83fefb8fa33d04fd08b58a7386e6f15e3e0fbf2b426b1938899e1f809367f1a2a552fd8a1fe4b4153f206e1c41d93719f7aacc8af7bfa2b3225dcb460207f17c7a10468c59df4ee6e8583e2e72df96f84405bb1e4bb6235e931b061c5190d3554be54be5e539601692d35037f213e2d8c07322b469d47efaff52241bb0c632eb9285256e2e5f18d0fc287dff51fff4280a4429fd48aa8a0b88699e36089bcdcc06c4baa7d50294144bb55eb9e13c24b82821e0e9fdea782a507da2daeae63a99e8e4333a2aa2394ece3b0c80695944df7ae109b21cd7bea7eb8c5e88a5db75fe6d4d875a2e1d9148dfc407e2ffe979b64af1bb34275c3a5d153f997989fdeca4c8bfd5d8989b9414a4f9b60fe36585c6c252dfa88749a93b7558f70d41af497015081ca1d7a88d012e2795613f4ed665d0bb038c4c7e67cb9a69ddf074fb2f11271bb0543fc7bb8d11ec326d80673286a2d8f450ddea1b41146f6e10cab7391b8b44cfe86ba8219392dfe68e4e43fad1d5e8f603997683cfd04eb379afb44775c7b5ee0c03b1fed85ff70b15c8aa1ac7d2dab53cea758aed3bf840654c75b0272265cb3a23729f7e42fcc794e0893e08c701fc924db12e6d2587709f97a25feefd56d3280dd5160adae1774c30257b6d2e3f65e1d9b3b0c2bf3902c6f1ec2f563f2858885cdcc558628f8f2217e6d5dea89da1e9d407d4847b728d1085561937ef5ae5f6c134a490c59c1c0a0efb0b14116022a77c53c53669f00b3ba4d9b0f344dd75ba785b792fac42e2f78678c6beb795e581e48cb070debf0e89f22a9ab13106ec759b566a6193c4e32bec09cb851a8046afc77f78e01d9f7dd41656eb4b0356771d09aea5f32fa1577635e5d866d9033398cc46c45ae9d6662a234d4cb85b3ce680ac7e43d4a35c6f124de62a274a6f1be3994f86dd8da3dc7348bbe73daf8f358b3bcc63faf1b96f6933474cc58f55563fddad94371a38ee875d18cfc83ba2d9ece85f4a1b3c4c2c260084df40ad2fc2c1b5db772fb45fed922bc5b382fc4636a2c2b28249c0bf4f4eced2ebdaa124b1b6bb12f8bf5c5622481f549fab5ad8e871dddf21bc28d2053c7192ed9b28eba0a76f6039e9a999b55c000ba6a4c2c584829db44278fd95f205f8fc8803e25e60f4ae27011338d562caa37db52cf4e8b49ffdf9665a11288f36c0d5fb43d77ad75367d4033c15c3b005b733878806e51e81dfce295413075d3573a985ff068dec84c8d34cc078501d6c7c8511203e656b3976527df985c8f652e8b01d401cd54bc5be32e65543563273ac0dfbb4e9d3a89931fd94e6709351222bfff4416cbf2c17cb89450f5ec6fe9f1f359cbdfcbfcf674b6ccf1beab528002a4e2818b1cd078fcbe2bdcf7dd92f9b82b9619e17a926da86d3d724d0af71fdd094dad07d0c001b932328460cb5fbc78456407b3aaf0156c7e1cf5b0290470743b6cae89a834a4b1e09afaa40ada2359496e11c73ab718c588d7c323e59c719b8a64b51a8ea66927d1785f2ecaa225a3970c7c58152b776e5c829f0bb1a6651cf202a809a03a61e4ff2b600a114944cefa1f3ca9146ee6cb858e738b455985ced989211d5b30ce4198a422bb7fbd7ff8b08adbbda6a9b13e44953e7571dc0418d5f1355e8de57a4460ff001a20fee32dd0440f56bbd4753074c2ddf8ea3ffafd9429606010cccb2ced267e396e878684a7ec366a15666bba57cc9474bd44701356605fd35df2857b49d8430b58c94471d51406618e83a432aed5565540365bf7ab34c097251fceee411b08b5a7d5dbda04d65efb6861d6a130df4347d8b9c77bf5e46ed63806c89c0f673221a96f524fdd9b08f5dc5917a141ec030e4cc1675ec87df5a2273f7426cbab7cd607617279706d55dd8896d30cb69a87679401ac9e6ba49ff767b4800ceeb98f9c918e6003abb483998bd1772eed353b0641c044181c70cfd33a49ef152887420306ef894126a056e97cd6782a3afedf10d6f3f399a4da1d451e61f5b29c502840e372d7d862cd7bec039fe85899cd40592bb81f3deed28c26946718919484472b1a5b0e06d1adaf7d8b6390fb91efd03350bf51a1193ba366453f2813350155fd9f5b16f6cacac661721fea48ff551dd26e2b152c1dd389d2ed5412cf46dd0c2667ce63f2fe24f0750b5f16ff5a4758ac7497e8fd2a6ae77543d4131eb628fd4e661e0447f67715a2c504e91eb84ff2d12c66f9a1d645118f17038bf214ced16c2bf782befd4e334d2a24466826c1277a42ea0fa4bcc6c9d5480ddafb954533ab5c7b372cf4c573c10d1587830b8bcf670740951316006ceb7b4dbe84336046fa2c9bf877ea5d2ede1c41625a57a49f7a9a1ad40e079e3a7f51d632e0b29697367ce6c7a3675cf52be03bef507d615f74dc153fe641e4e4da8b79b2fe4d9ef4f3a76a9a165f9364a98147e9d423c506404db1a63b2c94f7cd865ff3861fd0c5ca5c20d4625377a9171197b5558fa5f03b14bffef2e36e4aaff29405337a7cb636892433b7e4a7e8a713e96ab9eb4c1a90497bcefe57c0b43268512bf33f7063ae63a564ebd84a3923e07a5d6e6fa823edc49ade859400e534efdd5aad503f6566db3e3c61047dd982506b07bfd39a467c2d010907f7d9e1f6df127b0e79fbe7539515d8df7a70af6f8d6f688057a9f9b3ac62621ea97af5308c5344f40d00f1f785ac8d0cbffee92b2e6f1f4bf0a51e6d235fcc2bda8f37af661ad6cfaf5f3c3982d80e8e1f998ad3b6d97ca54d649ce44aa385d7f39e18799372348d235e3ffff346b2b5d12da6911fc5a2f173c30678a662670b72bb8dae2659f46dbe8eebe8e150c6eed4f9ed8ae86b8c57932d949b085bb1119c3e78ab380a6c18501684ffca1212a238b85eb4396b405a78940e4d4843c4b77eb2b07f9fc3e38390b5a1b3d8788fed1478ab409e843e756bc42bbc1d1c9477142db6004742e74741fbe5200e427f327709fda33dca264141e62e4aa2c1f8c99504fd0778d1d0065110842e16e6795c7f332a1b17dad6869fa09e812b545f6ca171c9d2da1ae3b7638b5666311f486fe8337bf21b2b268179088405c9d55969f37fbbb2ec7eea84686e10d6ee4158759de3b4cc95667e6a69cc2d1ec8266612554184e2098bd45fc7314577f649095bfc3b99e76ce33798c711caa1d0ad36b771429af6300089ac17d13c4415257853862837ca8191aac2bd29bf1ec0c0448587c0b132f14666b3470a7a7eeeb6369045dfa1f87d7de69639ebe73285ec7711773c02532b4727ed179bddf3e6ea7d4fd4a50bf7e2736b70defb3568d9d5acb1d0eacd236515a9db9f475f777a409cf9369db9d7bc3c6e583e9ffcefe754898a94724fc4788c8898195d89c40645f20a37955749003b72376936d4e830c1d9199ba1c3f586c424044cf4c89c73bde110b514220065ee482240c1ee8f465ea486dc9dd4e87a6f2908250d19ad9075b38774b174c6ee30aaacacd17bb8640e961a9dbe92f0df8d3f6fedeb1aa2f853603e5cb663bef5130db7443e498a61325d0120cd340d2c70d52ed2b7063fe76344d837b1f7f3cbe46fbe591568a7bc183d30e4f4fe5ae330dcfd350297f2c3bbb9c14aae2be6097260410436c4b8e4d8b5ff29f330c623ad7288cb61349350fccb97e310378a8efb127485240b04ee594404bb3d7ff819cfb4c8be254fb30fab192a43b9d6ec36b5d8b8ce73b5374cffab7c67064326e5a81180ddafd48e53600f1212d95b724582d87fefcac571d16900a33dcfd4c53cbac73f29fdab0db70d7b9e28dfcdb0666cfb7896b41f9eb8f8d657beea082e550e754e7fd634af9458898cf3d2417cb40f82535707d26060b5b8318788e2518dadad5d482e5c6282f93f02ad8ccea25c0022000f744c81c07d373cfedda4f046c0cb2fa7bb36d08e3e665c29357980ae7b144e6ae7ae3915551a85c498b5d60acee0a96285cb88ef329d57715c8b81fea30a71cda2a18c2fc820ff5153e765e5aadbae5f97ea3d611446918c8b16b67fab9cf186a83a1e4daf7b71c6b43c3bad71d97d242d15027ce24c549db80d3e002220896bf1a3acf14048351b25c4cbdca6f0769c02afbee49bc967fa3b2eb5dc212e4afe1b1c58787fad079bfee12dc827ee55794cbe0045c22cd6ca66b1e73234e18f802e7e55462d98ad95524231e29f5146252e9635b63a42d4f2f36622cf4d665d70d9cadf75839903eb862dc0146a96e2934b5f119065c12c06fb7f09104041542c668078b2b3128b0733b59f78bfb4a2371d55ed8eb2fc8391067fc94872f135b294ac09d22c2c06fff25a45b5fb85dc44af8c2c4b8baa8fca8c628f4dede7ae3cb98f6ce76cb79cad4c07703b38c61cb8d461f05e08149a617786e9a61fa98e8bc98b69a9e06583f5b45f2f101f52972f33db2dd2d60e9eecf1e06dafd59dd00bfb576a146fb3a75e18cf6ea4711f8357336ee0ae557ddedbafde862c991284a95957991cf2faf0fe71fcea07c5ccfc5045eff517aed952267aa2480f9e02c3aa8a6b668e6fba29dfede1ec0fe6a4b1bfd2666ae29f3dc43ac903a4a0afde2b71d2c5a23e4d7e3ce092fdcbee71520d9251822288f7cf9b8be592f273289f82f0faa6f602382f31311340edea23bf7911c460535ea15ce6a5aedd1981d16f6e5e9b2a844f3ae427e08c817d8eb2826fdb7e7391de145aeefb1ad53a8a57e59426aae026c52f1a8b2f4e06fa8c6d3bfc94fbf318ec8b23236d298a24f035806626f89dc9b964e560fe4c5ddbc5976723c13cdabfb433b626891a77f51424bead8bef89c8b973d0ab0c552b2bf8ef528e8dc6a176e72b1554642a370e47348dd4ffbce1d6081d75696c95a1987dd50414c17f6a4ce8126878d7507584c1294e15b2f9c54d3a9ad2fcccd152ed8ae95a525ff49ef82603d4138a5e63676acd65d3c6205b9a04abbe1f399cdfd080cb582c4c2984fe239108a75980ae8b3a5bf9d59350453232d93a0db2d2c177a4aae62033077b2766692abf07415b5bd879d08f715d3e63c3c1e645eea1ee56554954573c432326ab79cbcce9250c288fab4173457b3c8eef3b2d42864d8ed8f94a4547cbc69692081b986f10a3e7e6c68a639a4a726a9c27c46214a367af91e1ffcd252b825dd760d2a537464bc029698eb3022a3710ce7e555ba255a4d3311e6bd96cb68a02d502112410e4728dbe28d8633803cc7115440c532845f107cc80a42b508e42ec6943df4ac665126f1ab58b2333670c5b7a8dfe631baec10f58ecdd9c53e1b8f40336215f2ab71d59f43f2d3580c9dff37da6c7a6fe17b9d0569479b946c417bfb491bca86f516883e26bfab7e0a0f45e848d896260b445b66ec7c01062ef3d3fb663bff48973872e1f134be25dcd6e1c44fa25bf1fdf746b031c8827bffb5bae388a00f38740ec542db39fe5bee9712a87f36da80f081071b5b209adff46a87c19ef9428ffcbeb7bfffe8c809853f0a7fb779c1141c17a892589e0cc343623bff5d03085bd885c7291e82a48b955a44e6c720e5376479ea7ece26571dc51ac54773ad22d3e2e982b0adba36100e6bb20993c76facdb824b4e8a1d06cddc39b90d73beb6d5941105dd9eaa5321e31edc2e2e8834f500b01b2ff8e56e2bad0ecd8ae7289a1390e48e0b1fd5d6a0938f28176a9456467778443a6af5f8350a00773abd2f95ead7512374861578efc49e185cc01c38727c8f2e1ec904241f0f34ad81b0fa3acf9f05c167abb4eb63359f503c36dbfee1a07b7ddcc2dd665d519c54e47630375bca8356be2fbd07e7e25fd6f52821980711ab59443292252ccc7dc2bed529cff0a0232a828caed5bc0f9c0be8ff7634942451561c15d68da1dcc891124c96466dfbe0ef479806a7271d006b323fa20814e0885e0c05bc8cde3a2659a4ec46d886ef24bbcdf7cf47bd758860e797c0d0d81131352045d1ab4e0e0f6d3044a635d1238ad3c87f5f06cd1a3987167981ab4e22f768514f7722b7d35149cb92c036102235db35f85865e924c108abe8735bbb3925652ff30c7d384707667394c673117b98e8b795eca97d9066e1cf04d797482bf75ac6dbfe6cba98992f54dac3ebb5c62deb1d28153cbc804249d6110dd94f4e7a462164150883cf998eb89cfb6e370056cc5f54105d6061eeaebd1d3c3fa822e00921a4ad253175b546076cb68f5725926c23afd986d0515cdde2282bff9b1d0e640f15e1ef7ae87700796e24426d58c3ac3f5d7552ac71b403ff25638d33ecb11843da817b5ade9cb92397a0ba36a0f1d3ccff5ff3bfe32f93f9f20652462f6be80754a2e2c73d9742b563bd5f6b2a1895200d28deaf38812d220970069f7aee9869c9539335df8ebacdc315a3e212cdc12a6b7a1df8887cf242e484f6e0c4be28f894e22c569bf0604128b5eae9f0291e0ea41186efc2057734ca1199c6b742ba39f1b8f85a8a5bc8090f713ab6938c3c22faf120a60a9c949216c4fbf5c75f22b947a7d72710043fc08848a7a3bb4fc6c70a20af0ce64bc2d7d6dc4f6d4948555f54a0fa5574f10c85b3555b39c81db3fd46737cfa683eff066de30ef126fecfb39671080d415b71ba85c8181d189299e46504baf484764fd8fa396b9cea645645415b71f6ab54ccfda1ba44a9c0a68766f62e8658f8fc5cfb6142513c0564c5596079bd4eeca15f902e4418af33c9af56b1f8ed87af37f37927797051d200ad901720e55ecc129cb8e6815c595f244ced5c5b81ee5042664317f11af2bb4319de5a9f7ac9e51a657538958b03d32145915ab3d6155b9b21aecae576f212d7d5cf60144c80af7513b882645b95a32fd419632a363f6a6ccaa6a0f31a8133d102f28dd82eda959b56850d65a4b6b9ba68172afab2a011bd030705f0b54e9b2e597caf1e918366802ec32b362b57c8cceb17a24acddb722dfdfd410b4e0b2e80a2b17276c9208f9d72f3ae779b282e356faa280e75e0b495943bb869ff38646aee0605deca2a6ce333c9b6d801d4c990be165b14ba625521550aa00632c1c915df01b564e85b417efec2200257573d0e8eeabd8f9bf01413d445104c1b36f3b247cbc9d2386a2a35bdd4d6ed2e8a469eed74ebc45a015724d7baf32990eeb6736749fbdae15dc2eae Hey, password is required here.","link":"/2021/02/19/JP-KN302/"},{"title":"JP - KN400","text":"8d229d8e47333d3f189c47d25637efeb68979f642698e19acf948344191b8ee182e253d69ce6fbfe5058c5bb5f3f2d533a08bc904db5620138d186b79f855baf69dc299558f683f2594c5cc09724813822b5e29e0b62c74ada5bfa88abbb8b9da0c93b538b71536bb03132f3712b681cce03b049d264cacd38d6c67c35188eb3fef9c0bf4a0473c79e36ac56d2ef94651e62ed70178f4185ddd0b52d687c88ced35004fa8808b85d722d0edd65dfbf937e5196bd65356d95dfc84355e2335a69c58705b99eda875f615f7988c868c18258df3217d9dba2b4f3565f7de66338bbff025efb7c21c80a6dd69022434a3192d0b52b7556a5d6add9e116bececdba7bf86322c75b4f0e0aa3442108e5b09e3044ed55b51f95e9decc0b359cb127c4491f0187856fdd2ab9b2fcff73b56d54aa599ad9b2ac9dbe2b063c26ee2f3e98bc0392863d39a773c6e9c9a45af8bad9b8b8608a2dfd924a44e325536bd60baf96ee42b9f6b1c9efcb60ef745c23f0eacaf545871735729cf9f57061c04a2bd83882381b8e81aa537d1b93154dc4fa028490b1b71857980425264e04d200bfc657b20fdbb53f1b0d246b93aa11fb9645175ade50b01eca6efc8bec70c8ca691f08b71139727953ce01890c6bd0b0d65c39a26422da59e782ac7bf7543eff9399f85300653ced7d133aba934683672253849b5eef10bd548644bfd8c888b16c366dd17f4774f6d0333614ea89ba4bb0fd2c5af89b18a3631476b39e0d9d711a480f77b4fc7a1a40f79914fe77c60997a81c739eb0b9d9ed12b92acbf1c033ecb07515ffe42ae5b0b80e806997c7b724ae80fe467326c85028c2d6dfb7b0e7793166765fba94c4cf10e7980bd19226a310abf6052369fe904d32cb085c06a6de5604650134a0e3576b685d6a7bf3db22a8b519e0f0c841553fa9d80f6b9e92b2a3a5526b40c53a4d0409927fc142812957e3e73b51f3a8c24a19862bcfa81847533269498d65e722b401cfaa7999b94aa05b621c2d757d20dba8fe7ed8db62e3d4ff0838266b7b0197098e992028fc7e0c1c75778969453faf7b0c6cc4f1f076fac2fda7a252091e5c38792028cba09b25adf959086030866001f9e5be1dbed6c58e1ea65baf72b532e86fee85046e581b14403b7a8dde11bcf74d19d552c889768b2e6026518cd92832e2c9f82a3ffbff8e310385ee666e5fd3dca70c8aa1c64b46e0dbb0b7482734fb7f80d919eef5c9528f76daee9a35e92cbf18232f6b8df0670cf8c3a9ccfc6782f612b31e3ccb8bc67c53a63ce360449516591b6fb39958c6cd00d6f5ec1ecf5a4d45c503edd49aa6c24baa3888963365884ea9e69bf61a84485e35ec21582d5861febf36afcc14543d09511dee399d58026128abdf94feeaffa28bd7bec3dc9b048ffecd4a6a224f606805d05f3e1bdc71df615612696db7bebad66d04016402f8dd4f4be08ed12ed3117d4c46c31aa84ec1f425b5aaaa0380e9880bfbb1a61b368be07a57256c36f275454cd8d5ff6918857d9423b90a33a7c97b6fafcfa3d5bdb10f6e54cc7a0015227113314eb1c0c65c959dd6069e25f6d080eb6c836f3dd47fb091512566d924eb6c99e39ff017d57b3c2b411539413b60de0f59787dae064711ad76ecc38cc203ad1aa4f0da007ee907d2065b833a5b42eeed688af8e819a4edef23e85ec1faa6983ef20eb1d68280b2eb7e647b3014754bf9f4d1802b715b522a9a61e9497cc89fc13d603f3c835931d15297ceb40e2641594375eca7d02fff30f88511e246220695d40a452776329d344d62685e94d9700c1c33b58c9702b6bbaa69584d735aba4527b116284ad212e867d20968e19be6fa0b03dcdf6fcfae384ee41f51ea3de961e776133959bdbd329b7e51ef0fdc58e4bbf1406ccf88abb2a0b07778cf7fc83103261f4b5c8591f6a51692693cf5d815a6e6ced79539950f6aa4d72f21a235d10bd8a57a743c28836a4dfe9ab477932448cc75c1cddbdce2664dd00b51e16024c4def58801e71b731b662d81467595f9c32342bd8234adf15defdaac901a9ccfa715555c97a05dd0837f69aff327b4a711cc778ba7d66a8b4f67d9c20b986f01020bfdadb125715e560b43c3f189221a6b178e71809ceac7037c5416d73b1b45d810c1ae8e067e02a75254b2cc9fc9c1c466a6eaf6ee899a028d02b132b426f7034e6996b63cee58709d4eb64a9742d682b5685ccc593c3440756a7339bf1695f0a78731e7c3ac09a7dcaf21e24f276e3adcef4891c517b036bf5a07f2493de9965192478a3f0e673bfe873b174f9cbf897fbe6395827368c06a2583e2b89ea1a91f50436b08202f5e2c734c5bc868f334556f8a23c98a319083561da432d1b9eda20204e7f0e286ace163f49135cf2235d739a13a1eebf712d6f434c63844f0c88f743074101cb1624b1aecdbbb0a4154211bc9244cec780f0df4ec70d6799c415527459d295a9866e8090996be076be1ccffa5078d8f4fe81f8c0bf33a9e6f05101bdf930dfe6755ce7b5811ba87bfeb8d4418d9d3b256ca7adcb52d27ab803c9a90a527aed24c34d02a5c68eea61310df1afd86ce5c30ef6b0d1a22da285b2efa28f8cbfd7d02a3636b911b3f47d10c967b5282dd361f74f5cf3871bce6bf03d0fee571801ae12132db100e47c32e95f82a962e73ee27e2c7817239810fc9d721509f4e2d4331868619558e4126ba6b4e9057515e82ea39340b1318a7567fb1d73df46cf54f87095e97146f65d853cefad1c315cc8bc5ce5d1f8c53534fcecd10141925fc6e1bdadc30fe21d3642c38fecee0bca421b73958f9b1afca4ec8554d2c77e8f5c1dde21d2810709a098058fe013076e73e16a28d89c26858d0cf6594e81e4768b16f43d0b24265c6caf6a0b1b6213bc56f55b0ce8737bd1f189bf3696c39b5d16c931e1a7eaa58ebf5a026e6d5e94c3365341ba6848ee927c8cd350d971a8966d72d2a05e640bb1da6dfbcf486155916e124dd3313dfbde254e2c1a5ba479fcbdced107731fc153561a3f0e6fcd100a5bc86fdbefae1b35bfd6846f9d7f279568fc9ec08f06e9344fb19fb2c0bf0a5a34c94977d877346aa222b8fe069e78c14ecca32fbecd35d6e8f370111b6e211616a5d3daa73fd1c083433b219e15c0c1fbf6067634cb234b4fd82461d1b7e7c829934ea378245d769c56ff240486ae9c1ecf9742a8c4d73f11bbfe9c15e6a22b96bf7038264ec6f7659d006792e17e89299919369d8b35dbe5411a18ff9532fcdc29241020210aa9621e25453b98b869d34d51a18c1249627086f08264ca368b068627d90dcbe91e4239e0d9a5c9d8cafdab15ede92fa44efad6647de788d74c1943db7779454610b3abaa066cef3b9d162af8f8fcd954694d102b891f5678b4d546676181a4fe8687f047e7276761fd8333b36c92f6e79c09752a5adea88233f53d4ccd14603237850a7db800ba4912a0a4342961f3ae4ab9a302fc051deab479d9031e394ddb337bda8e62c4eb4660bd76a1dcc1e7b6e50e67b15bc9797b166a21c0f5a199cc729226874c2a1e0fa12363d82f81e1837d13aa7694b6fae53e367a98875410020f0f38d5e0914ff9c427e301cfcd312377374f6684be589d2901b3b05bd946035a3f1b89f90e91e53a0935c3083f2370e88bb8a41e9a5d1d3d05042f52e3d3914d08065692f7038977390c180b3b5392447a4742f4ab7cd962de58da0ad3e3b2f5b5ad0c65f8f317f2bb3d61a9e9633763e00fd5428e78c1b7d6ab70d1afda987247170049b3e4faf2c0365c95d15e58441d8f6452b3b4422e5e5c80d729424c4acb1e04570a9677d562d9d95f5a669cefb93153a27761abc52d04dce2c8ca5b3e5b880b4142f082afa7c4925481e70fd9972a5d02375027fc46ada63ed1d34d90e41eab5bfed692dcb579e40c44aacbd84f223ff9c1d886d1138cbf7f29cfb76e5281b3b2cbc75209bb31a56320a4388764ce4ddb5f8a8d0e2162e75d69bca7579a10e97a1b84a1b2db9a458eec32ad504b5132fe33ed719161f1cd4cf2940e3ec10be5194461f96a15831120c1a6468890584f65cbbe41fd20f0d928c291cdb5d0a78ab7ae41e7efd8e948fb1f1ebdd3fc74ceb6798ff4c7ec5d330d38e0d5ba13eba38bab4131e563ef0c273238d8acfda2b3b358f7bc1ee6acc49416e8fae3485f55212bfca7ce0db68c06c6b5315a8cfbcdd1500376007b8e70e6aa02f168ebd7ba0a20e54f79badf292dd2a086e12f803f639023f929e08c5476f812a058c1cbfc86764557320d19b34f713bebbe9dc7fe0224ac9341ad86047f6e3ab8422cc17f23adefb7e7f58808401079f40fe147cc143584851ada5f7a3ecc16aa66f62749e84d07cd0cdc6f097edce5cb1dea139a9ae3c72c186b52acf2fccb4af494950e1035a28871f1987fdbe6f86bf6c959027675bd76997c7368301d203968fb0092d0da1a033d5dac1981e9ef59bd8674ba2019b70e6f9e6856cf792cdf91d702fb5cac4f3dd5e1cd1bd2397fbf2a61414cc13f5cca0d3c0f7a6bc13391c97e114f328023c3bd97a1abfdddbcf448d123a89654440de0f530b0a70cef415181953f130d030d132bca0ef84b4d7ea12aafe4849e581e72e1414833731367d7b383a92828b3a5d52fcb7fa34cd85ea81aa47dfecf422aaef1cd4722edc2fd7580c0748354c718bcdaae57adeafc526a7412e482166b7f1d1f7d886a7f244b1bc9eeeee5326756e9857e91bb784afa682ad8599974440d1c65f5b53f36a5c6d48e95407e2fbe0cc5b1a5e418cb58998d9117e4ba281f5fdf9c81a107adfa084173b90c26caa82d2ea1defcfb88798c430d7df55ea409b896a108c9c13bc189f8bf26c55512c5120d81810da0fab1ce7a1319609ce123491a1a18998b40e129b4b15b4236ccbd220bc764b3c69ceb3a60eae03aefc7d3b33ae6cb9434135cf72e3db877b20e258fda0e941645ed6a4e37c7824606aabb22e1db8632f22a0f8ca82524f72b40000d838a120543984031597763d95803fa6e23d874487fdcbca1f66791d8a0a55cf5a72abf3bdeb4fd01720ed329f57a580b6f1e836f336798bd1202045d7ef70018ac4b0110fe6cce96117dd56ee95b1fa6a719c8cee139aae015a123db238468f2ec654af30d39c3684e6cc7609d07192024f15a60ce0456fe75be306812bf12f7a0f6bda1ed243f36070aa5131f1e8940eb7e7737e765a3b95ee2948d0956a0441b8712b5bfcd2b8f885de13b227f9a7d2ceab42d8646483e6d137886b86a38d81993053ca1bad798384e9738c04eefa6748c4eb9ff2b821767c9fdb846eac44b35b4dad3e8ef29dffd946bcd6e727943866ce6e788a9a1368e1f168b2a3041a1f4a0f1698ff35d6f7e25fbb36d28e85a97d3fb304b58b341466ef7a26b320506113a8da16601e625f9526235471f0cbfdeb1e948e2ded61246ce45ac80794ff1349977d741a52cc15e7ca62f113a42b7c7c110394be960b01ea1acfa63519824c5d7d7baafe814fbe7a4fe56e57f836e0958e89d2ea3e32942629e5bf0a7ae8673edbefbeff646fd7c7e1717f4fa02cbc122577138801e6bc085fac4d886460a2d6ce2dc85ad234cc5e8b6880221374daf01eca9e49b4bbdcb49d2ccfad8946cf675803d281c77d8ec343694ac22e4c04b4c2e7cb8bb14a474d0f1704597c04ba76994ccaa539322edb8e1e5138217be825e8e0017643e8a0e2ac6b3468f94b3f69528264cff1d641abc46bb029e599f76e83643ad075527b71a2dadeb9cc8766bdfeea74ed5555fac10e41b805118e0264df7543994dac84c781cc2b5ef6e7c70adb22ba68945958b79c1ddf3db2b3d5bef804296adaa8e6cc369eab3d95f85d00be35c7a108063c3983a421317fa1f89328ef69ae2d67661907a41d7902a35d42555fd6165a368eebda8c122ee3ee6433b50f85296e030543acdb590ffc54ebe6ed5df576f467431e0e40ddae0cde47994171bb540bb5f5fc074afeda48ef6b9f7ac3c18e53b673041b40d086fca94081fe6d804a3e120ada367f0e466e752552f24fe634724956eecf72c11bea574bc4c6a3516f9bbd860834875fc10bd85ae18eacbca46c2bb40261d16f53eda3622a00a38a6dbc2165ebe4e8231f200c4e9fcecf5da87030204af5ec193b6d87634bb11c87a18a69c98c19870f99e0911eb7d32886d7d641cd3a4e020ebfb23f0ccf5c2961fae16a645e0c24e902db98eddf55745d5a678a58e6b016d9457a086f84f0377ec92070f0eddf3b3d0e6e798d6bbe5f008abb015e6775743113ed9562840aa7edb22e3b21dd70370dbb07e22c708351a43fc7abae8ab04e35f53d95ddf27009b546611aff2ef6411b8464d799440d6572eb1580d0831117bc5cdfbd26c3852673afb737869896707739ade96578b2bf00e49245fa5651a360d639b26b8bd4e90accc2405b5987f76a77801f8e501550955a60bd6955b26fc07bc058c4998865b5f13f3d313f092d8b7be39f29375e947c9a18301b1075d9a4aaf1212e64e03aa4da6dacf1d07f67975b7a68fdcc10055ed06a5f9c3406ea6be4ca20283fcd80ce4fe35ef92851cb9ecdb95613aba5317ef678eaee3839f27588656f6cd6dbb88bc6bfcc9898d3449f3feb0d7fcdf1708660f3833e98c68263a457d67c4d08a65483fa379f2f47ccbbe8dc6ef38c59048bb39fb468c2fb07ba01423aac3f9b0f258a0c1536d0fccc39292af524be97fc220f349a7b10516d8a0a3038985cb85c8308927c87bcd415eb9f50b9aa1b0ba08cfa699a0c895ac628562f26131c78891171368dc1158e037f641aa308a3383ff026b5a0bc2e22a6ca93f2f978789a4a255893941da6c781a5d154d2f5f3ab5406db37cf1322983a1f10b27d80efcf63a3b7438b71c4611c947f3bfac8855f47cc9400da51656be41ee883571b552da129c445eeaae58aa6b982edde0d8a019bbc2c5061f552b1225c5068b39ff5668fb660114d80ebd97c457f37c13aba73c0a2b566e069c646635a5b20fd5934309b1b9765285e6b5e3307a941f65ed19e4af864a112221f2446d4678ec087b6827f21ff47b7fdfdeb30f764c05693aef8e4017ad728273f860bb239e487c2f8e6e87bf3be717fdbb972c60446bb6aeececd2a16d33c6a938d9dad73e66b6cb55bef358835120cdbe990288392c9f6c158fd124fa6ad1d4c49324608898872ba3a4e2bbba00f27fac501023a7f1c51adccfbe5f8d344a770b13cd03682f3b927b47730ce5763f296545cba16a8c84fb77a58e3ede3bcd7039e25a6b32831d4f81d0297a9b6d9f60004723a57bb52be135122b8145d0bda2311a71ad88de2d6a7f77ec645059000c2fc668c680a9fe590522604528827e8261b640838b71ecff9f66724e535ba4a1a26d27ed3959c85e7a212423ea349da3598c0fd9bdfcb6d7875a1a970664b03349864ecb562cd9869d99e751b05a243616e5c93557bac9f847116dd44eab1a61d0d8a8042df8580852bd61e8741f1acf8ca4e90d6efc18ec662442f76bec17856d3b0d53f93fe00d7656c22a814cf80296bb084f033dcfcbe4ef6ccc186e3652c15279363b03098407d1f970374c37a5e05454aec669565ae354462ab0824ef9421ddd59911a4b4726716b01aa5b42830f2978e5d50d68431b3d8fa3d13e1a651f70f15dec5db55147b479c88aa8d7517d92751763b5f1dbbe5baac8c0ab587c662c5277dd592f002cdaa42f331655280e8432fb6a45e7e3c6be359f6387707d2813571b5d421d08e6e35bac7e1db12a064aad0c3be62f10284360fb3def9a93e02fdfca6e476806881a0f397dabec6d496626458b4b930931db80fa097a1891e07e11f0a113231a1884a49d3296a111a7953bcfb2062c05a6164e31ff05ace2189db2860aa9d197f22a56b72b6f5f9ca0cbac743e2e875050d6db243a7ab2d9a5add9b7aeb401facb532f91b0d06182ab037f0dfce6b910a421b69e3e55fa1d6564703fbcb888b95c6c09e3a4bb1915cd26b0f643c99547a856a597b9e5d3d29f9330277fa062d95f462d6bc919ac165bf2cdcbbf8e787d102e5ef4f4d02f3de29ef754a267496329033ee2282ac3ea23bb204779024ce9157d0b7b9782cce13e724ce33f6153558e536278ac2744fb77d3fb16a19390649686fa8523f6e5e5d78403b4f494e643f3c25ecbdbab2b0f5461d867d6c0738333db197ada38c4c6227452aa2c9b192086c6f2744630ebe12afa75a4b1974675e79356c737046c5ec5d65870a2d0fba6d4ff3bd3d03c8daa33f24fe286acdb4356e992710d3723b7323866e64c0c02669b07697a869137640aadacca2f770d45d4c8675a010cbf25bd645134c9dbc3549155028eb89ba3ddc3dc8616d57046ad60766126438ad263efd9fd5df642d148cfcd3c38d9153c398db9e46ada60c78246591b21c5f0c84692d1b70f65be46403f347349b1f6989a5ba51797ee8ab176f25ff8874a6e9c1b0dc5ac6b38ef12118243f8b4abe571824b0b97fd917f72351b5055b670d55110bcbd3f2ecb2873fb435fbf15cf5fcb5b93cb7649d25d4008956caefd9e8e72dca53da26a82e8c6a19ba9e88f2bcf673f4815ab4329043b19d88f45f7e95d259429e2fa43908e36a894a9d768e5404c9469cca3951cc849e2dc50bd8a16638bb22049150323f1ccd6c9f71b87b5376a5c23ec531f8c211144b672d2718dd8f4d7b3f3f1e99c83f5e17eabf07b13797bdd8532549132c76df526dbe457034f35b72115b65e8ded95266d7ed1695aaff5fd07c63595bd66da47a91d4dae7fe558fef62c3ba1032685af3db79baaa0102c60c54776348c14b0e9bfaca3776f59ce1cd220f7fbe4d1babdef3cd1fea275c501bba5288ce9aea8b8a9286c9c6d9eaa71204c892575d82da076bf0eb34aa2786a783a97a6bb3b1a597c93fbd1b7d7449c61a2fba4429cd3e4472280a44d315503402f96501936e93e0d1118e1e44abb9587169c2d468798a8d4e1cc274b05ceefc57f4d68c4d20e1876b701422816770daeb649b067efa60d68cef39151ed3566c1cf067ce9f434362fd7487a3328b52ca47d3571c9e587a36ff0f95a63308609d625ed26cf2048793bd137c25ae757f14a0c89a5100b2781e4c3ed1c586b6a54c68112f6c191f697b679abb3f879ad6b3c6b640f918c72943d374016122ecec4d1732370782d3562b719f3df77628343549088b92c6783ffa9052007e28bd70042bc9f765fad0b598c14a119249d2f66e9dc93773ba4a1dc722c27628bbb5836370ca220c5d7151d5de3c50e8f63b3e49151b1f6bd524b3f3729fc6bf76e800cc17de2ec07a49bd837109a51b727d2989a87781ae74532b96a3bd5ed54fffc59b0e6831c75c3b3987396ef13b42e6e4c85bf5b6c80f7d068263c80c51e417a5547619d2086b6282ecff4cc700daf2db8dc5230d07c55b5b8b3a70038b8b8e954c7e735cba1b109eb20dd021064cc36e3a044d39c426d7c42cc50bb302b4934b4ae9efa971925a66f416a3a6bdc085873cf0158d2a0625db6c8c2351679f9aa961e387eedd496fda6d7b6b062967ce1e84ff3430304b5af7892be10da9da93e1f9aafbd39bcafdec4957554d0e98e9187ff9af44fee9d39720d39c86aef4dfc28eaf04d959c9cc63dd80522da038c3249f70ed94fb1c1f0a4a2c14a561f205efb2b5f454be68af9b7073f1a40ecf34c57bddeaf300415102908198109e0e845a20bc81de1f6445358fe8626b9a2a00a0b5e91565eabc32640b1d2ea58d4c5759e9d2d799af8ce1f3f9fe74810bd6a1e832f9fb89950fba23596f6b31fcd8b232faddb1672eec1ad756c6fbfffcad12b1b0590278f82ef3f38e6f329d81de615b3e48009acd230b4761cb1d26cd296447df65f5613d332b91322ee3b63d920110bfb543f5d17b02bf85ef1e4d09818d464b172717108cc6cbce4d3a8a86b920c4babd1bc480127f9ab84358c91ef411dd310d615acd8b8b94930594000ca1318bc4ffb2cc731ebe9959a171b2ef09feb7efea38f6c15cd6cd2420774385a36fc3a234c9c581ea38aa864ab1ee52376c31d2c32204518862fae550df3deb88b363f26314e12dfbb285b138615063e3e3955584855f120e02c9e59039f9dfbb98f14afdf04a015b9b3181b9033c864eb69b94ab82b2ba79c343926bb0ea981eb17bf5a772fcb4761264b0ee167c85c635a39d271f01cac3c233b3c318aa266fd6335da54d51b627cbd2a9e2bdd6b217cc75a7f08179754ccaf4329873c5cf1be769ab6e94edc541c3c2efd25ef6e059575d771d28094fa7aa52998ade5378a5d31dc465fe98a0bdea89351ba594db8ae0dfb25bd99ac239b841d8641bb8aa14a087c4f5abb4c4f817108a972a2f1683c84c40c905f9abc948735f05e56f81d9450facf553b5dd0b3cbc8996e32b80b1f612d79646f312b8d12e27e4bb85cdb24e3c0f9c9491d639877af28c548bedc71593629763969af5a45faefbca2a7a199230c34e9de0b6bea7361703eca893dcc67292d487c6dc48bf07425f3b4db93c910673700370d0facef1aac0fecbb857e7d4345c73b9bb0beec6276e44a1885ca165145f4b02be9d8943ce12e61f7cfeb0f4976342defb8879446f48f1fa18c823c45e16f2bd5a26ea38c07864a5468a517a65288326998922f77a9ddda07dbc79397a3ed80c449bcea222fd9f129ed30c0f5d09f1737c968ee834b3b7b939da56b23924fe482d6f091aa6d32fda0e8aab7bb6a8478a3691d4e0f88e38e9b0e84dad2286749c45e39682bda2b1a3e6dd53ec3f369b3f0bbd1e93d24d5ca1432da0979676a13e7187439722625bca3bc595cf1707bff4a215da0f0a8786f3af72492b119ff5fcd0e0682ee96cb913994f4d786d7870c7030e014b0e23316bce64762aee4c702f301597fa0177f8004ec8ef23762842a1ea69afbb13e1bab89117db2e0092bd266bdeb5a20cc67f7cd1cf3a70b6cd6ba18a4cbbe62e5fe125a0098d911afefe4bb9c277fa1ddf1e42ab7c5f289397082812ce65d6da215e868e68916d4ddcb111f2448f42d4026e29a9e67bdae9ac0feca6ba2b03f53101ca6ac2266bb360ad010b315988e1f49f0e41d1174c375559cdfd5a34307c7fb3a36f5ccdc46da57edd4fd8a0961a833d105a3e088ca7455e432b038d8e68d28658b7e4fd399811382b488bc774229053268be0991a64ffb111c89ed1738e40ac07f9af54e400c75ee977d2c29b6e7e9182897cf2316c3672f61a2e80961581a75d52b711cc21b80fa36c77e0c470b0ee9b2c5169bbc574825c8e63d1f343a486af17766fbc3ee703d366297594fa241714aef8e42349f757595b9f5304ddbe94810c0e403239e5b8d55221252bca722812ff8ed33a71e321ec43e08e66739be91827008195dac69f6acf12189240d7250311cab397ff28d772b18237bd1238099a241bc86346afcae7935979fa15846ef173f9debf2029ab8e67c25d7570c4e651a2318fbd61c31d8817b728a1d9d6f41e63b3c40ab7c1256ef1f5b2d209ea04e34086c58139a7198ad19868c1b4de63315f96aa454cc24558d3c58865117b640f54e13c7b806763e314151adf0d5452991fa65a13e32c82ced66f5b782d21b59f322ce1df1412ae4f1602e3b99cfeb549a8da1c2385cf584af4938f5ad437173c4ae3bc87e7bb9b6362872f71b05f551a5007563039678dc953a7b7f27d871d44a1ad0a27ed45d70657f297b82421fde21ed98d94a6a3d3f0efb93c226831f03f780086ca7cc6a8c7c0f08408fe28916dbb5f562e8ddc026a63846bd6fa54129b04bf2f6be915f49d4edddc690c161a641b6d09a097f234f342004099ef5c5b0953a5b2b4c7dea8dff2d55374de28219541482227e78e88f38644a6d5cbf1352f55e2d07f0f1a0fe176cfd8d31fab6a63e60d20db89a91335d1815469014f577514f5d0810abae0b2bac46b42e14e449ebe4f3bf58c19203314c18912bd7b3385a7a00bd184762ce8d2adeec4927701a42cedc75b967f5ce863d00e1eac484138343541bf5feb59916ccee043e9576c3fee01bab2c2f4504bed841430de267d415b7d51954676c6db21dd107f5edd26615e5be3872166a4a2274599d6dfe3fdeb6598758b1fa99c67204a0f060caf78dddf7de0aa662b9851d7b2728f58ca460a26b4ae1608b6c86b4fa7b4e3b172cf0a789c96739ef50c45b6a8d7b319c8ea9b1d84caa079d0facce5c3a37cdbb4db04a819bb33ea0bf56076a810e8c8d1d5af4f00d735406d4713afbad055100a2f35b30a4dd9c5eacc27f5a5fd1f015286443f261db12c2ea5a158b391236f7a580ebb843e459f764b74e0bc1717ad1a58b788a6f459ed37ed9dd3a227c51ea9ca9a3eecadd1792ee7b68f08f57d104142b1c34bdc1d7b7267bd7d2430ee788b1ee4aea7b3a9dbff88676a594f98153d82d398d2e84eb930deae0224a231002f4f80059aafb95c6f6a1947735af0ab29027d9e9c64b62b88e142dc1778ea63e25c688b210fff15cb7dc9089a365ca5bfbbcca241f2215544e98c9df88bb1726a858567862b206908ab20d551d41d40874a3e6a96d4ecd18977216cb51a4441242cd90aa0b80c584c7005049a4d59ed5faf90cdcb93bc7f51dbc6b170de6b8eea5b40980b5e7f5d54e90a27df392bbf10ac2996c93cd8bbf65bf43b406a18c7f08b2721cc9974599ef1d311d9f868c55e48b263c3e2a1b2935f89427668b786c01c59973b65f5abcf0eca8ba481699e82a4524847baa1699c49ac22abfbfe9b9d684ae1241492ad2bf6f1a5dd3df32afb5d97fa4593291faaac483bc2a63ee98ca0d0a9b6a07c84ba08290b734918d3c448bf2181cd928311d16365c7b40ccbf933eacf5edbf5d32e6df0b67e2e029c57a2200740e8a1bb88de3c8ce2300c8d7dc81e03d54db88b4b5ad5f404ebf080b397858f9d3ed970fd010b9afc060fcc82bfe26a25f1851c18e695a4b7cfd9d6b1033164bf7074040f2a60d9f7a9d6d52f9a0158e216c29a870cb141a33ecac835be399b54b941b587d705f8ffffc05c69ac1bc4d81c412e1896cf0fd8cbc9b967e1df84e2cbbffcf8c6ee8b5cfcdb999ef711dcc9c0fd34cfdb6bcdd297e29c07d63eb2ac751c265b34b98050ce7c00c14f1ad53e8b80bb04b8d4a70da8df6fa059ff58d242c0fcce592a4d8b1d50e5c146ad30d9b58825a2d858af1063058479c6c6c7d71f918ad4244d2b8a2ce513cf6de391e775586f776e45729975f4a32542b22dcab84aaceabeaea15c1cd2b8f78464412ed6d1d5e82091c02325fd6065dc2d9f305d4cf868a90295770bbd2a9a0e671ee4d78d33e8b249f5f5f2db82edcebb1f8fb722e6df0d0ccdb27923af7ead0e140d3a257ede61fd39660894624054ced79f2ac80d9ea741eff2a53c0dacc3410ea5b693f8607aa3d5acc51ebbbeca7357049ddabec5b70a79bb37e15930071209e656536569525146787a310dde3dac936fd9595ff32ab76fad6a164fe911414e898853de6c98db9448761d900bbe14805a6aa6c38f393e692283a0af89aedf13a65ba7860dda3f6f654ee73edcf0a138eb0fd9e0215088dd7729999b6fa9d8787a400b2c7c7d530df737f2fbcbbb11c9667521dc8ac3472cd84b4e364bce047aae2c28968c93e4191549c1bba6424c58a105e93192d294314eaa8e9bdea6370c2ebaeb974a835e7b0ec74bb882a80d31dd0201413e520b23de47d4eef87e812e1f5737bab442261f2043ad6cb23f730e4f271495934abb870685e55ca8621646e845a48175483d564f7c0efce409b89aac99682c41efb54eef1aff411b838b3ebfe4c8018332c3e4258523d45d86724407d0904845423ff673953c8171af6dd947785754dcab67282631cb815cd4cbcb88cf46c3470eb9b0088d2263b5f1b35c8719fcd4490299ded1c072e0b0c49945c3896b4d946a41b36a9f27eab98ff28e62e6f17bf68b5a9923f2ea1cd3f5b2ac4ac0947c9d5e10f88236b1dd4abaf5c5370082644ff0d0178c7696e21a8bb237936ba80f20abf24d199f23b0b2b4771c88ed5cd2c0a967ded86de15d33c3c873af406787403eed0f06cc4a85ff1a3e93cb9637319f64e9e02fe8fbc1f15b854dff4b20804876878649ebfd87087e4f5ca308b9dc18672d7b20c0f4c5258776fb87532332d7f3f183ca92dc68964be888b1d14bdb7b4de00e64eb8f6b9defd1b79a3f7b2af22c4915648bf4ca802c53bcca5a6c92f2b39e81d626f38f35ded927147315d87f8d2d311517d61125c47cb0882293a19bdac20f811307e2c771e5d1e9063b17cb26cde52448bb09bc2762249320d270bf2cc4984ed7f1236a802167e1b54c81570ab25fe9face4db25ee0ca4e7434f15efc43e66d434e0dc4f5eeba501ad4489902a76ab1d8e7282207fb7a3a0565d13f6722e61d586ff1bcda56402db5d5dbb50dcc73052893eb5355bf9a45b158554c86fdc073f3e21895c8bc085ef5be77a292de392f001559bddf7cf3b175b5702546668c9c79879e4b22084ae360fff8a0f4e5f2f8277007bc10f548ccdb6448497b6850547fee9d736dc9f77e613a550d3dc7f6ca42b67aadae24fe7eab0d9aff11014e3ad7a6d8141828a24a953b837fab33f7feb2604f12e8f42ee773e63007fd96fa0ac4dcc52a7cd8c0c1e2e81c51c60466c4faaefef3a94362a90203a049a7ec52ab655ef825b17ebad504f76e485fe11b1ff1b7252d85f4337016b82c8bd1613e073ddc4522b020e2e950f268dc6b4aa4a71974ff0ef73a1e51056daa32c98fa36b41aac677859d262e18d463653dc1f22bf30bf51bcbbea59c49bc7ee4b6a04bea76303eeb3a1de4ed587e11c935cba3c683d2356c73b2d16bbcba6f28b141680b2770615d42de50797877bf251ad3e80d8ef57048607d1209af15ed89dd98231da3bc9a0c2a915355e66d37088b0c9b0de981dd3488c6abda35aed1dc861a60d99c3f482927ea00b657c7e6c73c0964ed135b04d3dcdad0c6ac174443e971880e79bd8a854f940f8e3626ad87cf821263745fd894e5e5126d512391f2476511fe9cd0b4688546453ff8384413deaf1d06d0900270bfab42268c93f9ea4739e3c3b318b795bd20a08ae0ac216eb5e03f11422f0649d98afc16c02366bee1ee5aeded5bbd77e25aa0d67d47605bf31b73b96fda791be989fae02f281b65f479e7e976959faea537e160ab59e510ed1ab14a0c80c4e7a63736e8a08c8ceb52c90b8f2accfd647d095cf94a58be920cd4afdf6a454e9761451c6b06fdfa7324fb46901757c6c29b02fb852f607c4520fb7bdc7aa3f8710f07869286d2bf8205304bf8fa7bf1b3283c8475cc17af8f6b8374d232cbc7138f73d495641edc9cf1957e4f2eda3d2e52a52aaea2785701fbbacc156dc5ec5c6eb204b08a2ab248e6a4c77c3f2e825bb6812de37384157336bd08255c923ea86cafa65748f1ca31a3eb80b4c7a6a3435d71813fcab07b6f01f0d5adaaabf908f76e93c831a3d424c043eafd2fb6cfdbe6c9adf00b52a740464a8dca1768f571a720ad08ca27a2ca806148f430b9963219e7d8f3fd066ebd8b78983a0dd1bc4b6813594bf93e66dff12e9258d606f6a6d42132a8fb6bd2be87d6acc54beb701512c9103a44c2ea18ebcd95f24a691c096d6a0b25864d9a6df1676843c3fe86e94653e26d662a71ec12a6904bcb7937d6467418f8b733737a05363c15b322ef230b1704e0d649f00f04b13c89b85cbc319e31728a203f75dacbfc6704be462e4ccc28964a222445e2dc3d5eb011e4f9a684d58e11237b5a5b75d53cb48101206175c04bee3cefec5be1e1880ec8a1467f034cf59167487e8bc92508d3b795d77d6d11beafc0870b9d01043a2b08ae8f838021510397182a9970aa6c018614ccf24699ef9eb86d0ad2377fbfc372ba00500a59dc8372c1ea146a5e050076a55958346984c29d80f58b5ad6e4b6539de08d4e475998c69ca791bfebefbd75588082c10d4907338e3764911a86f049e2c21fb3225c8c063f78862ac93d56815e5405ff90c93a46a7a749279c943457dd084bea8fae2b75d5a8d69bb49c46ad1f23178f08ce5149e7f285de62aa07bd25ecd3e283b10beec40a4e0f5925a02f64e3a080da92763cf46363b5d975a922e6eedee7d50ef3269ff8fc7c86d2ea0f6faf912475aee643bbd593eb6f5299dd74871dfb8913ee14de9698218dadb10621e679e13cca68670f85e495fe48557acb99db331c2051e063bbb9bb572b023c9a88947ba784a820c23ac5e83fff67c6018aeedb95b2299024f4faddc26eb51303e184411d197bf83881f22fb405e3fa6163922d8c8b4f5d88c1ce5abf053e245de3d9074881bc3888c726bbdf51f3fdc9e10d20da03608091495cdb123b26c3173ff13f2b3f9adefea3bc36070a28f4f5a03615fc12db8972e1f94997c80634828d6bcc724333faba07415cc2b7c1271cfd9418d01a687f5f59158811c8041bada42a4870d10a9218b2273967bcd4967be56a883925e1a75ad302af8bd507fc39092c5be3fc78970967f26077ce75b5c9731e138eed80c1a356676912d28efa3aedde915451f11193e5970d0a12d7a0814d34edd5273945be4663ef9f67f7aefc089749c8734c61108a4ef7d45396144b116f6acaf1908b3211f17ae04dac26a0a9c0af86d91390222a9cdb25053f85a55b8fc96ee25a3c28981987cf5075bcc824fceaca483704d10e4ed6c91478390b4bd6061263dc52ac1f17a12ce646707f3662dd467532cc434baaf261c0923134865927026dd155df27f26dca084d8d318d40f4cd72b075767076de0323d611b63ebbfd9626d01d0556f5454952da0024d32ed29a19d3f100cf8ce2bd4dd07742a426d43ba3f82a74e04fbd88fe550008244b98f718c33ff86c01ed598d1ff1188ed69c87bd3a2645d43892a8e80fe4555993a34afd2693084e977afa63ea8412fb8a366ceb7d5bbe7eeb3670e73426136ad2eead4367ab9216999658476345215de1ef7a12e2eb7f7b8cd7e5821453fa7fdac2d27c5d16bf47f80e4aad70fbae4ad4edf64873048f62d707425f1a33c36f2393b8f0f86cc410f1ebb64e56d631289bc57e1ef7403951c37c4924f811eb9a93e7ca94165bc84125fecaed59976e1c921d734ef5e5c25047f1a0747092987400948401cfa51c54cdcdedf9001cc904d8682fe396f2eabb640cc5f9176d4463335b44acbab5a1b5488ffd48259b63f342d9d1b3ea3d2ad488b17dbcdc7c63caa4a32cde729fffab5c26798cd1f17368d1c50dc1546c18daddf045ded33df2664a3509c0aebab4b891b2f79251ddeb6e9f8f61b637e99d00b18dd22ee3a0762029a45dbee2f0c67313e3dcf162e0e67ed699215c784a00bb850c5dc72e4a7dfbe9c460d0100ddfc04d8008669e0be99c847b2230a76c562ecbf07c15bb4fd9e71eca289c04e85fb5638a95fc431d0deaef31d69e475fc47e77bec792698aa066ea57556e07e0d74541acbb8491f4ac83ed7bcfe1f72d9f9c40ba77c875558c9893d0a53331103b79b3af0b153fff3f16ea5e6d3902359ea72312432d7e553a546f186379817d010803f5be020586afe786652cd2cc16660f9421a5f8ca8840cdd2024f47a52965059af5b928eb4f29049a7b31124ed8b254f29948c2714e0d59b8be42ca239a72306f63e04a24922e0a190982e50fcf0f278a09e449662adfe2c8f77cbd7a62bee8691b1caf8acfce6f16b4ff04a325f3575301074e58e1cdd79515e6f2cb4c25d8b94e8ea81d459adbca43ba52f5f12f921ee02fd5feb2d5fe60f0dadd0622d4217dd12dd78dfd473ec109021671d51beda7d23320a777ac1f5a7ee1d216dd718b8fb96f269b540d7dca0bd52727874fdd017e12c90444a7e36fdfd7b765281bf7ebf152b8725a5492098dee3a5aaf2bcd50f96b54be78cb641c77f8c9a0bd80951578700c06418895f745d0d3f2053ab58163e4613a3f02b858cebc5a35a844c0acfcbe56711450f198da35ceb84e43028df1dae027cc18a1abee8d1af08257775b3135d1c15a3cd1dc6496758713a2c65cbab08d035518ed8db06b27569a5fbb834119dd34fc2009b90e203c8370c3223687bded45928382ae59b28f7238aa29fcb4398741a726ad70b6114cf0877ba1198d8638190634e5fd66a56776ea15dd658318f1f5daab0d992fcc9425f75796654e9e407ea7c0fb637b0c0d743adff90c9f905ed161444f6dff00d296b56713467b9075194fc1305f275944f1f28c0d8166e0e4df29f5cc4db6fcadb1c9b4cf8f694c14020e2f9c1ca25de6b9876176a8639d772d61c5f3f857d7b1838937966e6641363b445a53f7a877f678ce6e15f9073b10bba50381db6b4c94b1e9dc7220e44e01347797ec1f03cfbd45aa11fcaf9d51f0411e564849821b4c1a4f38058f37219024054c167d489bcf57fc8ffe8c8dd1ae404a25a952d195320b67c64ccff090aaa28a40a301d21657323d07f7ae79a5b2afd6898ae16e82d610dfe4c4c70696c0e181702189fe32d6e5dd3276eba05ea965f64f8c10b99fbe13a5202cd70f9ba4a46fed0068934a247dd601f88c08a965105b5443431aa659e5d7a0bbd2851c732bd0f605019eaf50748f617b3cd257e0d7f1bd5432ee32c6fb9324df0af072dd0e94886b28242b94be05df2f6216ffaea44aa92735c6a23ade0972d6681b425429cea2c46f8631f94cc07f78db3d478074a9be7f997a9d1a8d473511c633168a299436f32a5c04233a1304ca10b88c0e14e19cca1e3bd52d63696ae49457f4c0e620b648825019f62f3c897d5cec091d8a6f4922c0fd9bd3aabd33104ed3e194321751e78dd3dc376b8c277ebd49ceb3044435284fe62bb086911e272b9f6cf4da34a9a33964ec10d2e624d0cfefc28e31c8d5bc3d4b3c133332cc41c5e1aba67c5fb5ae76795fd5f0ee96ee94c2a7fcb62fef1e14c8665996d4a76c248aecd0d8b0f4dddd84b1a2950ef2a75bdbe3b20e275d9c3f2d27fe64db8380270c430cb14e9c44f4c2f3eb56df3aad86d22d021a00e5116d8e3a0daa3b38c35f0a6071a89f0e0d73c2cdd56b6d7fbeff222b284537b654c3dd16e2203766f128e3a9d3d9c0f4592e19a8be964d9a3a63d05b083f9882cb5c1c9c1dca65cff1258aeea71a4263caa4f37c97409f3dad1318cf99a38da66e42a96b85d026935ad9fec611478d8bc286bc91d85e828c9a73e57c496d7f5f88a971f8218e9d44cecb606724843fd99e6f8b00f025c1259bc228540e10eddeca4c5cd4846db2d7b162b055b06f11b49e47b4287bc24ed27485ab9f9074cd17d4608d4cbf45f057df0a64d36520c9d824e02e1a21fff78e4a71b5d754248315496b05354bebc09d6f7e404119e77026f49754b5038f53b653d514bc7e12459f67b70df5ab2c5ec19663af0be0dd661f823dcca1e6471db5b67f059299e7a18e1365f67a6f80cd1e6d64637355ed4f86566c1408671bdc3232235e3188eada9b0d33b45bce0fd77344b09284acac100362d3b8493c93cefa1664febe4837ded1f6a7fd5189546a6bbcf6d80fe86a0601f2169e8a620991e107efb9285019a89c42cd3e966863092777e9ac1a918f8ee00613c8ec9fe8baa8a614a06c0763b37c39920ded32ed434aa6f5fc48ddbb91681efdd03478382a9d39a7964601ee51cd14959a4f80f897acd7c8d908412bf156a207a5915f55e01ff964ffb46e3fd40ca034a38c2548971dc951ee05f4c9c70d33dc83279cbf8013f7bcdaaa65ca12d0f26ec20d8ba7e37dc666622aecb706f79dffc8ba67005ae5f047ecf6d1816dd8be170b0a2af4309d51a3b57bbac72811c97da8bdc51642699ed81a5956f193008c175acc1a31b6ce35718de91dfab14cc3d91f10b851c9e06056faca81154c97acf45e5b2812b860a6dc283ae32289c621e980b4d22a9687e3bd62784ec3b486583fcd94319611fe45e4b12cd455bfae4f57a0f553eefb81a591064c83afccd7a910ba8eecf5c0b153b312b82e24e37fdb40d5b84b5af1f202beee01f8e31f63d0842acbe4bb43f83c3ad1b6be3c42326b2039d34bdeb0594964b764eaa1ad11643f001bb756e7 Hey, password is required here.","link":"/2021/02/05/JP-KN400/"},{"title":"JP - KN401","text":"8d229d8e47333d3f189c47d25637efeb68979f642698e19acf948344191b8ee173de7e98889e32170987808e06ebfa7fa5f8fc468a3509f16abc2ede0fdd669c80f52254227b7f8f2b37c1f3660b350d8f9a66fc62891cbac6a88f1ada88b2047f383b0a5fc429999fe6b45c26cc8ef5147df0ee0cf91e797d9d2693873efabfcf2266d16e7364ca6fd38f931428b71eef97715ff88524fdce51963f6f1d9d56408fa87051117fe3c7e14a050afb5c8341fbd96cd2f3c993157212a9dff98a6ad47e1bc8e29206d59aab34d5cbebea9ae2aa4cb6dbf47b20abacda7ff4bdfe7f9849ba50bb666be8ad4edb4de9e5190a9a1e6f0a707e4ebc678f42ecf78e743364ffad243ab3a85ee02c4ae7f4e653ba4465b3b48f9a486fdebdf482c77bf8f156fa27f5a36fd9acb2da20f6d71fd4220e16cfe0ff2dda7be5b962334e09fd609dcc1e2a0db9d252df868b8686246e8189d2452f20b7735d43a24930229f475710d53e44be67f488f00012d7a329b01293afb5114bfca5b9262865a9a8d3db8d195f93933967f60c2725f2db19a1ce453e490b0c3588577f66b1f42197403fdda31972891e47776a1bb8b8ba803b881181211085749ceff7eaaa0dd6af254b4aa0526659a04edf1e1d814a09b7abbb2c7c6ec8aeb44f49d9314219d39b9d1cd91dae5b436aa64cfab077a0ffea1dacfd9f51ac7228c41aaec1b26304e618f480f24334c0adde65e7b3905a43df3a9f89c2ff64526100b8543f16ad94daadee5abc8464ed36346ca181fed5e988d91474226f2fce571e253570bfb5fe51c0f983d4922d6f75672876231896853a73427a34386128d6db753bdd2f8ace668bf94fbc6a15c01c034bb8b4c1659396b3320063ff86037e59b2b85dd4448ce44cb549181eafa89c62839c05bf719789780699d93f949d29eb2ca184ed0f3bce73f29397ff5423b645dcf0004ef6b5be417e26a35fea8e2739bc034200df95ea9bf8bfdbd9d9d65e3041cfd1d44cb833e519a4fb826fe9a6214fdb82258d2127836fdc2c3d5b26073a6af199186b03578abf05278e5e238bdca694d7eb5b3efc55188ec4efd91a2915f7d12377b6b3466875f514d4d204e8dab48cccdbc1f354f64cf084b35fce428df9645b3ce8831e1b9ae531729dce617cb9caf6ebaf242f6e71b2034fda1cdd41538e7d31ac218d3209f03cd62aad32d8f5582150f7c361db424a293d7b330a5337959453cf5eba525b62b55634af95ff8ea8fd2029d62bddea0b4505765f5e94f84f63a290121f320ea1c39c3e28650c8dfedfc9c27afe3cbb7c40599690ef92873a3f0bb7442845245d7088bf2497680b1e5420a635653332f0a0629286a3fa7cf9b39edb18b5394ee3d68e2ab86992f730004433cfcda016a5f503c81f7a35ee932aaa32f8798d6495c7bbce61f73d6318f649ecb171ffec912eac27240fd8ed52b8c353ae746b8d9c99e62b1d3e776674714a1a7ce994ad521fc13ab662f00df22d0e40a24cc8952a11975818a3025adc9e03d32b7bd712094a693792d3e807730f9b6d1a583460d1cc508e6c19464a0008d82fe13c88b0dded3b1dffc757e961eda727f0722d366a128c04864ee6b1c2036e4ba57cc42210783cc7ad224afc1d171e321fce60768da81e6a052044c4be49dc9723885ecafdb3c76801b7144c156b0660e90c4cfca7ad6d42a89af9bd97fe1d70cfe64f5ad85fd38e9a0b6a4de0bd927a3d76b965f911d52c048b613502926af0b9b3360c5fbef1f33255b01920065fa9a13e1dfebaacfda5dbbdd4fe82578cb50fe3cef7fe3afa18a76109561f408a0d822f613e7cdd4bc367ea097438342568b39a9bd211c21a334c9bb0a751e2cbda8a33a5ddd8f61729ac82314a35b3e258a5fec149caad12a938424f4ad3ea7dc74d572b19e86e8294177fc8f51721a2075161063864f30d11f3ffdf21ddde13406b2e374e87477ddffd693fd37b7a7926bad20585a47348c1431287bbc353e51fa9db497a9c5331b1ae142dd47d3d1115fa3d6b61acebef9a86415ff83f1a0d5c56e10297a3ba1ad0e48142d107535086d2bfdc3abd587c9a58f79c5f853480abab61980d67a9e43d79ba5dbdd9180458620fcab48642fe418b8a521d57a7eb0248660bb47354bd663cb0e5a20db5db1250ed084a1d07df3e6200c7021244784623861f53da011318698a807ea8518b31bd59e7f1175efed75c3926f41cbdafa255cf3f12298aef630eab9e309217238dcc29e443bf628fd9939d27e23a001d176e3883b9d0dd95ffae579fd6fd7834687be12ccf94e65a84efe5de893f23422d05e0d12a81feae0e88fb91783a5e92c7203549fc8d71b107390ce8a8fec00ffcc96fb318561b2a4912f20183a25a51863e0e766cf92c7dc6700088675f69132201cde33acd56d81ec638fe05c09bc5aef926c971804cc41e6715e38164f3d34a37ebf0a5e9931d878e4718ce76399337fefc2f0fe887698437fc270af5b2b8bcc9d4629555c997a8d7667787007c1d8b8ac5656a46d0a5d81092b74496f8e8279d603dc0ef242fda7d848cb5861ecfd47a2dbbddd28d5990d49248a7a995957c490d0dc89d213a150caa1d72af21f478fc644b093f26ffdc9ee66699ce284d8cd9863575cb76f1d2456af0d02f968d221d5f7f557b077b6309933089e485d6912bbf271d8c83ae5e79053fc87a0b6c73a52ac98cdc2fde0f2a10792001ad8a7e6fa289eaa40023d2774788c01cc4424f71391c086693125898a120d5db44404e36fd894a4dd4c8aa09c1a2655563ebce81e18508075e163703e38909342a8a8de21f7e5d56b648e8b4647f2c19f4fc7bbd0febf34ae3e7a03cac165f9ac66844ec40f6c77d41ac4bf267a2276a68aee84ba12fbf3305a27141819d6c5ac7394ca8e05fd17438792b6961a6522c5bccef8a36b948ae7202c50005864256983cbb08b4b71e1ac9660d99b4ca747d62bcdfa6c7535fce3153a1331dd4f7a994bc0ededff3fc861f5b6414fee7ebf059136a446d0d2a68eba010f17865e7e86dd7502e4ecfbc91c9c9665e32a3dfac7110c03a0348da851e5eace6900390e9f3c69ca0f2b6456db722066c5b9403d0a45a01043ab6164f28146dd430c4f3fd43468a89e129bb48c177459a1a70f78de8bc84a497d834da921490a0df73ed68e706d05f47fd2ffe58fa2e70ac7810f07e0cc86e1c849583155dfd02080acec37964e3e9bb2ef68d273e33d562d7283ebd7beac2f406c424d4a2e6ee54fa7f62fef04d1830c4c1f25a7637fa3e4ab8a031b1f86f60cfeb82f352b1c728e0e6f6069346091d319e34f6b5bd3d0ac91902519e3a6d3500144504ab5e3d999fdc072653c09deaec84d67586390b0faccc673f5fa0343d4e41fb6a6b1ee972727aca1da1d69b7b8c58acb01faf6a323301ef44ee43803d8c3a14bddbed38d3dd5fbb0b1a47325631246cebb2431d49d5d4b851dfcce1b7d2ef2c4bb31367fec3bc6cb480c4a5d827cfe8efc11bde8b774aa5e299dc1f8be362852f38afea27059c050685142c02451a6ffcd33ab913a473fb8eb9cc9e02b864a164640b15d645fbb7701815ca38fc53fb05eaa758c3309f9f5f0fff58fa7e4e7c9f04cde6a5c13eeb773a2369d12f18e68bb3b540ff9eabbc503c28f996df5cc3cfd8b751eaa20f1bf811f1c2d2faa437158901cf3ca57760b0dbd14e850c4667bfa5ea965dea39ad3d6199c89e2d385b6b87c5b2bff999247e76dcba95052d9552a5a3b616819758d60d2a3ed416e55e44c651dd436e4a081187470a6a8b569c11c4e5644cfd65d3976f9a0c941e4bbddc94b1fffea51af04f5f9efc1d8662a6d540415b922eb81759b8c224c07ac464723891de7afc247f91b11859c82dbe4c9e4664a01717f685a8648cf1568200910ac1a0446890d08be77d5da7470a582de56e6842f563a3fc594eb03705b4125267beecbb14b4ac34793185d8746d64f3a84986daf5f1ffc61dab0bb2a074a5e7efc58e68261eb9af22a50c068cd6edb97ddbf33b6fb5679a3f9132aecdd08e39acc95361c2ace6f6ec60a3c61233865cc2f4716e5d18a380e741b8e3ca218f2a3e1839903800c3dffa6cfa40437ae7cef5290f8f5a33c423bb9511fd595f347dcb1b0e432783fd9144d9cec768839858622609d7b98c6bd5f0b7f0754642883fdf811d4e39408b80c934274ed34a59c87a0d06ea979b025e223e290b7744191e85bb601cc1ff35641ed44f01f1685b4d98613c3fb0e7580a7e56135e71d01d14c2882bd662491a857faf0e2b20ab7ac05c37f00be151e8e8f39486dc36e2af2e83268ada5406354c6bf282cd40c9a6d25868cc5cf54e1cb0edaee4da2982e1889ccbbe773f0763ce8d6a363ed5d08099ed4be6b5aacdbc4684242f26bf80b6ea639aa24cebd8b2d2b343f528a3bf3f12709a3ae96486d4792c5def276c6f786792e3d9d13f3d9438d9707741c6108f31413fb38703e8fc13e86d8b4939f2f6fc2a86bbd03a67d5fbbd3320afaae4d7d925b0014605365a9e9a86087e045c67e1def9e017b02faa75f629e4570cbac114b55b0fc50ac96a45eb03d2511e859cd01e2299b7f86a1e3f5f5ccdd6d032580d7e5b8c5de70be4b9799b85b21e6a76e40aceac4c88ab53a7cd81042a3104c40b2666f2ec6e0c6495c032c86db4ca4f296f139064619b08462f2cb90477f00ff0b35ca1b8ee579caaf7fdb93f7aba920a3acab494464ac265ec3a5f55cb2b4306b96f4defc57458aaf5395a235bc87420696191238ed3c8b03fb60ba8c78f2515d96ed5d9c43c4039adbc016d831aebbf6fcdc1119bc8d04062a1682e8a254beddd55bc3f1735af884f3c075ad85fa30b722569b642fcf79682391610907b19f7f297222249a8f0f625ec0ebcf7ca59c7313dfcb9f05099e89f94c2569480926954b5c7300511cf6b3b5e3055185153cea9107877308acd84083a120114aec4459b4f1432d21194bd7c819f4aacf784763a08df13aa571e8d4fbb87ab28ad62d3be17c1337de3ecb1028d6505c5b5f4b8de2b6cd49b7c0b8cbf0f9522fba0a312b7c964a283a8d53945a244edcdc3bbc5d9f177df0a7fed9794ce6a518e281b3ac09f0943d1d5b0767246abe13e5a68321ebc64b1862cf6e7e98162419c73c914808dc8db5f9b676f6e8a09b800ab840441c71aa1d58cb3e5f44bd4a05453fdbfa67f79d5de44323830cf5e0d622f5ac903c46c8db6412997e7647b7154f2f147bfa474c0a936797984b8e0177e7ef6b9b941713bba2c29b72cd0fde4a163964618a727d95a37d55464fe041da79185c0de9f819d3741e51b9bfa480aee21a6aa18a3c4a3e3da21f635211dd182fefc225ce9326a139f6c2be869b232f9189f16960b2d9d47be3d9f7ac0b6e6f89badacaadad219f6dfa1f71bddd8be0538f9bc54571b649a94a88171e2484beb8d192fa452ec813a9a1dc233d65025f57a92b4c73bf4aa341fa64e0b14b0b74d1968b5233e7551860335776e35c97eb2e6c4407d5d20ae6c32f333be43762082f5b03134f31242be2ea38618fc3863b4b44953bd351f83c40f8e914f69ad6a9dad2ffd5ab0e00115ee10127ea66db9c0efd250a7a2b21d8daa5b950656b663543ec8763e32ca75c6e920c852e8f0d1a6e00c2edb7b92feaf8fc79fc798b2e3419ddde99387b44442d87fc6697ec2db07e184f2dead343ce33ef8401c7eaa251d7327b20d7b5f21c78f86beb378c53d0844b8f1f1d8b771608741d10981b0d1717e76579d61c9860999b5b94f06cd64d581bc2c4a0f2a8d561b3d64d9ff775270e4e873223dbf879ec2de298dcae1155502fef248bfffbd7869b5d3d1daf68af2e90546f7aaf29cc768fad2e9a0828e2cbbba3e728ecdb1044324f3e3eb0986e8e1a9ec6065ba5eee626778b1fa1a9357c68a5d24dddcffe5da39956624bad4b2db68a9a699a74483635d820ce8ce09e835c0f33d909aea90d4e6d4f7d682810a86c206e28151e3f286c729f09d830d2283b585059ec88efa394823f5dc32cb76d55b756d158343cb0ef14289612d3e8f6db71c08242d7ced9c8a3dca43ebee69801e772fe133eeafb3e5a896dbee0897c2e5d35d0d52da010312158462e6a64164c3476dc7e086617554577655ed039050f07e0df35bc0067f434b08aa1eb68221346df4f78cc2ef0c0c2881f2fca044441509892e0de2808dbe0e534d50fbcc655192cae378228cd32a58202ad4119960e2ec63f310aa05eb426eb897ec4e4d526b769808b582d7cd3927bbc8319eeee6c7408d581bb668f65463471ff3e0682ed7c79fdabd6da5110f47a7bd4bccf16fc28c1f6855e12d42606ee4d8b7c9d31898be433d3c0909e0526268fb4b48f9c94891063b5e62a38020ef0716ee3c728eb003dc6c995aa2b91f3fe57666aba34ca022cfc4d73f02c4b85c9301f586bbdad3e03e64c14996ef47d06be04827dcfefaf956205fe39b031fb86c0364a74d1e30ef509bb43b5967ac46352c8e6d9a03adb8ed9ecf56b0a4bae7280ca410776af039fee58f9f2e6023a4a489c62d4194c2acb5ba165cba32f176940c4053e59de0995b7d0aa3c551813568b7a0cd8a86b5df797759c988794b07181a52b83fedc3fd52835c917d7d1044bdfb5c529fced8e62a2ec8663b32f0cac6429105f914bd59c1de3348ea8cb0d068817ccfccb1cbd9d5396e4d51524f65a0e0c98abbdc1cbb441dea086405d38e6effd1d3d7a7d4ca44d794b6c2e902c25da84ff7e8a3e0587a100cd115dd096cc20f8b47c30ed1222e143b272812bb2858023e0dee2842ac936ca2ad52d94b1a9b45ae342b27312635266d6312f206003bbed85298f79f3aa4bd6a1f47fe09f52834c58550759acead1dec95a9218a826f34ba73e1e4014fe570c1b2964e67ccd02e1fdc1580fbb79c66cffc1e0d886cd55266be0237dbfb58753e8c85cf34e103882fc8373baf1aedd314192522708a49b8ef6f5b56b689cf10c76e6fc696c4a953d1bf6172e750d45ab09fe73e134bd1c6218e64f815b34742b105e84a9071f25bab1f8f7398dbb3dd652adb0e77338ad0c7f26e4e044101f0ab789bd7603a3ad6946b7101c37c329ab3f914a7eab7f145c88804c937f7e804b51164e7636cceb466f53f986a4d640a7f4722f92e4fa5a00070218ef512a17c3f38c3a92fffc11944618d95bbe7b5d87e301ce826d32fb0dad076ae03379516b18dec229204eef9b91956187048e7bdac6bacd4ee126165376047ebdd6206e7aa05bd7b8de28e2ba88470106a6d6a238fbc47054e96d6cb93f62df7500d143c7868bd4d2ccb13aece8c2dd1bff1aa0358212e19c25af4fb719a274871965c618153e746bccc95ca3a29100abf17464dd17e8f23eb5c0a8b8072a32f94459ef914f2185906d539b5eedf3990493056f8adc2e1b83141f585e89c596a25613818a7cf2055c36b86df6b442586a852bd6f438152955465c7f68750ca4a1cfe010207e6c04a072b9e3a94f672bfd90ca692c9b4c86ac21bf1d226441887fae877b13ae17b365b907b64133b091285a79fe4dbd35880ea58ee77a4966f2f0a556291be0de3a25ef0ae36c89cb6e5b7b5f464073f089fcd98526ca2468f04ba3c7a867df7bc38732b1e0db1e3ab2ac168e3cb9bbf0e7e84f5e9a0ec5be40d96a140023081d1ae922d3799df117df2f64de22b453fc410c52e89349e7ea3ed1c61cab064066aba80471826e4134ccf020c4d8beaf87ecb086781f61026b39698583a006e248a15e8c1eb2b44fe9b7c648bdefff4f1230a0e68feea726579544215385af64df95c661999ab963808260e1f789623eb7c4597547edf76438f6327dca1d0de0fde69c1855b121e059f838a4b6c3e6a249d0f60ed6e2071ab93bd828ef2db2302ffb7aa3d5bde0c3e1353e85c23c3bd428ccc5ca31ad1afc9168d0e20457e2dec83b1bee2f4ea9afb59eb63d0aac3af2062ca30586a1ed3535b7153b143bdffec69f822370298ed993d5abe7ee8b3855438f28e4550d67ae2d54bdcd3db963b05bdd605c646f0d24f33661278a05252b7ddf992bcd0167147603b5ab6235d764b4480deb4c48a90ed6a7ef121c2feda053d32e951060fcee0d8fa16f6f737a468c17837c630387526823108b0a171c9581725ab9b29ac02151e703c75b56e4c609a545bb7370a9151b8c48798a24808f6dab9e3dfc8bd2f40238e4ef36c145bbc84d7f4299fa046d0124063d497e7a8e4f526d40f1383eec2580adb96a52e773e993dade8a4f5234e3f2320306d6904b79e86aaae1f878869ea56c7e0c0d2f8e64e59499c1098fecec89f26ef5ec2ed0bfc9f6cb5072b04fbc2fe1166b701fe70e09083de3c631ff04ff1528bd96fd1c5c087caff900a9ee3e256d38d158f72621bd343a2bcda25c2d095cae854630855bde5b3cb8470179ff0a3af16b339e98f837e209c0141757fe15fe15fb94db65ed741e617a3210a797aa0db21f2be9b7899b5d3ae7cb8c88e740bf89e2787a8c7f683c7ac289d5e1d71428f31f3ebe573062b5a64fede7e62fbc368421d0488ada47d1de717fc95db215a0b222c33e171215d5bf4d7f129a3de70bfe16e9593676ab58484a433dd9b06fa143c32dc9099f42800c091e6bf4430056add7198de0851a2dadc4aa680ac06a5abc1ceaa3789dd4ac99143acde9ec26edce70951b3d62a32533d64449f0961814906b1c75a351af7fb0d5c4e755cc34957a564183210637d1750162fe9bcc25e690da978527efe7fefbf61483f2c0e464b39bb27d833a3a16760843bb7f55b251fd9cb7037c3015d65b7025f8db5b780e04eaf7c2c52a71aad1b964e9fefea855051746549ba9d4f8cb8c8831bffbfb67d78a19afbfceab70160653e186f8e982d42f87f88397d17795513b4a26adc0d28e2924d0c4616ca917b24ccc9c51ebf331e4e185f584ca4b159162372f613e6716b07d27d43415dea1fdd32d23891845e17b475677b2aff0cf213dfdba73de5a884dbac0510103dcb1bc53e47c3eb86a2a1c219112143ffc68b6021c58247897dcb81492c6431aa16972f1f58cf0fc0956e60949a07d48ec4dbd222d2cb114b08c0b5ac0d83e5d9c526ef0c035567fc7fa63b05752be6c6c3698c89bccd16ae8e1ec05fe6cbe98a52202a6282b7847091596bda75562d68c369134b0c7c671aad9be350e317420dd7ce49def40f4cae9525e015e7bee7046996e2476dbd1d9c4034944f72176f4a3091e1f76ca832caa1312e5d1b7596181cc24d9b1bfa96bac82f14e3bd2c20fb1d8ae52af512eee4447eed01e3ede6f6caf0d0061ea93e8d0a45c073c84330c4c975bd7307a006ac0f6c515c3319ec3c62d64c0df4c663521b3f2b52d692df79d688158fe10bc25a1a91c8314c68051e263ad357b6ff06cdbe53f166dd3e3d92691c455674e41d034ad9edbbdf86214fa75a603cbfad08b009c5c4e4f4e9928a3bb44ba72e42ff20f0a62275cb400357847ee4d3c330a1e50d24dbcfdd917df3e7ec01184c531f94440b8ccdbaed86308103b3faf8645f02f1b3e8eff6f85217892e291f2825a7a6ed73d7633c27d4aa1ed0a015cba47b431a08e398aa5b9b74e9c98741a8d6b641948823d760fcdbc429cffda93203cad826bc8b7bc3087358217d533d79fd1be9faaad9ddc590e1cf01e8153622c530a500d29181e1fab7e2543c77e88dd0d108bee927d8c3de8bd3d62b4b384328f908a66c6026aa5882de9a0391da05ebad078a0c1f19a2c2bacbc94bd9f5f24aa09c29bd3dba55f7d5d9e300405427657a3e0fd43d59ef1264371e61db22fba1a89eb312d6b8cfb444f89c3867b0d1dd4eceaed684f2784e45f1d5ba6d529f3bd3798ebf9b5a6a5aca68ece142bad78355cb89fda009d6a3cb1380a023132adb8fd44c6bc5c1dc85507140203cef6d8f87b24a4f6b9443e28715e461c12636c722f61ce6b6c281e2d8a46d8cf7e231a2cf0abafda9fca2357d396e880de1a3c808c3e9db14806351012440dd2061601b3e21d91709ee7738020483318dde50dd10d0d0f7008d2f3385b7d70f51adc0e8286e8baf104badd979c7300b4b5ebe89ace441de98524b31be0b8aedea7b6f4352e7e099c189d789ba80bf85b22707ba25e45e1da7dec8ee03f01a7c00b0137d4f2d0cd0cd994f3f1334c2099bac3c2f727b0f661945a654704c466277693605f42c7fed7ebe52dd7f60573826ebb1e7d591d586758398ae862d8dea71c4b9c07907a4f06142fe6711d0235f314ed7ace5f1c335ad293eb609d97ffc76d4fcef62f2f5fe51f152f0af7390e9a2c7bb9ecbe9ea455863d6944a1cf91c68c0fd77b8195e38563d59c1426888368709f949a804530f10423255e48ba4f12b1457bc5ba62918a5a19c0a3a6c87825a4ddf99e6c9e61861f072706ceb279a5be33d27bcccc749ba6331a9e530f82194107123531e393e6c47cf2b220ccacec6cc4b0d0fa32cc08a148d526ade8a6ce3123422889a9e8a2a086c9cf2fa0d989c2caff16108f7a80f5b515318274012d075d6b0c8cc2d0d34ecfdf110bb5f90e1c0435a911ab2182ee2267d720120b972ba64fae5eba6f6ed9ea27f59070fbe9a7d1783093970e478b525506e099c9e1df286dbce97eb2c562e743ad2c405be7d22442cdc7a58c731213f3646efc57abe5ce9a59531750fd947ca2919a637b718a027936040630985dc26db7ae19c556ab90442ecbe50154c4737c91a21128667889b2cedccc0dc5644b5ad964ee9e461cfb331ec8aa7c9999795ed07f0746cd6f8365b75668996ef4ef6c2c98eca0182cb679f0ff93b577fc2e2268951b38859f345ee161b6d6a3bba815219def5ca906a4335400a1ac38f11b898ad96759c11184e3b52c03a3250c629ac977e71a67548f0af2f509094c0db9bd3ccfbc64e61311aca1f2345dbaa9733ff82745a085a7f223e2b4649c02c6c6b3657613963d6d60a6553d15dbf47e21cf3d2efb4cebffb47c1986af7ded04bf96787a610ca12b183dfc7a1ea4161d3607d3e719f1c94069c8f45f96d82dd5e1b95f1cf12486d36f1c8f5cdb03a18555cf06c8ba7acd16ddd5de7e681b7b9724b7972eba4907a05ddbd9fe2c2aba38deec12696397410337c67d42b8b35dba29d970779084afd959c4e7a15efc761d89a4a113ab083c331f5da864f8f5f6d0379da0f336082bf9963c2832dbb7795e5500a183c5809858a5bb00822ef3f8073b4519138ac52f088f5e313f0b0466035e252b3ddaabfe06b405cea0f7401d5e47695b6aaad8d1e4995347e6f4fc5afa4cb73151892b037e72ca23c82322c9d1656735361e05082084e832cfa05202e78023722b857f05c3a2a98efbef2ef6de6e2460811f559c0b0afa4813e65a0f5223b415b90b83e701ba2a37ad851d4539d258e965d88b7dbc6518de2ae96fa1d77d492b1c94772340f02cfbb2faa557b593b7fe6fd700c1b777a67f08d0bf59a8bd7d573b565af3037e1fe15bd199db9e8b5efd16c77847ab3a9dede38244eb25d2b062b3ac96dba06fccdbb0eaddd4a84b29129911d573520cb49ae140af5f4298678c3f8ecb3a069cc122d0c448e2d9e5e73cfd399a361afd35d5d9146cf26ba41b02a672dc96dbebbe2c25baa973c8fe4cc0fedb8729dc103cac7feb38059a9c3e5d1eb0c1cf2aa03f5507f430c8a59a29dd46a17c5618f04872ef9b4672869ab7f9bd5ed653cfe05fb3c6afae6f2045460dd44e4658278b4c68da51df47f1079e6180afeb59b7bc136ebbf369940552478cd353a4d0ca2bed33e6c8474646b154698b6140206fbe3702a7fcfb30539c28e3d01174dec3b11fba26e6d06aa23b173e07d0cbd7b4144e58311c65e8a72d1b898c52bb3c806f88d145ff47267d19b97cefcf6832d2782b8cecb6723e2a8afa88e7e701c2f0de084bb712ca888524fe8e22167f85f31cf3e52774a3e35ce2a32164936684db13b2c91b43ea50e62583931b1bcfb7adf52c0394f3b6554cf81ebaff311d5f0fc27a7b9f1c3b144070ee749ed8a6eaeea40d34d799967efe768fbc04e917ad195e5e7173597ba141f181084716af71e47f44b82f5f3a32d387d6f3d652c0a57d54a2007402f0b868c723111352fc2368d6d085d573b7f2c1c2370624dd1a5834af3340054a97540d94c44f9140c3b4294b7536c6a7544fc9ff5ffdbc18fc9d907979df8062f32226f8846592243c38405544d78b40f9d34f3aa6e4949e691d09a1da31a5710027ad0ccaf52f7031785a1df3337e5b248bb3daa3e3fa6ceb6d9ec8755e9272754d4e935ca4375c9e9e50bfc2550cae1f6a9bcdca645d85950420d64c7374f02af76583297336e6cd0426f1be82646dbd247a101e032eb691f9b2da38f63bac848da0c81d5156a72548f649164a3695edf102ad5b9ed494a84c611dd438e6766d5714b0b421d8e3a31df45f41b381cf616e7b5ae69c9988352b8285c95667bfc299bdee8a426cb41cd30d338fb564f6fd2e6abd6fa62b3c094b88cea8c1c8cd0fd89aeae50ea042a61f76e9ca4553d28201cdbe4d3690653e00639d217f208dd818c361eabbdeacb74c617125513496cd3df68a81c0580569dc5948e0de15c934e6ee41d5c91d491c46fbea922bc8f7b48425cb6cf0ab2abcac37f6f174ccf230fae575f3d78080124854f38dffe80bba724b2f26c73276bcff59b6e5861b46b7ea52b1cf278f8492d8a5fe07348b050978e73c384097d07979deaf723085cac6efb1feb9beb6f3f2d03d1f5a25eca8983d52a48820f20873245d1035e8f2eebec2b79c11ec1163dbbabf4cd1547cda594905f45134dbd0f2895f4ce2f698b248171bb078d5f627612bf02aa4147834849d38d36ea07a7adfb3b134c1e8a992250f9881dbe2947db2de985b4af093dfc548cf543b5ca73ed3b15dd21c2189017b28b0de83ca0d362b8f9b5ee7dc044cd374bf1df44f3251408ba375691083fdeafb110ad63162c24860c960212affeb272bd0e6f3c2580d91875ba8897a58f63caa620191d8fd544472955e9ef898a53542cfa091db92efa988e87c3045bbbf9fb2800b66a6d6f588f74ce7d019c9870b86ab9a77ac659617c7794873ec9525ba285c29c74756e8ec777fd9e51c204791b66063bf0af84d03566bc6105d8eafd9a661e477769cafdc61df895d67fa349302f46d4443344371ad8a8595fddf3fca49f58e67335cba75c9408a53a9d8170b0b4d2120c352d320f438e9be6ec2f9a044685fe53911a9ce43358b25ffaf55bb0986e4a8a9643bbbc449dce438f0f05b12c14e2342e73b838cfa9abb9298b82cf97cbcb6be20bbff29cf26656ddf792afae340d29de5fd040ffe4cf7c59d5664a16b512276d81e63f70cf2aa605952098fde233577310f280de21624f412e91a32b78124cdbca1f87fa0a9ad24eb5758ebd178f555e9fd3640bf32638561dca919f9e9c6582dd261febd422b8bed5f60028ab83fbd5f3388d60e944775ff9d7fc066cb4495030c2ac3603b4da296b1f8f67c7c1585f6fefd50968d3cc7c0ff89d2bf515e9878f2338a2422231dea60c8b416575e4ed505a50e1feb2dd392898fa5ec5d9507e261da96d918edfce9de78bb8f51787d48c3985cc1bf35a3c1a010a96334b6d016875eb06321347448860375f5b66fdc9535c31b4fcb7113ced09ad15946c7d403c2d5c3a3de16508f33071ea50a2f741b468753fbff6be3617a50ba569878da0d0ae315bea9d185d2218a029c6cc232adb507b04b6aaae12403bc18abd75c62addcbedfaead37fa691776ed2a8d62702fc1aeaa0a5438a2dda8b39fa8455d073dd9dcd1f5791f829f7cb66776c890d7f10e47a5c61254bd30fdfdf45a14d9ed25fb00e64844052c98fa3f9f5d5e82e48418bae3810d6cfe5177065ab3a99488e318456de0ed61efc9b7ed0f3bf2889dbf082e5d07f38179f91938e4b2a58b957558ffedfc46d2403563929cc8816bb5062ce6e096540e68e254593049948c52736a5081b32d2344ad47f5265c1da40ca69e3b472cfc58eacb446715b2058fad2c8f5ba45c64a0af206d16abb8ea2499f431f5ea3bfbe0dca5a42ffdf333049862a49fd2c810d2cd3f65ff16ab2659904f064e931ded9b92b79cb4189b137fb064e6063a8607d2d7cb12d5d2be69b596e54a807409d5d400a9880010a3d0007187aa7691f525e1a8906ca1cf05e6a92c7faf0a9fead13895b710d684c67bc3eae56cacf51eeeadbc7fa658e19593b68181225f53ffb5231467937a4673de91a473c9e44de77b8a49847a0f78f11b635df33f8cf70d2bd0cd29aae85d1a100b7a8e021b71b43f2eca0c0f0f359c0950a5ed85d12661ac3c0b91a0769a8cf0f8cb63f77f4d9edaae346c902c084357d0b2d604ee776d6eb142b4fd1ea1bc9e3eeccca7cb24216a3368a66babbec5baa5ac29d6bf9a4c378475ccb9a14c7eac04282d81b8de80c28870c17ab3ab787d92fdd8365da93431daf66e557d8240c145897aed545dc3ce599ddc0449fda9f6ecb8f55750b226c51763f1cc59f4b88967620730f635b739c6d7ff565e8c3189f01ae320db3cd0419a8443b783caa2b73f2f6ed9d4c8c044a7840475d30045a2e6ece9524b28c690767fb23a696044eaa6dfc393eb57de842ef57c2a4b93fb3f7e89e0a8e83e309da56f8ad4c484c9c3f9db120bc155734592004aab8d01957a1d30570cf4c53fe7e207fbbbc9964f68bd65b3b2872ca3e88218d7b5b0486b80a79eda5177d5cf7211b5b3e951c6878340a213f01ffeb9057453f83456a72dd0a83c33a9f81c268444ebdba2e68a15cce49b6a00b1f9fe3dc852e13a9fd5bb0426a31dc2d4ec7639223ec0424163cb5e3062390ed0fbd139b2e3008cda31d4de85b2c0be228b69a6ded0900c09edf5db530da00c26704e1997fa648958e712ab2b531bb5dbf5727630cff53af400573fe8c73a93dd57f4430412f6909f70477d9bf51af836f9f92331ef3dab792dcd933043035e83e75eff2757a23cbaf34980bd47b5676bacc2526f5a48d602d34caf579739bf22ad606cfcd9cd3f0630f92036e8ecb4d6f8afd7d26d406e0de813f05de0742cdc22131ea7466222d8844d06f204bba4ce46d133ef07b880c5957d919f6f061a8ab7eaaaaf766a51251ec3fbfbba7669ebf1ab2be92d986fa181d09543fc8bcbdb03a1d1fa0166308319352ca4ff529484bc187f9499b8f4b1a2f1428cab6e6cf3c0a92df0d177a3c504c7811670e6b116c649c2e42360484ba5305e10eb57ed74f23969f68c96101231d31e2b0ed4121adbfe64f099dd44b8e81d63c2b14934da0f4f247f73d8f1e0d0887a83748a3ac97d577c5f34bc91ff44f912f407d2bfb7dd0a2c62f14a7a8dfa9c8b70c4ba7287ed36a57c97b1f4167 Hey, password is required here.","link":"/2021/02/05/JP-KN401/"},{"title":"JP - KN402","text":"8d229d8e47333d3f189c47d25637efeb68979f642698e19acf948344191b8ee173de7e98889e32170987808e06ebfa7f3c46275e104fcd095efd6a5d3a935e8b087c8270985f6033d9bfe0fb6244eaf14b4916343d98f637261965eb057d01b70b92ff721e11e3d7461524bb21b602a8bef285c16bcc16f4751295a81e9cca0dfb505496be50991ebc8c24f4c4f0b13bdee905243d708cfb80beaaf9e057b07c719c89845c7d140bf68669465436fbacd64a6661252c66c20208c4934d2b236656e2e64929da33bd9992899a4adcc8481648bafa8e4d04592a38d012ee00c66c35309c74dba773180201d8616f0323ccf958e35a3da617c00f9154aff398d97232715999bfefa8586abdd96f494d1935389a7a614880eb2d8cf25894ac8fe2d695cf4326bcd09d99e2822c31cdf30a3173219e08069967953824b0b1d9f0126b1078c4cec286c54f4aa2de27e97a1cf9c4b10acd6d91101ab03520c1058b44bdc29e433212dda0b3a77327c6c143954453c8ca0b5cb749786a50510105936eec3101e362aeec57adba1b59e1d82ce21b17075995038fc26b7c6ce0837ea753ac639008889f3588584eb03a5e0077ed03eed529985a6a377cb69ed7580e938352aee33793257fd6adba759f9804c7f5f6c1d23d1ca1a4672f98afa4463647b912123376972ba946c18faf47e2633ec89cad03a44a87d90ae48c373410780f2a284829d06b62c9bba250ba6dd32d5f33a9387d822c7483d960ebf0f2655e35b3a2f84ac28edd86b5ac07d8c4966d9fa6b1d83977cee23afc4291f2faca4c8567410e380b6107117bc2cebd7fd3015b54e89b8be1f267ac8d197df85c53fb32e4c51bc19c447b428e024b869b3d2ceb51a7f50db773648850a914666598c9d5647b3001c4919554acad809fa5a95a4070bafc9c08c8d17cc6ba928c577340466481520bb12aced2be5f7f49f779f2614cbf5576b54b611bf4be4491b0ebf49fced672327e28fe07d0cd17cafbe411496afb94a8c41b406ceeb668b4c3adbb0f4148167b9b101fd3e8c816bbe7b4217214b456fe9207b4525d766b46fb8608fc6a20543469fc458e024c9ce862990792c361b254025aaccc97d0d3dd62ada6dd5926bd95273975da81183bc0d9eec0142a72e98f7250d372508a81c66eb808585ff8801ae0997e2230280d934f3946380a9b1f16a1e811ac4bdde8b082de055f0589f7f69339018ffed3eb5547214ef70b787b8876de870024ea06012ef623828328e90688250296a1212e4700e2dceb93548ac717448a5ccfcf82c66e37ba04d2d91f0d9cd3e35c21fd1a4ce51dba13e45a54f024c2459e6d9145c69f077246a05a2dde69e94c0fe50ff12606be69f03603f56be2cd86a2b1446f1e242a7a9626e69db06e5864a4c9ae757c8762c6d50b1a070ffa94bf9177e01f6c2f51d71910eb13de3aea667d16b29fe2a17b877858f712d045931a1e81f0203b3189a109664418ef0ac60c98fedc1b211402f6bdc7b238c0da011bf28f553f381230cd9a4aab9623001252c07410c0c133c6110204c38fae7c840f33ad5fcc58e88f12f24ec54697d2c4a27df5d02888023f6170b03e9a13949fd3b5a5a6115931231679ff148b03a12cfe7f78e69e066e9d300a857030ca9ab92dfbc7c69cdd6bceee3f674ea715e19a08a573b5c9627979cfee5c2a9e23480d5637ceb00ab420c0620ab578365576769ca04cc044cb9360a7fa67e90357254e5c74459d358fd4db3803451cc60d444dbe20feb65d889f2ce3933361e793c4c527edab96d25119668457ee48a3226b9ddbfe171c5ed446c9918c9de3ed70020580e7c9ea5f07dc26effbccea3a9971f5c8e1d403210af05526ce91f653aca190846d09e1c934b2af4c0076ebd9b3a7e257451b68f21c2e55f9fb1a7d5d3300acda82eb8ae5d0e5e2f3970d6d5e88ce63384e8844edaceb7c8060fa62fef3a1fbcdccedfc6b7cbd0d876b6c65431e79b6c2e8e1f1faf2ada63bc98d1aad6e8fb2e100a49e12c43991e63b67c5bc044c2b0e1ec169756ae0f2aff46f5bfd30a1a704bbf20ed5ab0071f7b75aa92cb8f55ee62a663adfd9bcb0d59a7c83b37932ba7b4d39e71aa35dccbdfc6e160a2bf3148fbc72b706a773be6e07a6986727c65691bd366110a9d95b70b6a6bf25c586dafcb9ceb03f665ea74da19f8397350bc77394a448edf9dd824d065728b8ee9c43fb27b4b6e1016bc169664980efa181f79b377abcc9e0ffc3edec93a03714e8de3d4b472edecb33caae4ae107890becdf4920e6a3469b34a2ed1c751166da61f1419bad937fd2629c03aea0b9279f929a92c79627c05b019749f37a873c3bd3382ed14a5432d19d04078391670ce58d6ca33ea349d391b0585e8a3b0585bef3a5d68f43f3581ac967865a5fc0d45c64e9a2f4cbd1203fdc39a3d45fecdbcc3353be8fb64f377ec367335556879eb4c55e2a55ece402ac5bc9fdc7e833b9eb86ba23bd173d12da3c84d0118754a4c358f1acd1384c14822a548ac67aa1631ea31e675b416f92fe9dc1987f02d22838b2bfb878555f370874c2f6a3e75ba59dbb4a5f5b0049782529c6b0b0cf37861dc6bd433ccc750578d16b3962b78ca35936d43a6a384e5514879b219d7c27174b564a4234731ef8d7de5a21849517340e2afaf824756a08405c708b921b3f5b96ba04295145aac5d09bcc83c99370ccb82f7bf6f7c977d3c993c367b575856b9e7558f5f06433109e9e224661280cd7ab8af4aecc7d54f5c1d4c60ba6e24777df8947ed44981d30147272ab40dfa3980b7f69d62e1f86411faa9c8e18fd2f463f094ae1e65eb0e789e1f7b9b1bd08b88c0e022a41c1065424f81178a1509848a092fb4f2eaaf2bc93ddcd9457b8c3c514bde5e0dba8740811a0feacd88005269655bbf9ae93a8c26e49cfbef42dc928369022eaa789389d8b00c68e9050ba4424ee0d1123716309f88673078b178a4be7fb7482d4565e10cd9a867c8e60681edcc3462269abd0d54c168c9980bf4404047d87fff22cd17a85915dfe6f1a692dd77ad5f9487558cf5a50d921ccaac2c38a59a8d02516b0eb2fae579e87efd4368872e156e27bd96980e9462229b3e21cf23cf6e8f22be68d2f563e000bd951bc05b6ea15dd3b37cdd3034e9ca5df4597c402eb9f3ef95fb42390feda71f7a70cf24f95a5a5438a3e7d6ca24446c2e1e9fbbcfc9ec239cd06cb9fdc1600dbe6d80eee005fe744be598596b26e922ba989f2e52ed302d13aa7111055436b8fd4219aa95c5c857ce82f97c86f28dc6efebc12880543fdc688b2fb1ae9f55e66c2fdef95329c117dbc2ed313952ffb231bd6cedba9dca090bb3f62dac58d732e90c2e30355439312c75d90ddb0c049e316faeb94e0c042edda64993cab9431e031074bd0b89117a93013b9e41fd1f05bcd85a8a72ebe04b94e2e8221b9979d71962d3279552ce5225ed69b23b2c183d848d85e80a9290e06272c3078fc92ced078fd78ffb57e477e3223b6dfed03774dfb40ecf457672deee050bf1dda41959eccebf234753986b94900e555d57e1256a561c03b29662d43c3faa5916b372f297a2555772b954eaea009134da024c983227df82adca2301d6b2aa286c9ca373ca154598bac91c876afc92fd3ad355c423c77332b6384de32651c16054df0361e1e1bb1ef042c0f1e626c99e9c2f124806753de8f01685921bb29f2c6e88543021b7c8e96e805651e88b5c2b14231c6b254f38c4fce6d0b02b8b919debf28b4770258e7d64adb3b4cfab6604ae3f3153a37515876b3778e9f6727518dd3e3c0e8e7d3f1bb276c704bd09d90ed505a574744445819f732c8b1b9f557623efd70b202c85c97d5576789f065b9019d9da27f5d5a788db957f1c0caaf7230f0eec0f044a194304ff8adeaf9a1527def647b00dcff1270f01dc60bad51d01ca0a32e1660de29add8c49ee38f3a421d4eb72ab4145f02bb4cc0d42c472f27b2b38b18b8820c8317e505de91bb382876ee2930cdad5bdb19ac389bb1f3ce3394d6ceb3f3f3868a7d85e7a7c10f913614007f1d956f5b3669113639c639998b84e71181baf0282e0f8f66013d671c3c72c7bee063e31e3d41ba66092d0609174e0a3ed1451e2a92876e615c4da851d061ebdcbc64470cca8d5fe305ca4e55376dd49e8414abeddcec89efb111120dec52b59cfc63c537106d4c1b7061b3b54d07d68a8399a9f1b327690c0286bee20a792d40b43978f01eebf5a2dff275b973f2a683ae931dced540ef8922728a0f7e50f7612ef2339cdc87c3af51c991cdd9242cb76874dff1b6546210991f830d97b2941452740726fd234cf3123dd2a7fb2b89b1e2b894eaae68041d0652e5343ee2152911f3dee45f2caac163860ecf2f4e01417fb972a344ed35b9eae60de04da15d892de2889b325437c05cdc71f4f86f35df11f80a1cd321faff5373c9e2344ca3b98f1e502594bac2cf80f4a869e5f6e62bb7c923b4cbdad1c48bb1d6ea0f683a010330e3855c2bf2d35796ecba37d7fc3ce36948ba7349746c628fd60e16cf7503be4086e5170560728b20c2eb8aca639d042ed4f503b7f2a3a1f43f3dfa4fcbe5a67295d7af4f30bcd34c2cd73ef9789cab8f0748c134782c94fedec9511c7c6a13a6f74178ea64138f9c4091bc95839c477af9c90519145f08d4b7bfb8cf41049ba1b95c133243e6edd4d77af641c92fd3c0a63640437c557a0657c5522cc60681b0de9654c4e9f074d390a694b1b96351bde255a3c423255bd185abe15f69868d8b4805441fe0940bf7b547413490341cc0827c133eddcbd448be8696162db4a2903512417bff4884126f3e7d519f0413ba5c8cbd8759624d68e117542b5c3e34c5867af625536d0fce2e9fcc985c2009e7c7ee32acb6b5b2cb9fafc00188d0443bd2879daacd89e914924ac7bcffe8805e36c9600b49774ea291c12d72c1b4103e20d58f5f95e8408737a973cb5e5955a157c81bb8b72f21275b6815c6265bff190ddcaea695ff14f5bc4139009b2346fd7b4732f565d8e22a19ccbad9061b5065f64822777c805f13ef550387c293756fa49daa8b27d964978af5ac91a0145ab546e2962e9ac0897ba539ca64ac86ff51d1e079cd9b01d89ad8d15614576a2919266e6ad315df0321eab69ab10ac83eff683aa6ebf6af1c383b78f0b8107912c2143bc8d200bc16d303b215d1373d73b23d75f80d45ce3866f20a201c5dd39a67c6fd125d33591a1c8b170c53f8086f8c03f1ff2a4a84f9c5fb1e477619ce6344862ce4ea60efd3f3050cccc1ac0d42e61784ce284d2d891824b87e65bb2495af86018359927b7f2dd2cad64253ce66450e47a386aaa89b7029f9f6ae98429fa32148fdaaf11565e0fbea40f8c1d41f1e856b810517f38c126df25af99e1ec8246a060f1fb718f8ecd68ec375869e6e108d5c8beb4a41c3490f4f70d4507812959d502616061046a75638c2eafd9a288e65318e8cc9150b799a87fc7968702ad93abfee3312a7621e5be63c7892d76e472484fa7519014d521468c5e36f8146db01f2e5a529cd9e48a271805f03a280d29054ed800ad2873f85fbd340cc483d8f18ade9233736a234350024b5d38f196c7cca5dac01009ca76d50bf867b1580a61f0bc7a9b13341bbfc428f6f820274ca6404db22090d9c2a976adc901780dae004894db1959466dd50511901d2a3e483fffdbb39f84f77a597b3b8e0c2b14cbd611eed26ab98910d9b73d044d32b2d87759e041861a5e0afe2a010df132b35c577e680ab2ea0bae36ad603a8f3deb2c349b9d19ad3cd9a0efb414383cf1c4ab0e1a269b72348b849c21e0d18f0ef6b7916e60774206302dc2d1d2e4546937cdcc4b62c9002f33fe0393cc2b02a869e01ce23b78437000887b3721f41f44f9fa5c4f610f7e200852c5e80655b10b1c783701fb87096bf4a80568db6b4894ed1fa4deb3da74b16b1ec87c6e86e8f4d629f1915bb22becf2ffee50f9598b50a97fd3f65a633028d8998d29db550c37fcda46fb85a34b8379de0b2f18efd112140dcddd71f7f4af4589d1ed765adeaf278977c1ab6f8e646213735df886c4fba0305d67ebe50f8e9c22f6872f34918c04a3e1208254d013c86f0ed64456712c6ba2cf49080175a91a6f4b3e5154126150ea47ed4766d3b32c4c3dbf1fe01cb14668b5ba76f9c51d38807345c5d2130d91f69e22a07ab2ea01e479b67ec773116ef46200184a2c5d7d7de692ad19aa56366612bf59f7a4dd558e08dab512fcff42ca6c654185de4413505745b1bb556c76716c871a6b1e3abc41f3807a5c10b66d1a4cbf210f06d93ee9a38812578680b7e2c56eeb6e5b3e71fcd245c28e2a0f5523258dbb0388117869ae5b7342c167b95efbc4eab779e8f341d90d01cfef5c9ae36edb7ae77ca5f5bc264003b16540d9a93162093ecbe0ada65bcfee779d082bea67764418ea982027a1e63cdcebd5cd909637deca9e96c28dc619fe51ae9b5fa83f018d095b59b882ff91659093dfdfe9fd801693e3b6e0ef8796b4205ffdf8803c1c28baab19f2c652b351e42f652cd9e32a1b5a91ba57aabd36575f345d411c862a93c7fed3a26f09122c4427206832da5c0a5231a2ad844df60893eb7bb9b4b45c14f8dc157b56eeb339735dc47ed932e149738d3643e6300cf44f70b184b59de51ce5a6b214dd8eda0eccb5865527fd67db4cef576f8fe351dec186e3379942acfdfba09f63637102a379e65bcf12391885a091f3f88106983714571eafc38e69083081cc029f6dc56f96b663246c3218974629784eb766b0b7c00283869cab4b841857fff0855dd3d7120cc26ad48e8a4786057e4e1c116f773f8549e240f343047e9eb1c82336ca6d00880593a337c87a88766d799e4b2e71123a50d3bcf4b8861ff03f670bad3f53385c2406db5d022ccec50d0ee416137853bf21b14b3495fc461c4d3cca0bc6577e3dfaba1de9ada9a4ceb74753c8e3327665f82fcf186164496a562d63a02090fa0e623e6aec2e7dad4d26e47c7a106b0a059ab6bc38bf3971256293f5dc81936e83382ad1580044579798c933277f02d61e1bc7510f877207fa32033a01e6b1cb31ac79f6b04ca1fd7a349d9d3aec988083b4512bb1dd51213e8e4d99f266797755e99ee318edee546947e227738dc85f0aa93f96be9e3844a42d5eec176eb6a0e38f54216738283293867cf07b5a25ffbcb33655946a1b40bc6f70ad031c96ef904e1ac9a3624c2d49d689488cb23b68134d417ba164fe9d87aeb2dbb363a8beb893cae0116d9bc498840f0763e9810c5f09e563d4620f32cbcc23af21f089ec95656ded0e9c9ec88e380e9a51cdebe10a0d93bbb12ae823e391fb583b13902e02be5a227c399fc0bebd8ccfdf17517f055b2df8456d395989da5c3d5c2896138ae41f8020160fecda634d6bc052ecbdfba3596cd1c44dcfb826e0488c8d455cd30c7f3338cc32519240fa73bfb5ad3a2036ecc8f094533feeabc74565f6cb2f90a0e5210d7db0a9a1c144320ba46a6fc1e80848722ca8e86bc1ac69a845ce10a8f35df1a0c60d5e5f625e0388a4eaca7308940542c7186bc70345d962253fef66a285c4a7f6fd9e59ab81e9bb1a278d6da663275872b71be75eac8b3186ee1a9a9e3a14121cee8d6f934e64c8de4a4f47875c55b32a72747671c19ff2fd41a1ff38ae55ec9e83a551209a18f8cc65bb584edd45322b53c99e24fd2a6566223941de642adbf15a92e3535091b43a03a15d03458121ebe36564e1dad3d3e3e5f479a5ba35f8e8ec951457807fe96773da1a08cec53d4307bd73e9d8ad4c126209904ccfebb35e788c053eca45369a5a64db2332f0f77149608b392242bdf3e4fb0c3693f3a5e7ab0c63ea353ea6942298e94993a8cc7322443872ea434673e80454371e6604edfe5263dabc51a4fd4b1c6b5fb8b6605765233690b3604f26ec3121b73ed6b291a6e3db34e8ca3878b4a19845858e351f731b43ba94008a73fae97d8e7efa0eb9611deb33a3b915dea7f750f4cde7f69c130555ce42c9f0f5493007735155ac5c52d94504f2e19b0d6eb7393e4209a664ba5b1e8f7209ed1cc7286abcb4dbfafc6511e3b78f16ad0186e20b0778e6cdb5c7ec6e4d88be805e39babf964151a5607074b03986d31b74a1c8c78a3b980901bb7008d8c900baef27d4d4e32776c675881f8aca9fccd4aecca89eee073d15a8a6c3f410172c88aa2c881acacd7bde554b2d8804e719454dd44ef9e665fd818ba808c977bf90f520963663b997cb70eb2ef1d255f70dfce3ae0a7d4e936e5ecfadac8d93001be38843df20d47b9f3b1257af0026a54033f1fa928ae0ed61234c95b1ba2c7b2b6cd5627b4acb0bd60f044156554f6f7e5272db66317f9d1a090e0f118d55aa57d16e97b766d54c1a30755db2f800a5429a8cd52822616e0550659f0b35f773625a40ed2faabaea5efcd795ed7b6dfc0cce446ca65e21926ec0fabca340e47f22deda628b11a778e22d19f216a8e3f0acd2a1ce212409bb7f8ded5aacba3734087d5c08a3de6f8e02ad4888cd9a8f5c24efaafcc8f77119b2e8bb81ab6ebba6f98ffca647b0655485a29bc214aecebc277eec08e927aa69b82d9b900854ea75800fabba82218e6e506102900f81fee223bfe728d69419e8a56705adec2b32a8548e8c5091c5b45409e1eac5e8e27722b2bd7a212cb7a224c514d4601976fe5f7a2cd2d50d5960bd73118703721e85b706d6f4ff23976d4d7983597145c85a6d1a3c9316b3f17086db815b6019aabde5fe45879c81f8eb961c2c4499c9104289f958c46314bc341093816e116c91d33a90cc7210cce747f096952f73a1186543b493ae2fe35571904aabd3e06a49d09cfc6b7cf44ff48a7da66c4163940af80b66cc24f715b096d6b04a2a6b1e3ef77b6d344eb17af0e5736d1c186d3e5206c4a5e4770379627ec3b955b7aabe5896a9209fc2395652678efa8066b69f4714984506743eabfe9ddc6609da92fcdc1b1a89e000d63420939237d8e0743c5819f9e091f809a843c3d660f842cf419c2714b9c610643d93a82758f6b3823efbe84f7ee58e2d90d1807323f84f18a4b74515f2ee2129b0ced3c1cec84bbb657b03b5e269a810c9077e7ebbbb56315e79a417a5d051b3a71ca0ba7229833438f982ee982107ace8a87a8f355b554be20d0d06966a6378e6193400f7c12dd3bf6444de83900d9576817f6631efd9a2b37c5b75ddf7bb21fcd473c91a9672107a25bf256fe0c243bb547dc242d8357a2eda327957b9aaac179d7ab3987dbe3a38f3bf77046417d5dc35715917d98ddfab415d42a19b7bd0886bc2174e08e24168e1edfb95102f396abd0a7bd4207c7a91b73c56bca191e3592e71462f967486d89ef560cc672a7381e79f09d302ea900ee545d91a21f3bfaa4c05af9a99c48a573be66ce55caff4ba9df35990e5b5c1d538dc682988c795680c89c2f5db3d247e399210e6e172dc78308bc1a6efdb133468f3587346934c847cee155c8a87d0603b3cf5f4e93731321bce848f00962921487972a8f2d6725f2483989cd2c639e51c25f41b6bc9f85bde9bd83504abcb8ff6931745952f3ce4ab63c0037c4ece1eec9216e9761a559381641b1c8d11af0da53649debdd874c2e3b66118e2e123ba23c2db8955bde507cbd13eece93a5a7d1dfdc961e701796fb4a64af7b34521d8c5656d8c7f02c8d3954930dab19652a6d063aa20aa787454d16ca08899a3b2b08ea2580b7b0914e98a449c43128802899e21c6cb6831a845aeff985ed55119da719c60e5d06bded4ea391a59a7dda975749c8f94fdf80a6cfc9d503b66de62c63628664e83f674f5ea16cf0f6fcfbe361046ffbd86e081b976d1deaf8305de48134e90378aeceb1c184c9a28c0392404f002b21945c4e9f181cbafa21c52dd6aa4542e8a49d192d463ac5cd7a0ca706a6543080efbed14bb910f7488beb6cd944b7f6e15edac0eb2bbfde1fd8b4497e00cc019dd74d732fb517016e5aade4958cc8d83f23f183b307e1588df3a598aaa011ec081688c8f9420f4bddef64d509b975096b154cc7b24485d59a214322d38e9da3b9b28122353a304b3c47d373e7b224d9d2f5a1dc76785e8afab0d41fa3a6cfcb6e340a9e8340fd977db13f6c191329810538104a8da4ead8c66d461ecc9af233a91fc779b890324ec391ee8ce1164d2cd0c2fce7f7e1bd111ba93711d49bcf34b986da56f56720b0f6e4743a43f93c65513f6d66dc721f91c8f58328e430aa46e6a28788349921b1008bdd1a425dcdedbf998b2a9e3bf84bc7412dd4955e69315a8c290c20d8e4785235f4f898a8fea54511d2df08e7bcbc71bef88a1d251c87fd3149a476150e2461bcdad4c36ade72827878029e78110e8ae4726ed0a6b6fd927fc54a42504ab4aabb221d374847fb42333da313649095a1faf0c4af809e8df0b15a0fc47e4113a515e26785282f2418a124432a737560006abff166428665f697e56c3ac34609382a8e26e7a7ac607d984a4decf6d9cdea6e4e8eb74cbd5fa1962f08995acce0ad10de5a229c73d69b32c76f0268f12b67e7a89352480a98104be063539cee908dc61bd55b3055f61da6f39b2fea5f90522d04d5c7a5abe23c538decd21d267614eeb45047148691f4f48ba6f90b6d15b70e1cb6933f8168094079d435982912dd136090ada29153ecd10be43a2d3fe03c2248e3538d605b67c2bf3ebcb93c7121912c111060d050de5a805cc927b4382cbc5fdec0072ef63ab7cd64ce9c9d5ad71e4f9e4289414f66f4453f9315513b17ccddb64144ad593090acfc82c2ee1bbb4c3af587e4633fc9395753f9c7c500b29a5fa3e49bb6790db0463ddcda5e344d8066398aa7e88da0578bd8184bf42c64bc553ddb2e06a9732812c9d8c2d47f13154744129e81ecb46acda936654ea2cda53b5bad64bcb88c3d693e0d66e287b2aa70766b496cf4a7f1703024172f85a54bafdb0e6da8d429a0f3ea6c290cdbc171e02c74ae0046bfe4377e0836a0fd9221ed281e7f176f159155762514da54ec34b9daf20421eb1f12201901b69294420f3c8c0456a63798d38daeea8562332404d4f7192c54c087e92866daabbe015c6a19b542b7960381a532b6ca2d42ecfa33ff723f393ab93693964bd17a32e1bd25a0772fd27b826f198bbe9326888a3ab9da1c31f32982b291068aa549c5511ca3c5c97e478b7ee55451780260e8006d7010af043d789c4c171ffef5f3676980b40aa2c7f7337ba84fd7b45399e2858e843e0e81a25764670401047966d01beb453ed427ad4739b8987d02e2f4924dbf6e26d306838cfe96b9b5cf599aa8da944ef8147819046330c905ad1003a30e5ff96278ba91e74aa3008d439e38df2771cdee4bb651e42729c43f18e198e7d5f6267ee07517fb5ac3e91843bf0d34a1a1d89284b14e77efb5505462294f37be5359af16c6d1f78a9a694929a25a9ae97850711c04bf515f1e863a7dd0dff788d2f712b93ee192a492e782f60ca592b696a9f38e2b367269b1ec4c9456855ef64680f2b88f71274e2e21d00e218ad6622c88427858e23fced9672b76691663463cabc336844d9eebed4ff1ea453cc2bb0e591bc7a4b71ebba1fe1036057c59105155966aa1eb516724d3182d510b048f31dffe3b1c48831b8bf12a6ee05b494c122a05f0b0f46ffaeab0145908a616c4eed50272c7a51bc4b76f9cd586016b944ffd42884178ee3ba07dae31aa91ef79059112c89fec8028f681ffe931a7e5a9a84ce7c462588f226780100c23fcd45541be0e21e2efb88f1762d3642418286d2dd3330f9071db3d88f596ad7bd8558c05f85aae57d901ae14da7908bc8e14c28d4c4ccd7cbb951d4774dd81c5b9a691ae9336e4fcd511e4e22249eddf9dd44c7fda85d5169a5f041349f0af7f0aac7132d70ea3e23922c3159112c802459f5d088962ead5ff6f131a868dc241178ef282df761263da0c6122daf59b8b62e95ff48c710a0ff63b668d5a1916901a480d2d22cd706ac288411ac7a00e6efe6ca02cf6840c5e3b52086358d1d7826d6dd93b0fec55d68cc0e4dec15d8bfc7da2fbd553b1a5854c8717135a0e92ae44b4c1cee048663cb6581ff00d8a4da962b13a27caa386df9eba6fcb1343a59aafb20500f68517b588dc97759bbf4bd14611549332ec91877216f6a1657c0c0fe6e895b7026988eafbe9357802246496b3b3baac46253dfc943b283d182a2611f7ed267af52a64f5d89f87b61da3557d1a7c3fc2ae7eb746c81bc273bf41431ab332a716bbd44d5e015e894a04dd7e84a6db283325945f16a19c301b0d9780bb7a0ce2e8161cb49ca6aee27273cfbc086829b7f0866a63f0f5f392b0c7ebec64303ad09be51ddf056e07023f9618fc4cbd8ba46309ec000bf41cb7d62ed76b6659c3e739c79269cc3937d7817a1700d8356c436a06b24aa6c5e3409e51733acfc7ac7eeabc6c22a730547d8659ac75fc5962fbdfe4dac669b1e3a0517c5861a8d6b08c6275843ca5695944c4ab41387a1e41f6b851bc0cdc41753c7edfa3e703c47076259f5e42136f62e1df74deae97ec217c16e494eb7aaadeff029e82b3217526fecd9bbac61879b55dd091ea412b300002204f0ef286e5f06f39d01cdb7791ff6408fd97b0879bd2cf95ffe9825defec54fe9907689b573a7fa650cccc0f9d360dae3909f93efca7102de14a4fbcdc1311da6a1de91b2236e0bd3553ad8b1c6249146b60b00f102d7bfbe612292b60b70a637116bb0ff1668f95b6874166568cf4d5b26dc2e1a9a7e949306c0730c566ec2451c3101396b3027ae3995b64133c3934966955d370d7aea3c717b2af8966411c3c9bc6cd4989146746fa0157710a12e8cf66e843672b5a9f55dc6c112c21c3bd5af43a1bb22e0f73590e245bc615b2bd70dccc6ba935aa34acd9c6cea3fab50b5383f670167ef245f169476598d8417b965b428fa15e4d9a22800c687e53d8bb678a76100f2fd55a6001796211c99318b4bda7751aae78393dd4357109c228d0a1ebdb039158984fa3e66633c0ec63c9a42d1033b066caf634f23aed175c91e009558b47897e2fd93b8a786afddbd88625e4f1571d539483b366ada5d559ed8f8babcfc2c4c6230d91f93a65f569f13d7ed55b869cfc0b3111268e37d4029685448699d17b577579f9003ce9f54d8d8d2561c26a0908c5196e39d84ab897eab381a9c3fc60753ae2b858c1604dc2493464509fe15a1791cb78d55055ac6d6e28ab536f1d2fbe7a8f67d4c517ea09782612601bd6eda377c6d36d5baf064072552b0413ca005a9ea3d11c70ba475a3b2ba1fe9a1d6e3331154858f105c631c2b3a771bae49ada486ee439cd6f1cf80a913e085b8b7eec67e98db7077d69fc17e0414abfef968c741dfda253c54192af31075d335a0fbdff79faac4c5eeccb6468af2bbfaddfb3ded857eb682404883986f691d6572eef7251a5b3e93c08f2b7885dcda83e8d3d1ce5b254f609f091e8edf92ebbe2e7465fe527b502a9fdf6925ecb89bd9669bfeacfa0eb3d44e951d70f6ef758d1883a694f4b5f073c5b934053a1ef9322b2aa4ef92da31a6bbe7bd01da5779db4e72da568c609a2916e867ee6c56ba31ea66578e251b02819a972e87dbdca4f6d8122224b78759278393aac9918948a0c64c4ae199beb69849c1c973f9fae1cadb7cfe789b98033f18935cd1d167d8372e20ed94cf726791d1fc5d57b15b703567524ea491bcc05c4c4593f98624e68df5f2c4ad3bac12b81e65524316e25f7df4ea5fd2e27e1fe726e99d3d784cc00dcd629d167b3068f5fcd1d693608e39f0b681513d630d69e35da6433970a038662710ef8afacae65b4ec02d2a03e131b3960123a14c0927d3cc2b2af86bde416c7a5e865cef7c034534ab6094d5dbdce79c4c282cd5185b2930ddafe7b7e48b352ef019d4bdb041b2cc850a58b3527373fc3f5414e535cb12cc1aa8a566ae5a32c4d659bc2db6419fa3341f12ab66897e68eb6bcd6b28920890fb1509d7721770c784d1d2bdcf7933195a559f88091e6e1c33557abdebc64e460ab9353d002d042c5f9c678f16b800dd6b8b4ce55d78f631c5a3464c385e2d4ae720b3d72326a37fce8c5710dd6513e3ea422a4af4af6308997b733ce22bd2d559328da067120e254911fda3368d8d6ae611e5d5054c4f02fcea6f47a1a7297af7757cc1106ec616a3d88d27f37b1d489526cd51991f2a95244b44d1e1d08194f8aa0bea53a06f4a964dbb2b91f25e448bce3861148b8f0241c059630495134b236e9a293d9db350d80a93c98dcb124ae908497fc4f8fe9258b2009423d7fc5483f0f75492206e3432e25c038c28f0f998ec5741eaa314550d7871734c8eb269132f2171c804e977769969ed837cfb827717757ac2a65555eec7f2aac6fc4a7d01f9bc2c89ccbef09be1125e397b91a3e547ca6664295e470de01f3e9f2f5d75d265a1a0c3cf072bda60f640ce98afd2f2a6149b75ca185bea296e7068e2e7889f84a69101cdf10cfa84dc3f2cb85f6f38269901d3cbbb157027548a0fc5cfee2d4426451ab577f815222a88c88e24e7e1bc8200a31fd8dc9d3abd18291903195905d8ffa5b30358b485827602f613364d772962e6bea376a29689077e12265b357a32cf8ca63b80a82498772cdcd3b1bae595e13859c7007b4d58a9683ee6a0dbbdb159d8a469a824ad497ffacf975eedf55632ef935fa169113af21cd3eb8ab02ca782cfd178aa955484024e027454672bd19a55853ac4cdf067630f5dd1bc01fc22ba43450730c11e46d5bfa8548a77d97a96627dc6eb18d090c76b5344f3faa69a7134a67f6d8729cbf31cb61c916061adf414600d9475c91481207a8038065d59d29cb38c4f6fe58e59740416812e239b370efd3864c58b71f8f360a1c90d8edf41ad485ced59896aaa0aa9da8db38d17dcf00fcabb4a3afcde41e7e881cdbf60f9cd16cf6c6601812f7252617b77a26c21e3351671c3b1adde1bc481861fb6298af6ed7a81fa0b8fc438f0b9e84fab76ecca557b2ab731a9a4dde5504a5590930b456b2d63b6cdb3938df680ac5d9c267efd983149512deb4d6f12a34ed35412dadc2ee8283d978f9414ea3a63085937fbde8bf2db5ef485c98b8db691bda680b45f23afc3c5673d058cf3c75df93521e449792547df64d7a6d1d581e19cd7a38be3c8e7f66b6f70959198fce73f8fdefeb8d06b60e9692f6641db6d9cd207ea6b2c95e619a2f559c1eeef903f5c058ce63115bea8696df34bd6b5ae73534480fd14ec8d86a2739ee7ff5397d514d67d8ed494c69b259addc86a8ddc256e8c6698dff3071a727a1f6b5c00db31cbcdff6dd0dbb0dc47bd019bb6195bca9178d2d53b30b83636bf230508850f3bae488154b629fad656c5c92439b1ddd3c06b1195085ce8463e3b49cec0d0ae2db52d4fcb34ab6069061cca4e4653af4b621548b8de380ca15aff836734d9fa5ae756ad6a689ed90cdaca9fdc1f78305b60d8f9612b51989ff3e20404cb58389f79c4d06169eef450decd0d325ff4cbf37762acd45b5bfc45889cd24cbf0d470493634e26933857d7efe17c0cc3cfc6d1bf1d8c3443f14a1eb4cbb78321959b8cd9a177f3e381a99f18e0dfebbe2b06eb7fd768f4c72b5c09d8038742bc002586285776979f3f5ad3a2817cbe516c49b5f579971f8e89e22d68205a8b91b59be15a23fc9e3fecebce691d21a74dd42a6079d0dc5a39e8aca7c7c5bfa7a0946295c07b61ac85f1bbe23ed33638207c4f82d4abcb470f3db12ff340babf8b06075e1e5ed93faed62491788fe4d18ffb3927a6a44e04124cfaf4edf31c62cf6a3d10520087722ac3e6ed98250af2447ba3573c4e29f4d86797551035605ca9660342ee8e3d6e6fec677803cc74d9b2ad46b9c066dc24727be14429aff9630f82c9c15fac58361820e45593c17d3918191a5617bc10908a115aa20ceb74dbdc8ca73bf211572123d066bb8fa728987994b8521f9770538516c21860cf5f63195a08aa715515aff2860b92edb6dfb853989a649e5470755c9645346ac59b472611ad423175b98ebc8d728992d0b1abddffc3b71ac80d0c2b3caa412ef312ecfb29eccb4c8a22caa8f72699a8934ef3b3fbda562de12edc98221e02876df63e3889415f035f3269e7a3bbbb93ffc18c6d855ce9c2f0fdf2e9400030e16b4ce26eaf35083b4ebddd9d6fb6e87479099d2ecdd12eccb9bf6054120e16a2f5d8cc4b91c78707f12a0069a2d0d8d7493cf42be680b2bab56f772a04c58a8864a47c50220aaa54ce2865dbdb924f201ffc6ac4c89d4b10b40d106849729cad8d5e051b11f3a8304649c8444fcdb37780fa80c751e62e7eb81b9025d2bd490f3d434a122d1e9cf6c0a54fe39eb1e1c4286a8bd89fd198a5da07851a4baac973ae8b6e6627b562317b3e32c2f014b5c923f13ee74249bfb505a2e6a6a94257cac0057c9757c7f5ad72d92fb58cf5d07eaf7540feebe3bcf5616b773ee6d8c5159bc302631de025e125b7f0fc76c9df402c265ecd4f42462b4e8cbd9d91755a09ecab44d3279d9f5d6071a51f8a2886ce8f68606436887d18a7670bd54a5cdc1ff0b95df255eae16f7966bb508290e4eee3b74313146964d70fd723e11b49358e268af543670684f575991cb27e52a01ad2aa79a592e08b793d13506a97cb45172a054ea36c2cf924aeb50d2d643efc16360a6cb00c509c09fa363cbf5872a1888b49daad25e8033caa8a30ab9307382ee8c58ee3ccb06aff99cc6ad80f6c9ee9f94beca4cad89c9459c8460918779186e830d8827bbb40dda4992551efe3d4a5cb554b8b74fc0e960e4afdf382115667a6c79ccadbcaced033c1472948862beba75ca923a4d33b688cc6ad86d30834ffd73644882d2787a7185d7c6e66e4614d349f141d8da6814d519c9900842c8b9a2548dfffd3a0abb8a412c9b19 Hey, password is required here.","link":"/2021/02/05/JP-KN402/"},{"title":"JP - KN501","text":"8d229d8e47333d3f189c47d25637efeb5cb93a79968515e30e77e9ea060cd38b369142d174715c10e854b175b846cd04fb7976f5a1d2272f790cc55ec0278e488a56464af50a1608d13adc9e54009072b5196ce21bf3f9d67049d219d83c07a71d73a4980d6d285091fb5b3deb64bdfa9145ba20ef3afb4801938bb1d730706718f42224ee406eb4742f4ff187f43aaf36c953c1615dc2cf1bef1ddac66c5d270c382145749b7f08cab687214f1d1245b7c083a9d301a8217f97e60cf761cc3541786f90e74c0d420bfae615f8c9873c20e7477ecd59a808e13f8345a5c11bf393aedbc0e493157f34c6eb4718c2846e90c3bdc6cfb2f0b4d6ca4b9e8d30c54842d552112457eca760f21682a23f1b1eaad6826792b42d9b88555bbb85c467ce345a57d272b4add151a2b7437f90636684c89d3f56b8a9ce0a4a797f043f819db7d5a685e5e60a7ed657cd02cc94a6ab76c1e16ea36ffb90d579f0feda37c7623d012aa1c5d0381974b8567ef2cd7c21c7aa98d08e2d4e8f6c4a1a25f8df3822a62e330681e32a3846ccd8b9dbe92d731063ccd6f3264584c25a5b01d55ccff9861ffa32a141a9e9b6e13c92fa15eda4687f3dfd9043c7ee26a4206446b333ea32ee30a11100cd158d9c26d464245c15d57a313d1fe9b53e04fa702d2b707bfd77833c7d3e13fb7a8574a3d705e82efa11a616037230ca6c5a974071702ffc188ca4137dd905d35c84bd96dbf7bec6b0eb92b8ebdc4f9599b6cda5dc56ded2ba50cb3dfa8b28067780cdb84028405ba92e3e882c8cde904e77a8280296da14189d435108f0fcd1754109ba1ebda80b5ad1b1b2f59579538eab3bb6db7729a70c3eef3ee5dc46f188b64abb2700593876d2816e3df3dd08029ae2090042a07e07b3edd4a93591f4064000fdb82126677c6e223049bcbab8140ef512f090954ce917064c80c1f67155547c0ecb85c233e5d8b3f01d6cc04595b09f057300d802c81ae9ce7d0d7063d7d0546ab2cb717b266fac90ec1387cf1d6c07e6a7775f3ef13f8bc4a72076d72b5ade0a24f612ce0725206de37c305884b1b9221f7778ea97811ee9f65d9bc7e59452b40d6b23b238c25dbb5cf196ec34658bb6c315a98a9761bf3f7b9997885a19d766d2d6418bbbe29a208e744ef5a42e7d5336b7d79796c719b9bfca184cca9ce90acc09aecfceb9d63641542e95b9e309cdbb6fbbec03b11d0d807369c3f587e0d41e981f43602616c8cc1f80eb525667ff0a2d4b0716bbc44d2dc89e754bcef4057b3772741eb8bbeb8fb105bc4d5900ad41b4e2458e04edc5f49537279b2849862d28bce95c401c6e24ba3cc71b6ea81c94e2a1cccd0d5ee3a28df41e41407628bc04651bbc2b3603dae9af3b91c633b0b4259c908928d5e3f82ee8c780969c01c9d6ef4993bd5657bbd27d5f4b2ae37539e523a5526851149a31e687d1d444ec2d5e41ee32bbfdbd73b4ddb177c83427920511a3a1535862282bacb1200f8453e9d1fb1cb5413ca5c314ab0f91fa5831b27453434769687de7943b392dd33914d8fa9b534795fb69773124d4c5a933efa5cb4d709097e81d5b566dcbbc9aa0b2cc552080a9d825a65e85abb7bdb4c35a2c854cec078930106e8d9b82985c950b70a118376716e898b211d5415ceb1a0c80687dca2b1b8511812f04265fc8178ea0203a4d70bd53175bd69f316bae2bc98ceb0b852a9d867a20f887268ea2240ebc4b11a8ccd72bb9e7578046487f5d4d31157cb4e0d064d7ce15240e184f5e810940884dcb6692d1b662275a3f58c9e6acd4e719e231a5e9bf5a63dad7692a82adfc52ab7622dd8ef47eb2280115524c170e5d0ded573775d158e6bbddfd50b87e3759e4c790fa64045c625780f635339d090a039833c64997755d8b622bb467cd7615df489453b0756606a2ee54dfc9758bb18006d528a9dc36ba04ee323c316009e147fe96e82afb8f7653b30d1198f4ecb2d40b2082e88e37dc5d13eaf67cfa12e2b854dc18cda50e614cbe65a366c826093f2e5941318de1a052403cc984caeee385deb090e6de6091facb78bbb71115abc570bd3d5905c418211bedba1430712fe34fd7ea747fdd29e4bc1dff3d9edd00b9b78d3a414a23c2cb19fe4d8ee76ea422f28bff3a9fdb971a74ff4b3ee6ba2b3f304064cd7b304860310883fcf64de9e4aa154e6dad11bce593ed4671b26163b9edbc49d7e1d32c20fa0d7e91df1a77a6e0dad14710bf7804dbe7d76b06417d24941357eb85d6aa3490bd3b2093ab7f18f4960bf1e1d4da0bace3cb8034cfc63f75fdbfb1bef4d3f59fac319b943a8ea090a04bb35c0dd45a11ea1890f8a8ff06a06e83bbc5e5651b96d0d8aa179767d4dac71724ff09bf092553b56fb9e97ce9ce4e01af35b9fc438849fb2ca0cbec72f0be6667906efd1c442115e78c8cf6e8908427ba03c4b07122deaf2558b36f50641b98e8a773930228ad391c870d81d95b7926d1bc44381fb8da934813619140c889ea61ae04b410d3b6c6a2418706039173fa571b23f175d0dd5aef827cea2d0903e55c111e6f9ea25b4f0b08e6a412b42ab11a9e972a13161f852229b5d05282094b2865c06449296ea3cb1df8edc5516d5b15d1031ee4d6f897039465046508e36c44a0a649bef1378b00ea175ddf87fbc2314573e9726b5921dc755e8c43e0429107809c48d467e7e48c9c21ce429135869e71ddd8cbc5673e380bab30224fa4b0c7c7d6dc4f98f1d3dbd74923f1c75f8d4d0a02cad7477d828f6a20ccc6d841ecb857fb8531fc360bfc785dc4e548642a73a97c8e81e4100bebaedbeaf155e5729b63f400f3946c88cd019e49177181d1998db14487dcbfbeb41abc7aac31dfbeefac8d48613159988bcc637b6149e634348b14dbffe1b97625de71fc4b1e648b4d8a2281c00b081b3244cbce6782de869c582c31096d1e4559e6a8a27d6bd4c022961fdfb08b8af75bb8ba0c8dab6ec70d10639f14acd4c187f6168915fd264d4f7d330b8f7b43e0e2b3c08f4834feea11348b2faaaa465653023a94bd2e115d6b68a35204b513a8bdc2bf1b45d188d9b3409468eef6489f96a957d04f327e69220aa15cdcfd51e1f537c9498ddf144b197fdde2a6e559f7eb77dc0a58fa09a7583cc9dbd62b12b81e22cb198bd655b3db68cd1ba44025be61f6b0f4a730bec0c90a9c58f50b6a7e6e9ef2dbb83e1a8c8b2fa9205d843837b4b8bbffdb923627244b3eef30712ab51a077a6b8fb1bcc39a9b0a1dae4ed434375e2a3f48da74843721f057c626828625928215cfe2084f46630000f7c241bf39fa093494a2dbb818d117ee27a11a64fcdcaea3d4493b3e5e8abe5c0b12530edcdb458fcf5ca29543a60835ebb22fd83b4899235a528cfeb9a97aaa0f804d98dc33ead492cb0db15230f9f16f4edc29917ce5ee6dbfb217b8e23b14e36d11eaf5f329d48f65fb287680d1d4c915afb409706289f61585c7d15091e275132ffc329e0c8ef659f5c560dedb1f9235eaa6a7d33ab81b3efe3f08be7802f22f27170df0d08ece8a63e9f0482aa02d9e8a0975c078b1d6dee6fd58597d7814bb2250b59a6fbbcd7d56914645a8d4087478e5f6bd94fee9e1cdec44d55be2d8bd7153e2ad535a217f83514f60d5ca11079396e1f0a1a7c22e5b508cc596eda58b171986c2942f2f3c84f28211fb6d91b317d7921a89befa05e2691dd8a67fab84f1e63ff06ad67eac1a75ecd01fe6f15f69e29e1803bbbac0efe82ffb1a6199d1f684ea5d8ff5bef31affd05dfc7107cec0911030fcd3fef7f83c1ea50fbfd02e26c572979e4dbdc6836c2778690eb4c807be3546f59a718c4534a62446cb769457804a5064756313c8e9bf037f7c9053413618f827f56f9d27bc95d75fc6e3b05c2a8991492b32f796cf317989ac14892b1d984993a8fe6b2ad631bc4147922bfe9de7a8da6cccf2fa653fc4ca5f16b0d584461b08c295cbc73b650716416738dea92c56e864ad3c9ad7145f0a5e1a1026417a9230c7d96aaa6658587b99de11d3715f788508b57127f65e23abbf311f6aed0ca8700857de62cacdf59dc5582c8312feb77e6820b885a50ed1b6e5d5166f55ceb18124ab3928b8828ca0c93c28e24a2d82c2a60baa9b5c36a4ef74b7053843fe5a4e61e5666894b753ff1037f82e6fcd4d8d8c87e5ddfa0c7c44aa22e4097e351b9020447dd980248dc597864c8aee40ab01fcc19284b54bac6af1174f33a7b0809a7bf325fae7e28ce386eb2206820c7f5bf8b408f6c30ebc9e7c9c88d919bcf7a3c6203d71724274a3dda2331500459cb89a73fded45665af24979486f235a6f464c3ee5810c6335338c26c7f082ed7e4c75abdf2fc1da28b042b9977b4f95ed67da4fe80d3a906dbeb5ad17a3000751e3a6e95c73bed3783c5b5ebd7fc65a66cfa7aa51e21a5a488d6666f8d62d37cdfc7daa139cfc4a0364015f86b7d9fe0fecb1d09e4215c287f64b00cfa0f301fc09a9d2ee6ff1dca11161e8e79371dd2e247bbbb91f31722e442b23a7605836400efb87ff0f11fbbe7c18c1cd50fc3bae3ebe47441b0097df5a405dd7733805a22663c034bab41342eeabcb48566cac2c7a0b9a844ab2306db1018415fcfe0045a17d9cbbc46169aaf2b93593bcd224bf02f75da99bc275888aa2b8667a6f89fcc80778286c94ea8dd45176fda8f7c1a7306c1b2a11806cc418421a490ce040f26cceceb172163ad2099b36d9930dcc8d75dcc814e41c53c46392d29850b3d71d41b544cac9c6e17a628a3f647ae292456ad6abfafb1f800831eb24c759fc6bf8a96466be62acd7b4aa16d423d9419f83dc23a4cd55928ba7275eea37a7e93eb7f665b6d943ea7a2d4687d6d7f716d9d6e7d8fffd33d250f4608f64db4ad418e298fa108e9a6b247de495de17b64278721b4c1f3b2120837ee2059c6d84144aa5cb4877de12b26ef6cb2873e8f217121a3cc381a0c4f06da1a84a897993e6b088b372feea44fa383f578ad74ea1a1ca33e8c62853f0161cf711b9890fb760988dd78ca5aedec5e641cd5ea0994dc6c0240567074472986c17a016e85868685a4c75292568b01f811cb45cf43eb125e7f4fd9eee15e82486e34122ad8466f0ae9251996adf5bc8461362ffeb9696192140767abedf3cd41d20f36d54f95e0ebf0ce71bf7162fa1555f24547dd4526ddc064d5c5c27ad17a9e5a6b073f261825f0ffaf114e8c61afce2e4814ce92d5732b6388e01edcabfca5fc5a99bdbf08a5acbbc1b39398f94c1cf5de04b2abd7ea4ca89be3928e0a48565b91033b47370aed064693ad706d75debfbb5ed0b06e6c80aaca0954ed4e9b2fae52f5818a8960faa3d251beae6801cb93e6f195a7b7597efddf8b0a7bd1d100d51e1917eff4115520eb82face5c5b5e40a165d1e065a7c352c284e2d2f89af95b1f3b953efdab077d4e6fccadb273263c9f1b418556917c5c26cf78191f196adb7a1093900a565698801d70c9a53c657fe28b53c6769044714cb8a8472037dd3859ffae44fb5c23ce0e8d17d6e9ae5c3ee5d35b5a47588df93aaa3ee08e32eff617c57278684c66ba63ed2511feee83945060abf164db8387d5b6a60ad7061fa55fcdbaa8341b570f67ee2f92bb263202d048bd80d1263a12d8aada55ac5c40bf29a6e6af8c9dba346f75b5be44c785e587b25e60a393e562263ff1f620167334e331b703c38fa84b59a4f1cf8f4a9d1df4ca2ec03541e5efa612704f396584b122d30f59da33e81e8cd3f515132df7767c81c269991be191304902365a322b740d9f2e619b6c21ccd7fea68cfcb4d188bdfe989232fdeb85cf2d1d77da06eced3eca1d088beb75c0c38f0500d6e9448d84e06da2b14da57936ce27e895d62d55c2ad0252a4b87bf8748d5f467ae49c193389f54a856577e349f1bb8ff71f182459b0af64967022b2c18dcfa360a5c403be364e523637f703956ad3fbff738d1a4f917d701a1f3ac05639cac5f50afdb687d946b39be8d375917a9f0372d3375c1c2a415f50780c1215c15b20679ba77516e00d57433c5351b3056d55e86c593dff5192e92a8f85dc357e5890505c5e40bfed46b5cb7d64c1607bfee1a7dc1c074561d0917e0f24247ea7bf1b38fb53931c60cf2b490f74762e1409194d745dcd4e0fe2fe90c07a2d581d741efc83c08fb55633de600a9eb01f0b8d95647a47dcfa9850fd1524e978cf1402637449a296938a1ab7a7ff47818e3c9e8bb64954426f99a02fa5bec6deca4f911da364538f09ffe496eb24474aa160a8e7340ca35701caab498fac5798d89b9c2a7a9a168014afc9b66eb2a9b1aebd8c6fc723a032766e9da975881c6fb587835e10897b83034b9de56fa005cf9909d59f13aaf7fbb00c95b0d88cc2d5db1c44688cd48c46ddf378d045dd723ea078d56639c01e358dbf6b37e999e644ae6c073d40e79037a720cb43de48d86948d9de3388a75b4c490177124ef71c954bd6056e82ebe3af88e12360d61c63b8876e4d12c5a0c51563cb91e3cada61cbb9a83c1e3643c491c224b393cafe79fd4a59858165c857048957152452ba439c257eb17d543a837f20f9b3f78630ac433be045aab010973b9ef1c2afd49c2696f40a2dfaf2b9869ebc793ceac26146f2b11388173c73fc4b4267c7f0c11d2f086ff611023f567add469de9f493fcaf4079c0d6663c9f611a92d0f19ca2b8a9f359b261e75de6adffbd631134b6857e863c216f1da9e56b970bc0a701d8a1013d6678b77c19fc5371af5e145f422ba259b3b4583b592c0f421937a1768d2fa4427a8929967ee609e433c244f7cc8fe1c44d8dcdba7f12699850e14df779968c479b9b06e4f221572d22441a751ace9036b32ff3780a7ba0abab137b3a742a979416eee5d54b3063a33447853952842237c02d5ef8984a003c9d9192b5abafec7ece96f0fb7e650280f9058f1979823555a39fd83ae234ee9ff0987649c5ab821d68797448f81b7c6d26bfc90da834c7b093fc6f8b7775a66e9f554c333c5bfcefa28b9cb5907646771c051ab1c51b774fe3bcaacf49f822ddb7a9432c264f5521b6aed6ba900d235c47c844ff232d4c29d5e69a8a8cb80039e9f2fb05560c51348055387d6b7b6a3cb70d753e4f0ae54c41758423d8e76089ca34fe1c08e2af15bbdc85ae408a266d24f7c97511859e3240c83ce64fa0f17bc13874bc33dc6377bcef4a4174478f017a800adae1b5c68a096f320aa36438587203a0e0b7782ab46427d3670da5c39e03a20c7f3a7c163c56ef83059e554bbde6af395b0605fd6c9473bcef907f8993fff04e519c42f7640f1fbe222fc0618879736130331877cc97e268c3df234f6a752d016b4a3339e72e53327fe274beafad89540ccba2fa8d4b90a9d25592c4872d831b46abf85b63dd9a6280f67b7fa7dd5550c1df6cf1610b03c758a0971d72e138437bfbf64ad2806270cf1419ac778ab5c18a8362ce48636e2fb0f0606b2e1c9e4f171b49b603b99ce2144c153c5266ffa7039580f3869994fb20ed3fc96b00b0dfa222afa1a591c3b369902c2999ae3db294f4525bc7d1f1611b032718a380c8aa4ea49d03e1d6cd6547e32533d83ea33df1fbfdc4726fe2575e24546a8445d63ed6555d4189c7a1c5cab9c677e2c6adb572ba92c08650a079b7ba898c8e3e3760477c02f9d116b3843dc943dfe0f679b6896ad2d05542f201877da30a5558ab66616427c91712cf3224137b8ddbeae8a02dd3e77c143e881c38c690be69f6236bb4297fcbd4c03d78a1bacfa2f00659b5858927dd6b3daf66202d6b089549dafbd3be6f36bbef64745f1c50de6b63b6242c88c1e05f859486ba3be8a5987ec32395a2b9eb457985dfe0a241d642a351a8630c182ae1c143e3b53d50914be963a25cfa5f9d8c8decec5825bc1d48787390798fd3592514224b7626abd990d51aefc9af7968c302d8f6868793f6d2593789def5e98efa343a2a9c7499e8ed86a3d0f189d261ffc445ad6b3a086e7b39e061d51170536dbd69798cf57e39eab687cd89a69faa2bb0d2259b5c92bcb6504f5031aad6b526bead098b258bbdb1d35f4e88e6fdbf7d0bcf9548f180681d82fad92cd4ea061d8de112b717e1f475b0c83146b2338c21e4c919b7c78cd7a7719fe8c29ccc10e311a76c48141a210dd4eec405025e73b5d88ddd29b97054a2caa2a41aefef53840ab1a9fc965128f2befccb045c9997f152810c5573f5e720cd225dd1139dac6eca764456965bd2e0805ece8acb668965896fd537a227a90437c14af13dbf93748720159a1ca87f4e736b5c956c24da6cb7e3204697bf5beb6068b3c3f752e726d761b5628b5913faa85e438fa27c39a77079a85516838a965f8bf8a663463643513630aa19264885b9b654e093d084fae7fc367b716a8e99cd0ae846cfbf40ae782b3bd5683a90919b0fc09a4306f5845bd6ad01e37117cba11f097edc1e6bec0684e953d735311d8a7c55776b2d1e44bfd79b172d5d7fc0c16bc00a390431389315787e7577b2910d658682cfbf9a315ab1dbfbc6ea75e95761f16f8d26548e551b0d0444088b55f72cc347fd703df24154dd7673f48bd3d7f2197d6632ce5e88a17aa65c618347dc6dfa770e45e3e7858e9df22bdb2f64f8b4ec17fb4ecbef5192ebdf07cd983ae9ce41cefe0493da588593e25c4edba54db50c6cacea1c194fa9965d3b2b31f8c6bc4d224e1983bcb9878673b7a94a53b994ce71c3109ab3b58b9e5c8021e6f01eecd56ee050676cb182a24cdd32f7110452aed456b88ef4b9d2bcccddad38e5c8426b7c10eca0cc1a3a3891ad9e2fdef9d62767f86dfc93c60692153c9a7bc1bb530189d7322e9888c63be545bddb16259bd62e3a53fb9507ac382b81d6ebb6ebab51c40ecab4930179c22d297bd2617e3864489e3e7fc9ee49510156609d864ae7dcc5185b5b9b4d6ac0219e713e98c94c63939a0e0e811c1aa02cb08290aab37e38972cf6dbc5b738b3eb1f1336057129112ac1be2c0ac9b498c650009904b8808b32983d9e97d094b19a9bc7e2df8b0f706fb424ed5f683886c6e57e990bfceb5f29b87ca8040a561df1992445c461ca7af99dea13afa458d94d1bc56ed602fba29cd69de8b402644a954b53851067893b4fb6cb57e830ae966a392c4bbaf63dd2fcb76f9f583cc17828481dbf13c68b558db022025f6fca0c9153f161e2db2a4523b2d258b5369d8e6491fbe75176157fdc7a63b990c82e2c0ae99f5628a051cde9d55b60175326695699d2a69b9a5a6ea224b3083e8300441b1d945c2bb7e4e549ed97cee25f1594181a632791e5ecc281c5134af2c41cd41323ba17df10e5cc412d1cf644fb331f362494cf63331e415c7de49579a9ee9230b555fc90fab57af4e68ea95eedce5e9053bba0df4233fc049985eba2800256e12f554a32909679125823070222ddafd8db459214656190431de1435a1f2ec98980a55a31319e858c30570232492d950ebb5e48bbc09d9e11d42cc4b3d9857ae55d087f2b02d51f39c30a574e698c1867ffcfb39c46f9434266dbfcbb1a9934a0d1881a9b4c13543bd82827016319ff63e359da73e3986140172e64390edacdb18f2d56e4a7e665a47e057e638dd15178f480a094a9479a1c2d444e78b61c9b2adee358f5dbf1e0ad96c91fc2ce9b53eecdb27ded5a71b8e7a84ddb9fea904e38574406e73c2a24bf24493a7fe76beaff4ecbabc16cd561464a8e259cc8250bc4821f07384c1f8bf3e7e969fc5ca7e0407da0c3d038edc0975782410037d5dea517414df9586b412f77943a456144edea71b0a9fb1c82bb8a470f3f3a694530d35ea17af79d9a2e60a0fcbf9e180e5907d7265a733f93511cf735ae0d6c4a0c1385f5e3db6a2fa40ae16b174a0f90a7b6f95db464d3ccfccee54b59b8de322e262f99aeb1e3337ca7cc19cabd21d139f99c280a141d53520b23c0ccf5eb9e62e21fa5e1de29bb656cd5ad52d373d2de12c91fd3ca67f55fafb5958424d5c5b4df9729b6a41d55f350c9097465da5b6994f25f315d4394d02cccfec8157f1764ec5065ad8e359d3636ee9c25b3fb777136baf61159da94e4b927a55f4e5305d68278c03a4c48fd9f19105b94d82f88874b99246073b9c00df2f752fb5bbc04fdb31d1686c799ccb8ef9e5e69f7705d7b687dfb39e486a3db9ca8729690838ab41086c2bc3d2955c4d1ed839f72673d12448ef19ae27b82671279b6e64526ce25326fe6f41b66be93c9c572a135b29c429e0694d27ef84278cd33703935f3ab1f348950dfb7d531c79ee97810f983c5edd883adc84f3839a913c6618082ff986d3f674c04e47f3af19320837761435cb6fef60cf9c099d0a935e362d30b76bd2733fb627ca33e9381ae9ce71a538864354c74d0d15559f5c528e299cea4e08340d4b1957044cf09b32421e505776a3e74d3866ee90094513adede8e1e7cc93c2f800e94fc61482d7552fcd2772dc3a760be270c15e137a48d827d36dd01dd54eb9987543c7be5d57ed7624a31e2dcbd1486b5e06809315a45606c31ae61e02827ee7fb4edd76e6c312b49512f61db170bad3ba6af7174a2fef60e6f3487958d2d2b20866ca5a38ac10044d2e97951f2317674351c288802a4ff683dae405a136179afaf6f9f9c04e982d82a4d390ca2ed99b3e9b5f06a1c09fcf0f146c4e6bd71e207d5ecdd9cecb5fb02b158530cf262a3919573ed12bb5692e88159dbf67166f732c0d7f7f5251789f596f6ef3d2cf9afd67da99f52699ebf479f25d44aa0bab739db9d49000ced5797b73b214d7a36e232185c377133a11f7a37f9c18c6be2c824daace04f7c796efa6b8c2948e8f5b1493693e17f8319b694a22e39fc3db449d9efa91a3442f352306d5fd2459122ae71635a54dde62ac9f4a60c7d72338bce1406494fb62b0cf28fa49ac4c88ede6dedeef1261d941391e3e880c7ebabb0e25df214952a172dffea150cf0196bd5f03b8ff28e696a3e83ee367ff2d53691ab7c649a57ba903eea70c85c3ff4fe4dc65693fc2737d0b84283ee6e21841aff456b1e5fb7b3e5bcce1168bc54f520b80a4d1bca0bb19edf6f6485a39ded9b9c7cb9c8de1a1024f3e1153f025dc470dd940908bc20a657a88024f088c4e71f619aaece5651e6a4c70640f50bfa8ad44af4b33feeb873209aab51c28ab9a367f36751e5e677b6a3c25e6e8efb07ce46db3983e1eb6a8230c01a99cee67bfb4136e3f6d7cf48f162f13253dc492477ef7dba489fc170a8ec3e75ef9b913fb255bdd68a707255aa69ee24d45bfc46d087fc469c89cf5b6cfd9b0e36907af0ee191d35d9982ef0b51a51873e6699cb81fe06d2c778e2d1f8130d785f79d31f8409261df2b73daf87d63e089561203669d2631d3a8bb19f40b621adb51c0fff7f10e979450e45e99909e3d68f366593dd21e42ff330bcec0dc720e095b82ff4246235e75ac6571605c9ef3b0fe526a7bdc4720c05a43fff2a126c890c975d02ce56f84542a4880b4c2fc9685fc096b7c76fbfd8be571d92c4f27b32d273a5bc354088864741fd41cec3b86a335871a88e5b22cf60df56d2bfbac8b4b5236ab90bde9132b1a8f45dd04521d0c4fe2d7f8b6e3d9d99e107fb40204238b70e5cd6cc6812a66b45af32fd3e8cf6bdf8b550cf4fbaa795f6ce93d438f1e43183cabfbb6636d8bf5ed72f1beabbe78b5ee187d99cdd4aaa27f964baf4512d39bff98c598b5013470836e1f9e2708e7351fb33752124e9e57a97f308e55e24ff48a68f03d2a9a590a1a0186f123e5350942f8e5484cd4000a23964b593851c102daaee904151d270ea5f839d9529345176883a97bbe8e32b34768eb885a4dea9ae2b7861dff3d4b1c525828fea2435531b48eb952aada8cf983d86055ecb2c9c235fbc1cb926c0193eec16b4206e95430f068bc6005e217c67a3b3e86ceb31676182f52fb96a84b1d5ae584a9067d5cf4271653dc2acf2c361e18b13de28e4026f06c87bbb15185562cf841a32a478ceb4d9f671746fb7adcb832721c1429bd9e983e41371980887239588bc23e76b841d1c2ab9b327e Hey, password is required here.","link":"/2021/02/16/JP-KN501/"},{"title":"JP - KN502","text":"8d229d8e47333d3f189c47d25637efeb5cb93a79968515e30e77e9ea060cd38b369142d174715c10e854b175b846cd04fb7976f5a1d2272f790cc55ec0278e48fd583a3946dc290084d7b2772a6d6cfe188673756c66aa0952da36efd94b066df83f82d5755003e1e8ae56fa6b7ef38c7607f43d4d36a75766fe6e12ace8c70e7224235687c8882dadfefd2625026b2f28377db2f248734685672465eb606d4dd391d0a0434fe4138cbeed1d9db1853db19444ae5f3b2169e1f2c30c506b4995f2f673dad8ca59558af8864d1a6d6c9d6c4e190555666763b58e73428f82fddcedc54592c1e79c85fc0258cda29cfc1898bed3733b0bff7d08d9627a74b52d63407903de4b24cb7ce9b2252fda760f2cefb44b708f2cf01cdf0e3ab183549e7442c3b58df0542c7cd10187857e6157165e014410f8e71467beeeda61dfff65e1a7d2d4dbfad1d21f44ebd16de3e8d1df39f970b616ca36da9901232db05da9859d88b5a6f5c80509330be42d1f2699ef4c63e1b73f6410a11e436c36264e51854f6a1db426b78f834c6b71b8ae0566083be46feccf3254f5d5a0d42e84449b939a732fe7811392e8027d79c173e30baf8cba0f2508ab5027390615429f9e5b4a668b5e1b4361728fb703441b1cb601717071ce6c25dbeda4a1b7ab8c272d9b0cb31e8c9f7a15c6c08ab1aec18a40fc5573fd9925e841570ca766ebd7d003a3b4f3ed84248520f06b7b4cbd7d689ffb074b7065d8e5c00e6f92e0a96b7bc4c0c05fe3adabbca1070f2dacb8829fdcdde60b88dc2ab85df1b725476237dbd5fd78d81368cdf3d18bffa11884427083dc752073269a88366c128603a442d144cfa733abb7b66a0eb90c8982b7d1e7189de3c44e80bfbf6e418e76130bc0bc4955e62487adf0b57f4dfdcaa61761f2c218ba1465d89db5724248f62c0f9e2dfd19a016c56d038da6b3c2042e3b901cc7dddb5133ef776b699d592bb52ef785aea5917d010e5a0a2d374fcb29a6f4d941342996842b7761191dfee380a630cac517901a1f5e1248858facaa43651a75a19cbb012c352376354051baf1feebb7affcac966ab201d264ee9c5c4beeb5bc611c1fe2983dbc263ac00e4ff5f767dc64157326a9ffcb31c6bf1beececa8c6ddf98e361437b9a22e266314405dcb537ef452fdb11a3e9a14493e59e454c504235d094b05006eef1295e9434ce2dfae990b46f74fc95b6bc2952903b90b457b4c86ba3bd71a9ec1b0388523910fca10e0c8ce92d256a6fc533d730d2aa8ca96317f22db8a120979084b5d6c83ca2de857c130b0a2f6b5c1218751527fa8bf6f902449d0cd5ab880f5d8b6a1c6c066f0e5b9338e37e68cc3fe95c4a8be9f4e54df8c849100efe45f963e22ef7e84cbb5c48b1de78e0c96b4ae6744cc558a5080b483924508aa75c66f7445f9af748ee1789ab960ff7feba8a1a36ef335cd591c089324285424fccf3a3db798e7c214be071fff78568577f1cbeec9397aba5cbf6a3fdf8a20200c0a7241e8dbb44e6523c163f74968d8f524eef8d8b0bc7ca8dc87a8c71dd50efd05aa62b83af19b7cded78ce37b9e26e965e6beb5f79d18040c87ce5cd34e559a72991475cf616932923ae3df7a3f33e29ab4a6d77503149b02a1ab52a6491c052b2dd96e653b37f61004821405e954c9f4e0fd5886e77a96c0b141aea242a47200916b18db13fbd3af5908eaea68566fc2c8940a5ceb71b69bd79578da90b2d8404708b25643b00f07d4fe7544a177433be280d90cbdb1ac660ba13326ee6d4760afc5ac848220c3624202d30c200a37b4b7f7f88997f98dd7bad394f2b62bcde15236d7bdb49107b6ac7f5d426bca18e8e43f9e023abc4b275f293930240296973af2590ca5e67729a772bb8166734a2ad759e13719d0ae0ab119fad550423d5a0132aab4109abf77a2489c5fe6eeb766b4c78c180e924c5b3570e39d7e6f5b227f896efe3884a23b7c603c2b9426c08dfc83b716b1792aee8bf416ba7573731f46213cb2ec33d9ef72a140d5a3c423605ce2efced0146467b1ff3f96be9cbe49f95442debd2fc4a7b456053502bc19c1104db3e691f5274423a45df81f53dc3c06f86c9890990e9c59222f00b8f1219ecc7cf24bf97f587e40a39980928ddfdaf8ceddea968cd6412e926357f45024259b5fba7fda42e5837beecf62dba7238ff58e419155da44b00a6231933a100be55dc8634fcb083533b28d1b32b519c5f059c4f4377cec5f53b4bc2a1805c9a52cc2b2df207e06b4ca69630d0a8360bc9f5f187412c65a5d0f60c917c1c7f522cf0478b2e880502fd87aa3caa3bfe9cdf8c50e929a110b5d42dadb1288e1dfc4491c7fbfc1d42d0999e1d2f3416201907c23965caa72f0e059c847a4e18f7540a39a7e05e8a5318d299db48253a8e505063662d1ad1870a75e5bbf465993370d8914c2d3c0d6116f610602ca4d01533d62cacf5278925c6bf17dcb307232d8b4ac8e91654dc43031da5aca3198f384c192e6a7e418ed8be9e3bdba32e0abebc3eab4026a32716b7af95b6665cbf2a1eac2a29a8b9f26002f0e55d1a5c73946f2b76b8369ba8059312e85d430a9d72c23ceb84302236b39c6149c5f235e329ef3337c18c2ef364ae4a21626bebe7a66ce38c8a233895f5754671a5a20552c9de09cb0e63d13c9d1f2b80804f57f82a828ddf4ebb60617e1c12d80541ee34649b8c52be84c5cad00f810785c9e9188754009d7be3aebf7f274709957e91f0202d99062d11b7da1f15a5786b5d3af5043b43a2efc1a2a380769063762237d802c98f58c11dc08ee677bb65c8f139c1575ab26b8052467437c5d13f37c9a63c8c373ae27f188bbaafaeae5a2f7f155c542a82eadbf42757b60847713c6b21bc79143a9cea6c5bd48b1a1bdb72b4b4221ab7f25ff70bddb770c5477413f91fca017eeb0d48ce9a4b314839a3f0701502fc983889ce348ab7971ddbb039138655444f13a7fdbbd477af032252cde0e94c49a1b1468e9f407e9da7f74eb24dd97fd82f1a6da44879d4eadb801c03fb716036398f856f28f09c5170d399243ebfa7f6d784343c3121a83775579e0edc7df40997b1d26d443b876430ea575ad9c1224dd73902caa99a7ac7275369c5cf7ff11ec4bf4c5b0ad6c671b5d776f299b0d35d4574f7f81c7e1faa73043740dad01d58b88d34858546b1b781d39720a23c8f975032e58fc0293b69824e949b73f337a16f9849dd2aadccd4dba97a5fca7ee0371cfc9ec2f810aa56c6b6f2028a999d413dc6e9041e1e91de9cb8fd0e1c03dbf45fe3a20300ddbd02a7e1caaaa1d79b9e819549d6bccac2ca8589a41413b18e9e85e0cbda57b3ad0cff1857317f56b62336915eebdd8e80fcd955883732a2abfe95b521e29cef5aedfec1513444143260bb77f015dbd32a89339e5f87d0b79e7965b5471603fed9b30f9f21e2127bf47410f7e5baafcc5321b8fbb8c596882d2a143559eeee6a3e77a550517742835595d053e8056b81ecab4ae19a76c9eedf806185f002399989f0c75431dba8276b8c294fbfcf1e58ff4bf70d60ab44d1f5c11aa946f8abbd73b096f43900a9d67ef163faa4ad8b872f9aabb541f3215fd54310de80d3156b351349b80c0e3e52f49b84ba172d330539cc372046f16859d7c5e8a6b8fc9b37aa4363e1ed461ed9346c66c2f44ebbeb87a3596891d258d2c8b2b7d67cf75d5567802da734bd1666f20ede1565bc8679af4f440fba4a2d30b7f6f6925f1e1c68a4eb680d65a57fd3d9e574c41483555455900b36beb70cf87ba15719512bd59d8c0a6414b9648b3daa12a5b50ec4c7f81ab723a8d993c6a1b4bcac370d1e7a5350ae2910f3346738918865473b62c8aa4f4341a9c920e003cfbd281e0256324f96b7548bbaeb6b7341969ae37e2de066e807b9fc8a411ad9235b6896e4aa3e3e4adea793bf93a4ad68e922bdf7cddbf6018aa3b7ac190cca73ef6c5f5b250e2106f0b3cfb2cddf11d803cfebc11a26a810210fc45187554baa09f9e9a60159c08e1e7272a7dad1cde31fc8ffd7fae8d18c1c370ffb1613c6edfbecef58bc2f07f66314bc74d14d33e3cc59240c733e49c9fdea40c650e18317cd59981d0831b0ccad5e5f6ce8ec62f27b1e94a5d00263f1b9c837da19f3894db3f8fbb5a776e61458f6a693f3457d885a8b92dc3368937649bf4e34adacf0df81939f8d7bb2a7cbee9516c2a930d619e830ee0e2690eab99979cb6462bef5c010020870d70b6fb320de12f16b245b05d6db55e829f38740bd5b0470298cd2f8d71c96ab131e8f179711f4986498d4d369e7d7f929b1e02ef8face1181ea70121c3de3f43aac97200e6e98ab80160892b85967e1c60b3c510c50925cb8bceb6b0655d91677537ba1fdcf36906b59b2af70fa33d1e299da8f26783db39095bc884f5bb33af9c322f989de6218943f84b358213ec1515898e305c61e25cdba854181e595a1b5f9a96a45eba231c146559cc653128f1880a23cd303152dd81271a736bf184f359f12fc0714a4a2ebf04bc632339057f33455e6e67530f197c970b32e146ec886871f18f12bde9e10a6db300bd40f179f9a429075852812289022abdd3d879e39b983874b198351a0c961e51c6bd94ded2f27ff9bea5e7e81719f81bb6ef2bb87fadfb376b3fb43e4c9db5607ad809d55e2a5e07c799b9da97f6120f8a75c4f9d7d6f5bf86f716802309e9b7d7b9b1fa5df26cdbb132fefdcb50fe967d723a626ec8476564e7180f010c41479f3a71e1e65f4ae0534ea03674fa1a4a668615503dc3eea39d97ad45c362069f599fbeefe0b279d44615c5cc79faf9b8f3ef4e37c9f666a40451061f8b74455a8b838a7899e382e94f827ac3743660da12d3fc7e8d65f84f371beb67ba51d06753080aa45e526c70a8a1b36dc6e6f408e9c765443c508145bae502abcf04dd6161c7609b6d33c85746db11691ce51e11c9ff2f1840d8beebe1a01af770fe78f02d21a8e40c9ff9a25d98c397c70bf687d4df2d088d982606d43c1e70d77e9ab84ae07dbc3883068d22610cb7292b4c0f4c6cde611266d6f62b4777ddb9bf8fc59f8aab9b2fba991e340afd76e07ca47eb19def61f3d897b3cad65818d4219d81f5e2d6d5a8cf7acabe5caccfad8eb18e3ab906ff4679495cfe0a1d95128bd8066b36a5043d1ed03ef7559d627970b9ddf5d11127aeef9f39054bfa89168031bd970f2e324a30544002b40a0f52bd0bdd525ddea3ddb52182d6126a93e7f159f60fb915019aa79c83da8879ae56c5fc9158dfe8b3af62f1c0837aec59a0f019810ed4bdc451c339f3df01375029ea10db0fef51641f08c179bc836ca8210802e2d35464f7e54ccec5711d8f495fa6f9e578415306891bf6777cd2b51b44a679584ea1d044247f81075ed3bf47a3ebea6d98bdcc6c0b29c8a1ab5a88288c732a49b6c761910b544612e02a0e4cca145b53a0faca2c05aae0e258b57b7e20a01e67bee2b60c2d55ddf08d0a5db2f5c90bf0defbdd74510ac9f087cf243cda426b8704fff3f4639b325323125d1fbd43eba4e2b9c61e732d615eac5e499b70dcd85ddb628bac1fd0d74ebb6ebdde73955649fe34d900a21db39b68d7b74decaf7a595bd82a11f5288f332a1b6ead85fde53c9fde05cab418159979a9425597e943978717b9532cfa12454c37fce08e2045433c30983e98b54f9a0433f18e5e4c6e0023ffdc10e5e913b2fd4d71a483cdade500f9ecbc9f7807ca1b63797e72734d3e1209730bd33eefc148c9b1848ffa1446e0bfa992047607c8c81cbb67472a227889f20f161a4ebafa5cff8fda24ad50af8015bfe36c4e292cfde214b0a5929808e65ad056edfa9de755122bf9a44d771062b71a2888dff5afb5420c0572d685fc81eb8ff1575c4a1ae2e919e068105a0cf067bd958472890c3a4ddcf1330408e3a46f423806a52f8a9b3d1df657cf3d9abebab064b2779a740a1069897233ffada5a8e404458e60e78718a427fabafe557e3d6a7791b4be6b24f861286230197f6edf1859e7091d6a05ac6e14bbf6e1fe6e11b81a9c14fdf4c2633371190a927bd50fa4dd3da66403b76803ed07d0c5d23d0daf7afeab1b3bbff34d9951071ee0d2253eb2721ec734fcdefb9c8c22b9a8a1b63caa11e26802ff55d5c7a48dc5bc0de73669e19205cb90135ef1f1102954fcfb224d8634def69b1cd78d025dfbec67ad94480bbd58134ff9ff183ad55e03cd9a6bb4a8f414339cb8ce7d7686c16c4bebedd088c3320ae2da4fe9e5ad9edea838d44d90fa32ce202ace7bd4b846d7aba336e5df4251f17b69de3615b2c38d99c146d69ceb1a41ea85c6f808fde965b6a35a9cc786499ccb3596f360b3c47699d7af15edd061519f67a34f9058563e0ef918a72d8e401762229b9a50b1886d2a1b368d6057dae8d3daab4438097c4cdb4f7c64d9ffbf9e81e96513b0a917c0b64e26621d2fb8a7802f0851238fdcf907bf8ad0b64ec0c07e932f7e1b94d616427da48ee2559998234e9ce5463238c7ceefe82e97b23ac34447a1d1d4cc06f22b20b439af28649025b650ad89dfdc1579ead75b8a89765ca97688815c2f01ee959c68e13b1660aa876b728e332e0db704f5d148d38428dfc075c19c080187bfcb67797050c1f4efcefa3d3d135c90181384a28e1bd0eb19dd8cc2498d9f8238739918fa80e7b21b7eb40eae003b2035b73d2259c258f712f7d6c9ba49c855e0367e8d6b8a6071018e6435c30f7b12ac2e17676abcf1b308f48659144df9803ff42d1d91ffb41cb9055838e9c17303c679483153ebce393d1b30bb6c18379771b0148d91fb16a05a461f71fa9dd06ab2c3f11c3d4430a888926e7457cd3ab36b63e8d639455d83696788eb9971ccceddd295948ef51ab796fa70d478053c0e4b22beeb647530195516a4d53c0f4ab0362e8e14ebcd5a36f0c9e814c1432758a3b73611ad6a9d8112915a02d33dbb34fc7a499863a1ef01689a82428a35f0ab40f88cf42722ad1b92f429178597b898de990fd2323a4edf8c6a9a4b63c5ebb12d84e289fcf26c79d0d84d147c3bc471da2ca8836ddd0343521652f655fa239f616ec4391ae2c72bc6a1e1b82b45f42492011f44483ece8b50a9144cc326af46cc17d3eed02faf72b13ec6b4d67b64ee65b513e4a4b314ff3f1d71743b57ebe1403a9b66a455a4e0aa675e5f31e124a5df35bb74672216935e196f01d680ec8a47366c2d780ea12d380074224709c835cf5231687b0c4948f6af1fb9b1635f90a298ccbd7f5196fc0977114683d3ed3393e7d92ac48a2a23d6938c42860532757dd74996931deba3359647960b966d2840c8ac2f6907e2728e1655b8ec53d19ae0e126786530ee7fae881608e6227296072d072e3cc90246720c338d053334e7d8a9efaace95c1d939d9d5e611b5f22c10fd1bd22b13e5de30f0503c8bf0dc494a7d4d2107b76d66edcdc0b4826635415be6fa804ffc10694fb253c02971680fd1e7437d0c3d8c06d3061ad271c769ddd61e9b421bf653c4a494ff24f3c0a542d02d7852b54640c6fcd2878b3c809dcf5de57d5049b32efd07d39a6230a4be6c359de848254682d4718b6673abac69b29831bd0524e9d39b8e7293ec93dc598ee5c6660581a1cdaa9b4fe3f4d4b6afea335a73b2f98645dfe72dc8428af226910fa0e9a534334dcf25d542d0d15d0a0581cb7abff5011c67bd68c531e334ea82d9cfa55151da8629540481914b07510c3c53ed3f36350170311145d64639ca2e52ab3f6b875635dd12eeb7e3a9c85c90333044320c5e47d2a66e8c9e2c537e8449ef3501c2f93f40e9bba58878605a7f64ab1b2565907a89b5528629884d578afa6906e8a207992186e00733b9f86bbab9a549668d9322275c027decd6e728d4c7436df3a7dd82557aeb4d3804af8d2a9bc8b9e6edeb92ec8a9f1c91c90a975b58faa34d506e0081da02d9d86925e0028c99396c8ca7e025912bf4f2ce120521002a5c19b7609b4062931e15098289edfed1d6997e246810af5285def1e5d775573b3cbe11509c05c33a1263d92087d77c1ae0d09567ac7967add3ed6f9a8cf2985f8aa1b8016078bc40eeb68ead48de42679709b519de44e9b62772652d1e0f5baf3c3cb5539a73862bf8fabc9d021 Hey, password is required here.","link":"/2021/02/16/JP-KN502/"},{"title":"[JS] General asynchronous programming concepts","text":"Thái Bình, chiều 30 Tết, trời âm u, se se lạnh … Trong phần này, chúng ta sẽ tìm hiểu 1 số khái niệm quan trọng liên quan đến lập trình bất đồng bộ và cách trình duyệt và JavaScript xử lý nó. AsynchronousBình thường, code của 1 chương trình chạy thẳng dọc và chỉ có 1 thứ diễn ra trong 1 thời điểm. Nếu 1 hàm dựa vào kết quả của hàm khác, nó sẽ phải chờ hàm khác kết thúc và trả về. Điều này đôi khi gây ra trải nghiệm khó chịu với người dùng khi có các task mất thời gian. Nó cũng không khai thác hết sức mạnh của máy tính khi các máy tính hiện đại giờ đây đã có nhiều cores xử lý. Không có gì phải chờ đợi nữa khi bạn có thể để các task khác trên bộ xử lý khác và cho bạn biết khi nào nó hoàn thành. Điều này làm cho bạn có thể làm các việc khác trong cùng khoảng thời gian, và nó cơ bản gọi là lập trình bất đồng bộ (asynchronous programming). Nó phụ thuộc vào môi trường lập trình mà bạn đang sử dụng (web browers, truong trường hợp phát triển web) cung cấp cho bạn các API cho phép bạn chạy các task bất đồng bộ. Blocking codeKỹ thuật bất đồng bộ thực sự rất hữu ích, đặc biệt là trong lập trình web. Khi ứng dụng web của bạn chạy trên trình duyệt và nó thực thi một đoạn mã nặng, không trả về quyền kiểm soát cho trình duyệt, trình duyệt có thể bị đóng băng. Cái này gọi là blocking, trình duyệt chặn các yêu cầu xử lý tiếp theo từ người dùng và các tasks khác cho đến khi ứng dụng web trả về quyền kiểm soát các tiến trình. Hãy nhìn 1 vài ví dụ bên dưới bạn sẽ hiểu blocking. Ví dụ về simple-sync.html, chúng ta thêm event listener khi click 1 button, nó sẽ chạy một hoạt động tốn thời gian (tính toán 10 triệu ngày và sau đó ghi lại cái cuối cùng ra màn hình) và sau đó thêm một đoạn văn bản vào DOM: 1234567891011121314const btn = document.querySelector(&quot;button&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; { let myDate; for (let i = 0; i &lt; 10000000; i++) { let date = new Date(); myDate = date; } console.log(myDate); let pElem = document.createElement(&quot;p&quot;); pElem.textContent = &quot;This is a newly-added paragraph.&quot;; document.body.appendChild(pElem);}); Khi chạy ví dụ này, mở console của JavaScript sai khi click button - bạn sẽ nhận thấy rằng đoạn văn bản không xuất hiện cho đến khi ngày kết thúc sự tính toán và console đã được log lại. Note: Ví dụ trên là vô nghĩa, nó chỉ là ví dụ mang tính chất minh họa Trong ví dụ thứ 2 simple-sync-ui-blocking.html chúng tôi sẽ ví dụ một cái gì đó thực tế hơn 1 chút khi bạn lập trình web. Chúng ta sẽ chặn các tương tác người dùng khi đang rendering UI. Trong ví dụ này chúng ta sẽ có 1 buttons: “Fill canvas” button, cái mà khi bạn click, sẽ điền &lt;canvas&gt; với 1 triệu vòng tròn xanh “Click me for alert” khi click sẽ hiển thị 1 msg 12345678910111213141516171819function expensiveOperation() { for (let i = 0; i &lt; 1000000; i++) { ctx.fillStyle = &quot;rgba(0,0,255, 0.2)&quot;; ctx.beginPath(); ctx.arc( random(0, canvas.width), random(0, canvas.height), 10, degToRad(0), degToRad(360), false ); ctx.fill(); }}fillBtn.addEventListener(&quot;click&quot;, expensiveOperation);alertBtn.addEventListener(&quot;click&quot;, () =&gt; alert(&quot;You clicked me!&quot;)); Nếu bạn click vào button đầu tiên và sau đó click nhanh vào button thứ 2, bạn sẽ thấy không xuất hiện msg cho đến khi các vòng tròn vẽ được render hết. Toán tử đầu tiên đã chặn hành động thứ 2 cho tới khi nó kết thúc quá trình chạy. Tại sao lại như vậy? Câu trả lời là vì JavaScript, nói chung, là đơn luồng (single threaded). Bạn cần biết khái niệm về luồng. ThreadsMột luồng cơ bản là đơn tiến trình (single process) cái mà là 1 chương trình có thể sử dụng để hoàn thành các nhiệm vụ. Mỗi luồng có thể chỉ làm 1 task trong 1 thời điểm. A thread is basically a single process that a program can use to complete tasks. Each thread can only do a single task at once 1Task A --&gt; Task B --&gt; Task C Mỗi task sẽ chạy tuần tự, 1 task phải hoàn thành trước khi 1 task tiếp theo có thể bắt đầu Như chúng ta đã nói trước đó, máy tính hiện đại hỗ trợ đã xử lý, vì vậy chúng ta có thể làm nhiều thứ 1 lúc. Ngôn ngữ lập trình có thể hỗ trợ đa luồng có thể sử dụng nhiều cores để hoàn thành nhiều tasks đồng thời. 12Thread 1: Task A --&gt; Task BThread 2: Task C --&gt; Task D JavaScript is single threadedJavaScript thuần đơn luồng. Thậm chí với nhiều cores, bạn chỉ có thể chạy các tasks trên 1 luồng đơn, được gọi là main thread. Ví dụ của chúng ta sẽ nhìn như sau: 1Main thread: Render circles to canvas --&gt; Display alert() Sau một thời gian, JavaScript đã có một số công cụ giúp bạn giải quyết những vấn đề như vậy. Web workers cho phép bạn gửi 1 vài tiến trình JavaScript vào các luồng riêng biệt, gọi là worker để bạn có thể chạy nhiều đoạn mã JavaScript cùng 1 lúc. Bạn thường sử dụng worker để chạy các tiến trình tốn nhiều chi phí ra khỏi luồng chính để tương tác người dùng không bị chặn: 12 Main thread: Task A --&gt; Task CWorker thread: Expensive task B Asynchronous codeWeb worker rất hữu ích bởi vì nó cũng có những hạn chế. Một trong những hạn chế chính là nó không thể truy cập DOM - bạn không thể có 1 worker làm việc trực tiếp cái gì đó cập nhật UI. Chúng ta không thể render 1 triệu chấm tròn xanh trong worker. Vấn đề thứ 2 là mặc dù chạy code trong 1 worker là không chặn dừng, nhưng về cơ bản nó vẫn là đồng bộ. Điều này trở thành 1 vấn đề khi 1 hàm dựa vào kết quả của nhiều hàm xử lý trước. Xem xét biểu đồ luồng dưới đây: 1Main thread: Task A --&gt; Task B Trong trường hợp này, giả sử Task A làm 1 cái gì đó như lấy 1 ảnh từ server là Task B sau đó làm gì đó như lọc các ảnh. Nếu bạn bắt đầu Task A đang chạy và sau đó ngay lập tức chạy Task B, bạn sẽ gặp lỗi vì ảnh chưa khả dụng. 12 Main thread: Task A --&gt; Task B --&gt; |Task D|Worker thread: Task C -----------&gt; | | Trong trường hợp này, Task D sẽ sử dụng kết quả của cả Task B và Task C. Nếu bạn có thể . Nếu chúng ta có thể đảm bảo rằng cả hai kết quả này sẽ có sẵn cùng một lúc, thì OK, nhưng điều này là không thể. Nếu task D cố gắng chạy khi 1 trong 2 đầu vào chưa có, bạn lại nhận được lỗi @@ Để fix các vấn đề như vậy, trình duyệt cho phép chúng ta chạy một hoạt động bất đồng bộ. Chức năng này như Promise cho phép bạn thiết lập một hoạt động đang chạy (ví dụ như lấy ảnh từ server) và sau đó chờ cho đến khi kết quả đã được trả về trước khi chạy một toán tử khác 12Main thread: Task A Task B Promise: |__async operation__| Vì hoạt động đang diễn ra ở một nơi khác, luồng chính không bị chặn trong khi thao tác bất đồng bộ đang được xử lý. Tổng kết JavaScript là ngôn ngữ đơn luồng, tức là một thời điểm nó chỉ thực hiện một task. Các kỹ thuật cải thiện nó là Web Worker gửi một số tiến trình vào các luồng riêng biệt. Điểm yếu của phương pháp này là không tương tác được với DOM và cơ bản mỗi Worker vẫn là code đồng bộ Một kỹ thuật khác có lẽ sử dụng nhều hơn là lập trình bất đồng bộ qua Promise. Promise cho phép thực hiện các hành động khác trong quá trình chờ đợi 1 hoạt động nào đó tốn kém (ví dụ chờ ảnh). Theo góc nhìn cá nhân, đây hoàn toàn là đơn luồng vì chỉ làm 1 task ở 1 thời điểm, ở đây là trong lúc chờ đợi thì luồng chính vẫn chạy chứ không phải vừa download ảnh và vừa xử lý luồng chính thì sẽ là đa luồng. Tài liệu tham khảoGeneral asynchronous programming concepts","link":"/2020/01/24/JS-General-asynchronous-programming-concepts/"},{"title":"[JS] Introducing asynchronous JavaScript","text":"Thái Bình, chiều 30 Tết, trời âm u, se se lạnh … Một vài note về lập trình bất đồng bộ trong JavaScript nào! Async callbacksAsync callbacks là hàm cái mà được chỉ định như 1 đối số khi gọi 1 hàm, nó sẽ được thực thi bên trong. Sử dụng callbacks hơi lỗi thời nhưng bạn sẽ vẫn nhìn thấy chúng được sử dụng trong số lượng older-but-still-commonly-used APIs Một ví dụ về async callback là tham số thứ 2 của phương thức addEventListener() như bên dưới:1234567btn.addEventListener('click', () =&gt; { alert('You clicked me!'); let pElem = document.createElement('p'); pElem.textContent = 'This is a newly-added paragraph.'; document.body.appendChild(pElem);});Khi bạn truyền 1 callback function như 1 đối số trong hàm khác, bạn chỉ đang truyền tham chiếu của hàm đó, callback function này không thực thi ngay lập tức. Nó là “called back“ (do cái tên). Hàm chứa có trách nhiệm thực thi callback functions khi đến khi được gọi. Chú ý rằng không phải tất cả các callback đều là bất đồng bộ, một vài cái là đồng bộ. Một ví dụ khi sử dụng Array.prototype.forEach() để lặp qua các items của 1 mảng, nó sẽ được thực thi ngay lập tức.12345const gods = ['Apollo', 'Artemis', 'Ares', 'Zeus'];gods.forEach(function (eachName, index){ console.log(index + '. ' + eachName);}); PromisesPromises là new style of async code bạn sẽ nhìn thấy được sử dụng trong Web APIs hiện đại. Một ví dụ tốt nhất là fetch() API trong XMLHttpRequest():12345678fetch('products.json').then(function(response) { return response.json();}).then(function(json) { products = json; initialize();}).catch(function(err) { console.log('Fetch problem: ' + err.message);});Promise là 1 object đại diện cho sự thành công hoặc thất bại của toán tử bất đồng bộ. Nó đại diện cho 1 trạng thái trung gian. Thực chất trình duyệt muốn nói là “Tôi hứa sẽ trở về cho bạn với câu trả lời sớm nhất có thể“ giống như cái tên “promise” Note: You’ll learn a lot more about promises later on in the module, so don’t worry if you don’t understand them fully yet. The event queueCác toán tử bất đồng bộ như promises sẽ được đặt vào hàng đợi, cái mà chạy sau khi luồng chính đã kết thúc để chúng không chặn các đoạn mã JavaScript đang chạyToán tử hàng đợi sẽ hoàn thành sớm nhất có thể sau đó trả về kết quả đến JavaScript environment. Promises versus callbacksPromises tương tự như old-style callbacks. Chúng thực chất là một đối tượng được trả về mà bạn đính kèm các callback functions, thay vì phải truyền vào trong hàm như callbacks. Tuy nhiên Promises được đặt biệt sinh ra để xử lý các toán tử bất đồng bộ và có 1 vài ưu điểm hơn so với old-style callbacks: Bạn có thể xử lý chuỗi nhiều toán tử bất đồng bộ với nhau bằng cách sử dụng nhiều toán tử .then(), truyền vào kết quả từng cái như 1 input. Điều này rất khó làm với callbacks, cái mà thường xuyên kết thúc với một “pyramid of doom” (hay còn được biết đến như là callback hell) Promise callbacks luôn được gọi theo thứ tự nghiêm ngặt chúng được đặt trong hàng đợi sự kiện. Xử lý lỗi tốt hơn, tất cả các lỗi được xử lý trong khối .catch(), khối cuối thay vì xử lý riêng lẻ trong mỗi level của “kim tự tháp”. Promises sẽ tránh đảo ngược điều khiển, không giống như các old-style callback, mất toàn quyền kiểm soát cách thức thực hiện chức năng khi chuyển một callback đến thư viện của bên thứ ba. (kiểu nhận về kết quả promises vẫn kiểm soát được còn callback thì không) Graceful asynchronous programming with PromisesThe trouble with callbacksĐể hiểu tất cả tại sao Promises là tốt, chúng ta hãy xem Callbacks có vấn đề gì?Hãy nói về việc đặt pizza: Bạn chọn topping mà bạn muốn, nó có thể mất 1 thời gian nếu bạn thiếu quyết đoán và có thể thất bại nếu bạn không thể quyết định hoặc quyết định lấy một món cà ri thay thế. Sau đó bạn đặt hàng. Nó cũng có thể mất 1 khoảng thời gian để trả về 1 cái pizza và có thể lỗi nếu nhà hàng không có nguyên liệu để nấu nó. Sau đó bạn nhận pizza và ăn. Nó cũng có thể lỗi nếu bạn quên ví, vì vậy bạn không thể trả tiền cho chiếc pizza! Với old-style callbacks, mã giả các hàm sẽ như sau:1234567chooseToppings(function(toppings) { placeOrder(toppings, function(order) { collectOrder(order, function(pizza) { eatPizza(pizza); }, failureCallback); }, failureCallback);}, failureCallback);Điều này gây ra sự lộn xộn và khó đọc (thường được gọi là callback hell), các failureCallback() được gọi nhiều lần (mỗi lần trong hàm lồng) với các vấn đề khác bên cạnh. Improvements with promisesPromises giúp giải quyết vấn đề như đoạn code bên dưới, dễ đọc, cấu trúc và chạy. Nếu chúng ta viết mã giả với promises nó sẽ như sau:1234567891011chooseToppings().then(function(toppings) { return placeOrder(toppings);}).then(function(order) { return collectOrder(order);}).then(function(pizza) { eatPizza(pizza);}).catch(failureCallback);Nhìn có vẻ tốt hơn rồi, thật dễ dàng để xem việc gì xảy ra tiếp theo và bạn chỉ cần 1 khối .catch() để xử lý tất cả các lỗi, nó không có block của luồng chính (bởi vậy bạn có thể chơi game trong khi chúng ta đang chờ pizza giao đến) và mỗi toán tử đảm bảo chờ các toán từ trước đó thành công trước khi chạy với khối .then(). Sử dụng arrow functions, code thậm chí còn đơn giản hơn:1234567891011chooseToppings().then(toppings =&gt; placeOrder(toppings)).then(order =&gt; collectOrder(order)).then(pizza =&gt; eatPizza(pizza)).catch(failureCallback);Thậm chí còn có thể:12345chooseToppings().then(toppings =&gt; placeOrder(toppings)).then(order =&gt; collectOrder(order)).then(pizza =&gt; eatPizza(pizza)).catch(failureCallback);Thậm chí bạn có thể viết như sau, vì các hàm chỉ truyền trực tiếp đối số của chúng, do đó không cần thêm tầng của hàm:1chooseToppings().then(placeOrder).then(collectOrder).then(eatPizza).catch(failureCallback);Tuy nhiên, điều này không dễ đọc và cú pháp này có thể không sử dụng được nếu các khối của bạn phức tạp hơn những gì chúng tôi đã trình bày ở đây. Note: You can make further improvements with async/await syntax, which we’ll dig into in the next article. Về cơ bản nhất, các Promises tương tự như event listeners, nhưng với một vài điểm khác biệt: Một Promise chỉ có thể thành công hoặc thất bại một lần. Nó không thể thành công hoặc thất bại hai lần và nó không thể chuyển từ thành công sang thất bại hoặc ngược lại sau khi hoạt động đã hoàn thành. If a promise has succeeded or failed and you later add a success/failure callback, the correct callback will be called, even though the event took place earlier. Tổng kết: Cả callback và Promise đều là code bất đồng bộ, không thực thi ngay lập tức (đa số callback). Promises có nhiều ưu điểm hơn callback như xử lý nhiều chuỗi toán tử với khối .then() Bạn có nhớ: old-style callback, callback hell, “pyramid” Promise được đặt ở đâu và xử lý khi nào? Câu trả lời là Promise được đặt trong hàng đợi sự kiện và xử lý khi luồng chính đã kết thúc để tránh block luồng chính (JS ngôn ngữ đơn luồng nhé). Async operations like promises are put into an event queue, which runs after the main thread has finished processing so that they do not block subsequent JavaScript code from running. The queued operations will complete as soon as possible then return their results to the JavaScript environment. Tài liệu tham khảoIntroducing asynchronous JavaScript","link":"/2020/01/24/JS-Introducing-asynchronous-JavaScript/"},{"title":"[Laravel] Authentication","text":"Bài viết tổng hợp 1 số ý chính trong Authentication Laravel 1. IntroductionLaravel thực thi authentication cực kì đơn giản. Trên thực tế, có rất nhiều thứ được cấu hình ngoài phạm vi bài viết này. Về phần cốt lõi, Laravel authentication được tạo là bởi “guards“ và “providers“ Guard Guards xác định cách người dùng được xác thực cho mỗi request. Ví dụ, Laravel “session” guard sẽ duy trì trạng thái bằng cách sử dụng bộ lưu trữ session và cookie Guards: HOW AUTHENTICATE, sử dụng gì để xác thực (session, jwt hay 1 cái nào đó tự định nghĩa =))) Guards define how users are authenticated for each request Provider Provider: cách lấy dữ liệu người dùng như thế nào từ bộ lưu trữ. Laravel hỗ trợ truy xuất dữ liệu người dùng qua Eloquent và Database query builder. Tuy nhiên bạn có thể tự do xác định các provider cần thiếu cho ứng dụng của mình =&gt; Provider: HOW USERS ARE RETRIEVED (Provider: cách thao tác dữ liệu với người dùng Providers define how users are retrieved from your persistent storage 2. Custom lại mọi thứCustom lại đường dẫn chuyển hướng, email, guard xem trên trang chủ nhé. Một vài cái hay ho Password ConfirmationKhi bạn muốn user của bạn xác nhận lại mật khẩu trước khi thực hiện một số hành động yêu cầu sự bảo mật hãy sử dụng middleware này123Route::get('/settings/security', function () { // Users must confirm their password before continuing...})-&gt;middleware(['auth', 'password.confirm']);Chi tiết: https://laravel.com/docs/6.x/authentication#password-confirmation Login ThrottlingNếu bạn đang sử dụng class LoginController của Laravel, trait Illuminate\\Foundation\\Auth\\ThrottlesLogins đã được bao gồm trong controller của bạn. Mặc định user sẽ không thể login trong vòng 1 phút nếu họ đã đăng nhập lỗi 1 vài lần trước. Sự điều tiết này là duy nhât với mỗi username/email của người dùng và địa chỉ IP 3. Thêm 1 custom Guards hoặc 1 custom User Providershttps://code.tutsplus.com/vi/tutorials/how-to-create-a-custom-authentication-guard-in-laravel--cms-29667 Tổng kết: Cốt lỗi của Laravel Authentication là Guard và Provider Guard: xác thực bằng cách nào Provider: Cung cấp các cách truy vấn dữ liệu User Có thể custom lại mọi thứ, thêm 1 guard mới và Provider mới","link":"/2019/11/23/Laravel-Authentication/"},{"title":"[Laravel] Configuration","text":"Bài viết sẽ nói qua về các biến cấu hình trong Laravel 1. IntroductionTất cả các file cấu hình của ứng dụng Laravel đều được lưu trữ trong thư mục config. Mỗi tùy chọn đều được ghi lại, vì vậy hãy xem qua các tệp và làm quen với các tùy chọn có sẵn cho bạn. 2. Environment Configuration2.1. Environment Variable TypesTất cả các biến trong .env đều được chuyển thành string, do vậy 1 vài giá trị riêng đã được tạo ra cho phép bạn trả về phạm vi rộng hơn của các kiểu (một vài giá trị được thêm vào để trả về như ý)123456789.env Value env() Valuetrue (bool) true(true) (bool) truefalse (bool) false(false) (bool) falseempty (string) ''(empty) (string) ''null (null) null(null) (null) nullKhi biến của bạn có dấu cách, cần đặt nó trong dấu nháy kép1APP_NAME=&quot;My Application&quot; 2.2. Lấy giá trị trong cấu hìnhTất cả các biến liệt kê trong file được lưu vào biến $_ENV PHP super-global; khi ứng dụng của bạn nhận 1 request. Tuy nhiên bạn có thể sử dụng helper env để lấy giá trị các biến này trong file môi trường của bạn. Trên thực tế, nếu bạn review các file cấu hình của Laravel, bạn sẽ nhận thấy nó đang sử dụng helper1'debug' =&gt; env('APP_DEBUG', false),Tham số thứ 2 là giá trị default nếu không tồn tại key trong file config 3. Configuration CachingĐể tăng tốc cho ứng dụng của bạn, bạn nên cache tất cả các file cấu hình của bạn vào 1 file duy nhất bằng cách sử dụng lệnh config:cache. Lệnh này sẽ kết hợp tất cả các tùy chọn cấu hình của bạn thành 1 file duy nhất và sẽ được framework load 1 cách nhanh chóng. File cấu hình cache sẽ được sinh ra tại /bootstrap/cahce/config.php. Bạn nên thường chạy php artisan config:cache như một thói quen trong 1 phần deploy sản phẩm. Không nên chạy lệnh trong quá trình phát triển local vì các tùy chọn cấu hình thường sẽ cần phải được thay đổi trong quá trình phát triển ứng dụng của bạn. NOTE: nếu bạn thực thi lệnh config:cache trong quá trình deployment, bạn nên chắc chắn rằng bạn chỉ gọi hàm env trong thư các file cấu hình của bạn (thư mục config). Một khi config đã được cached, file .env sẽ không được load và tất cả các lời gọi tới hàm env đều trả về null (gọi env() ngoài các file cấu hình sẽ trả về null) =&gt; Đúng thật. Khi chạy php artisan config:cache thì dùng env ở chỗ khác ngoài config toàn ra null :v 4. Maintenance ModeKhi ứng dụng của bạn muốn maintain, có thể dễ dàng chuyển đổi chỉ với 1 dòng lệnh1php artisan downThêm các tùy chọn nào12php artisan down --message=&quot;Upgrading Database&quot; --retry=60php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16(nhìn là biết ý nghĩa rồi nhỉ, khỏi cần giải thích)Khi đã maintain xong, bật ứng dụng trở lại trạng thái bình thường thôi.1php artisan up Tổng kết Nếu không sử dụng cache cho configuration, thì cấu hình luôn được cập nhật, thêm vào file xong gọi là OK thôi (env or config helper) Nếu dùng cache, env ở ngoài thư mục config/ đều sẽ trả về null php artisan config:clear =&gt; xóa cache, không dùng cache nữa :D, quay về note 1 :D gọi ở đâu cũng được","link":"/2019/11/23/Laravel-Configuration/"},{"title":"[Laravel] Note 1: SQL &amp; Helper in blade view file","text":"Bài viết tổng hợp 1 số tips trong Laravel 1. Feature Toggle in laravelThêm helper cho blade, việc bật/tắt hiển thị giờ sẽ do config, dễ dàng hơn. Ví dụ chức năng login with Facebook Tạo file cấu hình (config/features.php)12345678910&lt;?phpreturn [ 'loginWithGoogle' =&gt; true, 'newSearchBox' =&gt; true, 'newsLetterBox' =&gt; false, /* Some Features .... */]; Sau đó chỉnh sửa file AppServiceProvider và thêm helper cho phương thức boot()123Blade::if('feature', function ($feature) { return config(&quot;features.$feature&quot;, false);}); Done! Giờ bạn có thể dùng ở blade files (views)123456@feature('loginWithGoogle') &lt;a href=&quot;#&quot; class=&quot;btn btn-primary-soft&quot;&gt; &lt;i class=&quot;fa fa-google&quot;&gt;&lt;/i&gt; &lt;span&gt;Login With Google&lt;/span&gt; &lt;/a&gt;@endfeature 3. Sáu cách để thực hiện 1 truy vấn SQL 3.1. Một số cách load dữ liệu trong quan hệ của LaravelTrước khi xem các cách thực hiện truy vấn trong Larael, chúng ta cùng điểm qua xem Eloquent của Laravel sử dụng lấy dữ liệu như thế nào nhé. Eloquent trong Laravel cung cấp cho chúng ta 3 cách query dữ liệu: Lazy load, Eager Loading, Lazy Eager Loading Lazy load (chỉ lấy dữ liệu chính nó)Đây là các lấy dữ liệumặc định, các Eloquent sẽ chỉ lấy các dữ liệu của chính nó mà không query để lấy các quan hệ12$users = User::all()$flight = App\\Flight::where('number', 'FR 900')-&gt;first(); Eager Loading (lấy parent model cùng các quan hệ)Khi bạn thực hiện truy cập quan hệ Eloquent như thuộc tính, dữ liệu relationship đó là “lazy loaded”. Điều đó có nghĩa relationshop data không thực sự được load cho tới khi lần đầu bạn truy cập vào thuộc tính của nó. Tuy nhiên, Eloquent có thể “eager load” relationship tại thời điểm bạn truy vấn vào parent model. Eager loading giải quyết vấn đề N + 1 truy vấn1$books = App\\Book::with('author')-&gt;get();Phương thức with này sử dụng lấy quan hệ cho tất cả các books. Nếu muốn load quan hệ theo từng model, hãy xem xét phương thức load() bên dưới. Điều đó có nghĩa là truy vấn sau sẽ không có ý nghĩa lấy User có id là 1 và quan hệ của nó:12$user = User::find(1)-&gt;with('posts')-&gt;get(); // find không có ý nghĩa vì nó load hết quan hệ và trả về tất cả users Lazy Eager Loading (lấy parent model xong sau đó quyết định có lấy các quan hệ hay không vì mặc định nó chỉ lấy parent model chính là lazy loading)Đôi khi bạn có thể cần eager load 1 quan hệ sau khi parent model được lấy. Ví dụ điều này cực kì hữu ích nếu bạn muốn quyết định có load các model liên quan trong quan hệ hay không?12345$books = App\\Book::all();if ($someCondition) { $books-&gt;load('author', 'publisher');}Trái với with là lấy dữ liệu quan hệ toàn bộ các model, load sẽ được sử dụng để lấy các quan hệ của 1 model do bạn chỉ định :D1$posts = User::find(1)-&gt;load('posts'); // không dùng with nhé Ngoài lề: Dynamic relationships in Laravel using subqueriesƠ thì đằng nào cũng đang nói về quan hệ mình xin nói luôn 1 bài toán khá hay mình đã gặp. Thông thường các quan hệ được liên kết thông qua khóa ngoài, phép so sánh bằng, như user_id trong bảng posts bằng với id trong bảng users. Tuy nhiên đôi khi lại có 1 chút khác biệt, giả sử user_id trong bảng posts lại là giá trị id trong bảng user cộng thêm 1 thì sao (ví dụ thôi nhé, thực tế chắc không có). Hay một bài toán khác lấy lần login cuối cùng của 1 user, dữ liệu thực tế chúng ta muốn lấy chỉ là 1 bản ghi trong bảng logins chứ không phải toàn bộ dữ liệu logins của users rồi mới xử lý tiếp. Lúc đó hãy dùng subquery để xây dựng ra các quan hệ động nhé :D Link bài viết gốc: https://reinink.ca/articles/dynamic-relationships-in-laravel-using-subqueries 3.2 Một số truy vấn trong LaravelChúng ta cùng xem xét 6 cách truy vấn DB trong Laravel Given this tables:12345678Users id namePosts id content user_idSelect all post from specific user:1234567891011121314151617181920212223242526/* First Way */$user = User::find(1); // Just Eloquent$posts = $user-&gt;posts; // Just Eloquent/* Second Way */$posts = User::with('posts')-&gt;find(1); // Eloquent with Eager loading/* Third Way */$posts = User::find(1)-&gt;load('posts'); // Eloquent with Lazy Eager Loading/* Fourth Way */$posts = User::join('posts', 'users.id', '=', 'posts.user_id') -&gt;where('users.id', 1) -&gt;get(); // Eloquent with Query Builder methods /* Fifth Way */$posts = DB::table('users') -&gt;join('posts', 'users.id', '=', 'posts.user_id') -&gt;where('users.id', 1)-&gt;get(); // Just Query Builder/* Sixth Way */$posts = DB::select( 'select * from users join posts on users.id = posts.user_id where users.id = 1'); // Just SQL 4. Xem SQL query được sinh ra bởi Eloquent hoặc Query Builder. Ghi logLaravel cung cấp 1 số phương thức giúp bạn dump câu lệnh truy vấn toSql(), getBindings()12345678App\\Models\\Division::where('type', 'rx')-&gt;toSql();// generates the following query:&quot;select * from `divisions` where `type` = ?&quot;$query = DB::table('table')-&gt;whereIn('some_field', [1,2,30]);$bindings = $query-&gt;getBindings();// Giá trị mảng truyền vào truy vấnVậy nếu để gộp 2 kết quả trên thành 1 truy vấn hoàn chỉnh thì sao nhỉ? Bạn chỉ cần thay các giá trị ? từ phương thức toSql() thành các giá trị nhận được từ phương thức getBindings() :D123456789public function getQueries(Builder $builder){ $addSlashes = str_replace('?', &quot;'?'&quot;, $builder-&gt;toSql()); return vsprintf( str_replace('?', '%s', $addSlashes), $builder-&gt;getBindings() );}Chi tiết bạn có thể xem thêm tại đây Phương thức dd() hay dump() cũng là 1 cách xem SQL Query:123DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dd();DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;dump();Link: https://laravel.com/docs/7.x/queries#debugging Để ghi các truy vấn vào log, hãy enableQueryLog lên rồi ghi vào log bình thường nhé :D123456// Toàn bộ truy vấn sẽ được ghi lại từ khi enableQueryLog()DB::enableQueryLog();App\\User::where(['id'=&gt;'1'])-&gt;delete();Log::info(DB::getQueryLog());","link":"/2019/11/23/Laravel-Note-1-SQL-Helper-in-blade-view-file/"},{"title":"[Laravel] Requests","text":"Request được inject tại class Illuminate\\Http\\Request :D 1. Request Path &amp; MethodLấy path, url, fullUrl, isMethod, is (check xem có trùng 1 pattern cho trước) 2. Input Trimming &amp; NormalizationMặc định, Laravel đã có 1 middleware là TrimString và ConvertEmptyStringsToNull được liệt kê trong App\\Http\\Kernel. Middleware này sẽ tự động trim (dọn dẹp, cắt) tất cả các trường string trong request cũng như chuyển đổi 1 vài giá trị empty string thành null. Nó cho phép bạn không phải lo lắng về request trong routes và controllers. Nếu bạn muốn disable các hành động này, hãy xóa bỏ 2 middleware này trong ứng dụng. 3. Retrieving Input: Lấy dữ liệu3.1. Lấy toàn bộ dữ liệu1$input = $request-&gt;all(); 3.2. Lấy một input value1$name = $request-&gt;input('name'); Có thể truyền giá trị default cho nó nếu không có giá trị trong request1$name = $request-&gt;input('name', 'Minh');Array thì sao?12$name = $request-&gt;input('products.0.name');$names = $request-&gt;input('products.*.name');Ngoài ra cũng có thể lấy tất cả các tham số truyền vào thông qua input mà không có tham số nào1$input = $request-&gt;input(); 3.3. Lấy dữ liệu từ queryTương tự dư cái trên :v123$name = $request-&gt;query('name');$name = $request-&gt;query('name', 'Helen');$query = $request-&gt;query(); 3.4. Lấy dữ liệu qua thuộc tính1$name = $request-&gt;name; Nó sẽ load từ form payload trước, nếu không có, nó sẽ tìm các trường đối số trong route 3.5. Lấy dữ liệu từ JSON InputNếu truyền dữ liệu với header Content-Type = application/json thì sử dụng dấu chấm để lấy dữ liệu1$name = $request-&gt;input('user.name'); 3.6. Lấy một phần của input data1234$input = $request-&gt;only(['username', 'password']);$input = $request-&gt;only('username', 'password');$input = $request-&gt;except(['credit_card']);$input = $request-&gt;except('credit_card'); NOTE: Phương thức only trả về tất cả các cặp key/value trong request, tuy nhiên, nó sẽ không trả về cặp key/value đó nếu nó không có trong request (không có giá trị default) Tổng kết: Phương thức only sử dụng không trả về giá trị mặc định và chỉ lấy giá trị có trong payload, hãy xem xét khi dùng nó (chắc dùng cho update sẽ tiện) all(): lấy hết dữ liệu, input(): lấy hết dữ liệu cả GET và POST (trừ file) và chỉ lấy được 1 trường, query() thì chỉ lấy ở method GET (query string) Các phương thức (trừ only) đều có trả về giá trị mặc định nên không phải xoắn =)) all(), input(), query(), only(), except(), $request-&gt;name, nó tìm trong payload (các tham số POST và GET), sau đó tìm các tham số trong route","link":"/2019/11/23/Laravel-Requests/"},{"title":"[Laravel] Testing Notes","text":"Bài viết tổng hợp lại một số link tham khảo về Testing trong Laravel. Tổng quan nhất về Testing trong Laravel Slide - TuanPT Notes - TuanPT Framgia’s Laravel Project Testing Guidelines Guidelines Viblo-TuanPT","link":"/2019/11/22/Laravel-Testing-Notes/"},{"title":"[Laravel] Validation","text":"Bài viết tổng hợp 1 vài note khi dùng validate với Laravel 1. AJAX Requests &amp; ValidationKhi bạn sử dụng validate cho AJAX, Laravel sẽ không sinh ra 1 đường chuyển hướng khi response. Thay vào đó, Laravel sẽ sinh ra 1 JSON response chưa tất cả các lỗi với mã HTTP code là 422 2. Validation Quickstart (chắc không dùng nên tạm bỏ qua)3. Form Request Validation3.1. Tạo Form Requests1php artisan make:request StoreBlogPost Vậy các các rules của validation được thực thi như thế nào? Tất cả thứ bạn cần là truyền request vào phương thức trong controller của bạn. Form request đến đã được validated trước khi method trong controller được gọi, điều đó có nghĩa bạn không cần lẫn phần validation logic trong controller của bạn12345678910111213/*** Store the incoming blog post.** @param StoreBlogPost $request* @return Response*/public function store(StoreBlogPost $request){ // The incoming request is valid... // Retrieve the validated input data... $validated = $request-&gt;validated();} Nếu validation lỗi, 1 response chuyển hướng sẽ được tạo ra vào trang trước đó, lỗi sẽ được flashed vào session và bạn có thể hiển thị nó. Nếu request là 1 AJAX request, 1 kiểu response JSON sẽ được trả về chứa các mã lỗi với mã 422 3.2. Adding After Hooks To Form RequestsNếu bạn muốn thêm 1 “after” hook tới 1 form request, bạn nên sử dụng withValidator method. Method này sẽ nhận cấu trức validator đầy đủ, cho phép bạn gọi 1 vài phương thức của chính nó trước khi các rules của validation thực sự được thực thi1234567891011121314/** * Configure the validator instance. * * @param \\Illuminate\\Validation\\Validator $validator * @return void */public function withValidator($validator){ $validator-&gt;after(function ($validator) { if ($this-&gt;somethingElseIsInvalid()) { $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!'); } });} 3.3. Xử lý dữ liệu trước khi validate123456protected function prepareForValidation(){ $this-&gt;merge([ 'username' =&gt; 'Minh', ]);}","link":"/2019/11/23/Laravel-Validation/"},{"title":"[Linux] Get started with Linux command line","text":"Bài viết sẽ giới thiệu tổng quan về hệ điều hành Linux và làm quen với các lệnh cơ bản. Tổng quan về LinuxLinux là HĐH Đa NSD, Đa tiến trình. Hỗ trợ lập trình, xử lý văn bản, trao đổi thông tin. Chế độ làm việc với Linux: sử dụng ở 2 chế độ đăng nhập Chế độ đăng nhập văn bản Chế độ đăng nhập console Mỗi lần đăng nhập tạo ra một phiên làm việc. Phiên được kết thúc bằng câu lệnh exit hoặc logout. Console ảoLINUX có thể mở đồng thời nhiều phiên làm việc trên cùng một trạm làm việc. LINUX hỗ trợ 8 console ảo trên một máy tính. Mỗi console quản lý tương ứng một phiên làm việc. Để chọn console ảo cần sử dụng tổ hợp phím tắt Ctrl+Alt+F1 cho đến F8: Ctrl+Alt-F1 : Console ảo 1 Ctrl+Alt-F2 : Console ảo 2 … Ctrl+Alt-F7 : Console ảo 7 (cho chế độ đồ hoạ) Một vài lệnh cơ bản để làm quen với hệ điều hành Ubuntu passwd - Thay đổi mật khẩu ls - liệt kê tệp logout - đăng xuất date - hiển thị ngày giờ của hệ thống who - ai đang đăng nhập script - ghi lại các thao tác uname -a- thông tin về HĐH man - hướng dẫn sử dụng logname : hiên thị tên NSD đang ở phiên làm việc hostname : hiển thị tên trạm làm việc clear : xoá màn hình who : tên của những người đang đăng nhập exit : kết thúc phiên làm việc mkdir : tạo thư mục rmdir : xoá thư mục cd : chuyển vị trí thư mục pwd : đường dẫn thư mục hiện tại cp : sao chép tệp rm : xoá tệp ps : xem tiến trình","link":"/2019/11/17/Linux-Get-started-with-Linux-command-line/"},{"title":"[Linux]: Hệ thống tệp tin linux","text":"Bài viết sẽ đề cập tới hệ thống tệp tin trên Linux và các lệnh cơ bản thao tác với tệp. 1. Tồng quan về hệ thống tệp trên LinuxTrước hết hãy xem xét qua các thư mục của Ubuntu có gì nào:12345678910/ (thư mục gốc) – /bin : thư mục tệp chương trình cơ bản – /boot : thư mục chứa hạt nhân của HĐH – /etc : thư mục các tệp cấu hình – /dev : thư mục các tệp thiết bị – /home : thư mục chứa dữ liệu NSD – /lib : thư viện hệ thống – /usr : thư mục ứng dụng – /var : thư mục dữ liệu cập nhật – /procTính đặc thù các tập tin của Linux Quản lý dưới một khung nhìn của tệp cho cả thư mục và các loại tài nguyên hệ thống (ngoại vi, bảng phân chương đĩa). Không có khái niệm phần mở rộng của tên tệp (kí tự '.' trong tên tệp được đối xử như mọi kí tự khác Không dùng ổ đĩa logic trong cây thư mục. '/' được dùng thay cho '\\' trong đường dẫn thư mục 2. Lệnh cơ bản quản lý thư mụcDăm ba lệnh thường dùng: pwd cd ls –la [tên thư mục] mkdir [-p] [tên thư mục mới] rmdir [tên thư mục rỗng] Các siêu kí tự: * dùng để thay thế cho một chuỗi kí tự bất kì bao gồm cả xâu rỗng. ? thay thế cho một kí tự bất kì. [ ] được thay thế bởi một kí tự trong một tập kí tự cho trước. [! ] được thay thế bởi một kí tự không có trong một tập kí tự cho trước. 12345678910$ ls -l *.[c,h]-rw-r--r-- 1 tuananh user1 2451 Feb 7 07:30 myprog.c-rw-r--r-- 1 tuananh user1 2451 Feb 7 07:30 myprog.h$ ls -l *progdrwxr-xr-- 2 tuananh user1 512 Feb 10 19:12 c_progdrwxr-xr-- 2 tuananh user1 512 Feb 10 19:12 java_prog$ ls -l .*-rw-r--r-- 1 tuananh user1 451 Feb 7 07:30 .bashrc-rw-r--r-- 1 tuananh user1 225 Feb 7 07:30 .bash_profile-rw-r--r-- 1 tuananh user1 351 Feb 7 07:30 .bash_logout 3. Quản lý tệp$cp file1 [...] dir: sao chép một hoặc nhiều tệp vào một thư mục. $mv file1 [...] dir: di chuyển một hoặc nhiều tệp đến một thư mục. $rm file1 [...]. Xoá một hoặc nhiều tệp Khi sử dụng rm, nên có tùy chọn i để xác nhận có xóa tệp hay không (sẽ được confirm để tránh xóa nhầm) $rf -rfi dir: xóa thư mục Tuỳ chọn -R (recursive): sử dụng khá nhiều đó :D: cho phép sao chép/di chuyển/xoá toàn bộ thư mục bao gồm cả các thư mục con 4. Đọc nội dung file4.1. Đọc nhanh một file, với các file không quá lớn cat: xem nhanh một tệp(Dùng cho file nhỏ, xem nhanh thì lệnh này có vẻ OK) 4.2. Đọc file theo dòng, xem các dòng đầu hoặc các dòng cuối đối với file lớnmore: xem từng dòng. tail: xem cuối tệp. head: xem đầu tệp. Với tail và head thì dùng để xem số dòng với tùy chọn -n tail -n 10 result.txt =&gt; xem 10 dòng cuối file Khi sử dụng tail, có tùy chọn -F theo dõi file thay đổi trực tiếp. Cái này cực kì hữu ích mỗi khi bạn đọc log của 1 hệ thống. tail -F log_11_11_2019.txt. vim, nano: có nhiều người giới thiệu less, tôi thấy vim và nano lại thông dụng hơn =)). Vim khá hiệu quả, được tối ưu để mở các file có kích thước lớn (như không load hết nội dung cả file đó mà chỉ load các phần cần đọc, tối ưu xử lý). 4.3. Tạo, cập nhậttouch: tạo tệp mới, cập nhật tệp cũ 4.4. Output stdout to fileGhi kết quả output của một lệnh ra file: echo noi dung &gt; [tên tệp]: xóa đi ghi lại nội dung vào file. echo noi dung &gt;&gt; [tên tệp]: ghi thêm nội dung vào cuối file. tail -n 10 result.txt &gt;&gt; new_result.txt: lấy nội dung 1 dòng cuối của file result cho vào file new_result.txt","link":"/2019/11/17/Linux-He-thong-tep-tin-linux/"},{"title":"[Linux]: Permission Management","text":"Bài viết sẽ đề cập tới các quyền đối với file/thư mục trong hệ thống Ubuntu. Ngoài ra bài viết cũng hướng dẫn sử dụng một số lệnh để thay đổi các quyền này. 1. Tổng quanMỗi file luôn thuộc về một người sử dụng và một nhóm xác định. Người tạo ra file hoặc thư mục sẽ là người sở hữu, nhóm chứa người tạo ra file hoặc thư mục sẽ là nhóm sở hữu đối với file/thư mục. Sự phân quyền cho phép xác định rõ các quyền mà người sử dụng có đối với một file hoặc một thư mục. Chi tiết các quyền truy cập: r : đọc Cho phép hiển thị nội dung của file hoặc thư mục. w : ghi Cho phép thay đổi nội dung của file. Cho phép thêm hoặc xóa các file trong một thư mục. x : thực thi Cho phép thực thi file dưới dạng một chương trình. Cho phép chuyển đến thư mục cần truy cập. 2. Các nhóm người sử dụng fileCó 3 nhóm người sử dụng đối với 1 file/ thư mục: u (người sở hữu) : người sở hữu duy nhất của file g (groupe) : những người sử dụng thuộc nhóm chứa file o (others) : những người sử dụng khác, không phải là người sở hữu file cũng như không thuộc nhóm chứa file. Mỗi nhóm người sử dụng sẽ có một tập các quyền (r, w, x) xác định. Ví dụ123456789101112$ ls -l----rw-rw- 1 minhnv user1 16 Feb 10 19:12 test1.txt-rw-rw-rw- 1 minhnv user1 16 Feb 10 19:12 test2.txtdrw-r--r-- 2 minhnv user1 512 Feb 10 19:14 vanban$ whoamiminhnv$ cat test1.txtcat: test1.txt: Permission denied$ cat test2.txtUn fichier de test$ cp test2.txt vanbancp: vanban: Permission deniedMột vài lưu ý về phân quyền hệ thống file: Để có thể thêm các file, cần phải có quyền “w” đối với thư mục Để có thể xóa, thay đổi nội dung hoặc di chuyển 1 file, người sử dụng cũng cần phải có quyền « w » đối với thư mục Việc xóa một file còn phụ thuộc vào quyền đối với thư mục chứa file đó Để bảo mật các dữ liệu, người sở hữu file thậm chí có thể bỏ cả quyền đọc “r” đối với tất cả mọi người sử dụng khác. Để hạn chế quá trình truy cập vào hệ thống file, người sử dụng có thể bỏ quyền thực thi (x) đối với thư mục gốc của hệ thống file. Một số quyền đặc biệt đối với các file thực thi: 12345678set-uid: -rws --- --- - Chương trình được chạy dưới quyền của người sở hữuset-gid: - --- rws --- - Chương trình được chạy bởi các người sử dụng thuộc cùng nhóm với người sở hữu bit sticky - Chương trình chỉ được cấp phát bộ nhớ trong 1 lần Một số quyền đặc biệt với thư mục123456• set-uid: -rws --- ---• set-gid: - --- rws ---– Các tệp mới được tạo ra có nhóm chủ sở hữu là nhóm của thư mục• bit sticky– Chỉ có root và chủ sở hữu được xóa, kể cả khi có quyền rwxVí dụ:1234$ ls -l /etc/passwd-rw-rw---- 1 root root 568 Feb 10 19:12 passwd$ ls -l /bin/passwd-rwsrws--x 1 root root 3634 Feb 10 19:12 passwdTrong ví dụ trên, khi một người sử dụng thông thường gọi lệnh /bin/passwd, xem như người đó được“mượn” quyền root để thay đổi mật khẩu trong file /etc/passwd 3. Lệnh thay đổi quyền$chmod123456789101112$chmod &lt;mode&gt; &lt;files&gt;set_uid set-gid sticky user group other rwx --x --x 1 1 0 111 001 001 6 7 1 1$ chmod 6711 test$ ls -l test-rws--s--x 1 minhnv user1 Mar 10 10:20 test$ chmod 711 test$ ls -l test-rwx--x--x 1 minhnv user1 Mar 10 10:20 test Hoặc1234567$chmod &lt;ugoa&gt;&lt;+-=&gt;&lt;rwsx&gt; &lt;files&gt;• u | g | o | a (all)• Operation– + (thêm 1 hoặc 1 số quyền vào tập các quyền file đã có)– - (bỏ 1 hoặc 1 số quyền khỏi tập các quyền file đã có)– = (gán mới 1 hoặc 1 số quyền cho file)• Quyền = r | w | x | sVí dụ:12345678910$ ls -l test.txt-rw-rw-r-- 1 minhnv user1 150 Mar 19 19:12 test.txt$ chmod o+w test.txt$ ls -l test.txt-rw-rw-rw- 1 minhnv user1 150 Mar 19 19:12 test.txt$ chmod a-rw test.txt$ ls -l test.txt---------- 1 minhnv user1 150 Mar 19 19:12 test.txt$ cat test.txtcat: test.txt: Permission denied $chown, $chgrpLệnh này để thay đổi người sở hữu và nhóm12$chown [-R] &lt;utilisateur&gt; &lt;files&gt;– Thay đổi người sở hữu của file12345$chgrp &lt;group&gt; &lt;files&gt;– Thay đổi nhóm của file– Có thể sử dụng tùy chọn –R để lặp lại việc thực hiện cáclệnh (ví dụ thực hiện việc thay đổi quyền sở hữu hoặcnhóm của mọi file trong cùng một thư mục)Note: Các lệnh trên chỉ dành cho những người sử dụng có quyền root Ví dụ123$sudo chown -R yourname:www-data cake$sudo chown minhnv file1.txt$sudo chmod -R g+s cake 4. Nhóm www-dataKhi làm việc với web, tôi thấy khá nhiều người chuyển quyền sở hữu file/thư mục cho nhóm người dùng này. Thực tế, nhóm www-data là tập những người dùng vào web servers trên Ubuntu (như nginx, apache2) sử dụng mặc định cho các hoạt động truy cập web thông thường. Máy chủ web server có thể truy cập bất kì file nào nhóm www-data có thể truy cập. Không có gì đặc biệt với nhóm user này. Chi tiết https://askubuntu.com/questions/873839/what-is-the-www-data-user https://stackoverflow.com/questions/9133024/www-data-permissions","link":"/2019/11/17/Linux-Permission-Management/"},{"title":"[Linux] Process mangement","text":"Bài viết tổng hợp một số lệnh cho việc quản lý tiến trình trong hệ điều hành Linux. Bên canh đó có 1 số lệnh chuyển kênh chuẩn và thực hiện xử lý song song các câu lệnh trong Linux. 1. Quản lý tiến trìnhMột tiến trình = thực thi của một chương trình được thực thi. Mỗi tiến trình sẽ tương ứng với một tập các thông tin sau: Một định danh (pid) Một tiến trình cha (ppid) Người sở hữu (uid) và nhóm (gid) Câu lệnh khởi tạo tiến trình Một đầu vào chuẩn (stdin), một đầu ra chuẩn (stdout), một kênh báo lỗi chuẩn (stderr) Thời gian sử dụng CPU (CPU time) và mức độ ưu tiên Thư mục hoạt động hiện tại của tiến trình Bảng các tham chiếu đến các file được tiến trình sử dụng. Các tiến trình được sắp xếp để chia sẻ thời gian sử dụng CPU. Có 2 loại tiến trình là tiến trình hệ thống và tiến trình của người dùng: Các tiến trình hệ thống Thường thuộc về quyền root Không có giao diện tương tác Thường được chạy dưới dạng các tiến trình ngầm (daemon) Đảm nhiệm các nhiệm vụ chung, phục vụ mọi người sử dụng. Ví dụ: lpsched: Quản lý các dịch vụ in ấn cron: tự động thực hiện một lệnh/chương trình vào một thời gian xác định trước. inetd: quản lý các dịch vụ mạng. Các tiến trình của người sử dụng Thực hiện các nhiệm vụ của một người dùng cụ thể Thực hiện dưới dạng một shell tương ứng với một sự đăng nhập. Thực hiện dưới dạng một lệnh thông qua shell Thường được thực hiện, quản lý bằng một terminal Ví dụ: cp, vi, man 2. Lệnh ps, lsof Hiển thị các tiến trình Theo ngầm định, lệnh ps hiển thị các tiến trình thuộc về người sử dụng terminal. Sử dụng tùy chọn ps -aux để hiển thị tất cả các tiến trình đang chạy trong máy. Xem tiến trình với port: lsof (LiSt Open File)123sudo lsof -t -i:9001=&gt; kill process in port 9001:sudo kill $(sudo lsof -t -i:9001) 3. Các trạng thái của 1 tiến trình S: đang ngủ R: đang chạy T: dừng Z: không xác định 4. Lệnh killLệnh này gửi một tín hiệu đến một tiến trình (định danh của tiến trình được xác định dưới dạng một tham số của lệnh). Theo ngầm định, tín hiệu gửi đi là tín hiệu 15 (SIGTERM – kết thúc tiến trình) Tùy chọn -9: gửi tín hiệu 9 (SIGKILL – hủy tiến trình) Tùy chọn –l: liệt kê tất cả các tín hiệu có thể sử dụng. Lệnh killall: dùng để kết thúc tất cả các tiến trình của một câu lệnh thông qua việc truyền tên của câu lệnh dưới dạng một tham số.12$ kill -9 1317$ killall &lt;process-name&gt;( kiểu như killall các tiến trình ở cổng 80)Quyền hủy tiến trình thuộc về người sở hữu tiến trình. Note: Nói chung, bạn nên sử dụng kill (viết tắt của kill -s TERM, hoặc trên hầu hết các hệ thống kill -15) trước khi kill -9 (kill -s KILL) để tạo cơ hội tiến trình tự dọn dẹp sau đó. (Các quy trình không thể bắt hoặc bỏ qua SIGKILL, nhưng chúng có thể và thường bắt SIGTERM.) Nếu bạn không cho quá trình hoàn thành những gì nó đang làm và dọn sạch, nó có thể để lại các tệp bị hỏng (hoặc trạng thái khác) rằng nó sẽ không thể hiểu được khi khởi động lại. =&gt; Phải dọn dẹp hết những gì nó đang sử dụng thì lần sau khởi động lại mới được =)) Ref: https://unix.stackexchange.com/questions/8916/when-should-i-not-kill-9-a-process 5. Các cách thực hiện song song các câu lệnh cmd1 ; cmd2 Thực thi nhiều lệnh độc lập: Sử dụng ký tự ; để thực thi nhiều lệnh liên tiếp, các lệnh này hoạt động độc lập với nhau.1$cp public/* perso; rm -r public cmd1 &amp;&amp; cmd2 Thực thi nhiều lệnh phụ thuộc nhau Sử dụng ký hiệu &amp;&amp; để thực thi nhiều lệnh liên tiếp, các lệnh này phụ thuộc nhau, lệnh sau chỉ được thực hiện nếu lệnh trước không gặp lỗi.1$cp public/* perso &amp;&amp; rm -r public cmd1 | cmd2: Cơ chế đường ống: Cơ chế đường ống giữa hai tiến trình cho phép định hướng lại đầu ra của tiến trình thứ nhất trở thành đầu vào của tiến trình thứ hai Cơ chế đường ống được thiết lập bằng cách sử dụng ký tự: | 6. Chuyển hướng các kênh chuẩn Mỗi tiến trình sở hữu: Một đầu vào chuẩn (ngầm định là bàn phím) Một đầu ra chuẩn (ngầm định là terminal) Một kênh báo lỗi chuẩn (ngầm định là terminal) Chuyển hướng đầu vào chuẩn (&lt;)1$ tee &lt; test.txt Chuyển hướng đầu ra chuẩn (&gt;, &gt;&gt;)12$ ls &gt; /dev/lp$ ls &gt;&gt; test.txt Chuyển hướng kênh báo lỗi12$ rm prog.c 2&gt; /dev/null$ gcc prog.c 2&gt;&gt; erreur.txt 7. Lệnh grep : Tìm kiếm các dòngCú pháp chung: $grep [-options] expreg [files] Tìm kiếm trong file hoặc trong đầu vào chuẩn các dòng có chứa các ký tự hoặc xâu thỏa mãn một số điều kiện nào đó. Các tùy chọn -c : chỉ đưa ra tổng số dòng thỏa mãn điều kiện -I : chỉ đưa ra tên file -v : chỉ đưa ra các dòng mà điều kiện tìm kiếm không thỏa mãn -i : không phân biệt chữ hoa, chữ thường -n: chỉ đưa ra số thứ tự của dòng -w: thực hiện tìm kiếm với quá trình so sánh được thực hiện đối với từng từ của chuỗi nhập vào (các từ được phân cách nhau bằng các ký tự không phải là chữ cái, không phải là chữ số và không phải là dấu gạch dưới _) Biểu thức chính quy: . Biểu diễn 1 ký tự bất kỳ * Lặp lại ký tự ở vị trí trước ^ bắt đầu 1 dòng $ kết thúc 1 dòng [...] xác định danh sách hoặc một khoảng các ký tự cần tìm kiếm [^..] các ký tự không tìm kiếm. Chú ý: để tránh nhầm lẫn, nên đặt các ký tự biểu diễn điều kiện trong ngoặc kép. Ví dụ:12345678$grep &quot;^t&quot; /etc/passwd Tìm trong file /etc/passwd tất cả các dòng bắt đầu bằng ký tự “t”$grep [^t] /etc/passwd Tìm tất cả các dòng không bắt đầu bằng ký tự “t”$grep &quot;minh&quot; /etc/passwd Tìm tất cả các dòng có chứa xâu &quot;minh&quot;$ls -l /etc | grep &quot;^d&quot; Hiển thị tất cả các thư mục con của /etc 8. Case studyTrường hợp máy chạy quá nặng dẫn đến việc đơ máyCó thể xem tiến trình nào đang chiếm nhiều CPU và bộ nhớ nhất12345678$ top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7643 minhnv 20 0 2899196 261280 136296 S 15,2 6,7 0:06.87 firefox 5328 minhnv 20 0 1557244 298152 83328 S 8,9 7,6 7:27.92 chrome 6015 minhnv 20 0 1416656 259440 75936 S 8,9 6,6 0:47.91 chrome 7693 minhnv 20 0 2707144 227308 143388 S 7,3 5,8 0:03.79 Web Content 5340 minhnv 20 0 1219988 131676 54040 S 6,6 3,4 0:29.68 chrome 1510 root 20 0 401932 89864 75344 S 6,0 2,3 1:30.73 Xorg Lúc này có thể kill một số tiến tình nặng đi để có thể trở về trạng thái bình thường (đa số các tiền trình nặng đều là do mở các trình duyệt). Cách 1:1$ killall firefoxCách 2:12$ ps -A | grep firefoxSau đó kill từng tiến trình một","link":"/2019/11/22/Linux-Process-mangement/"},{"title":"[MongoDB] Update Operators in mongoDB","text":"Các toán tử update trong mongo cũng như các database khác giúp bạn định nghĩa lại bản ghi (or document) hoặc nhiều bản ghi (or documents). Chúng ta cùng xem xét mongoDB có những kiểu cập nhật dữ liệu nào và cú pháp của nó ra sao nhé :D 0. Cú pháp chung123456789101112db.collection.update( &lt;query&gt;, &lt;update&gt;, { upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;, collation: &lt;document&gt;, arrayFilters: [ &lt;filterdocument1&gt;, ... ], hint: &lt;document|string&gt; // Available starting in MongoDB 4.2 }) Giải thích qua về các tham số: query: điều kiện lựa chọn document để update update: Cách thức cập nhật lại document (sẽ đề cập phần dưới) Các tùy chọn trong update: upsert: mặc định false. Nếu upsert:true, nó sẽ thêm 1 doucment nếu khi update, không document nào trùng với query. Có thể sử dụng nó kết hợp với $setOnInsert Note: nếu query với index hoặc trường nào đó duy nhất, tránh sử dụng upsert:true để bị lặp bản ghi @@ multi: update nhiều document hay không? writeConcern: méo hiểu collation: cho phép người dùng chỉ định ra các rule ngôn ngữ cụ thể cho việc so sánh string, đơn giản như là rule chữ hoa chữ thường hay trọng âm arrayFilters: xác định phần tử nào trong mảng sẽ được update hint: xác định index được sử dụng hỗ trợ query. Tùy chọn này được thêm từ phiên bản Mongo 4.2 liên quan đến Index 1. Các loại update trong mongo1.1. Cập nhật lại các trường của 1 documentNếu bạn muốn cập nhật 1 vài trường trong Document đã tồn tại, bạn hãy sử dụng các toán tử update được nhắc đề cập ở phần sau:12345db.collection.update( &lt;query&gt;, { $set: { status: &quot;D&quot; }, $inc: { quantity: 2 } }, ...) 1.2. Thay thế hoàn toàn documentNếu bạn muốn thay thế hoàn toàn document đã có bằng 1 document mới tính với các trường mới, sử dụng cú pháp chỉ có field:value 12345db.collection.update( &lt;query&gt;, { item: &quot;XYZ123&quot;, stock: 10, info: { publisher: &quot;2255&quot;, pages: 150 }, tags: [ &quot;baking&quot;, &quot;cooking&quot; ] } ...) Lưu ý: - Phép thay thế này sẽ thay thế toàn bộ các trường cũ bằng các trường mới được set vào (trừ _id) - Không thể thay thế được nhiều document 1.3. Update với Aggregation Pipeline12345678db.collection.update( &lt;query&gt;, [ { $set: { status: &quot;Modified&quot;, comments: [ &quot;$misc1&quot;, &quot;$misc2&quot; ] } }, { $unset: [ &quot;misc1&quot;, &quot;misc2&quot; ] } ] ...) Note: The $set and $unsetused in the pipeline refers to the aggregation stages $set and $unset respectively, and not the update operators $set and $unset. 2. Các toán tử update Reference: https://docs.mongodb.com/manual/reference/operator/update/ 2.1. Các toán tử update với trường (Field Update Operators) Tên Mô tả $currentDate Set giá trị của 1 trường bằng ngày hiện tại, có 2 tùy chọn là kiểu ngày (Date) hoặc Timestamp $inc Tăng giá trị của 1 trường với 1 giá trị xác định $min Chỉ cập nhật trường đó nếu giá trị đó nhỏ hơn giá trị đã tồn tại. $max Tương tự $min $mul Nhân giá trị của 1 trường với 1 giá trị $rename Đổi tên 1 trường $set Sets the value of a field in a document. $setOnInsert Set giá trị của 1 trường nếu kết quả của phép update là 1 phép thêm document. Sẽ không có ảnh hưởng đến các phép update mà sửa đổi documents đã tồn tại. $unset Removes the specified field from a document. $minVí dụ document hiện tại:1{ _id: 1, highScore: 800, lowScore: 200 }Giá trị lowScore hiện tại trong document đang là 200. Toán tử $mindưới đây so sánh 200 với giá trị xác định 150 và cập nhật giá trị lowScore là 150 vì 150 &lt; 2001db.scores.update( { _id: 1 }, { $min: { lowScore: 150 } } )Và kết quả ta có:1{ _id: 1, highScore: 800, lowScore: 150 }Toán tử tiếp theo lại không có ảnh ưởng gì vì 150 &lt; 2501db.scores.update( { _id: 1 }, { $min: { lowScore: 250 } } )Kết quả là:1{ _id: 1, highScore: 800, lowScore: 150 }` &lt;br&gt;(không ảnh hưởng :D) Note: $min có thể được sử dụng để so sánh cả kiểu Date $renameTa xem xét document hiện tại như sau:123456789101112131415161718{ &quot;_id&quot;: 1, &quot;alias&quot;: [ &quot;The American Cincinnatus&quot;, &quot;The American Fabius&quot; ], &quot;mobile&quot;: &quot;555-555-5555&quot;, &quot;nmae&quot;: { &quot;first&quot; : &quot;george&quot;, &quot;last&quot; : &quot;washington&quot; } },{ &quot;_id&quot;: 2, &quot;alias&quot;: [ &quot;My dearest friend&quot; ], &quot;mobile&quot;: &quot;222-222-2222&quot;, &quot;nmae&quot;: { &quot;first&quot; : &quot;abigail&quot;, &quot;last&quot; : &quot;adams&quot; }},{ &quot;_id&quot;: 3, &quot;alias&quot;: [ &quot;Amazing grace&quot; ], &quot;mobile&quot;: &quot;111-111-1111&quot;, &quot;nmae&quot;: { &quot;first&quot; : &quot;grace&quot;, &quot;last&quot; : &quot;hopper&quot; }}Trường nmae đang bị viết sai chính tả, chúng ta đổi lên tên thôi1db.students.updateMany( {}, { $rename: { &quot;nmae&quot;: &quot;name&quot; } } ) Note: - Nó update được cả tên trường trong Embedded Document - Nếu update tên 1 trường không tồn tại, nó sẽ không làm gì cả :D 2.2. Các toán tử update với mảng (Array Update Operators)Update Operators Tên toán tử Mô tả $ Cập nhật phần tử đầu tiên trong mảng trùng với điều kiện truy vấn $[] Cập nhật tất cả các phần tử trong mảng trùng với điều kiện truy vấn $[] Cập nhật tất cả các phần tử trong mảng, cái mà trùng với điều kiện arrayFilters (trong tùy chọn update) và điều kiện truy vấn $addToSet Thêm phần tử vào 1 mảng nếu nó chưa tồn tại (dùng toán tử này để các phần tử trong mảng là duy nhất) $pop Xóa phần tử đầu tiên hoặc cuối cùng của 1 mảng $pull Xóa toàn bộ phần tử của mảng trùng với điều kiện xác định $push Thêm 1 thành phần vào 1 mảng $pullAll Xóa tất cả các giá trị phù hợp với điều kiện từ 1 mảng Update Operator Modifiers Tên toán tử Mô tả $each Sửa toán tử $push và $addToSet để thêm nhiều item vào mảng update $position Chỉnh sửa toán tử $push để xác định vị trí các thành phần được thêm vào mảng $slice Chỉnh sửa toán tử $push để giới hạn kích thước được thêm vào mảng $sort Chỉnh sửa toán tử $push để sắp xếp lại các document được lưu trữ trong mảng Tài liệu tham khảo https://docs.mongodb.com/manual/reference/operator/update/ https://docs.mongodb.com/manual/reference/method/db.collection.update/","link":"/2019/09/08/Mongo-Update-Operators-in-mongoDB/"},{"title":"Một vài câu lệnh hữu ích khi sử dụng Vim","text":"Đối với những người mới dùng Ubuntu, việc lựa chọn trình chỉnh sửa văn bản, người ta thường nhớ tới gedit, sublime text, tù tù tí thì là nano. Mọi người thường không thích dùng vim vì độ phức tạp, lằng nhằng, nhiều lệnh khó nhớ. Hi vọng bài viết sau sẽ có bạn có nhiều thiện cảm hơn với Vim :D So với một số trình chỉnh sửa văn bản, VIM có một số lợi thế sau: Bạn có thể chỉnh sửa các đoạn văn bản mà không cần dùng chuột, chỉ sử dụng bàn phím (tiết kiệm được tầm từ 150k đến 500k :v). Sở hữu rất nhiều phím tắt đa dạng, đầy đủ giúp bạn hoàn thành các tác vụ lặp đi lặp lại một các nhanh chóng và dễ dàng. Bạn trông ngầu hơn khi sử dụng phím tắt này, chỉnh sửa văn bản cũng dùng lệnh, bụp bụp Ctrl Shift Shift Ctrl Delete là xong :v: . Tuy nhiên nó đồng nghĩa với việc bạn cần luyện tập để nhớ lệnh thì mới ngầu được. Nhẹ. Cùng một file lớn, mở bằng vim sẽ nhẹ hơn so với các trình soạn thảo khác (ít nhất là so với gedit). Phổ biến: Vim có trên cả MAC, Ubuntu và Windows. Khi triển khai các server, việc remote vào máy ảo, việc cài đặt gedit haysublime text rõ ràng không khả thi mà cần một số trình chỉnh sửa văn bản dòng lệnh. Vim là một lựa chọn không hề tồi :D. Cài đặt(Trong phạm vi bài viết mình hướng dẫn cài Vim trên ubuntu)12$ sudo apt-get update$ sudo apt-get install vimMở 1 file với vim 1$ vim file.txt Các chế độ với VimChế độ dòng lệnhĐây là chế đầu tiên khi bạn khởi động VimChế độ này là nơi bạn phô diễn kỹ thuật với hàng loạt các lệnh và các phím tắt trong Vim. Với một người dùng Vim chuyên nghiệp, đây có lẽ là chế độ bạn dùng nhiều nhất. Chế độ INSERTChế độ này cho phép bạn chèn kí tự vào trong văn bản. Chế độ VISUALChế độ này cho phép bạn chọn các vùng văn bản để thao tác với chúng (ví dụ như chọn đoạn văn bản để copy, cut hay xóa …). Để chuyển qua giữa các chế độ này với nhau ta sử dụng các phím Esc (chuyển chế độ dòng lệnh), i để sang chế độ insert và V hoặc v để chuyển sang chế độ Visual. Một vài lệnh thao tác cơ bản Các lệnh lưu và thoát VIM:123456:w - write (save) the file, but don't exit:w !sudo tee % - write out the current file using sudo:wq or :x or ZZ - write (save) and quit:q - quit (fails if there are unsaved changes):q! or ZQ - quit and throw away unsaved changes:wqa - write (save) and quit on all tabs Di chuyển chuột: h - Đi qua TRÁI j - Đi xuống k - Đi lên l - Đi qua PHẢI H - Move to top of screen L - Move to bottom of screen w - Jump forwards to the start of a word W - Jump forwards to the start of a word (words can contain punctuation) e - Jump forwards to the end of a word E - Jump forwards to the end of a word (words can contain punctuation) b - Jump backwards to the start of a word B - Jump backwards to the start of a word (words can contain punctuation) 0 - Jump to the start of the line ^ - Jump to the first non-blank character of the line $ - Jump to the end of the line g_ - Jump to the last non-blank character of the line gg - Go to the first line of the document G - Go to the last line of the document 5gg or 5G - Go to line 5 Ctrl + G: Xem thông tin dòng hiện tại Cấu hình Cấu hình hiển thị số dòng để làm việc12:set number: hiển thị số dòng:set nonumber: ẩn số dòng Lệnh chấm (.)Câu lệnh giúp bạn lặp lại thay đổi trước đó. Đây là một lệnh mạnh mẽ và đa năng trong Vim. Xét ví dụ sau để hiểu rõ. Ví dụ 1: Thêm dấu chấm phẩy vào file sau:123var foo = 1var bar = 'a'var foobar = foo + barTa sẽ thêm kí tự ; vào dòng đầu sau đó lặp lại hành động bằng dấu ; (len) Giải thích qua 1 chút về các lệnh bạn sử dụng A: Chuyển về chế độ cuối dòng và chuyển Vim sang chế độ insert mode (còn a là chuyển về sau vị trí con trỏ chuột và chuyển sang chế độ insert mode) ;: thêm kí tự ; khi ở chế độ insert mode Esc: chuyển về chế độ dòng lệnh j: chuyển đến vị trí dòng sau (như trường hợp này là cuối dòng kế tiếp) .: lặp lại hành động thêm ; j.: chuyển đến dòng tiếp theo và lặp lại hành động thêm ; Như vậy câu lệnh . giúp bạn lặp lại hành động thêm dấu ; một cách dễ dàng và có thể sử dụng lại :D. Tìm kiếm và thay đổi kí tựVí dụ 2: Tìm kiếm chuỗi 'content' và thay nó bằng kí tự 'copy' trong file. Giải quyết: Sử dụng lệnh trực tiếpSử dụng lệnh thay thế như sau ở chế độ dòng lệnh1:%s/content/copy/gCách này nhanh chóng, tuy nhiên câu lệnh nội dung tìm kiếm (content) không có sẽ có thể gây lỗi Cách thủ côngCách này thủ công hơn và cho phép bạn thay thế có thể toàn bộ nội dung file hoặc chỉ 'content' nào tùy ý thành 'copy' Bước 1: Search /content Bước 2: Di chuyển tới nội dung tìm kiếm: * (đi đến nơi mà bạn muốn thay thế kí tự) hoặc sử dụng n Bước 3: cw copy &lt;Esc&gt; cw: xóa đến hết từ và chuyển vim sang chế độ insert copy: nhập thay thế kí tự trong chế độ insert mode Esc: chuyển về chế độ dòng lệnh Bước 4: n: đi đến kí tự tiếp theo Bước 5 . : lặp lại hành động thay thế nếu bạn muốn :D Copy, cut dữ liệuMột vài lệnh sau trong chế độ dòng lệnh hữu dụng cho bạn x: xóa các thứ đã chọn dw - delete (cut) the characters of the word from the cursor position to the start of the next word D - delete (cut) to the end of the line y: copy các dòng đã chọn d: cut các dòng đã chọn dd: cut dòng hiện tại (có thể dùng để xóa) yy: copy dòng hiện tại p: paste v: chuyển sang chế độ visual để chọn văn bản (chọn xong nhấn y hoặc d để copy hay cut là tùy bạn) V: chuyển sang chế độ visual nhưng bôi đen theo dòng 20yy: copy 20 dòng đầu của file hiện tại 20dd: cut 20 dòng từ hiện tại (có thể dùng để xóa) Act, Repeat và ReverseCác câu lệnh tiếp theo là các câu lệnh giống như Ctrl Z và undo trong các trình soạn thảo như word :D Intent Act Repeat Revert Make a change {edit} . u Scan line for next character f{char} / t{char} ; , Scan line for previous character F{char} / T{char} ; , Scan document for next match /pattern n N Scan document for previous match ?pattern n N Perform substitution :/s/target/replacement &amp; u Execute a sequence of changes qx{changes}q @x u Làm việc nhiều file cùng lúc với VimPhần cuối cùng mình sẽ hướng dẫn các bạn sử dụng Vim để mở nhiều file cùng 1 lúc. Mở trên cùng một cửa sổĐể mở nhiều file trên cùng một cửa sổ, bạn truyền thêm tham số vào vim là được12$ vim *.txt$ vim file1.txt file2.txtMột số lệnh hữu ích:123:ls: xem danh sách các file đang được mở:bnext: chuyển sang file tiếp theo:bprev: chuyển sang file trước đóSau khi đi qua 1 lượt các file, có thể sử dụng Ctrl ^ để chuyển qua các file Lưu ý: Phải đi qua file mới sử dụng được Ctrl ^. Nguyên nhân ở đây là Vim tối ưu, chỉ khi đọc file nào nó mới load nội dung file đó vào bộ nhớ, vì vậy phải mở qua thì mới mở lại được. Chi tiết bạn có thể đọc ở Tip 37 trong tài liệu tham khảo để hiểu về cơ chế load file trong Vim (Buffers và File :3). Mở trên đa cửa sổSử dụng :vsp hoặc :sp nếu bạn muốn mở file sang cửa sổ bên cạnh hoặc ở dưới, chia đôi màn hình 123$ vim file1.txt:vsp file2.txt(trong trường hợp file2.txt chưa tồn tại thì nó sẽ tạo file mới) Sử dụng 2 lần ctrl W để chuyển qua lại giữa các file. Ví dụ 3: Copy 20 dòng đầu của file có sẵn vào file mới tên là copy.txt 1234567$ vim file1.txt // mở file1.txt bằng vim:vsp copy.txt // chia đôi màn hình để làm việc 2 file 1 lúc2 x Ctrl W // chuyển về file1.txt20yy // copy 20 dòng đầu từ file1.txt2 x Ctr W // chuyển sang file đích: copy.txtp // paste vào thôi:wq // lưu file copy.txt Trên đây là một vài câu lệnh mình hay sử dụng khi thao tác với VIM. Ngoài ra như đã nói ở trước, VIM cung cấp rất rất nhiều tổ hợp phím tắt hữu dụng khác giúp bạn thao tác nguy hiểm hơn. Chi tiết bạn có thể đọc thêm các Tip hướng dẫn trong tài liệu tham khảo Tài liệu tham khảo Practical Vim Làm quen với Vim trong 5 phút Vim Cheat Sheet","link":"/2019/04/11/Mot-vai-cau-lenh-huu-ich-khi-su-dung-Vim/"},{"title":"Một vài điều về sudo command","text":"Chắc hẳn khi dùng Ubuntu, chúng ta ai cũng đã từng gặp phải lỗi kinh điển “Permission denied”. Lúc đó, mặc định với 99% người đang sử dụng Ubuntu là sử dụng lệnh sudo để giải quyết vấn đề, mọi vấn đề được giải quyết 1 cách đơn giản. Trong bài viết tới mình giới thiệu về lệnh sudo này mà chúng ta vẫn sử dụng hằng ngày nhé :D. 0. Tổng quanLệnh sudo, theo hướng dẫn từ trang man page, nó được sử dụng để thực thi một lệnh như một người dùng khác. Detail: http://manpages.ubuntu.com/manpages/xenial/man8/sudo.8.html 2. sudo visudo?Đây là cách để chúng ta thực hiện các cấu hình với lệnh sudo. Trong file này sẽ cấu hình được các lệnh sử dụng sudo, NOPASSWD hoặc có thể cấu hình thời gian phiên làm việc với lệnh sudo. Chi tiết như thế nào thì mình trình bày chi tiết trong từng phần nhé. 3. What is a sudo session?Một phiên làm việc với lệnh sudo sẽ có thời gian là 15 phút theo mặc định. Bạn có thể tùy chỉnh nó lên bao nhiêu phút là tùy bạn :D1sudo visudoSau đó tìm tới dòng:1Defaults env_resetVà tùy chỉnh thời gian mà bạn muốn:1Defaults env_reset,timestamp_timeout=[new-value][new-value] ở đây là số phút mà bạn muốn cài đặt cho mỗi phiên sử dụng lệnh sudo. Ví dụ nếu bạn muốn cài đặt mỗi phiên sudo là 40 phút.1Defaults env_reset,timestamp_timeout=40Easy nhỉ :D. Nếu bạn muốn mỗi lần sử dụng sudo đều phải nhập mật khẩu, hãy set giá trị này về 0. Trong trường hợp bạn muốn mỗi phiên thời gian sử dụng sudo là vô tận, set giá trị này về -1. Tuy nhiên hãy chú ý khi set về -1 vì nó gây điểm yếu cho hệ thống của bạn. 4. The sudo passwordMỗi khi sử dụng lệnh sudo, bạn phải nhập mật khẩu. Tuy nhiên không có bất cứ gì show mật khẩu cho bạn, nếu bạn thấy điều đó là khó chịu, bạn có thể setup để mỗi lần nhập mật khẩu sẽ show lên. Bạn hãy tìm tới dòng:1Defaults env_resetVà thay thế nó là:1Defaults env_reset,pwfeedbackVà kết quả là: 5. No PasswordĐôi khi việc gõ mật khẩu khi sử dụng sudo gây bất tiện cho bạn (nhưng hãy lưu ý, nó là bảo mật nhé, việc sử dụng No Password này không khuyến khích, chỉ nên sử dụng cho lệnh không quan trọng hoặc trong shell script), một số cách sau sẽ giúp bạn sử dụng sudo mà không cần mật khẩu. Cách 1: Set thời gian session trong file cấu hình.Cách này đã được đề cập ở trên, set thời gian session sử dụng sudo command về -1. Cách này cực kì nguy hiểm vì nó sẽ áp dụng cho mọi scripts sử dụng sudo Một cách khác mà bạn có thể sử dụng là Cách 2 Cách 2: Sử dụng ngoại lệ.Ban có thể tạo một vài ngoại lệ trong file cấu hình sudo command không sử dụng mật khẩu với nội dung như sau1YOUR_USER_NAME ALL=(ALL:ALL) NOPASSWD:/abs/path/to/your/scriptVới YOUR_USER_NAME là username của bạn, có thể xem bằng cách sử dụng lệnh whoami hoặc who /abs/path/to/your/script: đường dẫn sử dụng command của bạn Xem xét ví dụ sau mỗi khi bạn muốn sử dụng1sudo apt-get updatemà không cần nhập mật khẩu. Đầu tiên hãy mở file cấu hình của lệnh sudo lên:1sudo visudoVà thêm dòng1minhnv ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt-get updateOK rồi đó, đơn giản nhể :D. Việc cấu hình như thế này sẽ cho phép bạn chọn được những lệnh nào là “NOPASSWD”. Cách này hiệu quả khi bạn sử dụng sudo trong các shell script. Hãy thử xem xét trường hợp máy bạn cài cả nginx và apache2, và nginx sẽ luôn được khởi động ưu tiên apache2. Bạn cần viết 1 shell script để ưu tiên apache2 hơn (tắt nginx và bật apache2). Vấn đề là 2 lệnh12service stop nginxservice start apache2này lại yêu cầu quyền root, vì vậy bạn cần cấu hình nó trong file /etc/sudoers kia :D12minhnv ALL=(ALL:ALL) NOPASSWD:/usr/bin/service startminhnv ALL=(ALL:ALL) NOPASSWD:/usr/bin/service stopRồi ngon, giờ triển với shell script thôi nào123#!/bin/shsudo service nginx stop &amp;&amp; sudo service apache2 startFinish!!! Tài liệu tham khảo https://www.howtoforge.com/tutorial/sudo-beginners-guide/ Man page Use sudo in scripts","link":"/2020/01/09/Mot-vai-dieu-ve-sudo-command/"},{"title":"[PHP Excel] PHP - Một vài notes khi làm việc với excel,csv file","text":"Tổng hợp lại một số libraries và kinh nghiệm khi làm việc với excel, csv file nào! 1. Some libraries1.1. PhpSpreadsheet Link github: https://github.com/PHPOffice/PhpSpreadsheet PhpSpreadsheet is a library written in pure PHP and providing a set of classes that allow you to read from and to write to different spreadsheet file formats, like Excel and LibreOffice Calc. Library này hỗ trợ file đa dạng Cung cấp khả năng load file mẫu, điền dữ liệu bằng cách fill dữ liệu vào các cell khá đơn giản 1.2. Maatwebsite/excel Link github: https://github.com/Maatwebsite/Laravel-Excel Package chuyên về xử lý file excel và CSV Hỗ trợ import, export dưới dữ liệu collection, array, blade view (hãy nhớ blade view là dưới dạng bảng nhé) Chưa biết các export file từ file template (chắc có đó) Định dạng các cột, hàng theo ý và có thể mở rộng các phương thức dưới dạng marco (không phải script marco trong file excel nhé mà là khả năng mở rộng phương thức): https://docs.laravel-excel.com/3.1/exports/extending.html 2. Download stream file CSV, Excel Nếu bạn làm việc và cần export file CSV với rất nhiều dữ liệu (có thể lớn hơn 100k bản ghi). Hãy xem xét cách tạo stream để download file (không cần package nào nhé :D)1234567891011121314151617181920212223242526272829303132333435&lt;?php use Symfony\\Component\\HttpFoundation\\StreamedResponse; Route::get('export', function(){ $response = new StreamedResponse(function(){ // Open output stream $handle = fopen('php://output', 'w'); // Add CSV headers fputcsv($handle, [ 'id', 'name', 'email' ]); // Get all users foreach (User::all() as $user) { // Add a new row with data fputcsv($handle, [ $user-&gt;id, $user-&gt;name, $user-&gt;email ]); } // Close the output stream fclose($handle); }, 200, [ 'Content-Type' =&gt; 'text/csv', 'Content-Disposition' =&gt; 'attachment; filename=&quot;export.csv&quot;', ]); return $response; });?&gt; Nguồn: https://medium.com/@barryvdh/streaming-large-csv-files-with-laravel-chunked-queries-4158e484a5a2 Note: Có thể kết hợp với chunk để làm việc hiệu quả hơn :D Bạn có thể tham khảo package sau để làm việc với stream này với dạng excel filehttps://github.com/box/spout 3. Download file dưới dạng AJAXĐôi khi để làm cho ứng dụng trở bên trải nghiệm tốt hơn, sẽ hiện loading khi download file. Lúc đó bạn cần sử dụng AJAX để thực hiện download file. Ý tưởng sẽ là như sau: PHP sẽ vẫn trả về dữ liệu file download dưới dạng stream như trên (vẫn set header là file csv như phần 2) Bên Javascript gọi AJAX và sẽ nhận được file này dưới dạng nhị phân. Sau đó nó tạo một đối tượng với tên là Blob, tạo thẻ a để click download file và sau đó xóa nó đi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Download POST Request&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Enter a text and click the button: &lt;input type=&quot;text&quot; id=&quot;content&quot; value=&quot;Text for the generated pdf&quot;&gt;&lt;button id=&quot;download&quot;&gt;Send AJAX Request and download file&lt;/button&gt;&lt;script&gt; document.getElementById('download').addEventListener('click', function () { var content = document.getElementById('content').value; var request = new XMLHttpRequest(); request.open('POST', '../server/', true); request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); request.responseType = 'blob'; request.onload = function() { // Only handle status code 200 if(request.status === 200) { // Try to find out the filename from the content disposition `filename` value var disposition = request.getResponseHeader('content-disposition'); var matches = /&quot;([^&quot;]*)&quot;/.exec(disposition); var filename = (matches != null &amp;&amp; matches[1] ? matches[1] : 'file.pdf'); // The actual download var blob = new Blob([request.response], { type: 'application/pdf' }); var link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); } // some error handling should be done here... }; request.send('content=' + content); });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Trong lúc gọi AJAX đó có thể thêm các ảnh gif loading cho ứng dụng của bạn tốt hơn, và khi download xong, tắt nó đi. Thật tuyệt vời phải không nào :D Nguồn: https://nehalist.io/downloading-files-from-post-requests/ 4. Macro trong file .xlsm Nếu file excel của bạn có kèm macro, hãy load nó và lưu nó dưới dạng .xlsm Marco gán cho 1 ảnh thì sau khi export sẽ không được tự động gán (nguyên nhân chưa rõ). Do đó không nên để macro gán cho 1 ảnh, thay vào đó hãy để ảnh đó là 1 cái button thì sẽ hoạt động @@","link":"/2019/12/29/PHP-Excel-PHP-Mot-vai-notes-khi-lam-viec-voi-excel-csv-file/"},{"title":"PHPCS and PHP-CS-Fixer","text":"Nếu bạn muốn gặp các vấn đề với code convention và loay hoay tìm một công cụ nào đó hiệu quả giúp bạn tự động kiểm tra, auto fix các lỗi đó, thì bạn hãy …… lên Google để tìm kiếm giải pháp. Bài viết sau cũng là một gợi ý =)) PHPCS PHP_CodeSnifferKhông biết giới thiệu tiếng Việt kiểu gì nữa, thôi thì lấy nguyên mẫu tiếng Tây vậy: PHP_CodeSniffer is a set of two PHP scripts; the main phpcs script that tokenizes PHP, JavaScript and CSS files to detect violations of a defined coding standard, and a second phpcbf script to automatically correct coding standard violations. PHP_CodeSniffer is an essential development tool that ensures your code remains clean and consistent. @anyonegithub.com/squizlabs/PHP_CodeSniffer Cài đặtCó rất nhiều cách cài đặt PHPCS, bạn có thể sử dụng 2 cách chính: Download trực tiếp file để chạy1234567891011# Download using curlcurl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcs.pharcurl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar# Or download using wgetwget https://squizlabs.github.io/PHP_CodeSniffer/phpcs.pharwget https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar# Then test the downloaded PHARsphp phpcs.phar -hphp phpcbf.phar -h Cài đặt qua Composer, bạn có thể cài dưới dạng global (system-wide)1composer global require &quot;squizlabs/php_codesniffer=*&quot; Sau đó hãy chắc chắn rằng thư mục bin của composer đã trong PATH của bạn. Giá trị mặc định của thư mục này là ~/.composer/vendor/bin/, nhưng bạn có thể check giá trị bạn cần sử dụng bằng lệnh:1composer global config bin-dir --absolute Đối với bash thì file đó là .bashrc ở thư mục home từ là ~/.bashrc, với zsh là file ~/.zshrc. Mình dùng zsh nên sẽ thêm vào file .zshrc1vi .zshrcThêm dòng này vào nha:1export PATH=~/.composer/vendor/bin/:$PATHSau đó kiểm tra lại bằng echo $PATH ra xem đã có chưa:1.../home/nguyen.van.minhb/.composer/vendor/bin/:.... Sử dụngĐể sử dụng, khá đơn giản, sử dụng lệnh phpcs kết hợp file, thư mục bạn muốn kiểm tra:12345678# Check cú pháp với file$ phpcs /path/to/code/myfile.php# Check cú pháp với thư mục$ phpcs /path/to/code-directory# Check cú pháp với các tùy chọn config$ phpcs --standard=PSR2 /path/to/code-directory ConfigBạn hoàn toàn cấu hình các chuẩn kiểm tra code mà bạn muốn, như sử dụng tab hay space, check các thư muc nào, ignore những file nào, chuẩn nào. Sau khi setting PHPCS, mặc định nó sẽ sử dụng điều kiện PEAR, chuẩn này đã cũ, bạn có thể thay đổi điều này bằng cách sử dụng các standard của công ty Framgia hoặc PRS21234phpcs --config-set default_standard PSR2 // Kiểm tra việc setting configphpcs --config-showCách thay đổi config như vậy KHÔNG KHUYẾN KHÍCH, thay vào đó bạn nên setup phpcs cho từng project của bạn, sử dụng các file .phpcs.xml, phpcs.xml, .phpcs.xml.dist, phpcs.xml.dist. Cài đặt Framgia PHP StandardsCác tiêu chuẩn check code của PHPCS được đặt trong thư mục ~/.composer/vendor/squizlabs/php_codesniffer/src/Standards. Vì vậy nếu bạn muốn thêm 1 tiêu chuẩn check code, bạn chỉ cần clone nó vào thư mục này:1234567// Version 2cd ~/.composer/vendor/squizlabs/php_codesniffer/CodeSniffer/Standardsgit clone -b 0.2 git@github.com:wataridori/framgia-php-codesniffer.git Framgia// Version 3cd ~/.composer/vendor/squizlabs/php_codesniffer/src/Standardsgit clone git@github.com:wataridori/framgia-php-codesniffer.git FramgiaSử dụng:1phpcs --standard=Framgia /path/to/your/codeKhá đơn giản nhỉ :D Tích hợp PHPCS vào Sublime text 3Công việc tiếp theo là bạn nên tích hợp việc check cú pháp này trực tiếp vào các editor để tự động phát hiện lỗi, thay vì cột 1 mạch và lại chạy lệnh phpcs =)) Bạn cần cài 2 package trong Subime Text để được hỗ trợ việc này Sublime Linter (package cha) SublimeLinter-phpcs (package con, các phần nhỏ của Linter) Khởi động lại Sublime Text luôn để tận hưởng chức năng siêu mới này nhé :v (khởi động bằng lệnh mới được ý @@)12cd project_pathsubl . Tích hợp PHPCS vào PHPStormĐể tích hợp check phpcs và các tiêu chuẩn vào PHPStorm, bạn cài đặt theo đường dẫn. FIle =&gt; Setting =&gt; Editor =&gt; Inspections =&gt; PHP =&gt; PHP Code sniffer validation (Có thể ở trong Quality tools) Sau đó bạn lựa chọn các cài đặt, hiển thị lỗi ở mức warning hay error và chọn Coding standard PHPCS FixerĐây là một công cụ giúp bạn fix code theo các tiêu chuẩn bạn muốn Cài đặtLocallySiêu đơn giản, tải cái file php-cs-fixer.phar về rồi chạy luôn :D Globally (manual)Đầu tiên bạn tải nó về1$ wget https://cs.symfony.com/download/php-cs-fixer-v2.phar -O php-cs-fixerVẫn là tải nhưng xác định thêm version1$ wget https://github.com/FriendsOfPHP/PHP-CS-Fixer/releases/download/v2.16.1/php-cs-fixer.phar -O php-cs-fixerCũng là tải nhưng dùng lệnh khác12$ curl -L https://cs.symfony.com/download/php-cs-fixer-v2.phar -o php-cs-fixerThen:12$ sudo chmod a+x php-cs-fixer$ sudo mv php-cs-fixer /usr/local/bin/php-cs-fixerEnd, xong rồi đó, test thôi php-cs-fixer --version Globally (Composer)Đầu tiên bạn cũng tải nó dưới dạng global1$ composer global require friendsofphp/php-cs-fixerThêm vào PATH như phpcs1$ export PATH=&quot;$PATH:$HOME/.composer/vendor/bin&quot;Xong! Sử dụngKhông khác phpcs là mấy :v123$ php php-cs-fixer.phar fix /path/to/dir$ php php-cs-fixer.phar fix /path/to/file$ php php-cs-fixer.phar fix /path/to/project --rules=@PSR2 Tích hợp vào Sublime Text 3 Package: PHP CS Fixer Sử dụngSau khi đã cài thành công rồi, mỗi lần file bạn bị lỗi, bạn sử dụng như sau:Ctrl + Shift + P và Tìm kiếm PHP CS Fixer. Thậm chí bạn có thể nhìn thấy tổ hợp phím tắt của nó không, ấn luôn nếu bạn đang ở file lỗi đó cho ngầu như quả bầu :D (trường hợp này là Ctrl + Alt + F) OK, cool ngầu nào Tích hợp cho PHP StormCái này mình chưa thử, bạn có thể tham khảo tại link sauhttps://www.jetbrains.com/help/phpstorm/using-php-cs-fixer.html Tổng kết Lưu ý: Phần tích hợp phpcs và php-cs-fixer chỉ có thể cài và hoạt động trên các editor nếu như máy của bạn đã cài phpcs, php-cs-fixer ở dạng global (vì bản chất tích hợp vào editor cũng là chạy các lệnh thủ công thôi) Trong quá trình cài, nếu có lỗi, hãy đọc console của Sublime text 3 để fix nhé PHPCS và PHP-CS-Fixer cho ta biết rằng các ngôn ngữ khác hoàn toàn cũng có các coding standards và cũng có auto fix tương tự, khi code với ngôn ngữ nào, bạn tìm kiếm thử xem nhé :D (JS có Prettier thì phải :3)","link":"/2020/04/06/PHPCS-and-PHPC-Fixer/"},{"title":"PHPCS configuration","text":"File PHPCS config mẫuThư mục config phpcs nằm ở thư mục root dự án, tên là .phpcs.xml, phpcs.xml, .phpcs.xml.dist, phpcs.xml.dist Note: If multiple default configuration files are found, PHP_CodeSniffer will select one using the following order: .phpcs.xml, phpcs.xml, .phpcs.xml.dist, phpcs.xml.dist File mẫu: https://raw.githubusercontent.com/squizlabs/PHP_CodeSniffer/master/phpcs.xml.dist 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot;?&gt;&lt;ruleset name=&quot;Framgia Extended&quot;&gt; &lt;!-- Bước 1: Mô tả convention --&gt; &lt;description&gt;Framgia Extended Coding Convention&lt;/description&gt; &lt;!-- Bước 2: Set các thông tin thêm cho convention thôi --&gt; &lt;arg name=&quot;tab-width&quot; value=&quot;4&quot;/&gt; &lt;arg name=&quot;encoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;config name=&quot;ignore_warnings_on_exit&quot; value=&quot;1&quot;/&gt; &lt;!-- Bước 3: &lt;file&gt; Danh sách các file check convention Ex: Check both app/ and config/ and resources/lang --&gt; &lt;file&gt;./app&lt;/file&gt; &lt;file&gt;./config&lt;/file&gt; &lt;file&gt;./resources/lang&lt;/file&gt; &lt;!-- Bước 4: (tùy chọn, có thể có hoặc không) &lt;exclude-pattern&gt;: Loại bỏ các định dạng file không chạy PHPCS --&gt; &lt;exclude-pattern&gt;*/src/Standards/*/Tests/*\\.(inc|css|js)$&lt;/exclude-pattern&gt; &lt;exclude-pattern&gt;*/tests/Core/*/*Test\\.(inc|css|js)$&lt;/exclude-pattern&gt; &lt;!-- Bước 5: Dùng rule nào để kiểm tra convention, nó sẽ có các chuẩn PEAR, PSR1, PSR2, Framgia --&gt; &lt;rule ref=&quot;Framgia&quot;/&gt; &lt;!-- Bước 6: Tùy chọn, có thể có hoặc không? Đoạn sau này sẽ là custom lại các biến nhé. Ví dụ tag là 4 space, mình không thích và muốn chuyển về 2 chẳng hạn Chi tiết các tham số trong property https://github.com/squizlabs/PHP_CodeSniffer/wiki/Customisable-Sniff-Properties#psr12operatorsoperatorspacing --&gt; &lt;rule ref=&quot;Squiz.WhiteSpace.SuperfluousWhitespace&quot;&gt; &lt;properties&gt; &lt;!-- Force checking whitespace on blank lines --&gt; &lt;property name=&quot;ignoreBlankLines&quot; value=&quot;false&quot; /&gt; &lt;/properties&gt; &lt;/rule&gt; &lt;!-- Check space between operator +-*/ --&gt; &lt;rule ref=&quot;Squiz.WhiteSpace.OperatorSpacing&quot;&gt; &lt;properties&gt; &lt;property name=&quot;ignoreNewlines&quot; value=&quot;true&quot; /&gt; &lt;/properties&gt; &lt;/rule&gt; &lt;!-- Line between class method --&gt; &lt;!-- Đoạn code sau có ý nghĩa là: với rule FunctionSpacing, thì `space` là 1, không có `space` nào sau và trước hàm (giá trị mặc định là bao nhiêu méo biết) --&gt; &lt;rule ref=&quot;Squiz.WhiteSpace.FunctionSpacing&quot;&gt; &lt;properties&gt; &lt;property name=&quot;spacing&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;spacingAfterLast&quot; value=&quot;0&quot; /&gt; &lt;property name=&quot;spacingBeforeFirst&quot; value=&quot;0&quot; /&gt; &lt;/properties&gt; &lt;/rule&gt; &lt;!-- Space after type cast, e.g. (string) $response --&gt; &lt;rule ref=&quot;Generic.Formatting.SpaceAfterCast&quot; /&gt;&lt;/ruleset&gt; Hãy hiểu property là thay đổi các biến mặc định trong rule đó, nếu bạn muốn chỉnh sửa. Ví dụ trường hợp gần cuối, spacing mặc định có thể đang là 2, mình custom lại 1 :D Ngoài ra trong từng rule bạn cũng có thể tuỳ chỉnh check những file nào123&lt;rule ref=&quot;Generic.PHP.CharacterBeforePHPOpeningTag&quot;&gt; &lt;exclude-pattern&gt;*.phtml&lt;/exclude-pattern&gt;&lt;/rule&gt;Hoặc có thể comment disable một fule trong chính file PHP1234567&lt;?php/** * File description * * @tags * @phpcs:disable Standard.Cat.SniffName */Hoặc comment theo hàm1234// phpcs:disable Generic.Metrics.CyclomaticComplexityprotected function a(){}Ref: https://github.com/squizlabs/PHP_CodeSniffer/issues/1179#issuecomment-446988725 Docs https://github.com/squizlabs/PHP_CodeSniffer/wiki/Customisable-Sniff-Properties (đọc chỗ Pages (13) ấy, chắc có nhiều thứ bạn cần). Ngoài ra nó còn có hướng dẫn kiểm tra PHPCS trước mỗi lần commit với Git (PreCommit Githooks). Hãy xem xét nếu dự án của bạn cần nhé:https://medium.com/@setkyarwalar/setting-up-phpcs-on-laravel-908bccb82db","link":"/2020/01/10/PHPCS-configuration/"},{"title":"Part 1: Surface-Level Improvements","text":"Chúng ta sẽ nói đến vấn đề đầu tiên là cải thiện surface: chọn một cái tên tốt, viết comment tốt và format code gọn gàng. Cách thay đổi này dễ áp dụng. Bạn có thể làm nó “in place” (tại chỗ) mà không phải cấu trúc lại code hoặc thay đổi cách chương trình chạy. Nó cũng có thể cải thiện nó rất nhanh mà không cần mất nhiều thời gian :D Chủ đề này là rất quan trọng vì chúng ảnh hưởng tới mỗi dòng code trong codebase của bạn. Mặc dù mỗi thay đổi dường như là nhỏ, tổng hợp lại, chúng sẽ tạo ra một sự cải thiện lớn vào codebase. Nếu code của bạn có 1 cái tên tốt, well-written comments và xóa được các khoảng trắng, code của bạn sẽ rất dễ để đọc. Tất nhiên, có rất nhiều thứ hơn nữa ở dưới surface level ảnh hưởng đến khả năng đọc (và chúng tôi sẽ khám phá nó trong phần sau của cuốn sách). Nhưng những tài liệu trong phần này được áp dụng rộng rãi, không tốn nhiều công, đó là thứ đâu tiên chúng tôi muốn khám phá. Mục lục của chương bao gồm các chủ đề: Chapter 2: Packing Information into NamesChapter 3: Names That Can’t Be MisconstruedChapter 4: AestheticsChapter 5: Knowing What to CommentChapter 6: Making Comments Precise and Compact","link":"/2020/05/24/Part-1-Surface-Level-Improvements/"},{"title":"Part 3: Reorganizing Your Code","text":"Trong phần 2, chúng ta đã thảo luận làm sao để thay đổi “vòng lặp và logic” trong chương trình của bạn để làm code có thể đọc. Chúng ta mô tả 1 vài kỹ thuật yêu cầu thay đổi cấu trúc của chương trình theo những cách nhỏ. Trong phần này, chúng ta sẽ bàn luận về những thay đổi lớn hay bạn có thể làm với code ở mức function. Cụ thể, chúng ta sẽ khám phá các cách tổ chức lại code của bạn: Trích xuất “các vấn đề con không liên quan” cái mà không liên quan đến mục đích chính trong chương trình của bạn. Sắp xếp lại code của bạn để nó chỉ làm 1 task 1 lúc Mô tả code của bạn bằng từ trước và sử dụng mô tả này để giúp bạn có hướng xử lý rõ ràng Cuối cùng, chúng ta sẽ thảo luận cách giải quyết bạn có thể xóa hoàn toàn code và tránh viết nó trong lần đầu tiên - cách tốt nhất để làm cho code dễ hiểu. Chapter 10: Extracting Unrelated SubproblemsChapter 11: One Task at a TimeChapter 12: Turning Thoughts into CodeChapter 13: Writing Less Code","link":"/2020/05/24/Part-3-Reorganizing-Your-Code/"},{"title":"Part IV: Selected Topics","text":"Trong 3 phần trước, chúng ta đã thảo luận về các phần rộng về các kĩ thuật làm cho code dễ hiểu. Trong phần này, chúng ta sẽ áp dụng các kĩ thuật đó vào 1 chủ đề được chọn. Đầu tiên, chúng ta sẽ thảo luận về testing - làm sao viết test hiệu quả và có thể đọc được cùng 1 lúc Sau đó chúng ta sẽ đi quan việc thiết kế và thực thi của cấu trúc dữ liệu mục đích đặc biệt (a “minute/hour counter”) để xem 1 ví dụ về hiệu năng, thiết kế tốt và tương tác với khả năng đọc code. Chapter 14: Testing and ReadabilityChapter 15: Designing and Implementing a “Minute/Hour Counter”","link":"/2020/05/24/Part-5-Selected-Topics/"},{"title":"Part II: Simplifying Loops and Logic","text":"Part II: Simplifying Loops and Logic Trong chương 1, chúng ta đã khám phá cải thiện về mặt bề mặt (nhìn bằng mắt) - surface level - cách đơn giản để cải thiện code của bạn có thể dễ đọc hơn mà không có quá nhiều rủi ro hay nỗ lực. Trong chương tiếp theo, chúng ta sẽ xem xét sâu hơn, thảo luận về “vòng lặp và logic” trong code của bạn: kiểm soát luồng, biểu thức logic và biến để làm code của bạn hoạt động. Như mọi khi, mục đích của chúng ta là làm cho các phần này trong code của chúng ta dễ hiểu hơn. Chúng ta sẽ làm điều này bằng cách cố gắng tối thiểu “mental baggage” (hành vi về tinh thần) trong code của bạn. Mỗi khi bạn nhìn thấy 1 vòng lapwj phức tạp, 1 biểu thức khổng lồ hoặc 1 số lượng lớn các biến, điều này thêm vào hành lý tinh thần trong đầu của bạn. (kiểu sợ luôn rồi ý =))). Nó yêu cầu bạn nghĩ nhiều hơn và nhớ nhiều hơn. Điều này thì hoàn toàn ngược lại “dễ dàng để hiểu”. Khi code của bạn có quá nhiều hành vi ảnh hưởng tinh thần, bug có nhiều khả năng không được tìm ra, code trở nên khó có thể thay đổi và chúng ta sẽ không mấy vui vẻ khi làm việc cùng nó. Chapter 7: Making Control Flow Easy to ReadChapter 8: Breaking Down Giant ExpressionsChapter 9: Variables and Readability","link":"/2020/05/24/Part-II-Simplifying-Loops-and-Logic/"},{"title":"React boilerplate data flow","text":"React boilerplate là một ứng dụng React đã được cài đặt tích hợp sẵn redux-saga, thuận tiện cho việc phát triển. Chúng ta cùng xem xét luồng dữ liệu, cách tạo component, container trong ứng dụng này nhé :D Tạo containerKhi muốn tạo 1 component mới để thực hiện chức năng, bạn có thể thực hiện bằng cách dùng lệnh 1npm run generate container (Nó sẽ tạo đủ các thư mục redux, saga, constant, selector, action và kết nối saga cho bạn). Đăng ký Component này trong router để hoạt động nào 12345678910/* containers/App/index.js */...&lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={HomePage} /&gt; &lt;Route path=&quot;/features&quot; component={FeaturePage} /&gt; &lt;Route path=&quot;/jest&quot; component={JestExample} /&gt;&lt;Route path=&quot;&quot; component={NotFoundPage} /&gt;&lt;/Switch&gt;// Đặt trước not found nhé PropsKhi xử lý các sự kiện (như click button, bắt sự kiện thay đổi 1 field nào đó) để bắn ra các action tới saga, reducer, bạn cần sử dụng nó như các props để dispatch được sự kiện (trong ví dụ là click button) Đăng kí nó vào đầu vào component 1234export function JestExample({ user, onClickButton }) { ... &lt;button onClick={onClickButton}&gt; Click me &lt;/button&gt;} và đăng ký mapDispatchToProps để dispatch sự kiện 12345678function mapDispatchToProps(dispatch) { return { dispatch, onClickButton: evt =&gt; { dispatch(loadUser()); }, };} Chỗ này bạn có thể tùy chọn bắn action có qua saga hay không (saga là middleware, nếu cần call API hay làm 1 việc gì đó như truyền thêm dữ liệu thì hãy dùng saga) nếu không có thể truyền thẳng tới reducer. Quyết định có qua saga hay không chính là do type của action loadUser bạn truyền vào (có type đã được đăng ký ở saga hay không?)Action có dạng 12345export function loadUser() { return { type: 'LOAD_USER_SAGA', // type không đăng ký trong saga thì chuyển tới reducer };} Xử lý saga (tùy chọn)Nếu action của bạn có chuyển qua saga, chúng ta sẽ mở file saga để xử lý.Bạn cần đăng ký saga và call API, sau đó truyền action mới tới reducer thôi, khá đơn giản: 1234567891011121314151617181920212223242526272829303132333435363738394041import { call, put, select, takeLatest } from 'redux-saga/effects';import { LOAD_REPOS } from 'containers/App/constants';import { loadedUser } from 'containers/JestExample/actions';import request from 'utils/request';import { makeSelectUsername } from 'containers/HomePage/selectors';/** * Github repos request/response handler */export function* loadUser() { const requestURL = `https://jsonplaceholder.typicode.com/todos/1`; try { // Call our request helper (see 'utils/request') /* Step 1: Call API to get data */ const user = yield call(request, requestURL); console.log('Hello Saga'); /* Step 2: Put received data to reducer with put method Note: action the same the action in saga (include type and data) */ yield put(loadedUser(user)); } catch (err) { console.log(err); // yield put(repoLoadingError(err)); console.log(1); }}/** * Root saga manages watcher lifecycle */export default function* loadUserFromFakeAPI() { // Watches for LOAD_REPOS actions and calls getRepos when one comes in. // By using `takeLatest` only the result of the latest API call is applied. // It returns task descriptor (just like fork) so we can continue execution // It will be cancelled automatically on component unmount yield takeLatest('LOAD_USER_SAGA', loadUser);} ReducerSau khi bên view phát action, reducer sẽ đón nhận và xử lý. Trong reducer sẽ có initState: state mặc định trong store Hàm xử lý action: initState ======&gt; (dữ liệu từ người dùng truyền xuống hoặc lấy được từ saga) ====&gt; newState trả ngược về view Render state mới ra viewSau khi đã có state mới trả về từ reducer. công việc cuối cùng là render state mới ra view. Ta sẽ ánh xạ state này thành props của Component để hiển thị. Nó sẽ được thực hiện qua hàm mapStateToProps trong Component. Chúng ta sẽ sử dụng selector để thực hiện việc ánh xạ này: 1234567891011121314151617181920import { createSelector } from 'reselect';import { initialState } from './reducer';/** * Direct selector to the jestExample state domain */const selectJestExampleDomain = state =&gt; state.jestExample || initialState;/** * Other specific selectors */const makeSelectUser = () =&gt; createSelector( selectJestExampleDomain, jestState =&gt; jestState.user, );export default makeSelectJestExample;export { makeSelectUser }; File index.js 1234const mapStateToProps = createStructuredSelector({ jestExample: makeSelectJestExample(), user: makeSelectUser(),}); OK thế là state user được chuyển thành props với tên user trong Component rồi đó. Tóm lại luồng dữ liệu sẽ như sauView: dispatch action (dưới dạng props và được đăng kí trong mapDispatchToProps) ======&gt; Saga (tùy chọn): nhận action từ view, call API và bắn 1 action mới tới reducer qua phương thức put ====&gt; Reducer: xử lý với mỗi action và dữ liệu qua switch/case, trả về new State từ initState ======&gt; View: nhận newState, map nó thành props và render ra view (mapStateToProps) Action sẽ có dạng 12345678{ type: 'ABC', // data user: { name: 'MinhNV', age: '100', }}","link":"/2019/09/08/React-boilerplate-data-flow/"},{"title":"[Regex] Regex Cheatsheet and Practice","text":"Một vài note cho regex trong những ngày cuối năm 2019 nào!!!! 1. CheatsheetNguồn: https://devhints.io/regexp. Và Nguồn: http://regextutorials.com/intro.html?Basic%20symbols 2. Một vài note cho regexRegex là công cụ mạnh mẽ chuyên xử lý chuỗi. Nó có thể: Kiểm tra, validate dữ liệu: kiểm tra một câu có chứa hoặc không chứa một từ, cụm từ nào không, có đúng theo 1 biểu thức chính quy nữa không? Thay thế: thay thế chuỗi này bằng một chuỗi mới. Cái này khá hay và mạnh :D Lấy giá trị: lấy giá trị các chuỗi sau một biểu thức chính quy 2.1. Symbol repetitionĐúng như tên gọi của nó, các ký tự này đại diện cho các kí tự sau đó. Còn đại diện cho 1 hay 0, hay nhiều kí tự thì phụ thuộc vào bạn dùng kí tự nào nhé :D. Các ký tự lặp lại như thế này gây ra khó hiểu cho tôi hồi mới đọc. Trong ví dụ giải thích sẽ nói về \\*. Trùng 0 hoặc nhiều ở đây sẽ hiểu là trùng với kí tự trước nó. Ta xét ví dụ \\d\\d*: \\d: kí tự đầu tiên là số \\d* kí tự sau sẽ có 2 khả năng: Match 0: không có gì cả Match more: có và với điều kiện tất cả phải là số (more mà) Do đó \\d\\d* là số với độ dài bất kỳ. Vậy nó khác gì với \\d* Match 0: không có gì, kí tự trống. Thực tế là các kí tự đỏ đỏ ngăn cách mỗi ký tự (kí tự đỏ đỏ ở đây nhé :v https://regex101.com/) Match more: rõ ràng trước hợp trên không có thì sử dụng trường hợp này rồi. Nó cũng là số với độ dài bất kì. Như vậy cả \\d* và\\d\\d* đều là số có độ dài bất kì, \\d* bắt cả kí tự rỗng và không nên sử dụng. Theo tôi khi sử dụng các kí tự lặp lại có thể match 0 (\\* và ?), không nên để kí tự trước nó đứngđộc lập 1 ký tự khác để tránh việc lấy phần match 0 (các kí tự không có gì). \\d*, \\d? =&gt; không nên vì nó lấy cả ký tự rỗng \\d*minh, s?he =&gt; OK 2.2. Line and word breaks and spaces ^: bắt đầu 1 dòng $: kết thúc 1 dòng \\b: đại diện cả bắt đầu và kết thúc 1 từ luôn In regular expressions, there are symbols that do not correspond to a character, but to a position. ^ and $ stand for start and end of line. While \\b means a word boundary. Try using ^\\w+ and \\w+$ to match the first and last word in each line. \\b\\w and \\w\\b will match first and last letter in word. Finally, use \\s to match any space symbols whatsoever. Cái này dùng để xác định phạm vi bạn muốn sử dụng regex. Bạn muốn check cả câu thỏa mãn điều kiện hay tìm từng chuỗi một thỏa mãn. Vậy ^[^abc]+$ và [^abc]+ khác nhau cái gì vậy? ^[^abc]+$: kiểm tra cả câu không chứa a,b,c? =&gt; trả về cả câu nếu phù hợp [^abc]+: kiểm tra các ký tự trong câu, trả về các kí tự không chứa abc 2.3. Grouping matches and replacingCái này cũng là cái khá hay trong regex. Bạn có thể nhóm các phần trùng với nhau bằng cách đặt chúng trong dấu (). Sau đó bạn có thể tham chiếu đến các nhóm này bằng cách sử dụng \\1,\\2, etc. Ví dụ (\\w)\\1 trùng với 1 vài kí tự được lặp lại 2 lần (\\1 lặp lại của \\w vì được nhóm vào trong nhóm 1 mà) Điểm quan trọng nhất là bạn có thể nhóm cho sự thay thế, tham chiếu chúng bởi số: $2, $1 … trong việc thay thế các biểu thức. Hãy thử thay thế format tên như dưới đây từ John Smith thành Smith,John bằng cách thay thế (\\w+)\\s(\\w+) bằng $2,$1. Thật tuyệt. Nếu bạn muốn sử dụng dấu ngoặc đơn nhưng không tính là nhóm lại, sử dụng (?:expression) 2.4. Lookaheads(?=) được gọi là lookaheads. abc(?=d) sẽ trùng abc chỉ nếu nó được theo sau bởi d (hiểu là kí tự ngay sau đó là d). Chú ý là d sẽ không trong giá trị trùng (giá trị thỏa mãn chỉ là abc, không phải abcd). Thử sử dụng\\w+(?=\\.) để trùng với các từ cuối cùng trong 1 câu. abc(?!d) sẽ trùng với abc KHÔNG theo sau là d. Thử sử dụng \\w+(?!\\.)\\b để trùng với tất cả các từ không phải là kí tự cuối cùng của 1 câu (kết thúc bằng dấu chấm). Negative lookahead có thể check được cả chuỗi KHÔNG chứa chuỗi con nào đó :D. Ví dụ: use negative lookahead ‘?!’ to check that there is no word ‘chocolate’ ahead at every position between the start and end of line. Hãy nhớ rằng các lookaheads cũng không nên đứng độc lập vì “Chú ý là d sẽ không trong giá trị trùng (giá trị thỏa mãn chỉ là abc, không phải abcd)”, nếu đứng độc lập nó bắt cả kí tự rỗng như match 0 đó. Do vậy bạn muốn bắt 1 kí tự không chứa abc thì không thể viết (?!abc)+ vì bản thân (?!abc) không đại diện kí tự gì. Nó cần phải có kí tự trước hoặc sau đi kèm như .(?!abc) hay (?!abc). và 2 cú pháp nay thực chất chỉ đại diện cho 1 kí tự (vì nhắc lần 2, hãy nhớ rằng giá trị lookahead không trong giá trị trùng) 3. Regex excercises3.2. Bài toán lấy các năm trước 1990Ý tưởng: kí tự đầu tiên là 1, kí tự tiếp theo từ 0-8, kí tự tiếp theo có 2 khả năng: nếu là 9 thì kí tự thứ 4 là 0, nếu là 0-8 thì kí tự tiếp theo là từ 0-9 =&gt; Biểu thức regex: .*(1[0-9]([0-8][0-9]|90)\\)). Có thể rút gon [0-9]=&gt;\\d. ta có biểu thức.*(1\\d([0-8]\\d|90))\\) 3.4. Grayscale colorsBài toán sử dụng regex với sự thay thế. Bài toán tìm các màu red, green and blue, các màu mà có mã lặp lại (12 hoặc 24 bit) Ý tưởng: Dùng \\1,\\2 để dùng cho các kí tự lặp lại, nhóm với nhau bằng dấu () Do 2 trường hợp 12 hoặc 24 bit nên dùng {1,2} cho bài toán này The solution is: #([0-9a-fA-F]{1,2})\\1\\1 3.6. Remove repeating wordsMột bài toán nữa sử dụng regex cho sự thay thế chuỗi hiệu quả. Bài toán sẽ là lọc các từ lặp lại trong câu sau: It was a chilly November afternoon. I had just just consummated an unusually hearty dinner, of which the dyspeptic truffe formed not the least important item, and was sitting alone in the dining-room dining-room, with my feet upon the the fender, and at my elbow a small table which I had rolled up to the fire, and upon which were some apologies for dessert, with some miscellaneous bottles bottles of wine, spirit and liqueur. In the morning I had had been reading Glover’s “Leonidas”, Wilkie’s Wilkie’s “Epigoniad”, Lamartine’s “Pilgrimage”, Barlow’s “Columbiad”, Tuckermann’s “Sicily”, and Griswold’s “Curiosities” ; I am willing to confess, therefore, that I now felt a little stupid. Ý tưởng: Đầu tiên ta phải xem có các từ nào lặp lại không. Sử dụng \\1 để tìm các từ lặp, kết hợp \\b để là bắt đầu và kết thúc của 1 từ. =&gt; Văn phong khi tìm từ lặp sẽ là: bắt đầu 1 từ, từ bất kì, dấu cách, từ tiếp theo có phải từ đó không, kết thúc 1 từ. =&gt; Biểu thức regex:\\b(.+)\\s(\\1)\\bThay thế thì easy quá, thay thế $1 là được :D 3.9. Digit commas formattingBài toán format dân số các quốc gia1234567891011Ten Countries with the Highest Population:1 China 13612200002 India 1236800000 3 United States 317121000 4 Indonesia 2376413265 Brazil 201032714 6 Pakistan 184872000 7 Nigeria 173615000 8 Bangladesh 152518015 9 Russia 143600000 10 Japan 127290000Về dạng1234567891011Ten Countries with the Highest Population:1 China 1,361,220,0002 India 1,236,800,000 3 United States 317,121,000 4 Indonesia 237,641,3265 Brazil 201,032,714 6 Pakistan 184,872,000 7 Nigeria 173,615,000 8 Bangladesh 152,518,015 9 Russia 143,600,000 10 Japan 127,290,000Ý tưởng: Chúng ta sẽ lấy ra những số mà theo sau nó là 3,6,9… chữ số và kí tự kết thúc là kết thúc từ (kiểu tính từ cuối từ lên)=&gt; sử dụng lookahead Thay thế nó bởi nó và dấu , là được :DKết quả:Replace: \\d(?=(\\d{3})+\\b) with $1, 3.13. Validate AM/PM time formatValid and invalid time: 00:15 AM 7:40 AM 8:51 AM 8:61 AM 09:59 1:00 PM 2:00 PM 19:34 PM Ý tưởng: cái khó ở đây là viết kí tự đại diện cho giờ. Giờ có thể là 1 số hoặc 2 số, nhỏ hơn 12. Ta có thể dùng ? để làm việc nàyThe solution is:\\b(0?\\d|1[0-2]):[0-5]\\d (AM|PM) 3.17. Validate 32 or 24 bit hexadecimal colors White: #ffffff, #ffffffff Black:#000000 #000000ff Semitrnasparent green: #00ff0088 Nonhexadecimal: #00ffhh #agaeffe0 Wrong bytes count:#00ff00f #fffff #888888fff Để sử dụng độ dài chính xác của 1 chuỗi, sử dụng {n} The solution is: #(([0-9a-f]{6})|([0-9a-f]{8}))\\b 3.21. Strings not containing wordTìm kiếm tất cả các công thức không chứa từ ‘chocolate’ Cake 1: sugar, flour, cocoa powder, baking powder, baking soda, salt, eggs, milk, vegetable oil, vanilla extract, chocolate chips Cake 2: cream cheese, sugar, vanilla extract, crescent rolls, cinnamon, butter, honey Cake 3: dark chocolate cake mix, instant chocolate pudding mix, sour cream, eggs, vegetable oil, coffee liqueur Cake 4: flour, baking powder, salt, cinnamon, butter, sugar, egg, vanilla extract, milk, chopped walnuts Cake 5: gingersnap cookies, chopped pecans, butter, cream cheese, sugar, vanilla extract, eggs, canned pumpkin, cinnamon Cake 6: flour, baking soda, sea salt, butter, white sugar, brown sugar, eggs, vanilla extract, chocolate chips, canola oil Cake 7: wafers, cream cheese, sugar, eggs, vanilla extract, cherry pie filling Ý tưởng: Sử dụng lookahead (?!) để kiểm tra thôi Vì nó là kiểm tra câu, phải sử dụng ^ và $ The solution is: ^(.(?!chocolate))*$ Tổng kết Nếu kiểm tra cả một câu, một từ có phù hợp regex, sử dụng ^ và $ hoặc \\b, toàn nếu chỉ muốn lấy chuỗi thỏa mãn regex thì không cần. Các kí tự lặp lại (Symbol repetition) đại diện cho các kí tự tiếp theo, số lượng các kí tự tiếp theo là bao nhiêu thì phụ thuộc bạn dùng kí tự nào. *,\\?,+ hay {} bản chất như nhau hết (ví dụ như * tương đương x{0,}) Lookaheads (?=minh), (?!minh) khá hay, nó cho phép bạn check được cả sau 1 từ có chuỗi hay không có chuỗi con nào đó. Nhìn nguy hiểm vậy thôi chứ a(?!abcdef) cũng chỉ đại diện cho 1 kí tự, nó khác với regex a ở chỗ check thêm sau a không được chứa chuỗi abcdef Match 0 hay lookaheads không nên đứng độc lập(\\d*, (?!abc)\\*) vì nó bắt cả kí tự rỗng (đỏ đỏ :v)) nó cần kết hợp thêm các kí tự khác để bắt chuẩn hơn (\\d\\d* hay minh(?!abc)*) \\1, \\2 và $1, $2, (?:expression) bạn có thể nhắc lại chúng?? Bạn có thể định nghĩa regex qua 2 cách: các kí tự được phép sử dụng [abc] hoặc các kí tự không được phép sử dụng [^abc], tùy từng trường hợp mà sử dụng cho phù hợp nhé. Tài liệu tham khảo: https://regex101.com/ http://regextutorials.com/intro.html?Basic%20symbols https://devhints.io/regexp","link":"/2019/12/29/Regex-Regex-Cheatsheet-and-Practice/"},{"title":"[SQL] Note 1: GROUP BY, create-update multiple records, Config MySQL","text":"Note lại 1 vài tips khi làm việc với MySQL nào!! 1. GROUP BY….Chắc hẳn khi làm việc với MySQL, chúng ta gặp rất nhiều GROUP BY và đôi khi gặp lỗi với nó. Câu lệnh này nhóm các cột giống giá trị với nhau vào trong cột chung, tóm gọn lại, như “tìm kiếm số lượng khách hàng cho mỗi đất nước” Lệnh này cũng hay được sử dụng với các phép toán gộp lại như COUNT, MAX, MIN, SUM, AVG để nhóm kết quả của tập kết quả khi group thành 1 hoặc nhiều cột 1.1. Cú phápCú pháp chung của cú pháp này được w3schools giới thiệu như sau:12345SELECT column_name(s)FROM table_nameWHERE conditionGROUP BY column_name(s)ORDER BY column_name(s);Như cú pháp chung ở trên chúng ta có thể thấy những cột được group thì mới có thể SELECT. Điều này cũng dễ hiểu, ví dụ như bạn thực hiện lấy ra tên của khách hàng đó trong 1 nhóm khách hàng của mỗi quốc gia, tên họ khác nhau, câu hỏi đặt ra là chúng ta lấy tên của ai? 1.2. ONLY_FULL_GROUP_BY modeTheo trang chủ mysql, chế độ này từ chối các truy vấn cái mà có danh sách select, điều kiện HAVING hoặc ORDER BY có các cột kết hợp từ nhóm (nonaggregated columns) không trong GROUP BY hoặc không trong các hàm (để xác định duy nhất giá trị) bởi GROUP BY. Vì lúc đó, bạn lấy tên khách hàng nhưng nó sẽ không biết lấy theo tên nào trong cùng 1 group vì nó quá nhiều tên khác nhau. Điều đó có nghĩa khi bạn truy vấn như sau sẽ bị báo lỗi:12Error Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'posts.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_byChế độ này được mặc định bật kể từ MySQL 5.7, giúp truy vấn của bạn chính xác hơn, và tốt hơn hết bạn cũng nên bật nó nếu chưa bật. Túm cái váy lại, cú pháp chuẩn của GROUP BY là khi SELECT, ORDER BY, HAVING thì các cột cần được trong GROUP BY hoặc các hàm để xác định cột duy nhất, do vậy chúng ta nên tuân theo.123456789/* Select, having, order by các cột trong GROUP BY cần phải thỏa mãn 1 trong 2 điều kiện- Các cột được GROUP BY- Các cột trong các hàm &quot;gộp dữ liệu&quot; thành 1 dữ liệu duy nhất: COUNT, MAX, MIN, SUM, AVG*/SELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryORDER BY COUNT(CustomerID) DESC; 2. CREATE OR UPDATE 1 bản ghiNếu bạn muốn tạo 1 bản ghi khi khóa chưa tồn tại hoặc cập nhật nó nếu khóa đã tồn tại, bạn có thể sử dụng1INSERT ... ON DUPLICATE KEY UPDATE StatementRef: https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html https://www.mysqltutorial.org/mysql-insert-or-update-on-duplicate-key-update/ Ví dụ:12345INSERT INTO devices(name) VALUES ('Printer') ON DUPLICATE KEY UPDATE name = 'Printer';12INSERT INTO t1 (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b); 3. UPDATE nhiều bản ghi cùng 1 lúc với key khác nhauThông thường khi update 10 users với id khác nhau, chúng ta sẽ nghĩ ngay đến việc chạy 10 câu lệnh UPDATE123UPDATE CustomersSET ContactName = 'Alfred Schmidt', City= 'Frankfurt'WHERE CustomerID = 1;Chúng ta thấy câu lệnh này chỉ có thể cập nhật 1 bản ghi với điều kiện ID 1 lúc. Hmm, vậy liệu có cách nào thực hiện 1 câu lệnh mà cập nhật được 10 bản ghi. Câu trả lời là có, bạn có thể sử dụng WHEN và CASE để làm việc này:123456789101112UPDATE mytableSET key = CASE id WHEN 1 THEN 'key' WHEN 2 THEN 'another_key' WHEN 3 THEN 'some_key'END, value = CASE id WHEN 1 THEN 15 WHEN 2 THEN 25 WHEN 3 THEN 45 ENDWHERE id IN (1, 2, 3)Trong Laravel, bạn có thể cụ thể hóa nó bởi hàm sau123456789101112131415161718192021public static function updateValues(array $values){ $table = MyModel::getModel()-&gt;getTable(); $cases = []; $ids = []; $params = []; foreach ($values as $id =&gt; $value) { $id = (int) $id; $cases[] = &quot;WHEN {$id} then ?&quot;; $params[] = $value; $ids[] = $id; } $ids = implode(',', $ids); $cases = implode(' ', $cases); $params[] = Carbon::now(); return \\DB::update(&quot;UPDATE `{$table}` SET `value` = CASE `id` {$cases} END, `updated_at` = ? WHERE `id` in ({$ids})&quot;, $params);}Ref: https://github.com/laravel/ideas/issues/575#issuecomment-300731748 Vậy khi tôi update 1k bản ghi hay 1M bản ghi, tôi cũng có thể sử dụng lệnh này. Câu trả lời là không. Câu truy vấn là một phần dữ liệu được truyền lại giữa client và máy chủ SQL, và lượng dữ liệu này được giới hạn bởi tham số max_allowed_packet trong config. Nếu bạn sử dụng 1M bản ghi, độ dài câu truy vấn trên rõ ràng rất nhiều dẫn đến lượng dữ liệu truyền giữa client và máy chủ SQL tăng vượt quá max_allowed_packet, kết quả truy vấn sẽ là quang tèo. Thôi thì ta cứ cập nhật 10 hoặc 100 bản ghi 1 lúc thôi, nhiều hơn thì ta lại chia ra để update nhiều lần vậy :D 4. Điều chỉnh config mysqlĐể điều chỉnh config MySQL như set các mode, điều chỉnh các tham số, bạn có thể cd vào thư mục /etc12cd /etc/mysqlvi mysql.cnfThư mục này chính là các cấu hình của MySQL. Mở nó ra xem có gì nào:123456789101112131415161718192021## The MySQL database server configuration file.## You can copy this to one of:# - &quot;/etc/mysql/my.cnf&quot; to set global options,# - &quot;~/.my.cnf&quot; to set user-specific options.# # One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html## * IMPORTANT: Additional settings that can override those from this file!# The files must end with '.cnf', otherwise they'll be ignored.#!includedir /etc/mysql/conf.d/!includedir /etc/mysql/mysql.conf.d/Phần comment giới thiệu khá chi tiết nhỉ =)). Phần includedir là đường dẫn thư mục con cấu hình. Di chuyển vào đó và thay đổi các cấu hình bạn muốn thôi:1vi mysql.conf.d/mysqld.cnfNếu không thích điều chỉnh trực tiếp vào file config, bạn cũng có thể điều chỉnh qua phiên làm việc thôi, bằng cách sử dụng các hàm trong SQL Ví dụ sau là điều chỉnh mode nè1234567/* Xem các mode trong SQL */SELECT @@GLOBAL.sql_mode;SELECT @@SESSION.sql_mode;/* Điều chỉnh các mode trong SQL */SET GLOBAL sql_mode = 'modes';SET SESSION sql_mode = 'modes'; Nguồn tham khảo Đồng đội …..","link":"/2020/04/03/SQL-Note-1-GROUP-BY-create-update-multiple-records-Config-MySQL/"},{"title":"STRIPE - Liên hệ bài toán sử dụng mạng hàng tháng và STRIPE","text":"Đối với các hệ thống thương mại điện tử, việc sử dụng các dịch vụ thanh toán trực tuyến đã trở nên phổ biến. STRIPE là một trong số đó bên cạnh rất nhiều dịch vụ khác như PayPal, Payment Asia hay các hệ thống thanh toán ngân hàng trong nước hoặc ứng dụng ví điện tử như Momo. Các hệ thống này có vai trò như một bên thứ 3, hỗ trợ việc thanh toán giữa hệ thống thương mại điện tử và người dùng, thuận tiện hơn cho việc mua sắm trực tuyến. Bài viết sẽ đưa ra một số thành phần của STRIPE và sự giải thích (hi vọng là dễ hiểu :v) giữa các thành phần này với bài toán dịch vụ mạng bạn vẫn sử dụng hàng tháng CustomerHãy bắt đầu từ dịch vụ đăng kí gói mạng hàng tháng nhà bạn. Đầu tiên bạn cần đăng kí một tài khoản, một bản hợp đồng, thêm phương thức thanh toán (như trả tiền mặt, trả qua ngân hàng, hay ví điện tử). Bạn trả luôn tiền phí cho tháng hoặc năm đầu tiên bạn sử dụng. Với STRIPE, bạn cần tạo cho mình một tài khoản stripe. Tiếp đó bạn cần thêm thẻ và phương thức thanh toán thông qua Card API để từ đó có thể thực hiện các giao dịch với STRIPE Product + PriceCác nhà mạng sẽ niêm yết giá dịch vụ băng thông và bạn có thể tùy chọn để sử dụng Gói sử dụng hàng tháng bình dân: 200k/tháng, tốc độ 3Mbs Gói sử dụng hàng tháng VIP: 300k/tháng, tốc độc 10Mbs Gói sử dụng theo năm thông dụng: 2000k/năm, tốc độ 3Mbs Gói sử dụng theo năm VIP: 3000k/tháng, tốc độ 10Mbs Gói sử dụng theo lưu lượng: dùng bao nhiêu trả bấy nhiêu …. Các gói dịch vụ và giá như vậy được STRIPE cụ thể thành Product và Price STRIPE cung cấp cho bạn một mô hình business và các dịch vụ sản phẩm đặt ở cùng 1 nơi. Các sản phẩm - Product (giá băng thông) xác định những gì bạn bán và giá - Prices để theo dõi số lượng và tần suất tính phí. Chúng có thể được sử dụng để mua hàng định kỳ - hàng ngày, hàng tháng, hàng năm (recurring) hoặc mua 1 lần và hỗ trợ các cấu trúc kinh doanh khác nhau từ các cấp đến thanh toán dựa trên mức sử dụng. Product và Price là một thực thể cốt lõi (core entity) trong Stripe, dùng cho các hoạt động subscription (đăng kí), incoices và Checkout. Các loại giá chi tiết Stripe hỗ trợ, có thể xem tại https://stripe.com/docs/billing/prices-guide Như đã nói ở trên, các hoạt động “shopping” cho khách hàng cụ thể bằng các invoice, subscription và Checkout. Hãy qua những ví dụ nhé InvoiceCái này chắc chẳn cần nói bạn cũng biết. Khi mua hàng, chúng ta sẽ có hóa đơn Invoice được sử dụng khi bạn mua hàng trên STRIPE, nó cũng giống như bạn mua các sản phẩm từ siêu thị. Hóa đơn sử dụng mua các sản phẩm các phí một lần, còn với các phí định kì bạn cũng có thể tạo. Cái mà bạn cần quan tâm với Invoice trong STRIPE tôi nghĩ là vòng đời và các trạng thái của chúng SubscriptionNếu chỉ có hóa đơn, bạn mua các dịch vụ theo chu kì, sau 1 tháng hay 1 năm, làm sao hệ thống có thể nhớ được ngày nào bạn cần thanh toán tiếp theo, đã thanh toán gần nhất hôm nao hay các thông tin gói dịch vụ bạn đang sử dụng kết thúc khi nào? Tất nhiên các nhà mạng phải lưu thông tin đó. Khi bạn nộp tiền cho mỗi tháng, bạn sẽ có hóa đơn, và đơn vị cung cấp mạng sẽ lưu thông tin của bạn và các chu kì sử dụng, thanh toán tiếp theo. Với STRIPE bạn cũng có thể hoàn toàn lưu các thông tin như vậy qua Subscription. Với subscription, khách hàng thực hiện thanh toán định kì để có quyền truy cập vào sản phẩm. Một subscription có vẻ không khác nhiều so với khi bạn mua một chiếc ao phông hay chai nước. Tuy nhiên, để quản lý các khoản thanh toán subscription, bạn cần lưu giữ thêm các thông tin về khách hàn của mình để có thể tự động tính phí cho họ trong tương lai và duy trì các quyền truy cập thích hợp tích hợp vào sản phẩm của bạn. Rõ ràng với các sản phẩm có giá theo chu kì như vậy, bạn cần sử dụng subscripton :D Một câu hỏi được đặt ra là nếu như subscription là các thông tin thanh toán trong tương lai, vậy bạn có thể can thiệp vào các thông tin này. Ví dụ như hủy hoặc tương lai hoặc đổi các gói dịch vụ khác? Câu trả lời tất nhiên là được! Đầu tiên tôi muốn nói đến trường hợp hủy các subscription. Đối với hủy, bạn có thể có 2 lựa chọn Hủy ngay lập tức mà không cần chờ đến hết tháng, khi đó sẽ gọi đến API cancel subscription (hủy hợp đồng luôn, không sử dụng mạng nữa) Hủy gói cước đang sử dụng sau khi hết chu kì tháng này (Tôi sẽ hủy sau khi hết chu kì tháng này). Lúc đó bạn sẽ cần cập nhật lại subscription, với trường cancel_at_period_end sang true, và Stripe sẽ chờ hết chu kì sau đó mới bắn 1 sự kiện cancel subscription này.https://stripe.com/docs/billing/subscriptions/cancel#canceling Trường hợp sau là đổi các gói dịch vụ. Chẳng hạn như nếu bạn dùng mạng thấy chậm quá, sau 1 tháng, bạn muốn nâng cấp gói dịch vụ tốt hơn trong Price mà hệ thống có cung cấp (nâng cấp gói VIP theo tháng) Lúc đó bạn cần đến nhà mạng và đăng kí gói dịch vụ mới. Sau đó đơn vị này sẽ lưu lại thông tin đó và cho vào “lịch trình” (schedule) thanh toán trong tương lai hoặc áp dụng ngay lập tức. Tùy vào các lựa chọn của bạn thì ngay lập tức hoặc hết chu kì hiện tại, đơn vị này sẽ tính phí của bạn theo mức giá mới đo. Với Stripe, nó là Subscription Schedule. Subscription Schedule Subscription Schedule được sử dụng để tự động thay đổi các subscription theo thời gian. Bạn có thể tạo subscription trực tiếp thông qua một schedule hoặc bạn có thể thêm schedule vào subscription đã tồn tại. Sử dụng thuộc tính phases để xác định những thay đổi bạn muốn thực hiện đối với subscription. Sau khi một schedule hoàn thành tất cả các giai đoạn (phases) của nó, nó sẽ hoàn thành dựa thuộc tính end_behavior của nó. Nếu bạn thêm 1 subscription schedule vào 1 customer chưa có subscription, bạn chỉ việc call API thông thường. Trong trường hợp bạn muốn thêm subscription schedule vào 1 subscription đã tồn tại, sử dụng đối số from_subscription . Tuy nhiên khi sử dụng đối số này, một vài đối số khác (như các giá trị phase) không thể được set. Do đó để tạo 1 subscription schedule với các sửa đổi khác, chúng tôi khuyên bạn tạo 2 API riêng biệt Một lưu ý nữa là khi sử dụng from_subscription, schedule subscription sẽ trả về cho bạn với phases[0] là chu kì bạn đang sử dụng và có thể là đang trong quá trình. Lúc này, bạn không thể sửa đổi start date của nó và bạn cần truyền đúng start date đã nhận từ API create vào để không bị lỗi khi cập nhật các phase tiếp theo cho subscription này. 123456789101112131415161718192021# Nếu tạo 1 subscription schedule vào 1 subscription đã tồn tại, bạn nên sử dụng 2 API riêng biệt# API tạo subscription schedule, sử dụng đối số from_subscription với subscription_id bạn muốn thêm schedulecurl https://api.stripe.com/v1/subscription_schedules \\ -u xxx: \\ -d from_subscription=sub_IYaJ8M7QOW4GnK# API điều chỉnh lại cho các price trong tương lai, chu kì tiếp theo (định nghĩa trong phases param)curl https://api.stripe.com/v1/subscription_schedules/sub_sched_1I6D5fEgEtsNy26hdAJQh9uQ \\ -u abcdef: \\ -d phases[0][items][0][price]=price_1HXfstEgEtsNy26hBZZiMTrD \\ -d phases[0][items][0][quantity]=1 \\ -d phases[0][proration_behavior]=none \\ // Nếu subscripton đang chạy trong chu kì hiện tại, start_date ở đây phải giống với subscripton -d phases[0][start_date]=1609834070 \\ -d phases[0][end_date]=1610093270 \\ -d phases[1][items][0][price]=price_1HSdCREgEtsNy26hlTiiJf1D \\ -d phases[1][items][0][quantity]=1 \\ -d phases[1][iterations]=1 \\ -d phases[1][start_date]=1610093270 \\ -d phases[1][proration_behavior]=none Create, Update, and Schedule Subscriptions Tham khảo thêm các trường hợp sử dụng cụ thể của Subscription Schedule: https://stripe.com/docs/billing/subscriptions/subscription-schedules/use-cases Một vài thứ khácWebhookCũng giống như Github hay Chatwork, STRIPE cũng hỗ trợ webhook giúp bạn xử lý các sự kiện trên STRIPE một cách dễ dàng và đồng bộ Webhook của STRIPE có thể dễ dàng test trên chính máy local của bạn thông qua STRIPE CLI TestingSTRIPE cung cấp các số thẻ và các thông tin khác cho phép bạn test các trường hợp bạn tích hợp STRIPE trong kế hoạch của mình (invoice thành công, invoice lỗi, subscription thành công ….). Sử dụng nó để kích hoạt các luồng khác nhau và đảm bảo chúng được xử lý theo ý bạn Ref: https://stripe.com/docs/testing Tài liệu tham khảo Stripe API: https://stripe.com/docs/api Stripe docs: https://stripe.com/docs/billing Viblo: https://viblo.asia/p/dung-thu-stripe-phan-1-maGK7j1D5j2","link":"/2021/01/15/STRIPE-Lien-he-bai-toan-su-dung-mang-hang-thang-va-STRIPE/"},{"title":"Some notes when I deploy my project to Google Cloud","text":"Một vài note khi deploy ứng dụng trên Compute Engine 1. Cloud SQL Phần này giúp tạo database MySQL kể các ứng dụng kết nối đến. Một điểm chú ý là Cloud SQL mặc định sẽ không kết nối với gì. Nếu bạn muốn kết nối vào Cloud SQL, bạn cần thêm địa chỉ IP của bạn vào Cloud SQL Open the navigation menu. Under Storage, click SQL Click the name of the SQL instance that you want to connect Click the Connections tab Click Add network Enter the static IP address of your VM instance Click Done and Save Your SQL instance will now accept connections from your VM instance. Với máy cá nhân, bạn có thể xem địa chỉ IP của mình tại: http://ipv4.whatismyv6.com/ Chi tiết xem tại đây Kết nối cái này để kết nối với các tools quản lý MySQL như Workbench Kết nối được với VM (xem docs trên trang chủ luôn vì nó khá ez) 2. Chú ý Firewall trên VM instanceMặc định nó chỉ mở tcp cồng 80, nếu bạn muốn deploy cổng khác: 81 chẳng hạn, thì cần edit rule này Để chỉnh sửa firewall, phần navigation menu, chọn VPC network =&gt; Firewall rules 3. Lỗi 500 khi deployLỗi này xuất hiện do 2 nguyên nhân: Bạn chưa cấp quyền đủ cho thư mục Phiên bản PHP đang chưa đúng (phiên bản PHP trong Apache2 nhé chứ không phải là CLI) 4. Cloud StorageMột lưu ý là mặc định, các file đang có phạm vi truy cập là “Not public” Public - object can be accessed or edited by all users on the public internet. Not public - object can be accessed only by approved users. Per object - access to a folder’s contents is set at the object level. Folder may contain publicly accessible objects Để nó có phạm vi public có thể truy cập ở mọi nơi, chúng ta cần điều chỉnh phạm vi truy cập của filehttps://laravel.com/docs/6.x/filesystem#file-visibility123456789public function storeAvatar($file){ $avtPath = $file-&gt;store('avatars'); # Ref: https://laravel.com/docs/6.x/filesystem#file-visibility Storage::setVisibility($avtPath, 'public'); return substr($avtPath, 8);} 5. Connect Cloud MySQL với WorkbenchVề cơ bản, nó sẽ như sau: Bạn thực hiện Note 1, cung cấp quyền kết nối từ địa chỉ IP của bạn đến Cloud MySQL Khi thực hiện xong bước 1, chỉ cần config như các DB khác bình thường thôi Ref: https://cloud.google.com/sql/docs/mysql/admin-tools","link":"/2020/02/06/Some-notes-when-I-deploy-my-project-to-Google-Cloud/"},{"title":"Tracking execution time, memory usage php script","text":"Chúng ta cùng xem 1 số cách theo dõi thời gian thực thi và bộ nhớ sử dụng trong PHP script nhé! 1. Tracking the script execution timeĐể đo thời gian thực thi đoạn mã PHP, bạn chỉ đơn giản là đo thời gian thực trên hệ thống trước và sau khi thực hiện đoạn mã ấy. Khá đơn giản phải không nàoHàm nào để lấy thời gian thực trên hệ thống vậy. Đó là hàm1microtime()Docs: https://www.w3schools.com/php/func_date_microtime.asp Ví dụ:12345678910// place this before any script you want to calculate time$time_start = microtime(true); // sample scriptfor ($i = 0; $i &lt; 1000; $i++) { // do anything}$time_end = microtime(true);Log::info('Tracking excution time of loop: ' . $execution_time); 2. Tracking the memory usageĐể thoi dẽo lượng bộ nhớ PHP đã sử dụng cho 1 đoạn script, bạn có thể sử dụng hàm memory_get_usage() AND memory_get_peak_usage() memory_get_usage — Returns the amount of memory allocated to PHP memory_get_peak_usage — Returns the peak of memory allocated by PHP12345678910// place this before any script you want to calculate time$time_start = microtime(true); // sample scriptfor ($i = 0; $i &lt; 1000; $i++) { // do anything}$time_end = microtime(true);Log::info('Tracking memory usage of loop: ' .number_format(memory_get_usage())); Tài liệu tham khảo: https://stackoverflow.com/questions/535020/tracking-the-script-execution-time-in-php https://www.php.net/manual/en/function.memory-get-usage.php","link":"/2019/12/30/Tracking-execution-time-memory-usage-php-script/"},{"title":"Tự xây dựng image trong Docker","text":"83091c2cfa1f0c3be410cd7dd7d2979d964f32e03c21bc6a27d7b403a53772094a06f0993a210eced9a9a7c21f216a9d5f864c1b6fffb5ca5b5b28b183c50f125b5858be0819860a3816ec5be9a117ffe784892a343697efc9ce5da12c67141ce0bf3f4ba760f1aea590d0adec9c1c8ea72f06ad24a2d302f310e25320aa28acefaf7533f702ae7a44d6b0cff2fff8807b39f7f0636ae5ba1465f0113b0962782760b2ceb6417016273a4cea88698dc7c0b7eff09c7a6deae62adacdaffa26cdfb18fbaf5dd3ce2aa415b8402733ac24825b3291aafaeef61164c1e927a7ecc90ed16f6bf6d3a9b5719df7015a62018aa3061f529e6f9d271af1278f10bb20de7455743e466b8255b03186463f7ef8ca73a85f4c4c6277f9f03cee975fe7cf12e74f8bcefca00daf97f5190123011c4529d13bd3be659091ea99941e347ac852cf5053310bbfa00ebf36e544a185011ca65691c124f9802fd7a9b5a45da328adf38f734cdf88d11f615a25fba909cb7f3e410a18977eb47de3094ad4d86379c58eb38cf2304d42d58847b1229ccfc4bb8f8e93727467d4348576d32ee631cdcb5f0b10cf673952bf998a4af1207c90c6f31294cd464c6dd6a3b7746e6fb40411c9764f9d61190713fabfe4592092a049188d17bf5d67a7074678b6d56be943fc986a92ca39873de5872a25e96a253ec892aa8182bb41c0ade26dfceab24971d8641b956872d0d8cec1e9db3c67858749927df5d789627620f7c0a322bb783e287c071b05b6b86aa97f58ce03e0f85473e937a14885d57404e407a06bfa12e80bf7391e18fde4ee28023093fa2392ee6914f8d8158a72d3c75f33108def85a3679620b5fd8ceb1aa09897c2c3387cdbeee1312d70847497208f096556e980c63269b2f1d200bf433bbf95351349002ab7b125c14551717eeab0d36ea2408c306606f4cf9e248aeabadc2c50587d20f793e2f39fb539d0ea38147f5d282728f99bf8dd709de65584ec0e63135f06045789e710b00e092e29669fc37b476b00b108098882dc455b80c2984f7309f91eebddc41d20580503a4773090a54077aa3f0824271aeba3fdb98f34e4d2ebb7ed305ba8832d8f0074d8e6b8aaa3df98a7f7522d303b28c2c78fac7906996196f1384fd5dd2bf778e154ced75bf828c91d1409da3e156dda5cd94a19d716f616dcc526276584ce1c01f99a103c6cafcbce571b6810f36d3b8c7f4e1e2ba93035ed1df8e3637646b0eefb48907fad168447987bb0a94aa8687b11e4c0b877561b871fd40205d5b0aeedaa218dec300737e50ee70edf0bdde7f6737597676d3835253bc0cd8203911a4fa22c5992945ba64d2ec78714e6b2ce6048ef7f836ba790a2514915aad1b0e68ea245cf970da5f54705f4cde417d1d29aa5683823ab822ed93ecb546136d38ecbec41d8c09804c07f8d3d726620d1e6ee6ef79fc1f5aeea9238a2f3d30a8ef51a80b596943631b8bbd2017f07e391355c51bbaa797588e6535d508299db15586be9f63c15f5ae445e96764788fd10629d95c4633ef7fcca54487c787b53da026f2bc3e88cda6d44b48dd875af89862811ef45a9febaa6dc29042d763b5056f6853c3975115df552241213ae072358f3b2047fb11576724fd8270aff85c277be9e09bed8cf58ca9e92b0681248ae60168b3bf66d78d612919a7059b0b880520386edef6e534e71f9a122bef6bca2eb41342d993d6150cf6f18167d669592b97dbcbf2d2562c524a12fe75c7b2482e0a65b2e8b8f6a4011b22178196a9c230bd814c1bbadebca2193377d0026ce91ca6427e34d8870b1e9148e9c1d338ad2ec37709c8c0c788770bcc377a6b967b18948185e6e0745b16d0912481ef63762255e86fb106c2f0965fb3142cd51cd61a668b2a2eca3dcf1f534c3e5892ed4b62173a4d214c4e2f20c014e284337ded0b872ce7b6d8cff48e584c9a0252783164c90ee654f02f4c3ca0d4441b7bd0b169c6f46aaa2ccec0289653247c1296d294fd5031a3e628b665725504a93b01683f6acda49f2a8466189ad48ccf20ab32fc11d0419b586ad1e02e998d6ac7914657289458b9a9beb359bdb7752b9bbdcd42ca238e49441bfc37f725ea0835fb9167c13c81edbeb96eb48082f5bed3a69c4a1aa24151e4f9e2a09c812ab9316851390bf3b453c12e911faf9fe98b243e529ce1aa434a1a3856a7a41c9b9d7169c429d31b89abdc404cd2c3f5abb695cdc870f803b59984c75073d368803f7b2dcd14e40bff0c760d4f6ec93d0d520d44f094bccd082ee18e31b9cc5b5d4e79702858e670411bf02695b19108129455ea22851738c23603b1ca37850c663681d6adbd3edcf8ff9ac6f0ef6c1c41b58ce2eb617165db3c80640691d216fbd3ccc8323186c230896d9631d892d57d807d13e526fb4d586b34668cc2c05a7dbb40acf03d39fcedd929a6c8bceb2ee28a158b8907e7c4da5585ef516f9b11dadf2d57b033e25621537eb8d556b63de85b1de3fc17aab685a79a2f5dd1af4d47bf52b329a499e7ebd97ff504f5e4b326378f4006b568ab554e52f717c011926d05a274518997056a192d5c143d3316e77070e4687dde9696238acdf713bcc40bea6ef5cc191c01777ad8f6aa1fe45653524fd061db2af8240e9b10916d63fd1d85048e1bc65aafd5a1e9883474bf1d98521b53be2165a07e56e99e545eb3c884350b2cef7e134ea041f433d3cf9c8e162985a706f1a02b69d75e68c9bc8918a17324eb46e00c6632e2bf69536facf0233d2bc952f9acb1ab5cf3295aeeabf2fc40c0fc422177d5f89cf4d4892df360f54d537ce06a8fb5edb19a3974f54aa536e4e7faa05bdf6b61c8b5f543adb1533e3741c17169ed74147a52b66291a3c12b16233f7c6e49e3828ff6c73354729b72826b2e635b0857033e0dfff0e514dce271c3b5f8094ed0b958f81e8e54d9276941d8082239ebdf5cd828788b3f4d562810fa23faa4fe3be28b35531d6a63adca66f602c6d1b2e45839165db83b18032106ecf01852d18c041babcce848d2bfcc78297ed7896291cb48523ff891ccf642653891d45e6489b2594dc9d538dec8f88da01a0097e9fe1e10373651404fa9d1333713e522e1f1dd70543cbf9817f0c01fb524c4203284a3150dc7e97bf3c8c160890789c954a4d9f910d2864d161cf3cdc42ce3dc5bde34c5926a9c7533b86e6a0dd68030ea7ff07bf2c9a3bffb605f2abd0e9bd3826db77ebb41b267cecdeaf08e7e359a40c2233ee3a5e037a518de40e6e42aef81f8c59f11f2e71edaf66d7e43bb7a3a05b06382bb4050b7170a28a344817f2edc2dfa1d0087970d7e54503fae8df3bd08154208ec74d280a0fefb488b80412c56c9f99002f4c867ec967956c47cf5a3d77f921c22d939317a99e02dafae1422462c290d64a562f05cb8e58648a38fa7233e6b55dfc3169e780afa5b601ffd90d1e8ca7978b7252c4f3ca500d4d14b795ea1b3034145639f3aec4ecd359a75ffff51972cf1ab00c3fb3cbcb23e3148d83b2494cf7b9f38c145d06a900fe15765c820651a18bf51a8a28913bdd4413ab6da7352658a4278782354f469891a55c8ad0d44daf3ed1f8499604209de58a5f72783abbd2030297d580d74aecd8e9afaf4309609e21ae40c0035e25260a5e57520033c23107b74d96c7a2f5a1e227440bbe4322c246444d5fc0b8b74b1df55e146962d00c6341df7ac6233088be65ca7ccfa8757b6202ff00ffc286586d088296e58e365248f5b6e4178dc2ee6532bf05ce1aa20b1e6e379c70714297ccedd71a6cf0ee60f52aa104202fbfe48cacbcc66cce334d2adc929b16aee6dd284f6d88649a98bd9136dfdf801887d55926e55df15af0de222e9620a8deeb012b5b745fdca11868fcd3ad2db474357d789a7ffb4cb9288b59337fd0f2b1c3035666679444f59818ff3fece9452d335d40f17b2787cac7d640a781b1e204f7957201fd55ce438eaa36dc9025c1f546dd5ae1e038f47f93cfa7a11b5c1f8e303285e126cb79517b4d9e5ce247563180cfd15c3ccf9ce0eb00cf91e2246a9d09565c65771e249dd0898797d6d02c04c17e07b0420b132d5145501641e17d18562d9a69782387caebd04ea8ae2705ead8b89093a9f6f1b557c4bab5c6963942560881460148304864bc698adc5aedc85441e3bf8717d3cc6a9298d3bb02815c41267a21d59e5fed27f318e7700abdbb978418c5926dfc11850323757585b296221028b60d3442c420fed8a6d70aac4a58586dfbf0aa9341ef3fa2ea0920e4e8ea73ec150752052cd0ac2367267f220b39010612166a186d3711dd285bbe7ddc357ae5d55984a030b563efe05db30388b953b5affa161a3af9dc895ad09dfd0d03f6329ca6682c86d401130a5f757abb0343c50e62eb01ca55e6c79ee3d52f04cc3d274526c44ff4a9a25227444833b633c83e06ff57bac22a6ce65f9e6d8b2e669858b57753a1090a252116562c59f23c369188652d3e497c4eaa070e31134f67371ba00523263992cdc1ec67a9f889ec190d16c47f3786c7789876fa30c8ab4c65b51f74b8c0a7dcf59cc51aba3c64c24634f0512b818c1acbea61b9d46f85ec3cac86bc2ed3a6b974c8febc2dc5f02a792acec7c995ddc40f861001ca5a2589ba89864c9c635698a0ee5bcddcc9dda53479e80241a10c0583bac458fa47ac135baae25920ea592a3f8c903b5bb181991a060e9d03f440560db7461f7a69b09c2acaae228c07e470cac8eecdfab2f02103001b055cee3914a2515a5fcda0cc8038430356e7e952df1a5166943b078abe6caef9becc01e6bebd64bd3b173a57e0f36bf98cc13e0d3fbf4af47f5d4fbb85831922a54a0f3e28fbf7283fcccc34182b6e4bd1f0d3bfeb43e82208ff8f274f69f8bf03281a9d04b1a1e65338be98a777240dd57db5d7ca40a85cb9965b9ef29642c3194a3bdbc437936f34d1a9182a90ee59f9b8a74af81d9817ff030858f21fd275cf0b295f0342e6563598eb11ec83b0f871a5f0e3b1501e7402715a49e3e87f77abfb15ff095f633c90a59b9566d0f974684191a1730875111f62e91476b5ed43f3f1c44cad8e0a84c03438b5e797f08edb63715a425161cd1baa886ac22c8e742f444724d9a28011e6a38af6f2eeb9851e55eaf09a42360bef5832a2477c93984ce81fe19b10d1f5764447147e46161f811e75386822915df16e44453fb7677f4067aa1543fb3dab8238644083a320806e6b32483db69fb94dff95f53b89e4b984a5650a0580e7d435ffb98032af71dc3502c3c830fc391cef256920ff1539fd20f9b315f156e7e7441d51ff4f18b7e00e7fd647f8ef650b20bf15bcb338c347e3ce59990907d45e201a7d92eacba86ebbbae79c8b88cf9bdd609cf6cc72ea3407471c462ecd482996e13e4b79c22f7051ebbdd248e9e2972910b0c4b85c2c14ee56037e786a3a943413458dc0af5a444b3b9f4541881bd5a459a759a2cb2bffd9112d477934e0c98d588361306cc6fe59114a58c0a342d2070a54ee40751febc9494e1a757fad76898d535b1a9a202c3be0d6d78bf217fd6eb0d3e7d0507db88ad77530c010bf8417f5f4130472912fb466cd67d9967070d4b075eb2c8ed6123e147cdc2af46c027d614e81d816ad5ebf684e3c507892012828ae90f6eb0f18a0102fb91bf7c7629e27f8829d7c2a84b7f249bc4711b17bcd29d7d6f463cfd0e7b109c5de68e288fcd6539c3e03909670128f56d2aed2c094f89ea96335173e0e411d787b9e771b4e519568f47e693a9d6c6e63858e0397c3226a827bc2d5d946067dacaa95c290c4d91c38e09f58d334649811dcb00d570589cc902147fb160bd7bacfa790e6deeba44129c7dd6ef065b0bf5a0422a0ce077fbdd18abc63fe5a7e2752f98fb02e9094e04995081e8e9f1e78d440b0cde2f2fa8d43310f6aa563aa2e9d4fb7e61a8316ad3858b5ded0ef65a6c0b58e097ae03bce54b1914c1c80daca38424eaffa5d9805d1bc6903315318ba14e0793ca48ada552952bbe247afd7ccd3d8a19854b3f2ff545b7a14604a5c3a46d068b74990a47ed540f3c5dfc6dd05fc7e8a7041bb8318097f78e502de06c856a05f2ff0d1957ba8a3403180653044075bf7e51f8dae715349042bb8966897bf81145e4b177734a3958666adf2b632c3877c2fabc83232ecde7803ac21aba39ab6241e4c78bcf11deb5e7be1709f3dc11ad307f49a6e0c9e8867d232ccc6b34f7bafa7ef2731413f2cb0355db4de0f1abcb7a4ad5ea69d03907723864d8cad428f7f8ab52e41cfb2f16cca5b4ae3d8dea62d0a1a0b5b48416320d3d1da17e5bb542481887d29ac220a175593b87d4c563b4b21054c80bcfd18c080ee87bc3d99c7927f7e5b7b0491870ad460a886aee6aa2ad1f2e8dbc5f193da02f3648c5a6d2a6fe92a403fdc5165daf841b3eb313c1ed518ec76ecf66218adb46b3ceedf786e46e9ee9a7756871455a1b122232aeb03ee052545d093cbf90a81af85491e9940692f36fa51072271851b605a0def89febea8b18812a741f1c12eedd3dd3235298ed721aad162f5f6a647363c457daf94c63ef83caa512d4b6921caf0233a19884b43a066066a2cc986cc065ad50a237df100c4d51f34f6ff061c9d3e4dc1ab045fafc421e5876a86822c260729ee6662aec6908aca117ccf8df52e7f94d133d5fe9ce590594d45f917dd38623112105b90fa4ee59c659f4c82ceacc7ffa60b4bd6911febc19aaa72ca25dbacc7416a533fa501e180cbaa480359b82d7344bbce14144c38033d7969371fa8dd442a82886957a71d2387a54d2857ff1f5cf197fc96332e28817849f84eb980da64461da864c254033439a654285d4e26e755d3235185f6c8858db4b6ccf0e191feac68595e02ae1a3feff4dadd46d90d3bcb6b38bee54f259a74e8d95b47d95247ca1abdf8173926dbb43d1ddde19d62c6919b740b9d8f57b5f9fcc0e381f49b3713f9e40ad499a1ce6d0846953b34c0bc863453850c3df4431e603e91aca6b3e6487cc4a2dbd96ce93893b3893192acdc1e255c82b5674a12aef136c542ec3fef4a4654a13a4b04c2b131acb975c4931f531daa2dfc0733ed3c755963b034fe702330fdc35dbefd50c663b66fc68b94b743484849628d3fd39c68ce62b9b978f95d0ae151ef06b540a07de5a3e5740023fe14791ffcd8bff7bf6824cd1d012a43c30b3d985a15c4a64705a36206ebe45ad5a730e25b635e726b776a8133e85ca67efbc4358cbe03f3c24f126623e8ac5bfe49a1a9415f481c02b7beecd40d9b313cca7080a17ee7cd413f07c50376f780277152925d428be2f69626b122c4810da92dec0fa1d44f8013245afd236796799090701c4d4de0e4561e5f395bfa44647f7fd1c0e5a1badb7101dcd15dcfe201fdf1837c50c800bd0aad7995fddff10a7c27f36908d4b8beac4fc1a3cf480e751c667c329f31be059abb244c887e406da6779f6d71a8171e0b0c4728fbca1cc44059f1bfb5a94ad1e248d237ca98ef4dc2f9ac7220ac5669c2ceb38d382587b4c3a5378c1e5506e2f2a1178f4e42ebb33d93191fd950dfaeafbe7cda4d3c2ceeb7f29275bb92105ca7099a1da75193a2ca9db3a2d2c7c97de8211dda9bfa0e0af1f60d262b4d53200fa81407269d9c18b69e2e0fc8f7fcf31efbdfece546d1dcf40d322e395cb8754f44cce595f19285e514e37701f00e29fe80970eb004112bc45a2d6d9924207b38089a248362750599af74803d8dd8745c094cc2d18076c9a7f3ccb2375e63409e829b92421f930ddb327b485f72000c4597fc43a382dd6d708a3055847b00eb24566fc6b9c212a443bf14d0a95da3418f5765077bec4bda233362163a68e3fa7f17411c910a779e55661dc2d235088d4caedd6e9a583ff043ba993651a0de431a26be6bcab1457469fd0d35985111185d10780a22090cc4e0e22806f634e5918aac8605e4a4ab6e19e8cd21b63aa9e749abb778a86bcde530566abe001f8e1b6d48af50580e84a603fa34bf48032206111458be381fb16a9b76669c94499a8e62b4e608c2c365bcd1692e26abb7f73ba760abae234648e2ca4b2f0a145e15b8ef54de36214f414fbf883ed5b66f1eb0d1aa93cdd571f23d0affd046e6b80c73b0a02bd510bb4b02ff80469168a73ebd182bf4b590bb346dcb4921a630fc8379570ccfcddbae37e4e0583d914e9d0a7a3a1edf94c3bf9a44dbf31a058a9b4860c0444fff2c3088e914347fc224f39f04f8d36aa1eb2a260278e898cf7a4730e42b5319c5f0f77ea78b96e5b5eb288148c945dca7c1384d5045deefd8a8b841f9ade76105e85ed136a9bbe4bcb0ed71d7ab281b299736dd793bf0da2f3a202ed3ee433e19d38cf8819a0f1f1d202f488143618894fbbb79c23aed9862507c2fda3df5498715fef38a91a07c5ab332af1fbcce48e7a24e5ce1775aae8ea73b3b49613db11007e24ad27417995c9351586351482a52db14e1dabc38f7cd6b3cba98acb1dc258edf8bcd05fd1af517a32a8f804882650d194e11dde3f0c428e045279bc89dfbb03abb0fd5107fc0f4b22bc5372ec9d6b7aa7f5eeac8742d336940081a58d5aed4ea0f7edf4deaa013d6e4e8a72ae3fa20b77a25ae26ae71656cbcb99fa11caab408254698f320504aea52293af95f6c2c6e6c63a81e2fc61ff3537832e81693276f06b2f1c15da8bfc769c9cbd2d91c5ced3785677263caab4890a69fbf99589a56ba313c285820e048bfd180f9aff502efa7550d75eb0ace7095acafd6324f7ec6bf83bedc0b745be9042bc624c79ddb0a3c8337cccb5534599f7391ba23a0630341019defdfe209d2e00b3bc627e56ea5628bd778cd646467ccb68479e28890826f132ac9ece2cd843fa72ebb880bb5dd05014654c4b51931278835ae838fa7d89fc60080afcfd42766f641175955b369423b58706653f974ff54225f256ff06e30a6228110099e076460885e97b636fb933ace633979a4067b92cacf3e199ff78f6cf2d217d6714036dc64c70458f51198048f89d36db2a077899a2361dc3813cf5f9dd1f6fc0cea4ecf4dea20478250b8a6a1039b78d868183a70f7c02d37a5496f48ee70204a20d89999fd2b040c8c1dc8442d616645b17436224d266c2e1b2da031c97386ac6f5f2beee9c59378842d3f3b1d2a1fd8408af98780f3f793821d3d64482578df2b5bae797422adbc25a11381e4c3a5ff80280e26d25ca11c85ba304d7326a1b5316e186bfe45eee2a3ea236b6eb20e66c6de0022d4bebfe23359e49040e27f2dad79005c65c8ae620ff45d76cfa3b0157feb44d0d293cb8f8b5ad58bf0fb2c2504c36ad1a16170be2a5dd6afba14968f8a479a2f8aae584d32ae723d4a6f8f5927a6e215c7554a9891329894f31b37e06e5218c030c4b1fe286f5dbb5bd517efd427fd4cb0cb02565e9cf8cb06b8f87bc43e812892e462625f2f352b7344f7ee6a9b91019644f3d85015052f9b54b7c97dbee914f7821ede81523582987a120dc733550742375210cfceb1b94aeb40d32d27faad132c03d3a1d8fcc2380a52aa66434034d25be6824bb9ad2236597cd87e8d60546d5e937ad99d2f5fb2813d790a2d1dc9b77626f314cffd08e990eaf0034d74a80310d28577e8b49e76ae51c3cd3fac64813e324b0238c6a2d5a1765785aaaf6db83e268cf3ddab79d2dc8f498eff19a8b14d388239be3a73571c62422c53219a6e6d64e6c989ab1e8d7fb81d3bed9920f94e1a92c2f1bbd88ad8219ec4dd9aea883ec0e8490929ecaaece2abf27b6a9ddd2d2c07466965c47a439953b2ec73c0ca84d7908cb57a5abb7a751772225ad2de1bd64611032b171eb9058232b68e1ced445cf5b8b3af50757194238bce0560f7fa346253c226be01c19e6006c61f6ba3fc226056ff94a942098bd24e88aafce26215029f675ea818b18e3588300235d3e262452d26e32ed13017ec4dcd16274a203d369646c701e92fef57ca795cfbd126430adb679ab40ef43f26e41e2a064e3b03b9ccfd7283a9e9614b613089443847eb6b1131762f1bbe8fd57f6a0a1115f0463a151675e26cdfe2e447d6e81eeb950b4b1cecd9a632eae6a033655a7210cb417f544357c73c524cd331e6ad33573174aad97a36a556477f2a80b1675da13338a914216ad5b21c0621961e029e6638dd6c666062b425b0e1c620ef6e57aaa5d9f48389207b9ea2b71ebe166a100e709a9749f68de64d9a384e5b2c6ac2eef4a59536cac017b30c16a8e70250d899d8353a17dd979418bb675b26567f1ec1edae6dc010e61140528d6c854ddf8722933d602caf683fa6e6cefbb08c3aa60449796bbc6052e49acccebb58b42240637fb02a50d552c5a8b0c6259185ec92de705c3854b37ce1fe2de4b305d8b4dbff2faf470c3489b2a251159796e0f8765586a748dc6de6a403254d178d5e19abb60868d6d9e1077f9f8f63f7df873e8f48049f2bbc96786900523e76370fef25338a13e3365cbcd5e1f2e73e0eb4109392521b01ad7c0aaca2d489837620c5fc3e78ba5c3b64f13d54ae00e07baa809bf7f3379015dea6e278e2f75f1a4563a2bb4ab9db93b368fa7f6712eab90ecaefcae82ad86a2982f30d0c97c56841f5a11e8a245552083448413870815427892266a70da3e1d955d92daf271174b755033516dcce6a02ccac2f65e113753b16eba40edbf9a991165e83e8eaf498a82e5dee345e07c9a9da928e050cadaa854eca6411d3c35a8d5842b2ed9c98f2095ee9625a40fe9c8c1fb09528f591e4d915316bf0c256619dfcba53c8a0951b1e1823897ef768255c69c65c5c82f31319bd880048a62b44890f3ec054cb1b7f0a4496605b3d8ca8cb732655437280a8e3e28c6be2aeb4d8e78496c51fcd54832692cc633271ab40fc5dbcb4f447c7e5c86336b83a8cc9b7d1d77bd358935b20bcffb6b8f7ea0fe56d0c2ecaedab3cc898c0e6722f7f0f4f5b5cc16b5a4bf234ddcbaa66d13622896909fa1227ac6a8abc8f025392b1a7cc42f7180b5a68a12829bee028c4823b048438b4dce31596597e3cc54d98b8e063bab7b02b1958941d119b17d40a3bd55739793cc34792aacbe12a6e8466f9653d3c30cb94830800f7e799a9f2e33b3ac881752202896c070c92dd8d330293d843909bfabeb3da8255e54707cf0b4508c91936e796ac5cdfd7fc697e46839b65e35eeab0adf311a1ffffe3bfcd757398c2e0cd8a95918f131183305a5047f438f21335e2abc2c07247d0dbe7ebc94f6e4ffaa5c45579f0a8d99cf424f5be3d534198274a2201ce61f8c79c10c8440822d56474df938f0ef27fa3b76fe378a6725252fa3c971b4e6b0ddf1c0f466c0fef411265e52b74baf1e4d9eafdecf8efc38063db94f28d6fd94baa9dff3844d7a5760cf898c9e5b6fb9034a6302f85601f0f506b8c08b00121452ce79ba6cc28e1b441d486eed28e39bf86d4b0edd6667395cd26ad230343d5a96fe390772c9f980b4a2ab51a4445f93665173292e8499cd40ddbf0fc20c8f048eff46018750b8bb5533513040034a0d7d944549e42be352ae54a8f9c76ac88b86a6ac47dc9740103cc06d69a11a09e761c3b5aeb1bb6b58c9215328fb04e1a1d55d81fb036dcd7e11b2821e3eba52ed652eed22c8a1d4ac71ba91bf01ddc6d3a905900d4a1535b3d78a72100b42a6af751e9329ffe397d8f64eedc3526697558c5b1043983e8460ffea73acd55f8ab6ecb5638a2ff9444d26fe4c701337c0832f6fb301a519b9cc3106c233d75fb1de879a3cee8ed7092248a2c13f4bf33869a550bc384adc5ff8d8018f8a1f833158d55bf350123a2c414a2d598bda249e7dcf284308aa6fd2c8f8f4eecbc97148836c6584a9ac0268c9c3ff851dc73bd153498b67e1fea2955bf16213bc651d0ae114ab23c96bc370e9d8b9d82df75b49955243f513d35f239c24e0477fbb7356fef923f2801a7ceec961b68b07475315a981bb5ac2175382f77907f7e370581def8a1d13205810a3a16f0a31f58ae86b293656e00fb71f21a5b4420b63ddbe111e2f914d5e72ea1269bd0e2220c4242158ed693c8d702239531bfd1c4c9281def4638e86dd727defcdb80afba3c8c4336511740901d1dbac3a62a5c10ccb1dd900212c561809a3f675c49da9a2b48cc3033d0aa15ba34af12e52191e85b6369fd6ac73278de2a5a88a703d51e328c3c9057f837e0c4f01d8d90fc508944f8478114d3856631abbb5d9aa945cc89f02980eedf0eb627a26a17ad3d6ac2758e0d9a0233d3de44de83facd8fbf75b2ffb409c4f0460436041fde526832cbd6e662592130ca4d0f528a7dde108b390f611ed3c4c8f9ebaf2156aed6382d4a9e772a814b3927b43f1e97d97b421511e080628849d8bbecae6b42384fe0de52708cbcb03c611ee6d596729936f6b6c461a634282dd4b3ef17163cd83cc001de563bbc9163d2adebfefeafc4d964017252fb2cece8800e8a67c177563f94ea029c3f504f0814a176da75aac4a4e420df19ef3f614766b1bad150f19584cbd354341a0403b00fa699c1365b968e6900929e6b5601376aeb7af479f306252026f6c5da01715d400d862c3d58cc6aa521144eb1740204a5e01e9640827215e594b35e4204a2b2371d88ec03ffc62d6a128cb732a7630822d2714194426b1de116b4863d7e5eee6940c0c10240d4285aec84e5d97a0cf081b47970bbe16dca5fb086e391472d3c491c34a061bdc9f26168ec6823aedcfc030e955a2dbae024c9a80c5afa2086260e90f4221da52bc619a91da43d62cb4089e63a67b0e7335b3c9cb8028c57bf0f6cad6d81f49838cd3a466bd457471b4cd2bf6edd516d39c491c18b742ba9f1fa092b03c2f7b11938a3246e3987dec2fca24b7053d98cbf97bc69e3c52e549893950a4e3cceb14e36d39a05f3ef681f23a5e7a26698f6bb359cd3dadee03c5553fa4be5a5c0f418154ef4d1e1ba0bd083cda34076930326185ce5c2b26e8f9ccbcc7475d02bacb811671f6219c651ecafc3be02158e2650b1a50c46c32b99370b2ad9471b2eec3dee88a5a57c240222cc19db62faa716e3d1940e9f85097832a5db45249824ae77c2d6d2eeba35f0413de676faad9367e0c580fdf164ab20cfa975b982bf739b8b4837a6297a8e9ce8caf84edacbf602c349674b5c8f4e0703c8921cd8bccb94018fdb2389e9d6891c3f4373d3edd9e99d5891a2a05c3a62f67f2d095581ff583b162554e1185bc7638c9404a22fea1e961fd85cf670f1d435007419f201d8bf4d1b0aaf93048ed3e4f135c607be6fb70f459b9ec31245786e6c49b0d196757a34ad6b2185b1653a97f22971789ca8dccc631e12804891f9ab7e8f9881f398d1425029ed361726b77c1db65aefa2b6fb15bb4d377daaea66dcb983872ad0baf6792f34976860c086690182d42fe43a78b1068a8c7a88e0602651968bb4782c2db4382a8db91e946adf96b44daec20ec3291dc440ad2b42d821d63cc3fc5d0a5dce227f39dfeb3004e66a853814e86911ccac2fb3f15f16267b30e36bb82fd30738035a95b9ffec8f6e4658492c7df57dda88998eaeb470732f6cdca7bf7a17bb6670f35fe7fe3c58582da5822f2bf9361612709fcc28cda5bf1bf0f5bf89f3ccac38749a0c352ea2b6903eb88a7237b96ff9dda544094099b7c0e3f95fbe51f855496746b2f453e9612b4000a3b6b6756f84c6d9cfdfd0d50e7bdfde53b925079ab6aba81021e91c1fd69c313d69971505de0a03858e1b5acb9d5b103edd11172439abf2158db5b14085e83f4d4a75629a920579c728216e0122667adbd0c201788c90e375feda312cd4598aee4b149265014f031c1ad3003a2e665973c49cb224203ed0c8e9ce5b2642bf9a19b439bad8af92b2b7068ebc149394e1bcbc351f7f52f72511cdcb8e57397fa13d5c87e1046adb5fa1f9e9a089eae085268deffeabd44de26627b822b997fa2196a9c1b12834a8bce65942294d32f49cf0bc878831d6ff867fc81ed577de55db741c6492642805491a6ff6e1d4aa33d85a0f8962690ba9c916d227f60850fb1eaf971d48f1055caa2fbfde047c8cafc4466f962a167e828851a312c5ca9547b5df2836d3f098c19e32baed40b81fe46ce1c098c56e8e2f3f8acbff62ee405775915c0f5f3ff90ce53dfdeace4ce973a466b7f8458b537a196f8e246b6b7d41eec476723f47c85f08e8401105c14c3118d1f1ebf21074b7972897d364452e3a2ab153e5830f4877ae5fcbc27c43f049fb7811fadc0bb92302f5575b2ac7a3aa01b48c7f0fd0ef300512375591640612c13ffed9678155c97f41ce255c6fd01019b50fdafb4fd8f531f578caa4c774d1fed1250f0420dcba5293d32e6e8fd9809a3680f9279ab10a90a9452b5566de3d8200d1096a415f91c6535dd822515709d48378d62ef5e454255f50a1da12eeda30bf3a4c6e32745ff4a8677b5a361e0a2f80cea1ca8cc3fc7613a39dfbce33872821079502c290b78c2647d1a67115372cbce35cc6c6f880f2be8bf8811ee6b7524eeb349558d65eeff6579f89452c7ee0f1559ee204b0e2e44921b2a873ddfe656673708f857ee8f2873b1719f690e933910fcacf6daaed737c397a180529910e3b3ba558b61867799cdb6d30a29e1f388250ed9510f8c5c8017a55865a220bc01f71bd1f7f4da8c6cd77b2540d2576024bc65ad1645371ab18d9e1f5e5900b0a200b7225a7468177e23e91e1734d70dcf1ec881349c63318bd6a857fba9e99c2109e5c7aea863bd9da1141028bd5a01ca945f86da5dc4404b0f04b40c3a73c29fa39aa33ec286727dd2911c759b8c941edc49ebfa9c331b6daa2cc32662093160e23e9401e792dd93e932c24d92ab7560c375a1a00eceda94e9ab8046cb399ec66c7e82eba4c2936498e0f66d64df421fb55b006cdd87d23872c2ccf6ad3f25a213423213535b1ec637d4c400e8271ca1fc4afcaf1b2603afba1477b051f459e4f07f94ec98704022f55a4c9455b7ab505a9804d4b32032a3dccf81fd2535d30284e9e414aac29a5efd6e14e2b950c8e6cb77bd316d92ff6b8fc91402e1f24413c66d9b58552acd40b309763854257ab938e28d9317f3f15b3a26027a3aa50cc4cf8a3a5c98e96458896e8ce8232952b275f4b6868aeac7d8845e3ca2d45379f288327c8acf80afb37c87909d6e245531d74757c264e0368caa0e728c417a3f254fe67897ec458f30f76080eea2cbe9df38f95b6dc36faf7c2418c231da77643a695d73735915c6bf4aa19c4b8f71ee42cc1d8481fe2a22634e80a779851af48757d34e9c6fb34fc501433394d3abe5bf8097332664de0e86ba9b444bcdc5f5e617bab0387f191d5394e17f17fbf93df40c811fc09002086e63d50d8fee202675f14db79e34af471af74b7a8d099ec846257b6264e09db44c8387b5961cc22ecfa5b3dc692b02fc53f5e0ee5ea0197ab3447aaa6d104c0213af5e958fa0cee43ecde12b7819982db1db0e97c3780fdf954f2a6b18f15cf1d3e03df8db7105186233689948a8a8548e5e854e6967c7aeb17c63472dfbb7f7dcc2f7291fb34b09c19533771976cda44f6969cd5ce7066ff56d6390927c58ead375305bdca300cd9acde695ab1152c713a819fe815daf342cbdd20a9f655a2d4c9fb45c7812160d40ab1d510d0ac1bde852fdc038adee43de133c523c55c125b264623ef1884e005c1557e8838d9676182677f304f8b151074af80376ebf9d111439877c17a47d52ea99ced2a871103a284640edc2e1d36ae54ee4d4dd58bfe8922a917723b31274989054ffae91c61ba79daba25d359c42dcf077e3b60596e7b79e81c7eabd8314caed84d73e7f34da78d6c18e35f191c7c07f89bfbf67e5de2804b09ee0f90bb94768b8bb72d59d44ca4bc375d689a3696b4edfaedc6c2d42a475b5a1ccaac3794825f74d39651090d3c3d197bdf8f6f68fec916ec324b611ddb6ca53110665de3529eb3ac434f839286c8d58134268a432837b3d6dc43fe9a505c5f3920e99b696439d7c4659b3502db17981ff57b6c4a93b56b6e4042283211b04a1fb4d3a0d76af7164fd8500e1a71566357cb073deb340075f469c0fb21fb2827d919c72e49adacc27e0acc733d35a949d8a6d0dd7d4d67c1362258a85576ee6061d8a592b80cb2b519ba829e30c78292db7fe7106fa88d85bedd9885bb3ea6ba8647acf8800bb139bca30717da0f975fed5395b55ef1ca770e2827fda88a6f85dc3e6e6878bc7618df020786ce4baa358f233d877b003484e6cdbe83fceade987d97af3fdadba8dd7cc2e9e5c955fc54f6e69617b8622506d361c3f3e9ed1d289d7563d1413f6475ed88b051c6252c2aebcd41ca3381668e9863610caaf132abf6b76f30d12d8d65f7cb189f7af682b9ac4014c2ed20b5ea8fc06aea42110e28a5148a3ae09efcdf13c79682f901d6a9749bd0f2070d429fe03d441f6b536e4898595d33e4303aae764dba41872e179646cec62bfa3d8b848ee1522cd2b82f928a522284d6ebcd1364c95adfaadfa413ecfe85bccd7548f82cceccd1342235258486e2a79c429e29168b601844e799505a1eb188ef928b5e6ea867a04a1826cc651ea5619c7513529a2ee268a2c1cc8b8c75b4e74f8139fc23c03e9ef4f0da44537d76e5726789e636b2c1d54fed7e64143eb657fc49ba087f39ce517724fc97f4a75f819fec233566c4e53c1d87d55a5d0ff23d1f281c7ccc67e09bbc82f29f27941c8f4e684cff5afe0c885bf95d56557858757b4ed2da80ef1647c077a14a35c13080bb7da740158e2d6c2444bd73254a6123b5317aaaee12161424e0bcf8e6590d9a648ca1611d298d14fac7d552dab3e3085d6729e5bd29c903a049c96b8109d1ae1d88effa7438193df11e5b8c738ebed4ebc88ad5f7c18e1597b2ef0fbcf026718e12d5fb92620d917073e27eebe51dbde0c1d3fdb24d10164629df5f54e49c86bf612f6b6e2ebba9b0f1d9b5513be89520c1645587aff04b7332c7eaebacdc71dada14d854f11789ba8e90b00ce43632dbfa1c5e1d329be8cf28fa563d458d82cd8b348a27a6f9382195e88dd0330150752da78100b69a0f152148e0db5563f7862b576ef91de2ff8ea9b5a40756b622945e861a3b00c51384920a5161f7a6a2f5ec3f6f9a8b9ef9b5445f11559745de2c37bb9b3aed91eb40bd9062ec2974ef96e2716e7625a4e6823ca4c0406090166a0d9d2f62c682884b5d154e26ab7110bea796e23f72e91f383cf8ac76aa94ecc60f99484f40c56fbdd6555c5ef723deee717c0f27dabfd1e0db6a3172b5afd71b5919ac824a6249b39a6fd5b3e7a1b161425b4c058a1b7dbc37a88212df2da62129109886264819b7d315ec1bdcb7f82c044c11c53f13523614a8b82b281d3e3ec007e98070eafaece08a4bacd934b2c55f1e89a6e52646ba6223724d422316f8c6eb46c5ed376707c57e98d93a4af7b466e7b1d4beb2aec629618d05b95cbb2eb7a377062d7ac47eec6be7e44c438e1700ab150586b69e1424bbba79bccde98a27f62cbc9b0b755cb88895062c590c2259ba14a28c03edff5b87c01b94eae370b528c414090edeefd525f231744d54a547abb63c03a8a2f3c3af9a20488e5a7a7d8a570ac73f9099fb91d1859dbd782d82d37c6f61fdf9790a1fe58335a2ddaf1f1682e54804c6e9c9d6f55b7bda4d1c5685b9e4aba71d825aae7cccc1594f3131d2b6d8ff12eebd36307c06ee77c36794b04f47593de91857366f9e748bbae3794b5a242717c9ba25b54fc6a13aa1169e7790e060ee1900a659f6346c4a9f21fbca8045eb4a9cf792b7eb382802d5475ad387a133c6e8240fe24afbc1e17e8b0ba021099b127027cdb277e319902ddd53bcf3e3545102f3effd680a889f069f83984b4ec1a1423976c0a0d6ee0d9a505be6565d6910a1a64edd1137d5b4ad3f789d9a1f864fb6ba3a640ca675c41674b2e0657009e3a49e27d729b12163fc44caf4710159e4ce28b7c119be6866d88788242231c2473653300c5a1295aaac90040146a792bf885c40649951fcafa9b1033a5353580b4b9bc9e3618ef19edfd55da0ee7204811159313286c398694f8d80a3f8af24083debd617dcf6fdf3d6cabd46c3d7d13f8a26582a4717f2e9bb445f34435f96c72d41f7d76ddae772297bdc949f9e19b20feeb1e85430600287bf6d533949e14e01690031291fb7fa40ca7c18ee5be96ddb994d7529f2a6852e14631be81e78b3e5b4e3a5e53618b245579781fda8af5da37a560987b1c299b2198e5c5e52de0386eaf48a0b96c3ac8947f53708c951cbb70fc4d19539f22745c1e2abfee914bf5a3773c4099f237a03417b2c4db66f90f86e0944cba8f764857ae2b23b6c0cc803bd98600d86abcb2207a3f1a0be2e5bf9fcc405f949a4c9634adc39d53ac09739ce42c70ee517b5001377f0d57c7d6b0ea51ba5eb01b4a6b2da27385aa4ca338f78984a617ee49710bcd3a4c6aa7b642d107bd894b9d0b7ccdf2d2ab3a71cb99d7904aecf44bcbfbb57ee85011c99df8a8bbea669e40b07c7546fef07df69c02200345a020af2b9925739afa1b0f6bb898b961960638a3f510c1f67d7cc7421f1e2e0d159771e43ca5e0b4b9dee305f2882c96e3a521c1141af125331b5d76bb1734924e66fbbbb7fd75534ecce0c203f74a73ba3a6c902d72c79c7a2452d53602af9c2a9a81a3821ff12f5825a2faae4797c41038a6aafdcfda4dd01166eb5cfd8a9e31fd516470f5cd2b9eca2fc1392dead0063c1bdf3d156ac6f68f76dda14771199d383082cd6d7e6fe839560920d7f9aaa9e7e6600f6e15066f99329bebc3df251ef9b0529c354d29edddca275e2dbf71a22957dc933f4a9c97cee7bbb71cc4e67198588e0500874ed0d83216f683a5ededc63fd1a2c0002041223012df171df9ecc338db3a7227a4e0e2a4bdf5a30206e8677a66f074d377a6411caafbf7e23b039b040863f6b2c53c9c082a8903b4824bf3d897cca2995e81b0ac6899c5fcc7d716a92b14a7ed4b12f65af902aa02dcc800ad85834c386c9dd705c7c3574a8e1a03483090e290cf5da3bfe5cc03c1c3b6018148f7a94adb82e2f7a9c4c4d2c44d0b446f861a9659a24ec095946f700a1d4b703e565cdd4d12312f5cddd57e465f535bb6b216307a3eda38e16478bc8cda7375abc2fe9f0bb948660be63bc60ce330e68745582856bc1303cbdb876620251247ce698bcd36cced03fb65e9f473a9ba34f5276597335bcc07833f48a468540c001c795e27e69d0ef604d7b914e994dfab98981bcbea2c187b98fa5c4da93e80a031ad36f5739cbd8282ecc96d65707e0db2d14d648b0db968fd0f1f4d2489eda75524fe627aa9bc7f857362afca63eff05d81c0eca3f4bbe1d4a7d314b57f2949f19b64f4451c3f57f24b90e38e7ca2736d4d4bd2edae01148eaa4cab741b7c6d0feb88bbf49f52 Hey, password is required here.","link":"/2020/01/18/Tu-xay-dung-image-trong-Docker/"},{"title":"[Unit test] PHP Testing Interview 2","text":"Bài viết tổng hợp 1 số note để testing với Một vài packages bạn có thể dùng trong unit test. Thao tác Database. Private/Protected attributes, methods. Me: Laravel có hỗ trợ Package nào làm việc với UnitTest không nhỉ? PHP Testing: Có một vài phương thức sau: Mặc định PHP sẽ có sẵn PHPUnit https://phpunit.readthedocs.io/en/8.5/. Ngoài ra bạn có thể sử dụng packge Mockery thêm cho test hiệu quả https://github.com/mockery/mockery. Laravel cũng cung cấp thêm 1 vài phương thức để test bạn có thể tham khảo: https://laravel.com/docs/6.x/testing Me: Bạn có thể ví dụ cho tôi không? PHP Testing: Chắc đa số chúng ta sẽ sử dụng package Mockery. Có thể nói Stub và Mock là 2 khái niệm Test cô lập được sử dụng nhiều nhất trong phần unit test. Khi mock 1 object bạn nên nhớ PHPUnit cung cấp một phương thức hữu ích đó là getMockBuilder(), nó cho phép bạn tạo 1 class mới thoả mãn điều kiện trên ngay khi đang chạy test mà không phải tạo file mới cho mỗi class. Và tất cả các methods của mock object này đều trả về null. Do đó nếu bạn sử dụng methods nào cần stub lại Tuy nhiên, có 1 ngoại lệ đó là tất cả method của mock object đều trả về null. Những method này được gọi là stubs! Stub method là một method bắt chước hành vi của method ban đầu theo 2 tiêu chí: cùng tên và cùng parameters. Điểm khác biệt của stub method là tất cả code logic bên trong sẽ bị loại bỏ (chỉ trả về giá trị cuối cùng bạn mong đợi Như vậy: Bây giờ bạn đã có thể overridden giá trị trả về của 1 method bằng stub method bên trong unit test. Sử dụng mock và stub kết hợp để chạy test case và test Dependency Injection Góc nhìn cá nhân về Dependency Injection: DI là cách viết code ngoài các ưu điểm khác thì nó còn để có thể testing được, khi đó code giảm bớt sự phụ thuộc. Chi tiết đọc phần “Nhưng tại sao sử dụng dependency injection” tại https://viblo.asia/p/php-unit-test-501-su-dung-mock-objects-stub-methods-va-dependency-injection-YWOZryg7KQ0. Tóm tắt lại ý đó thì code123456789101112131415public function processPayment(array $paymentDetails){ $transaction = new AuthorizeNetAIM(self::API_ID, self::TRANS_KEY); $transaction-&gt;amount = $paymentDetails['amount']; $transaction-&gt;card_num = $paymentDetails['card_num']; $transaction-&gt;exp_date = $paymentDetails['exp_date']; $response = $transaction-&gt;authorizeAndCapture(); if ($response-&gt;approved) { return $this-&gt;savePayment($response-&gt;transaction_id); } throw new Exception($response-&gt;error_message);} Sẽ không thể test được mà cần chuyển về DI1234567891011121314public function processPayment(AuthorizeNetAIM $transaction, array $paymentDetails){ $transaction-&gt;amount = $paymentDetails['amount']; $transaction-&gt;card_num = $paymentDetails['card_num']; $transaction-&gt;exp_date = $paymentDetails['exp_date']; $response = $transaction-&gt;authorizeAndCapture(); if ($response-&gt;approved) { return $this-&gt;savePayment($response-&gt;transaction_id); } throw new Exception($response-&gt;error_message);} Khi test DI, bạn tự khởi tạo mock object, stub method mà bạn dùng rồi sau đó truyền nó vào các class cần test. Một tùy chọn khác là DI qua bind() hoặc singleton() mà cái này ít dùng.1234567891011121314151617181920212223242526272829 public function testProcessPaymentReturnsTrueOnSuccessfulPayment(){ $paymentDetails = [ 'amount' =&gt; 123.99, 'card_num' =&gt; '4111-1111-1111-1111', 'exp_date' =&gt; '03/2013', ]; $payment = new Payment(); $response = new stdClass(); $response-&gt;approved = true; $response-&gt;transaction_id = 123; // Mock object nào $authorizeNet = $this-&gt;getMockBuilder(AuthorizeNetAIM::class) -&gt;setConstructorArgs([Payment::API_ID, Payment::TRANS_KEY]) -&gt;getMock(); // Stub method `authorizeAndCapture` $authorizeNet-&gt;expects($this-&gt;once()) -&gt;method('authorizeAndCapture') -&gt;will($this-&gt;returnValue($response)); // Truyền DI $authorizeNet sau khi đã giả lập thành công. $result = $payment-&gt;processPayment($authorizeNet, $paymentDetails); $this-&gt;assertTrue($result);} Ngoài ví dụ trên, sau khi mock object, bạn có thể tìm thấy Stub without Mockery: https://github.com/tuanpht/laravel-test-example/pull/1/files#diff-aac49332ac4c101b14e9115b7a49b742R13-R16 Stub with Mockery: https://github.com/tuanpht/laravel-test-example/pull/1/files#diff-162143d3f08dc0e12b06a6871e8c4f8fR14-R17 Me: Vậy còn việc test các thuộc tính, methods có phạm vi private/protected thì sao? PHP Testing: Khi Test các private và protected methods, properties, bạn cần sử dụng Reflection123456789101112131415161718192021222324/** * Get private/protected property value * $this-&gt;assertEquals('views/home', $this-&gt;getObjectProperty($view, 'file_name')); */public function getObjectProperty($object, $propertyName) { $reflector = new \\ReflectionClass($object); $property = $reflector-&gt;getProperty($propertyName); $property-&gt;setAccessible(true); return $property-&gt;getValue($object);}/** * Call protected/private method of a class. * $this-&gt;invokeObjectMethod($view, 'getData'); */public function invokeObjectMethod($object, $methodName, $parameters = []){ $reflection = new \\ReflectionClass($object); $method = $reflection-&gt;getMethod($methodName); $method-&gt;setAccessible(true); return $method-&gt;invokeArgs($object, $parameters);}Me: Hmm, ngon quá nhỉ, vậy còn khi Test với Database? PHP Testing: Để test với các thao tác database bạn cần làm 2 việc Tạo một 1 database mới không liên quan gì đến database của môi trường dev: có thể là MySQL hoặc SQLite: nhỏ gọn, nhanh chóng. SQLite nhỏ gọn, xử lý nhanh nhưng nó chỉ thích hợp với các ứng dụng chỉ có thao tác CRUD, với các ứng dụng thực tế cần JOIN, trigger thì nó không sử dụng được, vì vậy, chắc hẳn trên thực tế sẽ sử dụng MySQL hơn là SQLite https://freetuts.net/gioi-thieu-sqlite-sqlite-la-gi-1719.html Đây mới chỉ là phần chọn drive nào. Vậy phần tạo database (migrate) đâu? Laravel hỗ trợ ta làm việc này với trait RefreshDatabase: https://github.com/tuanpht/laravel-test-example/blob/master/tests/Integration/SetupDatabaseTrait.phpTrai này thực hiện luôn cả migration Trỏ tới Database đóViệc trỏ tới database đó sẽ là việc thay đổi môi trường, quyết định trong file config:12345&lt;php&gt; &lt;server name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt; &lt;!-- APP_KEY for integration http test --&gt; &lt;server name=&quot;APP_KEY&quot; value=&quot;base64:HaoSf5Y02/vR1a1WGy3qfQ/iZhON6PsLkF8QOBr8RyA= &quot; /&gt;&lt;/php&gt; https://github.com/tuanpht/laravel-test-example/blob/master/phpunit.dist.xml#L26. Lúc này bạn cần thêm file cấu hình khi testing với định dạng .env.testing In addition, you may create a .env.testing file in the root of your project. This file will override the .env file when running PHPUnit tests or executing Artisan commands with the --env=testing option. Nếu bạn sử dụng SQLite thì bạn cần thêm phần nàyBạn sẽ config trong file như vậy https://github.com/tuanpht/laravel-test-example/pull/2/files#diff-1ef70a974f238d54faeb90eb02582e90R31-R3612345678&lt;!-- Using SQLite in memory database test --&gt;&lt;server name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot; /&gt;&lt;server name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot; /&gt;&lt;server name=&quot;BCRYPT_ROUNDS&quot; value=&quot;4&quot;/&gt;&lt;server name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;&lt;server name=&quot;MAIL_DRIVER&quot; value=&quot;array&quot;/&gt;&lt;server name=&quot;QUEUE_CONNECTION&quot; value=&quot;sync&quot;/&gt;&lt;server name=&quot;SESSION_DRIVER&quot; value=&quot;array&quot;/&gt; Tài liệu tham khảo: Testing: Getting Started Demo project","link":"/2020/01/25/Unit-test-PHP-Testing-Interview-2/"},{"title":"[Unit test] PHP Testing Interview","text":"Một cuộc phỏng vấn với PHP Testing giúp mình tổng hợp các ý tưởng, cách thức về việc testing với developer! Giới thiệu automation test, unit test và integration testMe:: Hôm nay là ngày 11/1, một ngày không khí lạnh tràn về Hà Nội, vì vậy tôi muốn phỏng vấn bạn mấy câu có được không PHP Testing? PHP Testing: Tất nhiên, tôi rất vui vì được bạn phỏng vấn! Me: Tôi có nghe về Automation Tests, nó là cái gì vậy? PHP Testing: Dịch sang tiếng Việt nó là kiểm thử tự động, hãy hiểu nó là 1 phần nhỏ trong bức tranh Test rộng. Nó chính là viết code để test code. Me: Vậy nó đem lại lợi ích gì vậy? PHP Testing: Nó có rất nhiều lợi ích đó (nếu phát triển theo đúng quy trình). Nó cấu trúc code cho bạn (đặt tên các hàm sẵn cho bạn trong test) Có thể tích hợp CI/CD để tự động hóa các quá trình merge, deploy. Một điểm mạnh của nó nữa là nó có thể teamwork, nó kiểm tra được đoạn code của bạn có ảnh hưởng đến code người khác không (cái này cực kì hay gặp khi sửa 1 hàm mà làm ảnh hưởng đển code của người khác nè). Từ đó giúp bạn tăng sự tự tin trong việc thay đổi / bảo trì / refactor code =)) Me: Nghe hay quá nhỉ, vậy developer áp dụng nó vào project như thế nào? PHP Testing: Developer sẽ áp dụng vào project dưới dạng Unit Test và Integration test Me: Nó là cái gì thế? PHP Testing: À cũng không khó lắm đâu. Unit Test thì đơn giản, nó sẽ Test từng function hoặc method của một class, nhận đầu vào và mong chờ (asset) đầu ra đúng như kì vọng. Nó sẽ không truy vấn database, sử dụng network, call API, sử dụng file system. Trong khi đó Integration Test là việc test tích hợp nhóm các function, các method đã kết hợp lại với nhau và thực hiện các việc mà các Unit Test không được làm ở trên. Me: Unit Test thì tôi đã hiểu, nó test từng hàm một, nhưng Integration test thì tôi chưa rõ lắm. PHP Testing: Tôi lấy ví dụ cho bạn nhé, Chẳng hạn Unit test, test từng method của Service và Controller sử dụng service thì Integration sẽ test việc sử dụng kết hợp service và controller thực hiện công việc gì đó như tạo bản ghi. Đầu vào sẽ là input, sau đó thực hiện Controller này asset đầu ra nó đã có trong DB chưa, nó đơn giản là hàm gọi nhiều hàm tích hợp với nhau thôi :D. Với những ứng dụng nhỏ, số lượng code không quá nhiều, chúng ta có thể chỉ cần thực hiện integration tests mà sử dụng database connection, lợi ích là giảm effort mà vẫn giữ được tốc độ của cả quá trình testing. Các thành phần chung của một test caseMe: Cảm ơn bạn, tôi cũng đã hiểu sơ sơ rồi. Mà trong các test bao gồm nhiều test cases phải không nhỉ, nó có phải là các trường hợp kiểm thử, và khi viết test cases đó thì tôi cần những gì? PHP Testing: Đúng vậy các test case chính là các trường hợp chúng ta sẽ kiểm thử trong code. Các Test Cases phải được thiết kế để có thể cover được hết các sự kết hợp của các giá trị inputs cùng các điều kiện, bao phủ hết các nhánh if/else. Một Test case sẽ bao gồm 3 phần sau: Arrange: thiết lập trạng thái, khởi tạo object, giả lập mock Act: Chạy unit đang cần test (method under test) Assert: So sánh expected với kết quả trả về123456789101112public function test_fetches_items_in_array_until_value(){ // Arrange $names = ['Taylor', 'Dayle', 'Matthew', 'Shawn', 'Neil']; // Act $result = array_until('Matthew', $names); // Assert $expected = ['Taylor', 'Dayle']; $this-&gt;assertEquals($expected, $result);} Hoặc có thể phát biểu thành lời với GIVEN, WHEN, THEN: Given this set of data, when I perform this action, then I expect that response. 123456789101112public function test_fetches_items_in_array_until_value(){ // Given this set of data $names = ['Taylor', 'Dayle', 'Matthew', 'Shawn', 'Neil']; // When I call the until function and specify a value $result = array_until('Matthew', $names); // Then I expect the result should be $expected = ['Taylor', 'Dayle']; $this-&gt;assertEquals($expected, $result);} Testing khi chức năng phụ thuộc bên thứ 3 hoặc lớp khácMe: Oh, tôi đã hiểu test case. Ở trên bạn có nói việc sử dụng network, gọi API làm chậm test, kết quả không ổn định vì phụ thuộc mạng, khi test truy vấn CSDL thì làm chậm quá trình test và ảnh hưởng đến database thật, vậy gặp trường hợp này thì chúng ta test kiểu gì? PHP Testing: Test cô lập (Test Doubles) Me: Bạn có thể nói rõ hơn không? PHP Testing: Những phần phụ thuộc bên thứ 3 trong test sẽ được giả lập vì nếu không giả lập, khi chạy test sai ta không biết sai do code của test hay do bên thứ 3. Giả lập ở đây tức là thay thế Object hoặc hàm phụ thuộc bên thứ 3 bằng Object và hàm “bắt chước” hành vi của real Object và chúng ta có thể tự định nghĩa kết quả trả về theo từng kịch bản test case? Me: Đúng là một ý tưởng tuyệt vời, thế lúc nào tôi cũng giả lập cả Object à? PHP Testing: Không đâu, như tôi nói ở trên đó, bạn có thể giả lập hàm hoặc cả Object ứng với 2 quan điểm về unit test cô lập. Sociable test sẽ giả lập các hàm, các methods chậm, sức ảnh hưởng lớn hoặc không thể dùng trong môi trường test: database, network call. Và loại còn lại là Solitary test giả lập cả Object luôn, như Dependency Injection chẳng hạn. Me: Làm sao để tôi biết khi nào sử dụng Sociable test và Solitary test? PHP Testing: Như thế này nhé, nếu cấu trúc code của bạn tốt thì: Model: nhiệm vụ chính là để lưu dữ liệu bên trong và không thực hiện nhiều logic bên trong =&gt; không cần mock, chỉ đơn giản là khởi tạo đối tượng và truyền vào fake data cho nó Service: nhiệm vụ chính là thực hiện công việc, logic =&gt; cần cả 2 loại trên tùy vào chức năng? Me: Hay quá, bạn có thể cho tôi xem thực hành về việc giả lập này không? PHP Testing: Tất nhiên rồi, giả lập này sẽ gồm 2 khái niệm và Stub và Mock. Stub (Stub methods) là giả lập hành vi tức là các methods và functions. Bạn có thể giả lập hàm này trong 1 lần gọi (lần gọi đầu sẽ mock, từ lần sau sẽ là methods, functions cũ) hay áp dụng cho mọi lần gọi:12345678910111213141516171819public function test_order_sends_mail_if_succeeded(){ $mailService = $this-&gt;createMock(MailService::class); $order = new Order('Wine', 'user@localhost', $mailService); // Expect method MailService::send được gọi duy nhất 1 lần, // với 2 tham số là 'user@localhost' và 'Order succeeded!' // Expect cần được viết trước khi gọi method test $mailService-&gt;expects(once()) -&gt;method('send'); -&gt;with( $this-&gt;equalTo('user@localhost'), $this-&gt;equalTo('Order succeeded!') ); $result = $order-&gt;process(); $this-&gt;assertTrue($result);}Còn Mock thì giả lập trạng thái loại bỏ tất cả logic bên trong method của object thật và có thể thay đổi kết quả trả về của method theo ý muốn1234// Create mock object$product = $this-&gt;createMock(Product::class);// Stub method price, make it return 100$product-&gt;method('getPrice')-&gt;will($this-&gt;returnValue(100));Hai khái niệm này thậy mơ hồ. Đây là một ý kiến tôi đọc được và cảm thấy dễ hiểu: Một Stub không thể trả về kết quả unit test là fail bởi vì bạn biết những gì bạn đang thực hiện và lý do tại sao bạn đang thực hiện nó, Nó được sử dụng là để thay thế cho một module và được giả sử là phải thực hiện đúng các nhiệm vụ được giao. Tuy nhiên, Mock object chỉ là một đối tượng mà bắt chước các đối tượng thực sự. Nếu logic chính của method là sai thì các unit test sẽ fail ngay cả khi chúng ta thiết lập mock object chính xác. Tổng hợp 1 số ý kiến trên stackoverflow https://stackoverflow.com/questions/346372/whats-the-difference-between-faking-mocking-and-stubbing https://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub StyleMocks vs Stubs = Behavioral testing vs State testing PrincipleAccording to the principle of Test only one thing per test, there may be several stubs in one test, but generally there is only one mock. LifecycleTest lifecycle with stubs: Setup - Prepare object that is being tested and its stubs collaborators. Exercise - Test the functionality. Verify state - Use asserts to check object’s state. Teardown - Clean up resources. Test lifecycle with mocks: Setup data - Prepare object that is being tested. Setup expectations - Prepare expectations in mock that is being used by primary object. Exercise - Test the functionality. Verify expectations - Verify that correct methods has been invoked in mock. Verify state - Use asserts to check object’s state. Teardown - Clean up resources. SummaryBoth mocks and stubs testing give an answer for the question: What is the result? Testing with mocks are also interested in: How the result has been achieved? Chính vì thay đổi Object là Object mới, rất có thể sinh ra lỗi nếu bạn mock logic của Object sai, đó có thể là khác biệt lớn nhất giữa Stub và Mock. Một ý kiến khác về stub, mock, fake. Fake là giả, tạo một cái gì đó giả, muốn là gì thì là miễn là kiểu đó =)). Nó phục vụ việc các hành vi không mong kết quả trả về như click button, gửi mail, … Stub - an object that provides predefined answers to method calls. Mock - an object on which you set expectations. Fake - an object with limited capabilities (for the purposes of testing), e.g. a fake web service.Test Double is the general term for stubs, mocks and fakes. But informally, you’ll often hear people simply call them mocks. Me: OK phần network call, API call thì tôi đã hiểu, vậy phần database thì sao, chúng ta cũng giả lập như vậy?PHP Testing: À với database thì không nhé. Với databse, chúng ta sẽ tạo ra một môi trường mới (thường là testing) với database mới có cấu trúc giống như database dev và tiến hành test dữ liệu trên database đó. Với các service bên ngoài ta vẫn nên giả lập. Nếu trường hợp dữ liệu cần có 1 vài dữ liệu trước đó bạn phải tự tạo. Ví dụ như bạn muốn test trường hợp xóa 1 bản ghi, thì trong bước chuẩn bị bạn cần tạo bản ghi đó đúng không nào? Một vài notes khi thực hành test với LaravelMe: Tôi đã hiểu các khái niệm Unit Test và thấy nó khá thú vị rồi đó, bạn có thể hướng dẫn tôi thực hành trong một framwork nào được không? PHP Testing: Laravel nhé Me: Hehe, tôi là một master Laravel đó :D, thực hành thôi! PHP Testing: Trước tiên tôi muốn giới thiệu SETUP VÀ TEARDOWN dùng để thiết lập class property, object, env setUp(): Chạy trước mỗi method test tearDown(): Chạy sau mỗi method test setUpBeforeClass(): Chạy khi bắt đầu class test tearDownAfterClass(): Chạy sau khi kết thúc class test Tiếp đó là REFLECTION Trong một số trường hợp chúng ta phải truy cập vào private/protected method hoặc lấy ra các private/protected property của đối tượng để thực hiện assertion Service Container Đây chính là nơi bạn đưa các DI vào để test thông qua các phương thức resolve1234567public function test_register_when_valid_email_password_return_success(){ $mailService = $this-&gt;createMock(MailService::class); // Just use fake mail service instead of SES in this test App::instance(MailService::class, $mailService); // ...} @dataProvider Tạm dịch là: 1 test method có thể chấp nhận nhiều input khác nhau. Các tham số này được cung cấp bởi method data provider. Bạn hãy theo dõi 1 số ví dụ để hiểu rõ cách test hơn nhé!! Me: Okay. Tôi sẽ luyện tập phần unit test này để hiểu rõ hơn. Cảm ơn bạn vì cuộc trò chuyện nhé! Tổng kết Keyword: Unit Test, Integration Test, Test Doubles, Mock Objects, Stub Methods, Fake, Dependency Injection, Mockery, REFLECTION. Methods: @dataProvider, setUp(), tearDown(), setUpBeforeClass(), tearDownAfterClass(). Các khái niệm Unit Test tôi thấy không chỉ áp dụng cho PHP hay Laravel, nó là ý tưởng chung cho testing đối với Developer. Ví dụ khái niệm Unit Test, Test tích hợp hay Test cô lập như Stub, Mock, Fake dùng rất nhiều trong JEST để test các framework JS với ý tưởng như vậy. Thậm chí với testing cho các view bằng js, chúng ta còn có khái niệm snapshot testing cực kì hay. Cấu trúc của 1 test case cùng vậy, dù test bằng ngôn ngữ gì đi chăng nữa cũng sẽ có 3 phần GIVEN, WHEN, THEN. Các hàm để test cũng vậy, Laravel có setUp(), tearDown(), setUpBeforeClass(), tearDownAfterClass(), Laravel có Mockery, các framework JS có JEST, Mocha/chai Thật là tuyệt vời phải không nào, học ý tưởng cách test của 1 ngôn ngữ ta lại áp dụng được cho các ngôn ngữ khác. Tài liệu tham khảo: https://pht.gitlab.io/php-unit-test-slide/#/ https://github.com/framgia/div-high-dev-guidelines/tree/master/ut/php https://github.com/tuanpht/laravel-test-example/blob/master/docs/testing.md https://github.com/mockery/mockery Demo: https://github.com/tuanpht/laravel-test-example","link":"/2020/01/10/Unit-test-PHP-Testing-Interview/"},{"title":"Visual Basic for Applications (VBA) Notes","text":"Bài viết tập trung tổng hợp lại 1 số thứ tác giả học được khi làm việc với Macro trên MS-Excel VBA stands for Visual Basic for Applications, an event-driven programming language from Microsoft. It is now predominantly used with Microsoft Office applications such as MSExcel, MS-Word and MS-Access. This tutorial teaches the basics of VBA. Each of the sections contain related topics with simple and useful examples. Note: VBA chỉ dùng cho MSExcel thôi nhé, nó sẽ không hoạt động khi bạn mở file bằng các trình chỉnh sửa văn bản khác. 1. Bật macroBật chế độ DeveloperChọn File =&gt; Option =&gt; Customize Ribbon và bật chế độ Developer lên :D Enable macroChọn Developer =&gt; Macro Security và chọn Enable marco lên. Chi tiết bạn có thể xem tại: https://www.tutorialspoint.com/vba/vba_excel_macros.htm 2. Hello world!Để tạo 1 marco, bạn chọn Visual Basic, kích đúp vào sheet đó và viết các đoạn mã macro thôi. Hoặc bạn cũng có thể nhấn vào Macro và sau đó viết các đoạn mã như bình thường. 123Private Sub say_helloworld() MsgBox &quot;Hello world! I am Minh&quot;End Sub Một vài biến globalKhi bạn select một khoảng cell, nó sẽ được set vào biến global Application.Selection và có thể truy cập:123456789101112131415161718Sub Macro1()'' Macro1 Macro'' Range(&quot;E1:E8&quot;).Select 'Khi bạn select nó sẽ lưu giá trị vào biến global Application.Selection để foreach ở phía dưới' Dim count As Integer Dim valueEColumns As String For Each cel In Application.Selection.Cells count = count + 1 valueEColumns = postId &amp; cel &amp; &quot;,&quot; Next cel MsgBox valueEColumnsEnd SubCòn nhiều biến global, trong phạm vi hiểu biết của tác giả thì chỉ biết global này @@ 3. Debug and breakpointVBA có hỗ trợ breakpoint để debug. Trước tiên bạn cần bật cửa sổ lên để xem các thông tin debug. Cửa số này trong VBA là Locals window. Bạn có thể bật nó ở tùy chọn View =&gt; Locals window. Một cửa sổ mới sẽ xuất hiện dưới đoạn code của bạn Và khi debug chúng ta có thể đọc đang các biến từ breakpoint 4. Record macroĐây là một chức năng hữu ích của macro cho người mới bắt đầu. Các thao tác bạn thực hiện trong file excel sẽ được ghi lại là sinh ra đoạn mã VBA tương ứng. Việc làm tiếp theo của bạn là đọc hiểu đoạn code này và customize lại thôi Thao tác sẽ như sau Bước 1: Thực hiện thao tác macro Bạn ấn vào Record macro. Sau đó thực hiện các hành động với file excel (tính toán tổng các cột, copy paste dữ liệu, lựa chọn cột …) Sau khi đã thực hiện sau chọn Stop macro và nó sẽ lưu đoạn mã macro đó cho bạn Bước 2: Xem macro Để xem đoạn macro vừa sinh ra, bạn chọn Macro. Chọn tên macro đó và chọn Edit Xem đoạn demo sau nha. 5. Cases studyBài toán 1: Lấy ra giá trị sau khi lọc dữ liệu.Bài toán: Cho file excel với cột A chứa id của học sinh của 1 lớp. Bài toán đặt ra là sau khi filter dữ liệu (theo lớp, theo ngày hoặc bất cứ điều gì), hãy hiển thị ra 20 student_id đầu tiên filter được. Bước 1: Sử dụng Record macroNhận thấy sau khi filter các thứ, bạn chọn copy cả column đó thì nó sẽ chỉ lấy ra được các giá trị đã được filter. Do đó ta sẽ record hành động copy của cả column A này Và đây là đoạn mã nó sinh ra:123456789Sub Macro1()'' Macro1 Macro'' Columns(&quot;A:A&quot;).Select Selection.CopyEnd SubOK ta chỉ tận dụng được 1 dòng nhỉ =)) Bước 2: Chỉnh sửa đoạn code Record đượcNhư đã nói ở trên, khi dùng Select nó được lưu giá trị vào global Application.Selection. Việc tiếp theo là duyệt Selection này nhỉ.Tìm kiếm Google với cụm từ “vba for each in selection” bạn sẽ được hướng dẫn như sau:1234567891011Dim postId As String Dim count As Integer Columns(&quot;B:B&quot;).Select For Each cel In Application.Selection.Cells count = count + 1 If count &gt; 20 Then Exit For postId = postId &amp; cel &amp; &quot;,&quot; Next cel MsgBox postIdNguồn: https://stackoverflow.com/questions/21526863/excel-vba-selected-cells-loop Nhưng khoan đã, có gì đó sai sai. Đoạn mã này có vẻ lấy cả các giá trị trống của 1 cell. Như vậy ta phải loại bỏ các giá trị trống này nữa. Từ khóa mình tìm1&quot;vba get value not empty selection&quot;.Và từ khóa cao thủ hơn tìm:1&quot;vba select only visible cells&quot;Tất nhiên từ khóa sau sẽ ra kết quả phù hợp luôn: https://excelribbon.tips.net/T008524_Selecting_Visible_Cells_in_a_Macro.html https://stackoverflow.com/questions/43065610/vba-selecting-visible-cells-after-filtering Và đây là đoạn code cuối cùng sau khi loại bỏ các giá trị trống:123456789101112131415161718Sub Macro1()'' Macro1 Macro'' Dim postId As String Dim count As Integer Columns(&quot;B:B&quot;).Select For Each cel In Selection.SpecialCells(xlCellTypeConstants) count = count + 1 If count &gt; 20 Then Exit For postId = postId &amp; cel &amp; &quot;,&quot; Next cel MsgBox postIdEnd Sub Bài toán 2: Macro chuyển hướng đến một trang web cho trước với trình duyệt mặc địnhVới từ khóa1&quot;vba redirect url with default browser&quot;và đây là kết quả mình tìm được:https://stackoverflow.com/questions/3166265/open-an-html-page-in-default-browser-with-vba123Sub Redirect_New_URL() ThisWorkbook.FollowHyperlink (&quot;http://www.google.com&quot;)End Sub Tài liệu tham khảoVBA Tutorial","link":"/2019/12/30/Visual-Basic-for-Applications-VBA-Notes/"},{"title":"[Web Server] Apache Notes","text":"Bài viết tổng hợp 1 vài note giúp mình thao tác Apache tốt hơn vào 1 ngày tìm lại được 2/3 đôi dép bị thất lạc Tổng quanDocs chínhhttps://httpd.apache.org/docs/2.4/ Apache2 quản lý 3 thứ quan trọng sites: quản lý các Virtual Hosts conf: configuration mods: modules Ứng với các thư mục conf-available, mods-availble, sites-available. Để bật tắt các site, conf, mods sử dụng lệnh123$ sudo a2enconf/a2disconf [conf_name]$ sudo a2enmod/a2dismod [mod_name]$ sudo a2ensite/a2dissite [virtual_host_site] Server LogsLogs trong apache2 mặc định được ghi tại /var/log/apache2/access.log: By default, every request to your web server is recorded in this log file unless Apache is configured to do otherwise. /var/log/apache2/error.log: By default, all errors are recorded in this file. The LogLevel directive in the Apache configuration specifies how much detail the error logs will contain. Port configCác cổng trong apache2 được cấu hình trong /etc/apache2/ports.conf. Mặc định, chỉ có 2 cổng được mở là 80 (dành cho các dịch vụ web http) vầ 443 (https). Bạn có thể mở thêm cổng (cái này dùng khi bạn muốn 1 domain triển khai nhiều projects khá hiệu quả - deploy lên staging chẳng hạn) bằng cách dùng thêm Listen12Listen 81Listen 82Sau đó bạn có thể sử dụng cổng này trong Virtual host đơn giản123456&lt;VirtualHost 10.0.0.1:81&gt; DocumentRoot &quot;/www/domain&quot;&lt;/VirtualHost&gt;&lt;VirtualHost 10.0.0.1:82&gt; DocumentRoot &quot;/www/other-domain&quot;&lt;/VirtualHost&gt; Một vài modules trong Apache2Tất cả các module trong Apache2 có thể tìm kiếm tại: https://httpd.apache.org/docs/2.4/mod/ Một vài modules hay sử dụng:https://www.digitalocean.com/community/tutorials/how-to-install-configure-and-use-modules-in-the-apache-web-server Rewrite ModuleMột trong những modules hữu ích trong Apache. Module này cho phép bạn sinh ra url duy nhất và dễ dàng có thể đọc được với nội dung request trên serverModule này mặc định được cài trên Ubuntu khi Apache được cài đặt nhưng không được kích hoạt. Để bật nó bạn cần12sudo a2enmod rewritesudo service apache2 reloadNếu chế độ này bị disale, khi truy cập vào URL tự sinh sẽ gây lỗi 404 Ngoài ra có 1 số module được sử dụng rất nhiều trong config cũng nên quan tâm mod_authz_core: Các tham số liên quan đến xác thực người dùng (Require) mod_access_compat: điều khiển truy cập các host nào được truy cập vào server $apacha2ctl, $apachectl commandLệnh này coi như là font end của hệ thống Apache HTTP Server. Nó được thiết kế để giúp quản trị viên kiểm soát được các chức năng chạy ngầm của apache2 Kiểm tra các modules nào đang đang bật trên apache2123$ apache2ctl -t -D DUMP_MODULES OR $ apache2ctl -MXem các thông số server1$ apache2ctl -SCó các thông tin về các host nào, cổng và các tên host. Ngoài ra còn có thông tin về user và nhóm user bạn cần cấp quyền để truy cập vào ứng dụng của bạn12User: name=&quot;www-data&quot; id=33Group: name=&quot;www-data&quot; id=33và quyết định cấp quyền cho người dùng web-server vào thư mục của bạn12sudo chown www-data:www-data -R storagesudo chown www-data:www-data -R bootstrap/cacheCác tùy chọn của apache2ctl command12345678910111213141516171819202122232425Usage: /usr/sbin/apache2 [-D name] [-d directory] [-f file] [-C &quot;directive&quot;] [-c &quot;directive&quot;] [-k start|restart|graceful|graceful-stop|stop] [-v] [-V] [-h] [-l] [-L] [-t] [-T] [-S] [-X]Options: -D name : define a name for use in &lt;IfDefine name&gt; directives -d directory : specify an alternate initial ServerRoot -f file : specify an alternate ServerConfigFile -C &quot;directive&quot; : process directive before reading config files -c &quot;directive&quot; : process directive after reading config files -e level : show startup errors of level (see LogLevel) -E file : log startup errors to file -v : show version number -V : show compile settings -h : list available command line options (this page) -l : list compiled in modules -L : list available configuration directives -t -D DUMP_VHOSTS : show parsed vhost settings -t -D DUMP_RUN_CFG : show parsed run settings -S : a synonym for -t -D DUMP_VHOSTS -D DUMP_RUN_CFG -t -D DUMP_MODULES : show all loaded modules -M : a synonym for -t -D DUMP_MODULES -t : run syntax check for config files -T : start without DocumentRoot(s) check -X : debug mode (only one worker, do not detach) Cấu hình virtual hostOverview: https://httpd.apache.org/docs/2.4/vhosts/ Các tham số có ý nghĩa gì thì có thể tra ở đây:https://httpd.apache.org/docs/2.4/mod/core.html#directory Đây là một file cấu hình virtual host cơ bản, chúng ta cùng tìm hiểu các tham số và ý nghĩa của nó nhé:12345678910111213&lt;VirtualHost *:80&gt; ServerAdmin admin@laravel-demo.local DocumentRoot /var/www/html/laravel-demo/public ServerName laravel-demo.local ServerAlias www.laravel-demo.local &lt;Directory /var/www/html/laravel-demo/public&gt; AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined&lt;/VirtualHost&gt; Các tham số cơ bảnServerAdmin: địa chỉ emainl, cái mà server sẽ dùng khi gửi message lỗi tới client. ServerName and ServerAliasTrước khi tìm hiểu 2 tham số này có ý nghĩa gì, chúng ta hãy xem cách mà Apache xử lý khi nhận 1 request với virtual host nhé. Sẽ có 2 cách apache2 tìm kiếm 1 host là dựa vào Name-based or IP-based Virtual Hosts, và khi cấu hình chúng ta cũng làm như vậy. Name-based vs. IP-based Virtual Hosts IP-based virtual hosts sử dụng địa chỉ IP để kết nối và xác định chính xác virtual host. Do đó bạn phải chia IP cho mỗi host1234567&lt;VirtualHost 10.0.0.1:80&gt; DocumentRoot &quot;/www/domain&quot;&lt;/VirtualHost&gt;&lt;VirtualHost 10.0.0.2:80&gt; DocumentRoot &quot;/www/otherdomain&quot;&lt;/VirtualHost&gt; Như ví dụ trên bạn thấy các host đang được chia theo địa chỉ IP. Apache sẽ duyệt và virtual host nào trùng địa chỉ IP và cổng thì sẽ tiến hành chọn virtual host đó xử lý request. Hạn chế cách này như đã nói ở trên, mỗi host cần có 1 địa chỉ IP riêng Với name-based virtual hosting, server sẽ dựa vào phía client để báo lên hostname như 1 phần của HTTP headers. Sử dụng kỹ thuật này, rất nhiều hosts có thể dùng chung địa chỉ IP Khi có yêu cầu đến, máy chủ sẽ tìm thấy đối số &lt;Virtualhost&gt; phù hợp nhất (cụ thể nhất) dựa trên địa chỉ IP và cổng được sử dụng bởi yêu cầu. Nếu có nhiều hơn một máy chủ ảo chứa kết hợp cổng và địa chỉ phù hợp nhất này, Apache sẽ so sánh thêm các chỉ thị ServerName và ServerAlias với tên máy chủ có trong yêu cầu. Trong trường hợp không gán ServerName khi có nhiều hosts sử dụng chung địa chỉ IP và cổng, server sẽ gán cho nó 1 tên mặc định. Tên này có thể dẫn đến việc kết hợp với virtual host lỗi, do đó không được khuyến khích. Tốt nhất là bạn nên tự đặt tên ServerNam cho server của mình. Using Name-based Virtual Hosts Ví dụ, bạn đang có server với domain www.example.com và bạn muốn thêm 1 virtual host với other.example.com, với 2 hosts đều trỏ tới cùng 1 địa chỉ IP.1234567891011&lt;VirtualHost *:80&gt; # This first-listed virtual host is also the default for *:80 ServerName www.example.com ServerAlias example.com DocumentRoot &quot;/www/domain&quot;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName other.example.com DocumentRoot &quot;/www/otherdomain&quot;&lt;/VirtualHost&gt;Mỗi servers muốn có thể được truy cập bằng nhiều tên. Điều đó hoàn toàn có thể với ServerAlias directive, đặt bên trong &lt;VirtualHost&gt; section. Ví dụ: trong khối &lt;Virtualhost&gt; đầu tiên ở trên, chỉ thị ServerAlias chỉ ra rằng các tên được liệt kê là các tên khác mà mọi người có thể sử dụng để xem cùng một trang web:1ServerAlias example.com *.example.comvà sau đó request từ tất cả các host example.com domain sẽ được xử lý bởi www.example.com virtual host. Các ký tự đại diện * và? có thể được sử dụng để khớp tên. Các Name-based virtual hosts cho bộ &lt;Virtualhost&gt; phù hợp nhất được xử lý theo thứ tự chúng xuất hiện trong cấu hình. ServerName hoặc ServerAlias phù hợp đầu tiên được sử dụng, không có quyền ưu tiên khác nhau cho các ký tự đại diện (cũng như cho ServerName so với ServerAlias). Các tham số sub-directories123AllowOverride AllOrder allow,denyAllow from all Các tham số Allow, Deny, Order đều nằm trong mod_access_compat, thêm đó còn có tham số Satisfy dùng khi có 1 số vùng cần hạn chế người dùng truy cập AllowOverrideLoại đường dẫn cho phép .htaccess files (trả lời câu hỏi: apache2 load file .htaccess ở đâu?) Cú pháp12345AllowOverride All|None|directive-type [directive-type] ...Với các giá trị None: .htaccess file sẽ bị ignore. Trong trường hợp này, server sẽ thậm chí không đọc được All: file.htaccess ở đâu cũng được Allow fromTham số này xác định hosts nào có thể truy cập vào khu vực trên server Deny fromÝ nghĩa ngược lại với allow (Allow và deny có thể lấy từ config) OrderSắp xếp ưu tiên khi xử lý request SatisfyMô tả: tích hợp giữa host-level access control và xác thực người dùng Các chính sách về truy cập nếu cả Allow và Require được sử dụng. Tham số có thể là All hoặc Any. Tham số này hữu ích nếu quyền truy cập vào 1 số khu vực cụ thể bị hạn chế, cần có thông tin xác thực để truy cập chẳng hạn. Ví dụ: nếu bạn muốn cho phép mọi người trong mạng của mình có quyền truy cập không hạn chế vào một phần của trang web của bạn, nhưng yêu cầu những người bên ngoài mạng của bạn cung cấp mật khẩu, bạn có thể sử dụng một cấu hình tương tự như sau:123Require valid-userAllow from 192.168.1Satisfy AnyTrường hợp khác hay được sử dụng hơn Satisfy directive để nới thêm truy cập cho 1 thư mục con12345678&lt;Directory &quot;/var/www/private&quot;&gt; Require valid-user&lt;/Directory&gt;&lt;Directory &quot;/var/www/private/public&quot;&gt; Allow from all Satisfy Any&lt;/Directory&gt;Trong ví dụ trên, sự xác thực cần được thực hiện khi truy cập vào đường dẫn /var/www/private nhưng lại không cần khi truy cập vào đường dẫn /var/www/private/public Ý kiến cá nhân về Require và Allow: Tham số require thiên về việc xác thực người dùng được truy cập vào ứng dụng Tham số Allow liên quan đến hosts nào và địa chỉ IP RequireXác thực, phân quyền người dùng. Chi tiết Tổng kết Apache quản lý 3 thứ: sites (virtual host), conf, modules apache2ctl, apachectl giúp thao tác apache tốt hơn nhờ tương tác với các tiến trình ngầm của apache và hiển thị dưới dạng giao diện Khi cấu hình virtual host có thể dùng Name-based vs. IP-based Virtual Hosts. Với IP-based Virtual Hosts yêu cầu bạn cần có nhiều địa chỉ IP (không thì bật nhiều host cũng được, môi trường test hoặc staging có thể mở nhiều host, khi lên product chỉ mở 80 mới là vấn đề)Khi cấu hình virtual host hãy tham khảo các tham số như ở trên nhé ServerName, ServerAlias, Required, Deny, Allow, Order :D","link":"/2019/11/21/Web-Server-Apache-Note/"},{"title":"[Web server] Proxy Server","text":"Proxy là một Internet server làm nhiệm vụ chuyển tiếp thông tin và kiểm soát tạo sự an toàn cho việc truy cập Internet của các máy khách, còn gọi là khách hàng sử dụng dịch vụ Internet. Trạm cài đặt proxy gọi là proxy server. Proxy hay trạm cài đặt proxy có địa chỉ IP và một cổng truy cập cố định. Ví dụ: 123.234.111.222:80. Địa chỉ IP của proxy trong ví dụ là 123.234.111.222 và cổng truy cập là 80. Một tóm tắt khác về Proxy dễ tiếp cậnNguyên tắc hoạt động cơ bản của proxy Server là : Proxy server xác định những yêu cầu từ phía client và quyết định đáp ứng hay không đáp ứng, nếu yêu cầu được đáp ứng, proxy server sẽ kết nối tới server thật thay cho client và tiếp tục chuyển tiếp đến những yêu cầu từ client đến server, cũng như đáp ứng những yêu cầu của server đến client. Chức năng của proxy Giúp nhiều máy tính của công ty truy cập Internet thông qua một máy tính đại diện cùng với tài khoản truy cập nhất định, đại diện máy tính này được gọi là Proxy server. Chỉ duy nhất máy Proxy này cần modem và account truy cập Internet, các máy client (các máy trực thuộc) muốn truy cập Internet qua máy này chỉ cần nối mạng LAN tới máy Proxy và truy cập địa chỉ yêu cầu. Những yêu cầu của người sử dụng sẽ qua trung gian proxy server thay thế cho server thật sự mà người sử dụng cần giao tiếp, tại điểm trung gian này công ty kiểm soát được mọi giao tiếp từ trong công ty ra ngoài Internet và từ Internet vào máy của công ty Tiết kiệm băng thông và cải thiện tốc độ. Sử dụng Proxy, công ty có thể cấm nhân viên truy cập những địa chỉ web không cho phép, cải thiện tốc độ truy cập nhờ sự lưu trữ cục bộ các trang web trong bộ nhớ của proxy server và giấu định danh địa chỉ của mạng nội bộ gây khó khăn cho việc thâm nhập từ bên ngoài vào các máy của công ty. Proxy Server và Caching: Các máy chủ proxy có thể lưu vào bộ nhớ cache (lưu một bản sao trang web cục bộ) các trang web hay truy cập. Điều này giúp tiết kiệm băng thông của công ty và cải thiện hiệu suất mạng. Bộ lọc thông tin. Đối với các nhà cung cấp dịch vụ đường truyền Internet: Do Internet có nhiều lượng thông tin mà theo quan điểm của từng quốc gia, từng chủng tộc hay địa phương mà các nhà cung cấp dịch vụ Internet khu vực đó sẽ phối hợp sử dụng proxy với kỹ thuật tường lửa để tạo ra một bộ lọc gọi là firewall proxy nhằm ngăn chặn các thông tin độc hại hoặc trái thuần phong mỹ tục đối với quốc gia, chủng tộc hay địa phương đó. Địa chỉ các website mà khách hàng yêu cầu truy cập sẽ được lọc tại bộ lọc này, nếu địa chỉ không bị cấm thì yêu cầu của khách hàng tiếp tục được gửi đi, tới các DNS server của các nhà cung cấp dịch vụ. Firewall proxy sẽ lọc tất cả các thông tin từ Internet gửi vào máy của khách hàng và ngược lại. Ý nghĩa của proxy Proxy không chỉ có giá trị bởi nó làm được nhiệm vụ của một bộ lọc thông tin, nó còn tạo ra được sự an toàn cho các khách hàng của nó, firewall Proxy ngăn chặn hiệu quả sự xâm nhập của các đối tượng không mong muốn vào máy của khách hàng. Proxy lưu trữ được các thông tin mà khách hàng cần trong bộ nhớ, do đó làm giảm thời gian truy tìm làm cho việc sử dụng băng thông hiệu quả. Proxy server giống như một vệ sĩ bảo vệ khỏi những rắc rối trên Internet. Một Proxy server thường nằm bên trong tường lửa, giữa trình duyệt web và server thật, làm chức năng tạm giữ những yêu cầu Internet của các máy khách để chúng không giao tiếp trực tiếp Internet. Người dùng sẽ không truy cập được những trang web không cho phép (bị cấm). Mọi yêu cầu của máy khách phải qua Proxy server, nếu địa chỉ IP có trên proxy, nghĩa là website này được lưu trữ cục bộ, trang này sẽ được truy cập mà không cần phải kết nối Internet, nếu không có trên Proxy server và trang này không bị cấm, yêu cầu sẽ được chuyển đến server thật, DNS server… và ra Internet. Proxy server lưu trữ cục bộ các trang web thường truy cập nhất trong bộ đệm để giảm chi phí kết nối, giúp tốc độ duyệt web nhanh hơn. Proxy server bảo vệ mạng nội bộ khỏi bị xác định bởi bên ngoài bằng cách mang lại cho mạng hai định danh: một cho nội bộ, một cho bên ngoài. Điều này tạo ra một “bí danh” đối với thế giới bên ngoài và gây khó khăn đối với nếu người dùng “tự tung tự tác” hay các hacker muốn xâm nhập trực tiếp máy tính nào đó. Cách sử dụng proxy hiệu quảDo các proxy có quy mô bộ nhớ khác nhau và số lượng người đang sử dụng proxy nhiều-ít khác nhau, Proxy server hoạt động quá tải thì tốc độ truy cập Internet của khách hàng có thể bị chậm. Mặt khác một số website khách hàng có đầy đủ điều kiện nhân thân để đọc, nghiên cứu nhưng bị tường lửa chặn không truy cập được thì biện pháp đổi proxy để truy cập là điều cần thiết nhằm đảm bảo công việc. Do đó người sử dụng có thể chọn proxy server để sử dụng cho riêng mình. Có các cách chọn lựa cho người sử dụng. Sử dụng proxy mặc định của nhà cung cấp dịch vụ (Internet), trường hợp này người sử dụng không cần điền địa chỉ IP của proxy vào cửa sổ Internet option của trình duyệt trong máy của mình. Sử dụng proxy server khác (phải trả phí hoặc miễn phí) thì phải điền địa chỉ IP của proxy server vào cửa sổ Internet option của trình duyệt. Phân loại ProxyCaching Proxy ServerCaching là bảo quản các yêu cầu (request) của client với sự giúp đỡ cùa các nội dung đã được lưu trữ từ các yêu cầu trước đó (previous request). Không có sự liên hệ theo danh nghĩa server Web Proxy Proxy nhắm đến mục tiêu World Wide Web được gọi là Web proxy Web proxy Server như là web cache Anonymizing Proxy ServerAnonymizing Proxy Server cố gắn để ẩn danh khi lướt web Hostile ProxyĐược sử dụng để nghe trộm trên đường truyền dữ liệu giữa máy client và web Intercepting Proxy Server Nó là sự kết hợp proxy server với một gateway Thường được sử dụng trong các doanh nghiệp, các quản trị muốn áp đặt các chính sách của policy lên người dùng Forced ProxyLà sự kết hợp các chính sách của intercepting và non-intercepting Open proxy serverNó là một proxy có thể được sử dụng bởi bất kỳ người dùng Internet Split Proxy ServerSplit proxy là một proxy bổ sung như là 2 chương trình được cài đặt trên 2 máy tính khác nhau Reverse Proxy Server Là một proxy server được cài đặt trên các phân vùng của một hoặc nhiều web server Một reverse proxy có thể luân chuyển request cho nhiều server cùng lúc. CircumventorCircumventor là một phương pháp defeating bloking polices, được triển khai thực hiện bằng các proxy server. Hầu hết các circumventor cũng là các proxy server Transparent proxyTransparent proxy là một proxy không sữa đổi request hoặc response ngoài những gì được yêu cầu cho proxy authentication và identification. Nó làm việc trên port 80. Non Transparent Proxy Non-Transparent Proxy là một proxy làm thay đổi request hoặc response để cung cấp thêm một vài dịch vụ đến người dùng Web request được gửi trực tiếp đến proxy server bất kể nó có nguồn gốc từ đâu. Socks Proxy Sock là một chuẩn IETF (Internet Engineering Task Force) Nó giống như một hệ thống proxy có hỗ trợ các ứng dụng proxy aware Các SOCK package bao gồm hoặc chứa các thành phần sau: 1 SOCK server cho việc xác định hệ điều hành 1 chương trình client như là: FTP, telnet hoặc trình duyệt 1 client thư viện cho các SOCK Các sock proxy server không cho phép các thành phần bên ngoài thu thập thông tin của client đã tạo ra request Server Proxy miễn phí Các cuộc tấn công sử dụng hàng ngàn proxy server trên thế giới nên khó mà trace được Hàng ngàn proxy server miễn phí có sẵn trên Internet Search với từ khóa “free proxy servers” trên Google Một vài thứ trong đó có thể là một “honeypot” (tạm dịch là Mắt Ong) nhằm bắt quả tang các hacker Sử dụng các proxy server có thể truy ra mask. Với kinh nghiệm ít ỏi của mình, tác giả chỉ biết sử dụng Reverse Proxy Server trong các cấu hình Apache2 Đọc thêm Quản trị mạng Viettelidc Wikipedia","link":"/2020/05/31/Web-server-Proxy-Server/"},{"title":"jQuery Validation Plugin","text":"Một vài notes lại khi làm việc với jQuery validation plugin nào! Plugin methodsThư viện này cung cấp 3 phương thức chính, sử dụng chủ yếu để validate dữ liệu: Đây là phần chính của jQuery validation, chỉ cần có nó là chạy được nếu bạn không muốn custom gì, code mẫu đơn giản sẽ như sau :D validate(): validate các trường được chọn trong form valid():– Kiểm tra xem validate đã đúng hay chưa, kết quả trả về true/false rules(): – Đọc, thêm và xóa rules cho 1 element. 12345678910111213141516171819202122232425262728$(&quot;#myform&quot;).validate({ rules: { // simple rule, converted to {required:true} name: &quot;required&quot;, // compound rule email: { required: true, email: true } }, messages: { name: &quot;Please specify your name&quot;, email: { required: &quot;We need your email address to contact you&quot;, email: &quot;Your email address must be in the format of name@domain.com&quot; } }, highlight: function(element, errorClass, validClass) { $(element).addClass(errorClass).removeClass(validClass); $(element.form).find(&quot;label[for=&quot; + element.id + &quot;]&quot;) .addClass(errorClass); }, unhighlight: function(element, errorClass, validClass) { $(element).removeClass(errorClass).addClass(validClass); $(element.form).find(&quot;label[for=&quot; + element.id + &quot;]&quot;) .removeClass(errorClass); }}); Các tham số tùy chọn trong phương thức validate: rules: các rule ứng với từng trường trong form messages: thông báo hiện lỗi hightlight, unhighlight: tùy chỉnh highlight với các trường lỗi (thêm css hiển thị lỗi hay gì đó) Sau đó mỗi khi submit hoặc bất cứ khi nào bạn muốn validate dữ liệu, hãy chạy hàm valid() 123$('#my-button').click(function() { $(&quot;#myform&quot;).valid()}) Đó là tất cả những gì bạn cần để chạy validation. Phần sau chỉ là custom các rule và methods thôi! ValidatorPhương thức validate() ở trên trả về cho bạn 1 đối tượng Validator và có những phương thức public bạn có thể sử dụng để tự validation hoặc thay đổi nội dung form. Các phương thức sẽ như sau: Validator.form() – Validates the form. Bình thường validate chạy khi submit form, bạn có thể sử dụng phương thứu này để chạy bất cứ khi nào bạn muốn hoặc kiểm tra validate. Nó sẽ trả về true nếu pass validation và false nếu ngược lại 123// Giống phương thức valid() nhỉvar validator = $( &quot;#myform&quot; ).validate();validator.form(); Validator.element() – Validates a single element. 12var validator = $( &quot;#myform&quot; ).validate();validator.element( &quot;#myselect&quot; ) Validator.resetForm() – Resets the controlled form. Validator.showErrors() – Show the specified messages. 1234var validator = $( &quot;#myshowErrors&quot; ).validate();validator.showErrors({ &quot;firstname&quot;: &quot;I know that your firstname is Pete, Pete!&quot;}); Validator.numberOfInvalids() – Returns the number of invalid fields. Validator.destroy() – Destroys this instance of validator. Các phương thức tĩnh để tạo một methods: addMethod(): cái này chắc là được dùng nhiều nhất - Thêm 1 custom validation method 123$.validator.addMethod(&quot;domain&quot;, function(value, element) { return this.optional(element) || /^http:\\/\\/mycorporatedomain.com/.test(value);}, &quot;Please specify the correct domain for your documents&quot;); setDefaults(): định nghĩa lại các cài đặt cho validation 123jQuery.validator.setDefaults({ debug: true}); format(): Thay thế hiển thị (hiển thị lỗi chẳng hạn) List of built-in Validation methodsDanh sách các phương thức validate, các rule bạn đọc ở trang chủ nhé :D required – Makes the element required. remote – Requests a resource to check the element for validity. minlength – Makes the element require a given minimum length. maxlength – Makes the element require a given maximum length. rangelength – Makes the element require a given value range. min – Makes the element require a given minimum. max – Makes the element require a given maximum. range – Makes the element require a given value range. step – Makes the element require a given step. email – Makes the element require a valid email url – Makes the element require a valid url date – Makes the element require a date. dateISO – Makes the element require an ISO date. number – Makes the element require a decimal number. digits – Makes the element require digits only. equalTo – Requires the element to be the same as another one Đây không phải là toàn bộ rule. Nó cung cấp thêm 1 file additional-methods.js cho phép bạn sử dụng các tiện ích thêm cho validate (như check extension của 1 file, kiểm tra số điện thoại …) accept – Makes a file upload accept only specified mime-types. creditcard – Makes the element require a credit card number. extension – Makes the element require a certain file extension. phoneUS – Validate for valid US phone number. require_from_group – Ensures a given number of fields in a group are complete.…. Chưa hết nhé, bạn có thể tìm kiếm tất cả các phương thức thêm tại đây:You can find the source code for all additional methods in the GitHub repository. Và bạn cũng có thể custom lại các phương thức validate đã có sẵn theo ý mình:It is possible to re-define the implementation of the built-in rules using the $.validator.methods property Tổng kết jQuery validation khá đơn giản, chỉ cần phương thức validate() cho form Thư viện này cung cấp cho bạn rất nhiều các phương thức validate mặc định. Ngoài ra, bạn import thêm file additional-methods.js để thêm các phương thức tiện ích khác của thư viện nhé, nhiều lắm @@. Bạn cần validate với form nhé (có thẻ form), không form hơi khó đó (hiện tại chưa biết cách nào)https://stackoverflow.com/questions/15231847/jquery-validation-without-form-tag It is absolutely required that you have tags for the jQuery Validate plugin to function properly, or at all. Nếu bạn cần validate khi chưa submit hay ajax để validate, hãy sử dụng phương thức valid() 123$('#my-button').click(function() { $(&quot;#myform&quot;).valid()})","link":"/2020/01/09/jQuery-Validation-Plugin/"},{"title":"Chapter 10: Extracting Unrelated Subproblems","text":"Kĩ thuật là tất cả về việc chia nhỏ vấn đề lớn thành những vấn đề nhỏ hơn và đưa ra các giải pháp cho vấn đề đó lại với nhau. Áp dụng nguyên tắc này làm code dễ dàng đọc hơn. Lời khuyên của chương này là chủ động xác định và trích xuất các bài toán con không liên quan. Điều đó có nghĩa: Nhìn vào 1 hàm và khối code và tự hỏi “Mục đích ở mức high-level của đoạn code này?” Với mỗi dòng code, hỏi “Nó có làm trực tiếp mục đích đó? Không thì nó đang giải quyết các vấn đề con không liên quan cần thiết để đáp ứng mục đích đó?” Nếu đủ các dòng đang giải quyết các vấn đề con không liên quan, trích xuất code này vào trong các hàm tách biệt. Trích xuất code vào các hàm riêng việt có lẽ là việc bạn làm hàng ngày. Nhưng trong chương này, chúng ta quyết định tập trung vào trường hợp riêng và trích xuất vào các vấn đề con không liên quan” nơi mà trích xuất code không biets tại sao nó lại được gọi. Như bạn thấy, đây là 1 kĩ thuật dễ dàng để áp dựng nhưng cải thiện code của bạn đáng kể. Nhưng vì 1 số lý do nào đó, các lập trình viên không sử dụng đủ kỹ thuật này. Bí quyết (Mẹo) này chủ động nhìn cho các vấn đề con không liên quan. Trong chương này chúng ta sẽ cùng xem xét 1 vài ví dụ minh họa kĩ thuật này để giải quyết các vấn đề khác nhau bạn có thể gặp phải. Introductory Example: findClosestLocation()Mục đích chính của đoạn code JavaScript dưới đây là tìm kiếm vị trí gần nhất của 1 điểm” (đừng chú ý quá vào phần địa lý, phần in nghiêng):1234567891011121314151617181920212223// Return which element of 'array' is closest to the given latitude/longitude.// Models the Earth as a perfect sphere.var findClosestLocation = function (lat, lng, array) { var closest; var closest_dist = Number.MAX_VALUE; for (var i = 0; i &lt; array.length; i += 1) { // Convert both points to radians. var lat_rad = radians(lat); var lng_rad = radians(lng); var lat2_rad = radians(array[i].latitude); var lng2_rad = radians(array[i].longitude); // Use the &quot;Spherical Law of Cosines&quot; formula. var dist = Math.acos(Math.sin(lat_rad) * Math.sin(lat2_rad) + Math.cos(lat_rad) * Math.cos(lat2_rad) * Math.cos(lng2_rad - lng_rad)); if (dist &lt; closest_dist) { closest = array[i]; closest_dist = dist; } } return closest;};Đa số code trong vòng lặp làm những việc cho các vấn đề con không liên quan: tính toán khoảng cách hình cầu giữa 2 điểm lat/long*. Vì rất nhiều code làm việc này, ý nghĩa hơn bạn nên trích xuất nó thành 1 hàm riêng với tên spherical_distance():1234567891011var spherical_distance = function (lat1, lng1, lat2, lng2) { var lat1_rad = radians(lat1); var lng1_rad = radians(lng1); var lat2_rad = radians(lat2); var lng2_rad = radians(lng2); // Use the &quot;Spherical Law of Cosines&quot; formula. return Math.acos(Math.sin(lat1_rad) * Math.sin(lat2_rad) + Math.cos(lat1_rad) * Math.cos(lat2_rad) * Math.cos(lng2_rad - lng1_rad));};Bây giờ đoạn code còn lại trở thành:123456789101112var findClosestLocation = function (lat, lng, array) { var closest; var closest_dist = Number.MAX_VALUE; for (var i = 0; i &lt; array.length; i += 1) { var dist = spherical_distance(lat, lng, array[i].latitude, array[i].longitude); if (dist &lt; closest_dist) { closest = array[i]; closest_dist = dist; } } return closest;};Đoạn code này đã dễ dàng đọc hơn vì người đọc có thể tập trung vào mục đích cao nhất của nó mà không bị phân tâm vào việc tính khoảng cách địa lý. Như 1 phần thưởng bổ sung, spherical_distance() sẽ dễ dàng để test cô lập. Và spherical_distance() là 1 loại hàm có thể được sử dụng lại trong tương lai. Điều này lý giải vì sao nó là các vấn đề con “không liên quan” - nó hoàn toàn tự chứa chính nó và không biết ứng dụng sử dụng nó như thế nào. Pure Utility Code (Phần này kiểu hepler, codebase cung cấp các code tiện ích ấy)Đây là bộ trung tâm của các nhiệm vụ cơ bản đa số chương trình cần làm, như các thao tác chuỗi, sử dụng hash tables và đọc/ghi files. Thường xuyên, các “tiện ích cơ bản” này đã thực thi các built-in libraries trong ngôn ngữ lập trình. Ví dụ, nếu bạn muốn đọc nội dung file trong PHP, bạn có thể sử dụng hàm file_get_contents(&quot;filename&quot;) hoặc với Python, bạn có thể sử dụng open(&quot;filename&quot;).read(). Nhưng đôi khi bạn phải tự điền vào chỗ trống. Trong C++, ví dụ, không có cách ngắn gọn nào đọc 1 file đầu vào. Thay vào đó, bạn chắn chắn phải viết code như sau:12345678910111213ifstream file(file_name);// Calculate the file's size, and allocate a buffer of that size.file.seekg(0, ios::end);const int file_size = file.tellg();char* file_buf = new char [file_size];// Read the entire file into the buffer.file.seekg(0, ios::beg);file.read(file_buf, file_size);file.close();...Đây là ví dụ cơ bản để hiểu các vấn đề không liên quan nên được trích xuất vào 1 hàm riêng với tên gọi ReadFileToString(). Bây giờ phàn còn lại codebase của bạn có thể gọi như C++ đã có hàm ReadFileToString(). Nói chung nếu bạn thấy mình đang nghĩ “Tôi muốn thư viện của chúng ta có hàm XYZ()”, thì hãy viết nó! (Giả định là nó chưa tồn tại). Theo thời gian, bạn sẽ xây dựng được 1 tập các mã tiện ích có thể sử dụng trên các dự án. Other General-Purpose CodeKhi debugging JavaScript, các lập trình viên thường sử dụng alert() để hiển thị 1 thông báo chứa các thông tin họ cần, nó là phiên bản “printf() debugging” của Web. Ví dụ, hàm sao gọi submits dữ liệu tới server sử dụng Ajax và sau đó hiển thị trực tiếp kết quả nhận được từ server:12345678910111213ajax_post({ url: 'http://example.com/submit', data: data, on_success: function (response_data) { var str = &quot;{\\n&quot;; for (var key in response_data) { str += &quot; &quot; + key + &quot; = &quot; + response_data[key] + &quot;\\n&quot;; } alert(str + &quot;}&quot;); // Continue handling 'response_data' ... }});Mục đích chính của hàm này là Tạo một lời gọi Ajax trên server và xử lý response”. Nhưng rất nhiều code lại đang xử lý vấn đề con không liên quan, Pretty-print a dictionary*. Vậy nên dễ dàng tách đoạn code này vào 1 hàm như format_pretty(obj):1234567var format_pretty = function (obj) { var str = &quot;{\\n&quot;; for (var key in obj) { str += &quot; &quot; + key + &quot; = &quot; + obj[key] + &quot;\\n&quot;; } return str + &quot;}&quot;;}; Unexpected BenefitsCó rất nhiều lý do mà trích xuất format_pretty() là 1 ý tưởng tốt. Nó làm lời gọi code đơn giản hơn và format_pretty() có những chức năng tiện dụng xung quanh. Nhưng có những lý do tuyệt vời khác không rõ ràng: dễ dàng cải tiến ormat_pretty() khi mà code là của chính nó. Khi bạn đang làm việc với 1 hàm nhỏ hơn không liên quan, cảm giác dễ dàng để thêm tính năng, cải thiện khả năng đọc code, xem xét các trường hợp cạnh và nhiều hơn nữa. Đây là 1 vài trường hợp format_pretty(obj) không xử lý: Nó mong đợi obj là 1 đối tượng. Nếu thay vì đó nó là 1 chuỗi (hoặc undefined) đoạn code hiện tại có thể ném ra 1 ngoại lệ Nó mong đợi mỗi giá trị trong obj là kiểu đơn giản. Nếu thay vì nó chứa các object lồng nhau, đoạn code hiện tại sẽ hiển thị [object Object] có vẻ không đẹp. Trước khi bạn tách format_pretty() từ hàm chủ của nó, nó sẽ cảm thấy rất nhiều việc cần phải cải thiện. (Trên thực tế, việc in đệ quy đối tượng lồng nhau rất khó mà không có 1 hàm tách biệt) Nhưng bây gườ, thêm hàm này thì việc đó sẽ dễ dàng. Hãy cùng xem cách cải tiến đoạn code đó:1234567891011121314151617var format_pretty = function (obj, indent) { // Handle null, undefined, strings, and non-objects. if (obj === null) return &quot;null&quot;; if (obj === undefined) return &quot;undefined&quot;; if (typeof obj === &quot;string&quot;) return '&quot;' + obj + '&quot;'; if (typeof obj !== &quot;object&quot;) return String(obj); if (indent === undefined) indent = &quot;&quot;; // Handle (non-null) objects. var str = &quot;{\\n&quot;; for (var key in obj) { str += indent + &quot; &quot; + key + &quot; = &quot;; str += format_pretty(obj[key], indent + &quot; &quot;) + &quot;\\n&quot;; } return str + indent + &quot;}&quot;;};Đoạn code trên đã sửa được những thiết sót được liệt kê ở trên và tạo đầu ra như sau:1234567891011{ key1 = 1 key2 = true key3 = undefined key4 = null key5 = { key5a = { key5a1 = &quot;hello world&quot; } }} Create a Lot of General-Purpose CodeHàm ReadFileToString() và format_pretty() là những ví dụ tuyệt vời cho các vấn đề con không liên quan. Nó rất cơ bản và áp dụng rộng rãi và được sử dụng lại trong các dự án. Codebase thường xuyên có những thư mục đặc biệt dành cho những đoạn code như vậy (ví dụ như util/) do đó bạn có thể dễ dàng chia sẻ. Code cho mục đích chung là tốt vì nó đã hoàn toàn tách rời phần còn lại của project. Code như vậy dễ dàng phát triển, dễ dàng kiểm thử và dễ dàng để hiểu. Nếu tất cả các code của bạn chỉ nên như vậy!! Suy nghĩ nhiều hơn về sức mạnh của các thư viện và hệ thống bạn sử dụng, như SQL databases, JavaScript libraries, và HTML. Bạn không phải lo lắng về những thứ bên trong nó - các codebase này hoàn toàn độc lập với project của bạn. Và kết quả, phần còn lại codebase project bản bạn sẽ nhỏ. Càng nhiều dự án của bạn, bạn có thể tách ra làm thư viện bị cô lập thì càng tốt, bởi vì phần còn lại của mã của bạn sẽ nhỏ hơn và dễ suy nghĩ hơn. IS THIS TOP-DOWN OR BOTTOM-UP PROGRAMMING?Top-down programming is a style where the highest-level modules and functions are designed first and the lower-level functions are implemented as needed to support them. Bottom-up programming tries to anticipate and solve all the subproblems first and then build the higher-level components using these pieces. This chapter isn’t advocating one method over the other. Most programming involves a combinationof both. What’s important is the end result: subproblems are removed and tackled separately. Project-Specific FunctionalityVề ý tưởng, các vấn đề con bạn trích xuất có thể hoàn toàn không theo dự án. Nhưng thậm chí như vậy, nó vẫn okay. Phá vỡ các vấn đề con vẫn là làm việc tuyệt vời. Đây là 1 ví dụ từ 1 website đánh giá kinh doanh. Đoạn code Python tạo đối tượng Business và set name, url và data_creadted cho nó:1234567891011business = Business()business.name = request.POST[&quot;name&quot;]url_path_name = business.name.lower()url_path_name = re.sub(r&quot;['\\.]&quot;, &quot;&quot;, url_path_name)url_path_name = re.sub(r&quot;[^a-z0-9]+&quot;, &quot;-&quot;, url_path_name)url_path_name = url_path_name.strip(&quot;-&quot;)business.url = &quot;/biz/&quot; + url_path_namebusiness.date_created = datetime.datetime.utcnow()business.save_to_database()url giả định là bản “clean” của name. Ví dụ, nếu name là “A.C. Joe’s Tire &amp; Smog, Inc.” thì url sẽ là “/biz/ac-joes-tire-smog-inc”. Vấn đề con không liên quan ở đây là: biến tên thành 1 URL hợp lệ. Chúng ta có thể trích xuất đoạn code này:12345678CHARS_TO_REMOVE = re.compile(r&quot;['\\.]+&quot;)CHARS_TO_DASH = re.compile(r&quot;[^a-z0-9]+&quot;)def make_url_friendly(text): text = text.lower() text = CHARS_TO_REMOVE.sub('', text) text = CHARS_TO_DASH.sub('-', text) return text.strip(&quot;-&quot;)Bây giờ đoạn code ban đầu có các mẫu “thông thường” nhiều hơn:12345business = Business()business.name = request.POST[&quot;name&quot;]business.url = &quot;/biz/&quot; + make_url_friendly(business.name)business.date_created = datetime.datetime.utcnow()business.save_to_database()Đoạn code này yêu cầu ít thời gian hơn để đọc vì bạn không bị mất tập trung vào các biểu thức chính quy và các xử lý string. Bạn nên đặt code cho make_url_friendly() ở chỗ nào? Nó dường như là 1 hàm khác chung, do đó hợp lý thì nó nên đặt trong thư mục riêng biệt util/. Mặt khác, biểu thức chính quy này được thiết kế với tên doanh nghiệp U.S, do đó có thể đoạn code nên trong file nó đang sử dụng. Thực tế điều đó không quan trọng, và bạn có thể dễ dàng chuyển thư mục sao đó. Điều quan trọng ở đây mà hàm make_url_friendly() được tách ra. Simplifying an Existing InterfaceMọi người yêu thích khi thư viện có gian diện rõ ràng - 1 trong số đó là có vài tham số, không cần cài đặt niều và thường ít cần tìm hiểu. Nó làm cho code của bạn nhìn thanh lịch: đơn giản và mạnh mẽ cùng 1 thời điểm. Nhưng nếu interface bạn đang sử dụng không rõ ràng, bạn có thể làm có các hàm “bọc” nó Ví dụ làm việc với browser cookie trong JavaScript. Về khái niệm, cookies là 1 tập các cặp key/value. Nhưng interface mà browser cung cấp chỉ có chuỗi document.cookie như sau:1name1=value1; name2=value2; ...Để tìm cookie bạn muốn, bạn buộc phải chuyển chuỗi khổng lồ này. Đây là 1 ví dụ code đọc giá trị từ cookie với tên “max_results”:12345678var max_results;var cookies = document.cookie.split(';');for (var i = 0; i &lt; cookies.length; i++) { var c = cookies[i]; c = c.replace(/^[ ]+/, ''); // remove leading spaces if (c.indexOf(&quot;max_results=&quot;) === 0) max_results = Number(c.substring(12, c.length));}Wow, 1 đoạn mã xấu xí. Tõ ràng, có 1 hàm get_cookie() chờ đợi chúng ta làm để chúng ta chỉ cần viết:1var max_results = Number(get_cookie(&quot;max_results&quot;));Tạo hoặc thay đổi giá trị cookie thậm chí là xa lạ. Bạn phải sẻ document.cookie giá trị với cú pháp:1document.cookie = &quot;max_results=50; expires=Wed, 1 Jan 2020 20:53:47 UTC; path=/&quot;;Câu lệnh nhìn như nó đang ghi đè tất cả các cookies đã tồn tại khác nhưng (magically), nó không làm vậy. Một interface lý tưởng để set 1 cookie sẽ như sau:1set_cookie(name, value, days_to_expire);Xóa bỏ 1 cookie cũng không trực quan: bạn phải set cookie về hết hạn trong quá khứ. Thay vì đó, một interface lý tưởng nhìn đơn giản như sau:1delete_cookie(name);Bài học ở đây là bạn không bao giờ phải giải quyết cho một giao diện mà ít hơn lý tưởng. Bạn có thể luôn luộn tạo các hàm bọc để ẩn các chi tiết xấu của 1 interface bạn bị mắc kẹt. Reshaping an Interface to Your NeedsRất nhiều code trong 1 chương trình chỉ hỗ trợ code khác - ví dụ, thiết lập đầu vào cho 1 hàm hoặc xử lý đầu ra. Code “keo dán” này thường không làm gì với logic thực tế trong chương trình của bạn. Những đoạn mã như vậy là 1 ứng cử viên tuyệt vời để kéo ra vào 1 hàm riêng biệt. Ví dụ, hãy nói bạn có một Python dictionary chứa thông tin nhạy cảm của user như { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; } và bạn cần đưa tất cả thông tin đó vào trong URL. Bởi vì nó nhạy cảm, bạn quyết định mã hóa từ điển này, sử dụng Cipher class. Nhưng Cipher mong đợi chuỗi các bytes làm đầu vào, không phải 1 dictionary. Và Cipher trả về chuỗi bytes, nhưng chúng ta cần URL-safe. Cipher cũng nhận vào 1 vào tham số thêm và khá cồng kềnh để sử dụng. Những gì bắt đầu như 1 nhiệm vụ đơn giản, trong đó có rất nhiều code kết dính:1234567user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }user_str = json.dumps(user_info)cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)encrypted_bytes = cipher.update(user_str)encrypted_bytes += cipher.final() # flush out the current 128 bit blockurl = &quot;http://example.com/?user_info=&quot; + base64.urlsafe_b64encode(encrypted_bytes)...Mặc dù vấn đề chúng ta đang giải quyết là mã hóa thông tin user vào 1 URL, phần lớn đoạn code này chỉ làm mã hóa đối tượng Python vào chuỗi URL thân thiện. Sẽ đơn giản để thêm vấn đề con:123456def url_safe_encrypt(obj): obj_str = json.dumps(obj) cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str) encrypted_bytes += cipher.final() # flush out the current 128 bit block return base64.urlsafe_b64encode(encrypted_bytes)Sau đó, kết quả code thực thi logic thực sự trong chương trình chỉ đơn giản:12user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }url = &quot;http://example.com/?user_info=&quot; + url_safe_encrypt(user_info) Taking Things Too Far: Đưa mọi thứ đi quá xaNhư chúng ta đã nói từ đầu chương, mục đích của chúng ta là “tích cực xác định và trích xuất các vấn đề con không liên quan”. Chúng ta nói “tích cực” vì đa số người viết code không đủ tích cực. Nhưng nó có thể nhận được quá mức và đưa mọi thứ đi quá xa. Ví dụ, đoạn code từ phần trước có thể phá vỡ nhiều hơn, như sau:12345678910111213141516171819user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }url = &quot;http://example.com/?user_info=&quot; + url_safe_encrypt_obj(user_info)def url_safe_encrypt_obj(obj): obj_str = json.dumps(obj) return url_safe_encrypt_str(obj_str)def url_safe_encrypt_str(data): encrypted_bytes = encrypt(data) return base64.urlsafe_b64encode(encrypted_bytes)def encrypt(data): cipher = make_cipher() encrypted_bytes = cipher.update(data) encrypted_bytes += cipher.final() # flush out any remaining bytes return encrypted_bytesdef make_cipher():return Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)Cho tất cả các tiny functions này thực sự làm tổn thương khả năng đọc vì người đọc phải theo dõi quá nhiều và theo dõi con đường sự thực thi đòi hỏi phải nhảy xung quanh. Đây là 1 chi phí nhỏ (nhưng hữu hình) khả năng đọc code của việc thêm 1 hàm mới vào code của bạn. Trong trường hợp trước, không có gì đạt được để bù đắp chi phí này. Nó có lý thêm các hàm nhỏ hơn này nếu chúng cần bởi các phần khác trong project của bạn. Nhưng cho đến lúc đó, không có nhu cầu. Summary1 cách đơn giản để nghĩ về chương này là tách biệt các chung mã (generic code) ra khỏi code cụ thể của project.. Hóa ra, đa số code đều là chung. Bằng cách xây dựng 1 bộ thư viện lớn và các helper functions để giải quyết các vấn đề chung, những gì còn lại sẽ thực sự là mã chính nhỏ cái mà làm cho chương trình của bạn trở nên độc đáo. Lý do chính kĩ thuật này giúp các lập trình viên tập trung vào các vấn đề nhỏ hơn, xác định rõ ràng hơn cái mà được tách biệt ra khỏi phần còn lại trong project của bạn. Kết quả là, giải quyết các vấn đề không liên quan có xu hướng kỹ lưỡng và đúng đắn hơn. Bạn cũng có thể sử dụng lại chúng sau đó. FURTHER READING: ĐỌC THÊM Martin Fowler’s Refactoring: Improving the Design of Existing Code (Fowler et al., Addison-Wesley Professional, 1999) describes the “Extract Method” of refactoring and catalogs many other ways to refactor your code. Kent Beck’s Smalltalk Best Practice Patterns (Prentice Hall, 1996) describes the “Composed Method Pattern,” which lists a number of principles for breaking down your code into lots of little functions. In particular, one of the principles is “Keep all of the operations in a single method at the same level of abstraction.” These ideas are similar to our advice of “extracting unrelated subproblems.” What we discussed in this chapter is a simple and particular case of when to extract a method.","link":"/2020/05/24/Chapter-10-Extracting-Unrelated-Subproblems/"},{"title":"Chapter 11: One Task at a Time","text":"Code làm rất nhiều thứ 1 lúc rất khó hiểu. A khối đơn của code có thể khởi tạo đối tượng mới, làm sạch dữ liệu, phân tích inputs và áp dụng logic, tất cả cùng 1 lúc. Nếu tất cả code đan xem với nhau, nó sẽ khó để hiểu hơn là mỗi “task” được bắt đầu và tự hoàn thành. K E Y I D E ACode should be organized so that it’s doing only one task at a time. Nói cách khác, chương này đề cập đến vấn đề “phân mảnh” code của bạn. Theo dõi biểu đồ bên dưới để minh họa quá trình này: biểu đồ bên trái chỉ ra các đoạn mã khác nhau mà 1 phần của code đang làm và đoạn mã bên phải chỉ ra các đoạn code giống nhau sau khi nó được tổ chức làm 1 task 1 lúc. Bạn chắc hẳn đã nghe lời khuyên “hàm chỉ nên làm 1 thứ”. Lời khuyên của chung tôi tương tự vậy, nhưng nó không luôn luôn nói về ranh giới của hàm. Chắc chắn, phá vỡ các hàm lớn vào nhiều hàm nhỏ có thể tốt. Nhưng thậm chí nếu bạn không làm vậy, bạn có thể tổ chức code trong các hàm lớn để nó cảm thấy có các logic riêng biệt cho từng phần. Đây là quá trình chúng ta sử dụng để tạo “one task at a time”: Liệt kê ra tất cả các “task” bạn của bạn đang làm. Chúng ta sử dung từ “task” rất lỏng lẻo - no có thể nhỏ nhất có thể như “đảm bảo object này là hợp lệ” hoặc mơ hồ như “thực hiện vòng lặp qua mỗi node của cây”. Thử tách các task này nhiều nhất bạn có thể đưa vào trong các hàm khác nhau hoặc ít nhất là trong các phần mã khác nhau. Trong chương này, chúng tôi sẽ chỉ cho bạn 1 số ví dụ để làm việc này Tasks Can Be SmallGiả định bạn đang có 1 phần voting cho 1 blog, người dùng có thể “Up” hoặc “Down”. Các điểm sẽ được tính là mỗi vote “Up” thì +1 và mỗi “Down” thì -1. Có 1 trạng thái người dùng có thể vote như hình sau ảnh hưởng đến điểm của bạn Khi người dùng click 1 button bạn thay đổi điểm bằng đoạn JavaScript sau:1vote_changed(old_vote, new_vote); // each vote is &quot;Up&quot;, &quot;Down&quot;, or &quot;&quot;Hàm cập nhật tổng điểm số và làm việc với cặp old_vote/new_vote như sau:123456789101112131415var vote_changed = function (old_vote, new_vote) { var score = get_score(); if (new_vote !== old_vote) { if (new_vote === 'Up') { score += (old_vote === 'Down' ? 2 : 1); } else if (new_vote === 'Down') { score -= (old_vote === 'Up' ? 2 : 1); } else if (new_vote === '') { score += (old_vote === 'Up' ? -1 : 1); } } set_score(score);};Mặc dù code nhìn khá ngắn nhưng nó đang làm nhiều việc. Có rất nhiều chi tiết phức tạp và khó để nói xem lướt qua có bất kì lỗi, chính tả hoặc các lỗi khác không? Đoạn code này có vẻ như chỉ cần làm 1 việc (cập nhật điểm số) nhưng thực tế nó đang làm 2 thứ cùng 1 lúc: old_vote và new_vote đang được “parsed” vào giá trị số score đang được cập nhật Chúng ta có thể dễ dàng đọc hơn bằng cách giải quyết mỗi việc trên riêng lẻ. Đoạn code dưới đây giải quyết nhiệm vụ đầu tiên, chuyển giá trị vote thành số:12345678910var vote_value = function (vote) { if (vote === 'Up') { return +1; } if (vote === 'Down') { return -1; } return 0;};Bây giờ phần còn lại của code là xử nhiệm vụ thứ 2, cập nhật điểm:1234567var vote_changed = function (old_vote, new_vote) { var score = get_score(); score -= vote_value(old_vote); // remove the old vote score += vote_value(new_vote); // add the new vote set_score(score);};Như bạn có thể thấy, phiên bản code này tốn ít nỗ lực về mặt tinh thần hơn để tự nhủ rằng nó hoạt động As you can see, this version of the code takes a lot less mental effort to convince yourself that it works. =)) Đây là 1 phần lớn làm code “dễ dàng để hiểu”. Extracting Values from an ObjectChúng tôi đã từng có 1 số định dạng JavaScript để định dạng 1 vị trí của user thành 1 chuỗi thân thiện “City, Country như “Santa Monica, USA” or “Paris, France.”. Chúng ta nhận vào 1 từ điển location_info với nhiều cấu trúc dữ liệu. Tất cả cái chúng ta chọn là “City” và “Country” từ tất cả các trường và nối chúng lại với nhau. Hình sau minh hoạt ví dụ input/output: Có vẻ nó đơn giản cho đến lúc này, nhưng phần bẫy ở đây là một hoặc tất cả 4 giá trị này có thể thiếu. Đây là cách chúng ta trao đổi với điều này: Khi chọn “City” chúng ta ưu tiên chọn “LocalityName” (city/town) nếu có sẵn, sau đó là “SubAdministrativeAreaName” (larger city/county), sau đó là “AdministrativeAreaName” (state/territory). Nếu cả 3 giá trị đều thiếu, “City” sẽ nhận giá trị đầu vào là “Middle-of-Nowhere” Nếu “CountryName” thiếu, “Planet Earth” sẽ được sử dụng làm mặc định. Đây là đoạn code chúng ta viết để thực hiện task trên:1234567891011121314151617var place = location_info[&quot;LocalityName&quot;]; // e.g. &quot;Santa Monica&quot;if (!place) { place = location_info[&quot;SubAdministrativeAreaName&quot;]; // e.g. &quot;Los Angeles&quot;}if (!place) { place = location_info[&quot;AdministrativeAreaName&quot;]; // e.g. &quot;California&quot;}if (!place) { place = &quot;Middle-of-Nowhere&quot;;}if (location_info[&quot;CountryName&quot;]) { place += &quot;, &quot; + location_info[&quot;CountryName&quot;]; // e.g. &quot;USA&quot;} else { place += &quot;, Planet Earth&quot;;}return place;Chắc chắn nó hơi lộn xộn, nhưng nó hoạt động tốt. Nhưng 1 vài ngày sau, chúng ta cần cải thiện vấn đề này: đối với vị trí từ United States, chúng tôi muốn hiển thị state thay vì conntry (hoàn toàn khả thi). Do đó thay vì “SSanta Monica, USA” nó sẽ trả về “Santa Monica, California” Để thêm tính năng này vào phần code trước sẽ làm cho nó xấu đi rất nhiều. Applying “One Task at a Time”Thay vì uốn đoạn mã này theo ý chúng ta, chúng ta hãy dừng lại và nhận ra nó đang thực hiện quá nhiều task trong cùng 1 lúc: Trích xuất giá trị từ từ điển location_info Duyệt qua 1 thứ tự trên cho “City” và mặc định là “Middle-of-Nowhere” nếu nó không tìm thấy gì Nhận “Country” và sử dụng “Planet Earth” nếu không có giá trị Cập nhật place Thay vì đó, chúng ta viết lại đoạn code ban đầu để giải quyết mỗi vấn đề độc lập Nhiệm vụ đầu tiên (trích xuất giá trí từ từ điển) dễ dàng giải quyết:1234var town = location_info[&quot;LocalityName&quot;]; // e.g. &quot;Santa Monica&quot;var city = location_info[&quot;SubAdministrativeAreaName&quot;]; // e.g. &quot;Los Angeles&quot;var state = location_info[&quot;AdministrativeAreaName&quot;]; // e.g. &quot;CA&quot;var country = location_info[&quot;CountryName&quot;]; // e.g. &quot;USA&quot;Đến điểm này, chúng tôi đã sử dụng location_info và không phải nhớ nhiều và các keys không trực quan. Thay vào đó, chúng ta đã có những biến đơn giản để làm việc cùng. Tiếp theo, chúng tôi đã tìm ra cái “nửa thứ 2” của giá trị trả về sẽ như:12345678// Start with the default, and keep overwriting with the most specific value.var second_half = &quot;Planet Earth&quot;;if (country) { second_half = country;}if (state &amp;&amp; country === &quot;USA&quot;) { second_half = state;}Tương tự, chúng tôi tìm “first half”:12345678910var first_half = &quot;Middle-of-Nowhere&quot;;if (state &amp;&amp; country !== &quot;USA&quot;) { first_half = state;}if (city) { first_half = city;}if (town) { first_half = town;}Cuối cùng chúng ta nối các thông tin lại với nhau:1return first_half + &quot;, &quot; + second_half;Hình minh họa của chương trình chống phân mảnh ở đầu chương này thực sự là một đại diện cho giải pháp ban đầu và phiên bản mới này. Đây là minh họa tương tự, với nhiều chi tiết được điền vào: Như bạn có thể thấy, 4 tasks trong giải pháp thứ 2 đã được phân mảnh vào khu vực riêng biệt. Another ApproachKhi tái cấu trúc code, có nhiều cách để làm nó và trường hợp này cũng không phải là ngoại lệ. Một khi bạn đã tách 1 vài tasks, code sẽ dễ hiểu hơn và bạn cần tiếp tục tìm cách tốt hơn để tái cấu trúc nó. Ví dụ, dễ dàng hơn khi loạt câu lệnh if yêu cầu 1 vài sự cận trọng đọc để viết nếu mỗi trường hợp hoạt động có chính xác hay không? Thực tế có 2 nhiệm vụ con đang diễn ra đồng thời trong đoạn code này: Duyệt qua danh sách các biến và chọn cái được ưu tiên nhất tồn tại. Sử dụng 1 danh sách khác, tùy thuộc vào quốc gia là “USA” Nhìn lại, bạn có thể thấy code trước đó có logic “if USA” đan xem với phần logic còn lại. Thay vào đó, chúng ta có thể xử lý USA và non-USA riêng biệt:1234567891011var first_half, second_half;if (country === &quot;USA&quot;) { first_half = town || city || &quot;Middle-of-Nowhere&quot;; second_half = state || &quot;USA&quot;;} else { first_half = town || city || state || &quot;Middle-of-Nowhere&quot;; second_half = country || &quot;Planet Earth&quot;;}return first_half + &quot;, &quot; + second_half; A Larger ExampleChúng tôi xây dựng 1 hệ thống web-crawling, 1 hàm với tên UpdateCounts() được gọi và tăng các thống kê khác nhau sau mỗi trang web được download:12345void UpdateCounts(HttpDownload hd) { counts[&quot;Exit State&quot; ][hd.exit_state()]++; // e.g. &quot;SUCCESS&quot; or &quot;FAILURE&quot; counts[&quot;Http Response&quot;][hd.http_response()]++; // e.g. &quot;404 NOT FOUND&quot; counts[&quot;Content-Type&quot; ][hd.content_type()]++; // e.g. &quot;text/html&quot;}Well, đây là cách mà chúng tôi mong muốn nhìn thấy của code! Đặc biệt đối tượng HttpDownload không có phương thức nào hiển thị ở đây. Thay vào đó, HttpDownload là 1 class rất lớn và phức tạp, với nhiều class lồng nhau và chúng ta phải tự tìm ra các giá trị đó. Để làm cho mọi thứ tệ hơn, đôi khi các giá trị này bị thiếu hoàn toàn - trong trường hợp này chúng ta chỉ sử dụng giá trị mặc định “unknown” Vì tất cả code với nhau, code thực sự có vẻ hơi hỗn độn:1234567891011121314151617181920212223242526272829303132333435// WARNING: DO NOT STARE DIRECTLY AT THIS CODE FOR EXTENDED PERIODS OF TIME.void UpdateCounts(HttpDownload hd) { // Figure out the Exit State, if available. if (!hd.has_event_log() || !hd.event_log().has_exit_state()) { counts[&quot;Exit State&quot;][&quot;unknown&quot;]++; } else { string state_str = ExitStateTypeName(hd.event_log().exit_state()); counts[&quot;Exit State&quot;][state_str]++; } // If there are no HTTP headers at all, use &quot;unknown&quot; for the remaining elements. if (!hd.has_http_headers()) { counts[&quot;Http Response&quot;][&quot;unknown&quot;]++; counts[&quot;Content-Type&quot;][&quot;unknown&quot;]++; return; } HttpHeaders headers = hd.http_headers(); // Log the HTTP response, if known, otherwise log &quot;unknown&quot; if (!headers.has_response_code()) { counts[&quot;Http Response&quot;][&quot;unknown&quot;]++; } else { string code = StringPrintf(&quot;%d&quot;, headers.response_code()); counts[&quot;Http Response&quot;][code]++; } // Log the Content-Type if known, otherwise log &quot;unknown&quot; if (!headers.has_content_type()) { counts[&quot;Content-Type&quot;][&quot;unknown&quot;]++; } else { string content_type = ContentTypeMime(headers.content_type()); counts[&quot;Content-Type&quot;][content_type]++; }}Như bạn có thể thấy, rất nhiều code và rất nhiều logic và thậm chí 1 vài dòng code đã lặp lại. Không hề vui vẻ gì khi đọc đoạn code này. Đặc biệt, đoạn code này có thể chuyển qua chuyện lại giữa các nhiệm vụ khác nhau. Ở đây có các nhiệm vụ khác nhau xen kẽ trong code: Sử dụng “unknown” làm giá trị mặc định cho mỗi key. Phát hiện xem những thành phần nào của HttpDownload đang thiếu. Trích xuất giá trị và chuyển nó thành string Cập nhật counts[] Chúng ta có thể cải thiện đoạn code bằng cách phân tách 1 vài tasks này ra thành các phần riêng trong code:12345678910111213141516171819202122void UpdateCounts(HttpDownload hd) { // Task: define default values for each of the values we want to extract string exit_state = &quot;unknown&quot;; string http_response = &quot;unknown&quot;; string content_type = &quot;unknown&quot;; // Task: try to extract each value from HttpDownload, one by one if (hd.has_event_log() &amp;&amp; hd.event_log().has_exit_state()) { exit_state = ExitStateTypeName(hd.event_log().exit_state()); } if (hd.has_http_headers() &amp;&amp; hd.http_headers().has_response_code()) { http_response = StringPrintf(&quot;%d&quot;, hd.http_headers().response_code()); } if (hd.has_http_headers() &amp;&amp; hd.http_headers().has_content_type()) { content_type = ContentTypeMime(hd.http_headers().content_type()); } // Task: update counts[] counts[&quot;Exit State&quot;][exit_state]++; counts[&quot;Http Response&quot;][http_response]++; counts[&quot;Content-Type&quot;][content_type]++; }Như bạn có thể thấy, đoạn code này gồm 3 khu vực với các mục đích sau: Định nghĩa giá trị mặc định cho 3 keys chúng ta quan tâm Trích xuất giá trị, nếu tồn tại, với mỗi keys này, chuyển chúng thành chuỗi Cập nhật counts cho mỗi key/value Điều tốt nhất tách chúng ra thành các khu vực riêng biệt là chúng cô lập với các phần khác - trong khi bạn đang đọc 1 khu vực, bạn không nghĩ về khu vực khác. Bạn có thể nhận thấy rằng chúng ta đã liệt kê ra 1 tasks, nhưng chúng ta có thể chỉ tách biệt chỉ 3 trong số chúng. Điều này hoàn toàn ổn: các tasks mà bạn liệt kê ban đầu chỉ là các điểm khởi đầu. Thậm chí tách một số trong số chúng có thể giúp mọi thứ rất nhiều, như nó đã làm ở đây Further ImprovementsPhiên bản code mới đã cải thiện được các vấn đề từ đoạn code ban đầu. Chúng ta thấy rằng thậm chí chúng ta không cần phải tạo các hàm khác để thực hiện việc dọn dẹp code. Như chúng tôi đã nhắc đến từ trước đó, ý tưởng “one task at time” có thể giúp bạn dọn sạch mã bất kể cá ranh giới của hàm. Tuy nhiên chúng tôi đã cải thiện đoạn code này theo cách khác, bằng cách sử dụng 3 hepler:12345void UpdateCounts(HttpDownload hd) { counts[&quot;Exit State&quot;][ExitState(hd)]++; counts[&quot;Http Response&quot;][HttpResponse(hd)]++; counts[&quot;Content-Type&quot;][ContentType(hd)]++;}Các hàm này sẽ trích xuất các giá trị tương ứng hoặc trả về “unknown”, ví dụ:1234567string ExitState(HttpDownload hd) { if (hd.has_event_log() &amp;&amp; hd.event_log().has_exit_state()) { return ExitStateTypeName(hd.event_log().exit_state()); } else { return &quot;unknown&quot;; }}Cách xử lý thay thế này không cần định nghĩa 1 vài biến. Và như chúng tôi đã nhắc đến trong Chapter 9, Variables and Readability, những biến giữ các giá trị trung gian nên được loại bỏ hoàn toàn. Trong giải pháp này, chúng tôi đã đơn giản “cắt” các vấn đề vào trong các đường dẫn khác nhau. Cả 2 giải pháp đều dễ đọc và chúng yêu cầu người đọc nghĩ về 1 task trong 1 thời điểm. SummaryChương này minh họa 1 kỹ thuật đơn giản để tổ chức lại code của bạn: làm 1 task trong 1 thời điểm. Nếu bạn có các đoạn code khó đọc, hãy thử liệt kê nhưng task nó đang làm. Một vài tasks này có thể dễ dàng được tách thành các hàm (hoặc lớp) riêng biệt. Các tasks khác có thể trở thành “đoạn văn” trong 1 hàm đơn. Tách các phần chi tiết các task đang thực hiện không quan trọng bằng thực tế chúng đã được tách biệt ra. Phần khó nhất là mô tả được chính xác tất cả các thứ chương trình của bạn đang thực hiện. The exact details of how you separate these tasks isn’t as important as the fact that they’re separated. The hard part is accurately describing all the little things your program is doing.","link":"/2020/05/24/Chapter-11-One-Task-at-a-Time/"},{"title":"Chapter 14: Testing and Readability","text":"Trong chương này, chúng tôi sẽ chỉ cho bạn một số kĩ thuật đơn giản để viết các test sạch sẽ và hiệu quả. Testing định nghĩa khác nhau với những người khác nhau. Trong chương này, chúng tôi sử dụng “test” có nghĩa là một vài code mà mục đích duy nhất của nó là kiểm tra hành vi của 1 phần (“real”) của code khác. Chúng tôi sẽ tập trung vào việc khía cạnh khả năng đọc của test và không nói sâu bạn nên viết test code trước khi viết code thực sự (“test-driven development”) hoặc khái cạnh về sự phát triển của test “Real” code vs “test” code :D Make Tests Easy to Read and MaintainNó có vai trò quan trọng như viết code thực sự. Các coders khác sẽ thường nhìn các test code như các dạng tài liệu không chính thức của cách real code làm việc và nên được sử dụng. Do đó, các test dễ đọc, người dùng sẽ dễ hiểu hơn hành vi thực sự của code K E Y I D E ATest code should be readable so that other coders are comfortable changing or adding tests. Khi test code lớn và đáng sợ, đây là 1 vài thứ sẽ xảy ra: Coders ngại sửa đổi real code. Oh, chúng tôi không muốn làm bẩn đoạn code này - cập nhất tất cả các test sẽ là 1 cơn ác mộng! Coders không muốn thêm các new tests khi họ thêm code mới. Và theo thời gian, càng ngày các ít module của bạn được test và bạn không còn tự tin với mọi việc. Thay vì đó, bạn muốn khuyến khích ai đó (trừ bạn) làm việc với code được thoải mái với test code. Chúng nên có thể đọc và chẩn đoán được tại sao có 1 sự thay đổi đang khá vỡi test đã tồn tại và cảm giác như thêm các tests mới là việc dễ dàng. What’s Wrong with This Test?Trong codebase của chúng tôi, chúng tôi có 1 hàm sắp xếp và lọc danh sách kết quả tìm kiếm đã được ghi lại. Đây là khai báo hàm:12// Sort 'docs' by score (highest first) and remove negative-scored documents.void SortAndFilterDocs(vector&lt;ScoredDocument&gt;* docs);Đoạn code Test hàm này sẽ như sau:123456789101112131415161718192021void Test1() { vector&lt;ScoredDocument&gt; docs; docs.resize(5); docs[0].url = &quot;http://example.com&quot;; docs[0].score = -5.0; docs[1].url = &quot;http://example.com&quot;; docs[1].score = 1; docs[2].url = &quot;http://example.com&quot;; docs[2].score = 4; docs[3].url = &quot;http://example.com&quot;; docs[3].score = -99998.7; docs[4].url = &quot;http://example.com&quot;; docs[4].score = 3.0; SortAndFilterDocs(&amp;docs); assert(docs.size() == 3); assert(docs[0].score == 4); assert(docs[1].score == 3.0); assert(docs[2].score == 1);}Có ít nhất 8 vấn đề khác nhau trong đoạn test code này. Trong phần cuối của chương, bạn sẽ có thể tìm và sửa chúng Making This Test More ReadableNhư là 1 nguyên tắc chung thiết kế, bạn nên ẩn những chi tiết ít quan trọng từ người dùng, để những phần chi tiết quan trọng nổi bật lên. Đoạn test code từ phần trước rõ ràng vi phạm nguyên tắc này. Mỗi phần chi tiết của test ở ngay phía trước và trung tâm là các chi tiết vụn vặt không quan trọng setting cho vector&lt;ScoredDocument&gt;. Đa số đoạn code trong ví dụ liên quan đến url, score, và docs[] cái mà chỉ nói chi tiết một object trong C++ được thiết lập như thế nào mà không nói về test này đang làm gì ở mức level cao. Do đó, bước đầu tiên để loại bỏ điều này, bạn nên tạo 1 helper như sau:1234void MakeScoredDoc(ScoredDocument* sd, double score, string url) { sd-&gt;score = score; sd-&gt;url = url;}Sử dụng hàm này, test code của chúng ta trở nên gọn hơn 1 chút:123456789void Test1() { vector&lt;ScoredDocument&gt; docs; docs.resize(5); MakeScoredDoc(&amp;docs[0], -5.0, &quot;http://example.com&quot;); MakeScoredDoc(&amp;docs[1], 1, &quot;http://example.com&quot;); MakeScoredDoc(&amp;docs[2], 4, &quot;http://example.com&quot;); MakeScoredDoc(&amp;docs[3], -99998.7, &quot;http://example.com&quot;); ...}Nhưng nó vẫn chưa đủ tốt - vẫn còn nhiều chi tiết không quan trọng. Ví dụ, đối số “http://example.com&quot;. Nó luôn luôn giống nhau và URL chính xác như vậy không quan trọng - nó chỉ nên là các giá trị điền vào ScoredDocument Một thứ không quan trọng khác chúng ta buộc phải xem xét là docs.resize(5) và &amp;docs[0], &amp;docs[1],.... Hãy thay đổi hepler để làm nhiều việc hơn, và gọi là AddScoredDoc():123456void AddScoredDoc(vector&lt;ScoredDocument&gt;&amp; docs, double score) { ScoredDocument sd; sd.score = score; sd.url = &quot;http://example.com&quot;; docs.push_back(sd);}Sử dụng hàm này, test code của chúng ta thậm chí gọn hơn:12345678void Test1() { vector&lt;ScoredDocument&gt; docs; AddScoredDoc(docs, -5.0); AddScoredDoc(docs, 1); AddScoredDoc(docs, 4); AddScoredDoc(docs, -99998.7); ...}Đoạn code đã tốt hơn nhưng vẫn không đáp ứng yêu cầu vào về khả năng đọc và viết test. Nếu bạn muốn thêm test khác với 1 tập các tài liệu ghi điểm, nó yêu cầu rất nhiều copy và paste. Liệu chúng ta có thể cải thiện vấn đề này? Creating the Minimal Test StatementĐể cải thiện vấn đề test code này, hãy sử dụng kĩ thuật từ Chapter 12, Turning Thoughts into Code.. Hãy mô tả cái mà test của chúng ta đang cố làm bằng tiếng Anh:12We have a list of documents whose scores are [-5, 1, 4, -99998.7, 3]. AfterSortAndFilterDocs(), the remaining documents should have scores of [4, 3, 1], in that order.Như bạn có thể thấy, không 1 chỗ nào trong mô tả này chúng ta nhắc đến vector&lt;ScoredDocument&gt;. Mảng của điểm không quan trọng ở đây. Về ý tưởng, test code của chúng ta sẽ như sau:1CheckScoresBeforeAfter(&quot;-5, 1, 4, -99998.7, 3&quot;, &quot;4, 3, 1&quot;);Chúng tôi có thể làm nổi bật lên vấn đề của test này xuống 1 dòng code! Điều này không hiếm. Bản chất của hầu hết các test là làm nổi lên đối với input/trường hợp này, mong chờ hành vi/ouput này. Và nhiều lần, mục đích này có thể mô tả chỉ trong 1 dòng. Thêm vào đó copy rất ngắn gọn và dễ đọc, giữ các test của bạn ngắn và thực sự rất dễ dàng để thêm nhiều test cases. Implementing Custom “Minilanguages”Nhận thấy rằng CheckScoresBeforeAfter() nhận vào 1 đối số chuỗi mô tả mảng các điểm. Trong các phiên bản gần nhất của C++, bạn có thể truyền mảng như sau:1CheckScoresBeforeAfter({-5, 1, 4, -99998.7, 3}, {4, 3, 1});Vì chúng tôi không làm điều đó ở thời điểm hiện tại, chúng tôi đặt điểm số trong 1 chuỗi, phân tách bằng dấu phẩy. Với cách làm này CheckScoresBeforeAfter() cần phải phân tích đối số chuỗi này Nói chung, việc xác định một ngôn ngữ tùy chỉnh có thể là một cách mạnh mẽ để thể hiện nhiều thông tin trong một khoảng trống nhỏ. Các ví dụ khác bao gồm printf() và các thư viện biểu thức chính quy. Trong trường hợp này, viết 1 vài helper để phân tích danh sách số phân tách bằng dấu phẩy không quá khó. Hàm CheckScoresBeforeAfter() sẽ như sau:123456void CheckScoresBeforeAfter(string input, string expected_output) { vector&lt;ScoredDocument&gt; docs = ScoredDocsFromString(input); SortAndFilterDocs(&amp;docs); string output = ScoredDocsToString(docs); assert(output == expected_output);}Và để cho đầy đủ, đây là hepler chuyển đổi giữa string và vector&lt;ScoredDocument&gt;1234567891011121314151617181920212223vector&lt;ScoredDocument&gt; ScoredDocsFromString(string scores) { vector&lt;ScoredDocument&gt; docs; replace(scores.begin(), scores.end(), ',', ' '); // Populate 'docs' from a string of space-separated scores. istringstream stream(scores); double score; while (stream &gt;&gt; score) { AddScoredDoc(docs, score); } return docs;}string ScoredDocsToString(vector&lt;ScoredDocument&gt; docs) { ostringstream stream; for (int i = 0; i &lt; docs.size(); i++) { if (i &gt; 0) stream &lt;&lt; &quot;, &quot;; stream &lt;&lt; docs[i].score; } return stream.str();}Dường như có nhiều code trong lần nhìn đầu tiên, nhưng những gì nó làm cho bạn và vô cùng mạnh mẽ. Vì bạn có thể viết toàn bộ test chỉ với 1 lời gọi CheckScoresBeforeAfter(), bạn sẽ có xu hướng thêm được nhiều test hơn (như chúng tôi sẽ làm trong phần sau của chương này) Making Error Messages Readable Đoạn code trước đẹp rồi, nhưng vẫn còn vấn đề ở chỗ assert(output == expected_output) lỗi? Nó sẽ đưa ra thông báo lỗi như sau:12Assertion failed: (output == expected_output), function CheckScoresBeforeAfter, file test.cc, line 37.Chắc chắn, nếu bạn nhìn thấy lỗi này, bạn sẽ tự hỏi, Giá trị của ouput và expected_output là gì? Using Better Versions of assert()May mắn thay, đa số các ngôn ngữ và thư viện đều có phiên bản “tinh vi” hơn của hàm assert() bạn có thể dùng. Thay vì viết:1assert(output == expected_output);bạn có thể sử dụng thư viện Boost C++:1BOOST_REQUIRE_EQUAL(output, expected_output)Bây giờ, nếu test lỗi, bạn sẽ nhận được 1 thông báo chi tiết như sau:12test.cc(37): fatal error in &quot;CheckScoresBeforeAfter&quot;: critical check output == expected_output failed [&quot;1, 3, 4&quot; != &quot;4, 3, 1&quot;]với nhiều thông tin hữu ích hơn. Bạn nên sử dụng các phương thức hữu ích này để assert() khi chúng khả dụng. Nó sẽ trả về cho bạn mỗi test khi lỗi. BETTER ASSERT() IN OTHER LANGUAGESTrong Python, built-in assert a == b sẽ tạo ra lỗi thông báo như:123File &quot;file.py&quot;, line X, in &lt;module&gt; assert a == bAssertionErrorThay vào đó bạn có thể sử dụng phương thức assertEqual() trong module unittest:12345678910import unittestclass MyTestCase(unittest.TestCase): def testFunction(self): a = 1 b = 2 self.assertEqual(a, b)if __name__ == '__main__': unittest.main()Sẽ tạo ra thông báo lỗi như:123File &quot;MyTestCase.py&quot;, line 7, in testFunction self.assertEqual(a, b)AssertionError: 1 != 2Với mỗi ngôn ngữ bạn đang sử dụng, có thể có các library/framework (ví dụ XUnit) có thể giúp bạn. It pays to know your libraries Hand-Crafted Error MessagesSử dụng BOOST_REQUIRE_EQUAL(), bạn có thể nhận được thông báo lỗi đẹp hơn:1output == expected_output failed [&quot;1, 3, 4&quot; != &quot;4, 3, 1&quot;]Tuy nhiên thông báo này vẫn có thể được cải thiện. Ví dụ, sẽ hữu ích hơn khi nhìn thấy input gốc cái mà đang nhận lỗi. Ý tưởng thì thông báo lỗi sẽ là cái gì đó như:1234CheckScoresBeforeAfter() failed, Input: &quot;-5, 1, 4, -99998.7, 3&quot; Expected Output: &quot;4, 3, 1&quot; Actual Output: &quot;1, 3, 4&quot;Nếu đó là thứ mà bạn muốn, thử viết nó thôi!123456789void CheckScoresBeforeAfter(...) { ... if (output != expected_output) { cerr &lt;&lt; &quot;CheckScoresBeforeAfter() failed,&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;Input: \\&quot;&quot; &lt;&lt; input &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;Expected Output: \\&quot;&quot; &lt;&lt; expected_output &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;Actual Output: \\&quot;&quot; &lt;&lt; output &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; abort(); }Về mặt tâm lý, các thông báo lỗi nên hữu ích nhất có thể. Đôi khi, hiển thị các thông báo bằng cách xây dựng lại 1 “custom assert” là cách tốt nhất để làm việc này. Choosing Good Test InputsCó 1 nghệ thuật chọn giá trị cho các đầu vào tốt đối với các test của bạn. Những cái chúng ta có ngay bây giờ có vẻ hơi khó hiểu1CheckScoresBeforeAfter(&quot;-5, 1, 4, -99998.7, 3&quot;, &quot;4, 3, 1&quot;);Làm sao để chúng ta chọn các giá trị đầu vào tốt? Các good inputs nên test triệt để được code. Nhưng chúng cũng nên đơn giản để dễ đọc. KEY IDEAIn general, you should pick the simplest set of inputs that completely exercise the code. Ví dụ, giả định bạn vừa mới viết:1CheckScoresBeforeAfter(&quot;1, 2, 3&quot;, &quot;3, 2, 1&quot;);Mặc dù test này đơn giản, nó không test hành vi “lọc các điểm số âm” của hàm SortAndFilterDocs(). Nếu có 1 bug trong phần này của code, input này không kích hoạt nó. Ở 1 chiều hướng khác, giả định bạn viết test như:12CheckScoresBeforeAfter(&quot;123014, -1082342, 823423, 234205, -235235&quot;, &quot;823423, 234205, 123014&quot;);Các giá trị này phức tạp không cần thiết. (Và chúng thậm chí không kiểm tra kĩ được code) Simplifying the Input ValuesVậy chúng ta có thể cải thiện input này với giá trị nào?1CheckScoresBeforeAfter(&quot;-5, 1, 4, -99998.7, 3&quot;, &quot;4, 3, 1&quot;);Well, thứ đầu tiên bạn có thể nhận thấy là giá trị rất “ồn ào” -99998.7. Giá trị này chỉ có nghĩa “một vài số âm” do đó để đơn giản, nó nên chỉ là -1 (Nếu -99998.7 thì nên có nghĩa là “một số rất âm”, mà kể cả như vậy, một giá trị tốt hơn của nó nên được sắc nét thành -1e100) KEY IDEAPrefer clean and simple test values that still get the job done. Những giá trị khác trong test của chúng ta cũng không quá tệ, nhưng trong khi chúng ta ở đâu, chúng ta có thể giảm chúng thành các số nguyên đơn giản nhất có thể. Ngoài ra, chỉ cần 1 giá trị âm là cần để test việc giá trị âm bị loại bỏ. Đây là phiên bản mới của test:1CheckScoresBeforeAfter(&quot;1, 2, -1, 3&quot;, &quot;3, 2, 1&quot;);Chúng ta đã đơn giản hóa các giá trị của test mà không hề giảm hiệu quả đi :D LARGE “SMASHER” TESTS(Tôi đang hiểu là không nên test các giá trị khủng, thay vào đó hiệu quả hơn là xây dựng nó theo chương trình) Chắc chắn có những giá trị trong các test của bạn chống lại việc đầu vào lớn, điên rỗ. Ví dụ, bạn có thể bị cám dỗ bởi các test như:12CheckScoresBeforeAfter(&quot;100, 38, 19, -25, 4, 84, [lots of values] ...&quot;, &quot;100, 99, 98, 97, 96, 95, 94, 93, ...&quot;);Những đầu vào lớn như vậy là 1 phần công việc tốt để tìm ra lỗi như các lỗi tràn số hoặc các lỗi khác bạn không mong đợi. Nhưng code như vậy là lớn và đáng sợ để nhìn vào và không hoàn toàn hiệu quả trong việc stress-testing code. Thay vào đó, sẽ hiệu của hơn để xây dựng đầu vào 1 đầu vào lớn theo chương trình, khởi tạo 1 giá trị lớn của 100.000 giá trị. Multiple Tests of FunctionalityThay vì chỉ xây dựng 1 đầu vào đơn “hoàn hảo” để xem xét kĩ lưỡng code, nó thường dễ dàng hơn, hiệu quả hơn và dễ đọc hơn để viết nhiều bài kiểm tra nhỏ hơn. Mỗi test nên đẩy vào code của bạn 1 hướng nhất định và thử tìm lỗi cụ thể. Ví dụ đây là 4 tests cho SortAndFilterDocs():1234CheckScoresBeforeAfter(&quot;2, 1, 3&quot;, &quot;3, 2, 1&quot;); // Basic sortingCheckScoresBeforeAfter(&quot;0, -0.1, -10&quot;, &quot;0&quot;); // All values &lt; 0 removedCheckScoresBeforeAfter(&quot;1, -2, 1, -2&quot;, &quot;1, 1&quot;); // Duplicates not a problemCheckScoresBeforeAfter(&quot;&quot;, &quot;&quot;); // Empty input OKThậm chí có nhiều test bạn có thể viết nếu bạn muốn kiểm tra chi tiết. Có các test tách biệt cũng làm nó dễ đọc với các người tiếp theo làm việc với code. Nếu ai đó tình cờ gặp 1 lỗi, test lỗi sẽ xác định cính xác test nào lỗi Naming Test FunctionsTest code là thường được tổ chức vào trong hàm - một cho mỗi phương thức và/hoặc tình huống bạn đang test. Ví dụ, đoạn code test SortAndFilterDocs() trong 1 hàm tên là Test1():123void Test1() { ...}Chọn 1 cái tên tốt cho 1 hàm test có vẻ tẻ nhạt và không liên quan, nhưng đừng vì thế mà chọn những cái tên không có nhiều ý nghĩa như Test1(), Test2() hoặc tương tự. Thay vì đó bạn nên sử dụng 1 cái tên mô tả chi tiết về test. Cụ thể, nó rất tiện dụng nếu ai đó đọc test code của bạn mà có thể tìm ra: Class đang được test (nếu có) Hàm đang được test Vấn đề hoặc bug đang được test. Một cách tiếp cận đơn giản để khởi tạo 1 tên hàm test tốt là chỉ cần kết hợp các thông tin lại với nhau, có thể sử dụng prefix “Test_” Ví dụ, thay vì đặt tên nó là Test1(), chúng ta có thể sử dụng format Test_&lt;FunctionName&gt;():123void Test_SortAndFilterDocs() { ...}Tùy thuộc vào mức độ chi tiết của test, bạn nên cân nhắc việc tách các hàm test ra thành mỗi vấn đề để test. Bạn có thể sử dụng Test_&lt;FunctionName&gt;_&lt;Situation&gt;() format:123456789void Test_SortAndFilterDocs_BasicSorting() { ...}void Test_SortAndFilterDocs_NegativeValues() { ...}...Đừng lo lắng là có các tên dài và lộn xộn ở đây. Đây không phải là 1 hàm chúng ta sẽ gọi trong codebase, do đó lý do để tránh 1 tên dài không áp dụng ở đây. Các tên hàm test hoạt động như 1 comment. Và như vậy, nếu 1 test lỗi, đa số các frameworks sẽ in tên hàm assert lỗi ra, do đó một tên hàm rõ ràng sẽ rất hữu ích ở đây. Chú ý rằng nếu bạn đang sử dụng 1 framework testing, có thể có những nguyên tắc và conventions về tên của các phương thức. Ví dụ, unittest Python module mong đợi têt của các phương thức test bắt đầu với “test”. Khi nói đến việc đặt tên cho các hàm helper trong test code, sẽ hữu ích để làm nổi bật lên hàm này có tự làm một vài assert nào không hay nó chỉ là một helper test-unaware thông thường. Ví dụ, trong chương này, một vào hepler được gọi như assert() với tên Check()…Nhưng hàm AddScoredDoc() được đặt tên chỉ là 1 helper thông thường. What Was Wrong with That Test?Ở phần đầu của chương, chúng tôi đã tuyên bố rằng có ít nhất 8 thứ đang sai với test này:123456789101112131415161718192021void Test1() { vector&lt;ScoredDocument&gt; docs; docs.resize(5); docs[0].url = &quot;http://example.com&quot;; docs[0].score = -5.0; docs[1].url = &quot;http://example.com&quot;; docs[1].score = 1; docs[2].url = &quot;http://example.com&quot;; docs[2].score = 4; docs[3].url = &quot;http://example.com&quot;; docs[3].score = -99998.7; docs[4].url = &quot;http://example.com&quot;; docs[4].score = 3.0; SortAndFilterDocs(&amp;docs); assert(docs.size() == 3); assert(docs[0].score == 4); assert(docs[1].score == 3.0); assert(docs[2].score == 1);}Bây giờ chúng ta sẽ tìm hiểu 1 vài kĩ thuật để viết tests tốt hơn, hãy nhận dạng chúng: Test rất dài và đầy đủ các chi tiết không quan trọng. Bạn có thể mô tả thứ mà test này đang làm trong 1 câu, do đó các lệnh trong test này không nên quá dài. Thêm 1 test khác không phải dễ. Khi bạn cần copy/paste/modify, cài mà sẽ làm cho code dài hơn và yêu cầu đầy đủ bản sao. Thông điệp test lỗi không hữu ích. Nếu 1 test lỗi, nó sẽ nói rằng Assertion failed: docs.size() == 3, cái mà không cho bạn đủ thông tin để debug thêm Test đang cố gắng test mọi thứ trong 1 lúc. Nó đang cố gắng test cả lọc số âm và chức năng sắp xếp. Nó sẽ dễ đọc hơn nếu phá vỡ vào trong nhiều tests. Đầu vào test không đơn giản. Cụ thể, điểm ví dụ -9998.7 “ồn ào” và nhận sự chú ý mặc dừ nó không phải và 1 vài ý nghĩa của các giá trị đặc biệt. Giá trị của 1 số âm đơn giản hơn sẽ là đủ. Các input của test không thực hiện kiểm tra kĩ lưỡng được code. Ví dụ, nó không test trường hợp điểm là 0 (Bạn cần phải xem tài liệu để biết rằng nó có filter hay không?) Nó không test các đầu vào cực đoạn khác, như 1 vector trống, 1 vector lớn hoặc 1 điểm lặp lại. Tên Test1() không có nhiều ý nghĩa - tên nên mô tả chức năng và vấn đề đang test. Test-Friendly DevelopmentMột vài code dễ dàng để test hơn code khác. Code lý tưởng để test là có giao diện được định nghĩa mà mà không có nhiều trạng thái hoặc “setup” khác và không có nhiều dữ liệu ẩn để kiểm tra. Nếu bạn viết code và bạn biết sẽ viết test cho nó sau đó, một thứ vui vẻ sẽ diễn ra: bạn bắt đầu thiết kế code để dễ dàng test!. May mắn thay, coding theo cách này cũng có nghĩa bạn tạo code tốt hơn thông thường. Thiết kế Test-friendly thường 1 cách tự nhiên sẽ dẫn đến code tổ chức tốt hơn, với các phần riêng biệt làm những thứ riêng biệt TEST-DRIVEN DEVELOPMENTTest-driven development (TDD) là cách lập trình khi mà bạn sẽ xây dựng các tests trước khi bạn viết code thực tế. Những người đề xuất TDD tin tưởng rằng quá trình này cải thiện sâu sắc chất lượng các đoạn nontest code hơn nhiều so với nếu bạn viết các tests sau khi viết code. Đây là 1 chủ đề tranh luận sôi nổi mà chúng tôi không đi sâu vào. Ít nhất, chúng tôi đã tìm thấy rằng, chỉ cần giữ các testing trong khi viết code sẽ giúp code tốt hơn. Nhưng mà bất kể cho bạn triển khai TDD, kết quả cuối cùng là bạn có code để test các code khác. Mục đích của chương này là giúp bạn tạo các test dễ đọc và dễ viết. Trong tất cả các cách để chia 1 chương trình vào trong lớp và phương thức,những cách tách rời nhất thường dễ test nhất. Nói 1 cách khác, hãy nói chương trình của bạn rất kết nối với nhau, với 1 vào phương thức được gọi giữa các lớp và nhiều tham số cho tất cả các phương thức. Chương trình đó không chỉ có code khó hiểu mà test code cũng xấu xí và khó đọc, khó viết. Có nhiều thành phần “bên ngoài” (các biến global cần được khởi tạo, thư viện hoặc file cấu hình cần được load) cùng làm nó khó chịu hơn để viết tests. Nói chung, nếu bạn đang thiết kế code của bạn và nhận ra Hnn, thật là 1 cơn ác mộng để test, đây là 1 lý do tốt để dừng và suy nghĩa lại các thiết kế. Bảng 14-1 chỉ ra 1 vài các testing điển hình và các vấn đề về thiết kế. TABLE 14-1. Characteristics of less testable code, and how this leads to problems with design Characteristic Testability problem Design problem Use of global variables All the global state needs to reset for every test (otherwise, different tests can interfere with each other). Hard to understand which functions have what side effects. Can’t think about each function in isolation; need to consider the whole program to understand if everything works. Code depends on a lot of external components It’s harder to write any tests because there’s so much scaffolding to set up first. Tests are less fun to write, so people avoid writing tests. System is more likely to fail when one of the dependencies fails. It’s harder to understand what impact any given change might make. It’s harder to refactor classes. System has more failure modes and recovery paths to think about. Code has nondeterministic behavior Tests are flaky and unreliable. Tests that occasionally fail end up being ignored. The program is more likely to have race conditions or other nonreproducible bugs. The program is harder to reason about. Bugs in production are very difficult to track down and fix Trong 1 chiều hướng khác, nếu bạn có 1 thiết kế code dễ dàng để viết test, đó là 1 dấu hiệu tốt. Bảng 14-2 chỉ ra 1 vài lợi ích của testing và các đặc điểm thiết kế. TABLE 14-2. Characteristics of more testable code, and how this leads to good design Characteristic Testability problem Design problem Classes have little or no internal state Tests are easier to write because there is less setup needed to test a method and less hidden state to inspect. Classes with less state are simpler and easier to understand. Classes/functions only do one thing Fewer test cases are required to fully test it. Smaller/simpler components are more modular, and the system is generally more decoupled. Classes depend on few other classes; high decoupling Each class can be tested independently (much easier than testing multiple classes at once). System can be developed in parallel. Classes can be easily modified or removed without disrupting the rest of the system Functions have simple, well-defined interfaces There are well-defined behaviors to test for. Simple interfaces take less work to test. Interfaces are easier for coders to learn and are more likely to be reused. Going Too FarNó cũng có thể tập trung quá nhiều thứ trong test. Đây là 1 vài ví dụ: Hi sinh khả năng đọc real code để cho phép test. Thiết kế real code để có thể test được sẽ là vấn đề win-win: real code trở nên đơn giản và nhiều phần tách rời và các test của bạn cũng dễ viết. Nhưng nếu bạn phải chèn nhiều các đường ống xấu xí vào real code để bạn có thể test được, thì có gì đó sai sai ở đây. Bị ám ảnh về 100% phạm vi test. Testing lần đầu 90% code của bạn thường làm việc ít hơn 10% cuối. 10% cuối có thể liên quan đến giao diện người dùng, hoặc đưa ra các trường hợp lỗi, mà cái giá của bug không thực sự code và các nỗ lực để test nó cũng không đáng. Sự thật là bạn không bao giờ có phạm vi test 100%. Nếu nó không phải là 1 lỗi bị bỏ qua, nó có thể là 1 chức năng bị bỏ qua hoặc bạn không nhận ra được rằng spec đã được thay đổi. Tùy thuộc vào lỗi của bạn tốn kém như thế nào, sẽ có điểm thú vị về thời gian phát triển đáng kể để dành cho test code. Nếu bạn đang xây dựng nguyên mẫu 1 trang website, nó có thể không đáng để viết 1 vài test code nào cả. Mặt khác, nếu bạn đang viết 1 bộ điều khiển cho tàu vũ trụ hoặc các thiết bị y tế, testing có thể là mục tiêu chính của bạn. Hãy để testing có trong cách phát triển sản phẩm. Chúng ta đã thấy các tình huống trong đó thử nghiệm, vốn chỉ là một khía cạnh của dự án, chi phối toàn bộ dự án. Thử nghiệm trở thành một loại thần được xoa dịu, và các lập trình viên chỉ trải qua các nghi thức và chuyển động mà không nhận ra rằng thời gian kỹ thuật quý giá của họ có thể được chi tiêu tốt hơn ở nơi khác. SummaryTrong test code, khả năng đọc là rất quan trọng. Nếu test của bạn dễ đọc, chúng sẽ dễ viết, mọi người sẽ thêm được nhiều. Cũng như vậy, nếu bạn thiết kế real code dễ test, code của bạn sẽ có 1 thiết kế tổng thể tốt hơn. Đây là 1 vài điểm để cải thiện test của bạn Ở mức cao nhất của mỗi test nên ngắn gọn nhất có thể, lý tưởng nhất, mỗi test input/ouput có thể mô tả trong 1 dòng code. Nếu test của bạn lỗi, nó nên bắn ra 1 thông điệp lỗi làm cho lỗi dễ dàng tìm ra và sửa Sử dụng các input test đơn giản nhất kiểm tra code của bạn Tên các hàm test cần đầy đủ mô tả và rõ ràng cho mỗi test. Thay vì tên Test1(), sử dụng 1 cái tên như Test_&lt;FunctionName&gt;_&lt;Situation&gt;. Và trên hết, làm cho việc sửa đổi và thêm 1 test dễ dàng.","link":"/2020/05/24/Chapter-14-Testing-and-Readability/"},{"title":"Chapter 15: Designing and Implementing a “Minute&#x2F;Hour Counter”","text":"Hãy xem 1 cấu trúc dữ liệu được sử dụng trong code production thực tế: một “minute/hour counter”. Chúng tôi sẽ đưa ra cho bạn quá trình tự suy nghĩ tự nhiên của 1 kĩ sư có thể trải qua, đầu tiên thử giải quyết vấn đề và sao đó cải thiện hiệu năng của nó và thêm các chức năng. Quan trọng nhất, chúng ta sẽ cố gắng để code dễ đọc , sử dụng các nguyên tắc trong cuốn sách này. Chúng tôi có thể có một số lượt sai trên đường đi hoặc phạm sai lầm khác. Hãy xem nếu bạn có thể làm theo và bắt được chúng. The ProblemChúng ta cần theo dõi số lượng bytes của 1 web server được truyền trong 1 phút và trong 1 giờ. Đây là 1 vấn đề khác đơn giản, nhưng như bạn sẽ thấy, giải quyết nó hiệu quả là 1 thử thách thú vị. Hãy bắt đầu bằng việc định nghĩa class interface. Defining the Class InterfaceĐây là phiên bản đầu tiên của chúng ta với class interface trong C++:1234567891011class MinuteHourCounter { public: // Add a count void Count(int num_bytes); // Return the count over this minute int MinuteCount(); // Return the count over this hour int HourCount();};Trước khi chúng ta thực thư lớp này, hãy xem về tên và comment nếu có 1 vài thứ gì đó chúng ta muốn thay đổi. Improving the NamesTên MinuteHourCounter khá tốt. Nó rõ ràng, cụ thể và dễ đọc. Trong lớp này, phương thức MinuteCount() và HourCount() cũng hợp lý. Bạn cũng có thể gọi nó là GetMinuteCount() và GetHourCount() nhưng không giúp ích được nhiều. Như chúng tôi đã nói ở chương 3 Names That Can’t Be Misconstrued, “get” ngụ ý “lightweight accessor” (kiểu theo tác nhẹ nhàng thôi) với nhiều người. Và như bạn thấy, sự thực thi này không nhẹ nhàng, do đó tốt nhất là bỏ “get” đi. Phương thức tên Count() thì có vấn đề. Chúng tôi đã hỏi đồng nghiệp là họ nghĩ Count() sẽ làm gì à 1 số người đã nghĩ nó là “trả về tổng số đếm trong mọi lúc”. Tên này có 1 chút phản trực giác (không có ý định chơi chữ). Vấn đề là Count vừa là danh từ vừa là động từ và có thể nghĩa là cả “Tôi muốn đếm số mẫu bạn đã thấy” hoặc “Tôi muốn bạn đếm mẫu này”. Đây là 1 vài tên thay thế có thể cân nhắc với Count():• Increment()• Observe()• Record()• Add() Increment() có thể gây hiểu nhầm vì nó có ý là giá trị này chỉ tăng (trong trường hợp của chúng ta, số giờ giao động theo thời gian)Observe() okay, nhưng hơi mơ hồ.Record() cũng vừa là danh từ, vừa là động từ, không tốt lắm.Add() thú vị vì nó vừa có nghĩa “thêm số này” hoặc “thêm 1 danh sách của dữ liệu” - trong trường hợp của chúng ta, nó là 1 chút của cả 2 do đó vẫn hoạt động. Do đó chúng ta sẽ đổi tên phương thức thành void Add(int num_bytes) Nhưng đối số với tên num_bytes quá cụ thể. Đúng, trường hợp sử dụng chính của chúng ta là đếm cố bytes nhưng MinuteHourCounter không cần biết điều đó. Chúng ta có thể sử dụng nhiều tên chung hơn như delta nhưng khái niệm delta thường được sử dụng cho cả số âm, và đó là điều chúng ta không muốn. Tên count nên được sử dụng - nó đơn giản, chung hơn và ngụ ý là “không âm”. Ngoài ra, nó còn cho phép chúng ta lén lút sử dụng từ “count” trong một bối cảnh ít mơ hồ hơn. 15.2.2. Improving the CommentsĐây là class interface chúng ta có cho đến thời điểm hiện tại:1234567891011class MinuteHourCounter {public: // Add a count void Add(int count); // Return the count over this minute int MinuteCount(); // Return the count over this hour int HourCount();};Hãy xem mỗi comment và cải thiện chúng. Xem xét comment đầu tiên:12// Add a countvoid Add(int count);Comment này hoàn toàn dư thừa - nó nên được xóa hoặc cải thiện. Đây là phiên bản cải thiện của nó:1234// Add a new data point (count &gt;= 0).// For the next minute, MinuteCount() will be larger by +count.// For the next hour, HourCount() will be larger by +count.void Add(int count);Bây giờ xem xét comment cho MinuteCount():12// Return the count over this minuteint MinuteCount();Khi chúng tôi hỏi đồng nghiệp rằng comment này có nghĩa là gì, có 2 sự giải thích mâu thuẫn: Trả về số đếm trong đồng hồ, như là 12:13pm Trả về số đếm trong 60 giây, bất kể ranh giới phút đồng hồ.Cách hiểu thử 2 là đúng cái mà nó đang hoạt động. Do đó để không bị hiểu nhầm, chúng ta sẽ thêm mô tả comment:12// Return the accumulated count over the past 60 seconds.int MinuteCount(); (Tương tự, bạn hoàn toàn có thể cải thiện comment cho HourCount()) Đây là định nghĩa lớp sau tất cả thay đổi cho đến thời điểm hiện tại, với các comment class-level:1234567891011121314// Track the cumulative counts over the past minute and over the past hour.// Useful, for example, to track recent bandwidth usage.class MinuteHourCounter { // Add a new data point (count &gt;= 0). // For the next minute, MinuteCount() will be larger by +count. // For the next hour, HourCount() will be larger by +count. void Add(int count); // Return the accumulated count over the past 60 seconds. int MinuteCount(); // Return the accumulated count over the past 3600 seconds. int HourCount();};(Để ngắn gọn, chúng tôi sẽ bỏ lại comment này từ bây giờ) GETTING AN OUTSIDE PERSPECTIVEBạn đã nhận thấy rằng đã có 1 vài trường hợp chúng ta chạy các thứ bởi đồng nghiệp. Hỏi họ để có 1 vài quan điểm bên ngoài là cách tốt để kiểm tra xem code của bạn có “user-friendly” chưa. Cố gắng cởi mở với những ấn tượng đầu tiên của họ, vì những người khác có thể có thể đi đến kết luận tương tự. Và “người khác” ở đây có thể là chính bạn 6 tháng tới :D. Attempt 1: A Naive SolutionTiếp tục giải quyết vấn đề. Chúng ta sẽ bắt đầu với 1 giải pháp đơn giản: chỉ giữ danh sách sự kiện thời gian:12345678910111213141516class MinuteHourCounter { struct Event { Event(int count, time_t time) : count(count), time(time) {} int count; time_t time; }; list&lt;Event&gt; events; public: void Add(int count) { events.push_back(Event(count, time())); } ...};Chúng tôi có thể đếm qua sự kiện gần đây nhất nếu cần:1234567891011121314151617181920212223class MinuteHourCounter { ... int MinuteCount() { int count = 0; const time_t now_secs = time(); for (list&lt;Event&gt;::reverse_iterator i = events.rbegin(); i != events.rend() &amp;&amp; i-&gt;time &gt; now_secs - 60; ++i) { count += i-&gt;count; } return count; } int HourCount() { int count = 0; const time_t now_secs = time(); for (list&lt;Event&gt;::reverse_iterator i = events.rbegin(); i != events.rend() &amp;&amp; i-&gt;time &gt; now_secs - 3600; ++i) { count += i-&gt;count; } return count; }}; Is the Code Easy to Understand?Mặc dù giải pháp là “đúng” nhưng có 1 vài vấn đề quanh việc đọc code: Vòng lặp for có 1 chút lắm mồm =)). Nhiều người đọc sẽ phải chậm lại đáng kể trong khi họ đang đọc phần này của code (ít nhất họ nên vậy, nếu họ chắc chắc rằng chỗ này không có 1 vài lỗi) MinuteCount() và HourCount() gần như giống hệt. Bạn nên làm code nhỏ honwn nếu chúng bị lặp code. Chi tiết này cực kì quan trọng vì việc giảm thiểu code là tương đối phức tạp (Tốt hơn là có tất cả các code khó có giới hạn trong 1 chỗ) An Easier-to-Read VersionCode của MinuteCount() và HourCount() giờ chỉ khác nhau hằng số (60 vs 3600). Tái cấu trúc mã rõ ràng, thêm helper để xử lý cả 2 trường hợp:12345678910111213141516171819202122232425262728class MinuteHourCounter { list&lt;Event&gt; events; int CountSince(time_t cutoff) { int count = 0; for (list&lt;Event&gt;::reverse_iterator rit = events.rbegin(); rit != events.rend(); ++rit) { if (rit-&gt;time &lt;= cutoff) { break; } count += rit-&gt;count; } return count; } public: void Add(int count) { events.push_back(Event(count, time())); } int MinuteCount() { return CountSince(time() - 60); } int HourCount() { return CountSince(time() - 3600); }};Có 1 vài điểm đáng kể trong đoạn mã mới này. Đầu tiên là CountSince() nhận vào 1 đối số cutoff tuyệt đối hơn là nhận vào 1 secs_ago tương đối với giá trị (60 hoặc 3600). Mặc dù cách này vẫn làm việc, nhưng cách này làm CountSince() có 1 công việc dễ dàng hơn 1 chút. Thứ 2 là việc đặt tên vòng lặp từ i thành rit. Tên i thường được sử dụng cho chỉ số số nguyên. Chúng tôi suy ngẫm sử dụng tên it, là chung cho vòng lặp. Nhưng trường hợp này chúng tôi đang có 1 vòng lặp ngược lại và thực tế này quan trọng cho sự đúng đắn của code. Bằng cách có phần tiền tố tên biến với r, nó thêm 1 đối xứng thoải mái cho các câu lệnh kiểu rit != events.rend(). Cuối cùng, chúng tôi trích xuất điều kiện rit-&gt;time &lt;= cutoff khỏi vòng lặp và làm nó tách biệt if. Tại sao? Bởi vì các vòng lặp “truyền thống” có dạng for(begin; end; advance) dễ đọc. Người đọc có thể hiểu ngay lập tức nó đang “đi qua tất cả các phần tử” và không nghỉ nhiều về nó. Performance ProblemsMặc dù chúng ta đã cải thiện được thẩm mỹ của code, nhưng cách thiết kế này vẫn có 2 vấn đề về hiệu năng: Nó chỉ tiếp tục phát triển.Class này giữ toàn bộ sự kiện nó từng thấy - nó sử dụng 1 bộ nhớ không giới hạn. Lý tưởng, MinuteHourCounter nên tự động được xóa các sự kiện cái mà cũ hơn 1 giờ sau vì chúng không cần thiết nữa. MinuteCount() and HourCount() are too slow.Phương thức CountSince() cần O(n) lần, với n là số điểm dữ liệu trong cửa sổ thời gian liên quan. Tưởng tượng rằng server hiệu năng cao gọi Add() hàng trăm lần mỗi giây. Mỗi lần gọi HourCount() sẽ phải đếm qua 1 triệu điểm. Về lý tưởng, MinuteHourCounter nên giữ biến separate minute_count và hour_count, định kì với mỗi lần gọi Add(). Attempt 2: Conveyor Belt DesignChúng tôi cần thiết kế để giải quyết cả 2 vấn đề trên Xóa dữ liệu không cần thiết Luôn cập nhật minute_count và hour_count Đây là cách mà chúng tôi sẽ làm: Chúng tôi sẽ sử dụng list như 1 băng chuyền. Khi data mới đến và 1 cái kết thúc, chúng tôi sẽ thêm vào tổng. Và khi dữ liệu quá cũ, nó đã “rơi ra” khỏi đầu kia và chúng tôi trừ đi tổng số của chúng tôi. Có 1 vài cách chúng tôi có thể thực thi thiết kế dây chuyền này. Một cách là duy trì 2 danh sách độc lập, 1 cho past minute, 1 cho past hour. Khi 1 sự kiện mới đến, nó thêm 1 bản copy vào cả 2 danh sách Cách này khá đơn giản, nhưng nó không hiệu quả vì nó tạo ra 2 bản copy cho mỗi sự kiện. Một cách khác để duy trì 2 lists nơi mà sự kiện được khởi tạo vào list đầu tiên (the “last minute events”) và sau đó sẽ cho ăn vào danh sách thứ 2 (the “last hour [nhưng không phải minute cuối cùng nhé] events”) Thiết kế theo dây chuyển “2 giai đoạn” dường như hiệu quả hơn, do đó sẽ thực thi cái này. Implementing the Two-Stage Conveyor Belt DesignHãy bắt đầu bằng cách liệt kê các thành phần của class:1234567class MinuteHourCounter { list&lt;Event&gt; minute_events; list&lt;Event&gt; hour_events; // only contains elements NOT in minute_events int minute_count; int hour_count; // counts ALL events over past hour, including past minute};Điểm mấu chốt của thiết kế băng chuyền này là có thể “dịch chuyển” các sự kiện khi thời gian trôi qua, do đó các sự kiện di chuyển từ minute_events tới hour_events và minute_count và hour_count nhận các cập nhật phù hợp. Để làm điều này, chúng ta sẽ tạo 1 phương thức helper tên là ShiftOldEvents(). Một khi chúng ta có phương thức này, phần còn lại của lớp này khá dễ thực thi:12345678910111213141516171819void Add(int count) { const time_t now_secs = time(); ShiftOldEvents(now_secs); // Feed into the minute list (not into the hour list--that will happen later) minute_events.push_back(Event(count, now_secs)); minute_count += count; hour_count += count;}int MinuteCount() { ShiftOldEvents(time()); return minute_count;}int HourCount() { ShiftOldEvents(time()); return hour_count;}Rõ ràng, chúng ta đã trì hoãn được tất cả các công việc bẩn thỉu vào ShiftOldEvents():1234567891011121314151617181920// Find and delete old events, and decrease hour_count and minute_count accordingly.void ShiftOldEvents(time_t now_secs) { const int minute_ago = now_secs - 60; const int hour_ago = now_secs - 3600; // Move events more than one minute old from 'minute_events' into 'hour_events' // (Events older than one hour will be removed in the second loop.) while (!minute_events.empty() &amp;&amp; minute_events.front().time &lt;= minute_ago) { hour_events.push_back(minute_events.front()); minute_count -= minute_events.front().count; minute_events.pop_front(); } // Remove events more than one hour old from 'hour_events' while (!hour_events.empty() &amp;&amp; hour_events.front().time &lt;= hour_ago) { hour_count -= hour_events.front().count; hour_events.pop_front(); }} Are We Done?Chúng ta đã giải quyết 2 vấn đề liên quan đến hiệu năng, và giải pháp này đã hoạt động. Với nhiều ứng dụng, giải pháp này là đủ tốt. Nhưng vẫn có 1 số thiếu sót. Đầu tiên, thiếu kế thì rất không linh hoạt. Giả sử bạn muốn tiếp tục đếm trong 24h qua. Điều này yêu cầu thay đổi nhiều trong code. Và như bạn có thể thấy ShiftOldEvents() là 1 hàm khá nặng, với sự tương tác tinh tế giữa dữ liệu phút và giờ. Thứ 2, lớp này có 1 bộ nhớ khá lớn. Giả sử bạn có 1 server high-traffic gọi Add() 100 lần mỗi giây. Vì chúng ta giữ tất cả các dữ liệu trong 1h qua, đoạn code này sẽ kết thúc và yêu cầu tầm 5M bộ nhớ Nói chung, khi Add() thường xuyên được gọi, chúng ta sẽ cần nhiều bộ nhớ hơn. Trên môi trường sản phẩm, thư việc sử dụng bộ nhớ lớn, không thể đoán trước là không tốt. Lý tưởng, MinuteHourCounter sẽ sử dụng 1 lượng bộ nhớ nhất định mà không quan tâm hàm này được gọi bao nhiêu lần. Attempt 3: A Time-Bucketed DesignBạn có thể nhận thấy, cả 2 cách thực thi trên có 1 bug nhỏ. Chúng ta sử dụng time_t để lưu timestamp, cái mà lữu trữ số giây dưới dạng 1 số nguyên. Vì điều làm tròn này MinuteCount() thực sự trả về gì đó giữa 59 và 60 giây, dựa vào khi nào bạn gọi nó. Ví dụ nếu 1 sự kiện diễn ra tạo time = 0.99 giây, thời gian trả về được làm tròn là 0s. Và nếu bạn gọi MinuteCount() tại time = 60.1 giây, nó sẽ trả về tổng các sự kiện có t=1,2,3,...60. Do đó sự kiện đầu tiên sẽ bị mất, mặc dù về mặt kĩ thuật đang chậm hơn 1 phút. Trung bình, MinuteCount() sẽ trả về 59.5s giá trị của dữ liệu. Và HourCount() sẽ trả về 3599.5s giá trị dữ liệu (một lỗi không đáng kể). Chúng ta có thể sửa lỗi này bằng cách sử dụng 1 thời gian với subsecond granularity. Nhưng một cách thú vị, đa số ứng dụng sử dụng 1 MinuteHourCounter không cần mức độ chính xác ở lần nhìn đầu tiên. Chúng ta sẽ khai thác sự thật này với 1 MinuteHourCounter mới, cái mà nhanh hơn nhiều mà sử dụng ít không gian hơn. Đó là sự đánh đổi độ chính xác cho hiệu năng sẽ rất xứng đáng. Ỷ tưởng chính là kết hợp tất cả các sự kiện trong 1 cửa sổ nhỏ lại với nhau, và tóm tắt các sự kiện này với 1 tổng số duy nhất. Ví dụ các Sự kiện trong 1 phút qua có thể được thêm vào trong 60 xô rời rạc, độ rộng là 1 giây. Các sự kiện trong 1 giờ qua có thể được thêm vào 60 các xô rời rạc, độ rộng là 1 phút. Sử dụng các xô như hình trên, phương thức MinuteCount() và HourCount() sẽ chính xác cho 1 phần trên 60, điều này là hợp lý. Nếu cần nhiều độ chính xác hơn, nhiều buckets có thể được sử dụng để đổi lấy dung lượng bộ nhớ lớn hơn. Nhưng thứ quan trọng nhất các thiết kế này đã sửa được, sử dụng bộ nhớ đoán trước được. Implementing the Time-Bucketed DesignThực thi theo các thiết kế này chỉ có 1 lớp sẽ tạo nhiều code phức tạp cái mà khó để nhớ. Thay vào đó, chúng tôi sẽ theo lời khuyên trong Chapter 11, One Task at a Time và tạo ra các lớp riêng biệt để xử lý các phần khác nhau của vấn đề. Để bắt đầu, tạo 1 lớp tách biệt để đếm khoảng thời gian duy nhất (như giờ trước). Chúng tôi sẽ gọi nó là TrailingBucketCounter. Đây thực chất là 1 phiên bản chung của MinuteHourCounter xử lý chỉ 1 khoảng thời gian:1234567891011// A class that keeps counts for the past N buckets of time.class TrailingBucketCounter { public: // Example: TrailingBucketCounter(30, 60) tracks the last 30 minute-buckets of time. TrailingBucketCounter(int num_buckets, int secs_per_bucket); void Add(int count, time_t now); // Return the total count over the last num_buckets worth of time int TrailingCount(time_t now);};Bạn có thể tự hỏi tại sao Add() và TrailingCount() yêu cầu thời gian hiện tại (time_t_now) như 1 đối số - Tại sao nó không chỉ đơn giản là tự gọi current time()","link":"/2020/05/24/Chapter-15-Designing-and-Implementing-a-%E2%80%9CMinute-Hour-Counter%E2%80%9D/"},{"title":"Chapter 2: Packing Information into Names","text":"Bất cứ khi nào bạn đang đặt tên cho 1 biến, 1 hàm hoặc 1 lớp, có rất nhiều nguyên lý giống nhau được áp dụng. Chúng tôi thích nghĩ về tên như 1 comment nhỏ. Thậm chí nó không xuất hiện ở nhiều chỗ, bạn có thể truyền tải nhiều thông tin bằng cách chọn 1 cái tên tốt. KEY IDEAPack information into your names. Rất nhiều tên chúng ta nhìn thấy là mơ hồ, như tmp. Thậm chí những từ dường mà chúng ta nhìn có vẻ hợp lý như size hoặc get cũng không đóng gói nhiều thông tin. Chương này sẽ chỉ ra cho bạn làm sao để chọn 1 tên để làm điều đó. Chương này được tổ chức với 6 chủ đề cụ thể: Chọn 1 từ chuyên biệt Tránh các tên chung chung (hoặc biết khi nào nên sử dụng chúng) Sử dụng các tên cụ thể thay vì các tên trừu tượng. Đính thêm các thông tin vào tên, bằng cách sử dụng 1 hậu tố hoặc tiền tố. Quyết định độ dài của tên nên được sử dụng Sử dụng định dạng tên để đóng gói thêm các thông tin. Chọn các từ cụ thể, xác địnhMột phần đóng góp “đưa thêm thông tin vào tên” là chọn các từ với nghĩa xác định và tránh những từ “trống”. Ví dụ từ Get là rất không rõ nghĩa trong ví dụ:12def GetPage(url): ...Từ Get không nói lấy ờ local cache, từ DB hay từ Internet. Nếu lấy từ Internet, một cái tên xác định hơn sẽ nên là FetchPage()or DownloadPage() Tương tự ví dụ với Size(). Thay vào đó các tên sau sẽ rõ nghĩa hơn Height(), NumNodes(), or MemoryBytes(). Stop cũng nên lấy tên là Pause() or Resume() or Kill(). Tìm các từ có nhiều “màu sắc” Đừng tiết kiệm sử dụng các từ đồng nghĩa hay nhờ bạn bè gợi ý một cái tên hay ho hơn. Tiếng Anh là một ngôn ngữ đa dạng, tha hồ từ cho bạn lựa chọn để giải quyết các vấn đề của bạn. Một vài từ trong tiếng Anh “giàu màu sắc” bạn có thể xem xét sử dụng trong ngữ cảnh của mình: Word Alternatives send deliver, dispatch, announce, distribute, route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add, new Trong PHP, có 1 hàm với chuỗi là explode(). Đây là 1 cái tên nhiều màu sắc và nó vẽ ra 1 bước tranh tốt để ngắt 1 cái gì đó vào từng phần, nhưng làm sao để phân biệt được nó với split()? (Hai hàm này là khác nhau nhưng khó để chỉ ra điểm khác nhau giữa chúng dựa vào tên). KEY IDEAIt’s better to be clear and precise than to be cute. Tránh các tên chung chung như tmp, retvalTên kiểu tmp, retval (return value) và foo được hiểu là “Tao không nghĩ ra được tên”. Thay vào đó sử dụng một tên trống như vậy, hãy chọn 1 cái tên mô tả giá trị và mục đích của đối tượng :D123456var euclidean_norm = function (v) { var retval = 0.0; for (var i = 0; i &lt; v.length; i += 1) retval += v[i] * v[i]; return Math.sqrt(retval);};Tạm thời sử dụng retval khi bạn không thể nghĩ được 1 cái tên tốt hơn cho giá trị trả về. Nhưng retval không chứa nhiều thông tin khác ngoài “Tôi là 1 giá trị trả về” (cái mà được sử dụng hiển nhiên ở mọi chỗ). Một cái tên tốt hơn mô tả mục đích của biến hoặc giá trị nó chứa. Trong trường hợp này, biến là lũy thừa tổng hình vuông của v. Do đó, một cái tên tốt hơn là sum_squares. Điều này cũng thông báo mục đích của biến trước và có thể giúp bạn bắt lỗi nếu có. Chẳng hạn, hãy tưởng tượng nếu bên trong vòng lặp vô tình:1retval += v[i];Lỗi này sẽ rõ ràng hơn nếu sử dụng tên là sum_squares:1sum_squares += v[i]; // Where's the &quot;square&quot; that we're summing? Bug!ADVICEThe name retval doesn’t pack much information. Instead, use a name that describes the variable’s value. tmpXem xét ví dụ cơ bản về hoán đổi 2 biến:12345if (right &lt; left) { tmp = right; right = left; left = tmp;}Trong các trường hợp như vậy, tmp lại hoàn toàn ổn. Mục đích duy nhất của biến là lưu trữ tạm thời, với vòng đời chỉ có 1 vài dòng. Tên tmp truyền đạt ý nghĩa cụ thế với người đọc - đây là biến không có nhiệm vụ khác. Nó không được truyền vào hàm khác hoặc được reset hoặc sử dụng lại nhiều lần. Nhưng trong trường hợp này, tmp được sử dụng vì sự lười biếng:12345String tmp = user.name();tmp += &quot; &quot; + user.phone_number();tmp += &quot; &quot; + user.email();...template.set(&quot;user_info&quot;, tmp);Mặc dù biến này có vòng đời ngắn, lưu trữ giá trị tạm thời nhưng đây không phải là nhiệm vụ chính, phần quan trọng nhất của nó. Thay vào đó, 1 cái tên như user_info sẽ có tính mô tả hơn Trong trường hợp sau, tmp nên được sử dụng, nhưng chỉ là 1 phần:123tmp_file = tempfile.NamedTemporaryFile()...SaveData(tmp_file, ...)Nhận thấy rằng, chúng tôi sử dụng biến tmp_file và không chỉ là tmp vì nó là 1 đối tượng file. Tưởng tượng nếu bạn chỉ gọi nó là tmp:1SaveData(tmp, ...)Chỉ nhìn vào 1 dòng code, không rõ ràng là tmp là 1 file, 1 filename hoặc thậm chí có thể là dữ liệu được ghi. ADVICEThe name tmp should be used only in cases when being short-lived and temporary is the most important fact about that variable. Vòng lặpCác biến i,j,k để mô tả cho chúng ta là nó đang ở vòng lặp. Mặc dù các tên này là chung chung nhưng chúng ta sẽ hiểu là “I am an iterator.” (trên thực tế bạn có thể dùng tên này với mục đích khác, nhưng như thế có thể gây nhầm lẫn, đừng làm vậy!!!) Nhưng đôi khi liệu có tên nào tốt hơn i, j, k. Xem xét ví dụ sau12345for (int i = 0; i &lt; clubs.size(); i++) for (int j = 0; j &lt; clubs[i].members.size(); j++) for (int k = 0; k &lt; users.size(); k++) if (clubs[i].members[k] == users[j]) cout &lt;&lt; &quot;user[&quot; &lt;&lt; j &lt;&lt; &quot;] is in club[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; endl;Trong khối if members[] và users[] đang sử dụng sai chỉ số. Bug kiểu này rất khó tìm bởi những dòng mã có vẻ tốt kiểu như:1if (clubs[i].members[k] == users[j])Trong trường hợp này, sử dụng một cái tên tốt hơn có thể giúp ích. Thay vì chọn (i,j,k) bạn có thể chọn tên khác như (club_i, members_i, users_i) hoặc cô đọng hơn tí thì là (ci , mi , ui ). Khi đó các dòng trên sẽ là1if (clubs[ci].members[ui] == users[mi]) # Bug! First letters don't match up. =&gt; bug roàiChúng ta dễ dàng sửa thành:1if (clubs[ci].members[mi] == users[ui]) # OK. First letters match. Quyết định về các tên chung chungNhư bạn đã thấy, một vài trường hợp sử dụng các tên chung chung là hữu ích. ADVICEIf you’re going to use a generic name like tmp, it, or retval, have a good reason for doing so. Rất nhiêu lần, chúng được lạm dụng cho sự lười biếng. Điều này thì dễ hiểu - khi không có tên nào tốt hơn trong đầu, dễ hơn là chỉ sử dụng các tên không có nhiều ý nghĩa như foo và tiếp tục. Nhưng nếu bạn có 1 thói quen là dành ra vài giây để nghĩ 1 cái tên tốt, bạn sẽ tìm thấy “bắp cơ về đặt tên” của bạn sẽ lên nhanh chóng :D Ưu tiên các tên cụ thể hơn là các tên trừu tượng Khi đặt tên cho biến, hàm hoặc các thành phần khác, mô tả nó cụ thể hơn là 1 thứ trừu tượng. Ví dụ, giả sử bạn có 1 phương thức nội bộ tên là ServerCanStart(), cái mà kiểm tra xem server có thể nghe 1 cổng TCP/IP không? Tên ServerCanStart() là 1 cái gì đó trừu tượng. Một cái tên cụ thể hơn sẽ là CanListenOnPort(). Tên mô tả trực tiếp cái phương thức sẽ làm. Hai ví dụ tiếp theo minh họa sâu hơn phần này. Example: DISALLOW_EVIL_CONSTRUCTORSĐây là ví dụ trong codebase của Google. Trong C++, nếu bạn không định nghĩa một hàm tạo sao chép hoặc toán tử gán cho class của mình, một toán tử mặc định sẽ được cung cấp. Mặc dù tiện dụng, các phương thức này có thể dễ dàng rõ rì bộ nhớ và các rủi ro khác vì chúng thực thi các “behind the scenes” ở nơi mà chúng ta không nhận ra. Kết quả là, Google có 1 quy ước disallow hàm tạo “tác quái” này, sử dụng 1 marco:123456class ClassName { private: DISALLOW_EVIL_CONSTRUCTORS(ClassName); public: ...};Marco được định nghĩa như sau:123#define DISALLOW_EVIL_CONSTRUCTORS(ClassName) \\ ClassName(const ClassName&amp;); \\ void operator=(const ClassName&amp;);Bằng cách đặt marco này vào private, 2 phương thức này trở thành private do đó bạn không thể sử dụng thậm chí chỉ là vô tình Tên DISALLOW_EVIL_CONSTRUCTORS không phải là 1 cái tên tốt. Sử dụng từ “evil” là 1 cái tên không rõ ràng và còn gây tranh cãi. Quan trọng hơn, nó không rõ ràng cái gì marco đang disallow. Nó disallows phương thức operator=(), thậm chí không phải là 1 “hàm tạo”! Tên được sử dụng nhiều năm nhưng cuối cùng đã được thay thế với 1 cái tên ít rõ ràng và nhiều thông tin cụ thể hơn:1#define DISALLOW_COPY_AND_ASSIGN(ClassName) ... Example: –run_locallyMột trong những chương trình có tùy chọn cờ command-line tên là --run_locally. Cờ này sẽ giúp chương trình in ra thêm các thông tin để debugging nhưng chạy chậm hơn. Cờ này thường được sử dụng để testing các máy local, như laptop. Nhưng khi lập trình viên chạy nó ở remote server, hiệu năng là cực kì quan trọng, do đó cờ này không được sử dụng. Bạn có thể thấy cái tên --run_locally xuất hiện như thế nào, nhưng nó có 1 vài vấn đề: Một thành viên mới của team không biết nó làm gì. Anh ấy sẽ sử dụng nó khi chạy local (giả sử như vậy) nhưng anh ta không biết tại sao cần nó. Thỉnh thoảng, chúng ta cần in các thông tin debugging trong khi chương trình chạy remote. Truyền --run_locally chạy 1 chương trình remote nhìn có vẻ buồn cười, và nó có thể gây nhầm lẫn. Thỉnh thoảng chúng tôi sẽ chạy kiểm tra hiệu năng local nhưng không muốn logging làm chậm nó, do đó chúng tôi không sử dụng được --run_locally. Vấn đề --run_locally là được đặt tên theo tình huống mà nó thường được sử dụng. Thay vào đó, 1 tên cờ như --extra_logging sẽ trực quan và rõ ràng hơn. Nhưng điều gì sẽ xảy ra nếu --run_locally cần nhiều hơn chỉ thêm logging? Ví dụ, giả sử nó cần set up va sử dụng các database trên máy local. Bây giờ, tên --run_locally dường như ngon hơn vì nó có thể kiểm soát cả 2 thứ cùng 1 lúc. Nhưng sử dụng nó cho mục đích đó sẽ là chọn một cái tên vì nó mơ hồ và gián tiếp, có lẽ không phải là một ý tưởng tốt. Giải pháp tốt hơn là tạo một cờ thứ hai có tên --use_local_database. Mặc dù bây giờ bạn phải sử dụng hai cờ, những cờ này nhiều hơn rõ ràng; không cố gắng gộp hai ý tưởng trực giao thành một, và chúng cho phép bạn tùy chọn chỉ sử dụng một ý tưởng chứ không phải ý tưởng khác. Thêm các thông tin vào tênNhư chúng ta đã nhắc từ phần 1, tên của biến giống như một comment nhỏ. Giá trị với đơn vịNếu biến của bạn là đơn vị đo, thật hữu ích nếu bạn thêm đơn vị vào tên biếnVí dụ đo thời gian load 1 trang web1234var start = (new Date()).getTime(); // top of the page...var elapsed = (new Date()).getTime() - start; // bottom of the pagedocument.writeln(&quot;Load time was: &quot; + elapsed + &quot; seconds&quot;);Không có gì sai trong code nhưng nó sẽ không chạy vì getTime()trả về milisecond, không phải second. Thêm _ms vào tên biến bạn có thể thấy tốt hơn1234var start_ms = (new Date()).getTime(); // top of the page...var elapsed_ms = (new Date()).getTime() - start_ms; // bottom of the pagedocument.writeln(&quot;Load time was: &quot; + elapsed_ms / 1000 + &quot; seconds&quot;); Thêm các thông tin mã hóa vào thuộc tính (mã hóa bằng gì …)Kỹ thuật gắn thông tin bổ sung này vào tên không chỉ giới hạn ở các giá trị với các đơn vị. Bạnnên làm điều đó bất cứ lúc nào có một điều gì đó nguy hiểm hoặc đặc biệt về biến số. Ví dụ, có rất nhiều khai thác bảo mật đến từ việc không nhận ra rằng một số dữ liệu trong chương trình của bạn chưa ở trạng thái an toàn và bạn hoàn toàn có thể cải thiện nó. Để giải quyết nó, bạn có thể sử dụng tên biến như untrustedUrl hoặc unsafeMessageBody. Sau khi gọi hàm để xóa bỏ đầu vào không an toàn, kết quả biến sẽ là trusteUrl hoặc safeMessageBody. Dưới đây là bảng chỉ ra ví dụ bạn nên thêm các thông tin mã hóa vào tên biến Situation Variable name Better name A password is in “plaintext” and should be encrypted before further processing password plaintext_password A user-provided comment that needs escaping before being displayed comment unescaped_comment Bytes of html have been converted to UTF-8 html html_utf8 Incoming data has been “url encoded” data data_urlenc Tuy nhiên bạn không nên sử dụng tên như _utf8, unescaped ở mọi tên biến trong chương trình của bạn. Chúng thực sự quan trọng ở nơi bug do ai đó quên loại bỏ hoặc xử lý bảo mật cho các giá trị. Tên nên dài bao nhiêu là đủ Khi bạn chọn 1 tên tốt, có một ràng buộc ngầm định rằng cái tên không nên quá dài. Chẳng ai thích làm việc với cái tên kiểu như newNavigationControllerWrappingViewControllerForDataSourceOfClass. Với một cái tên dài, rất khó để nhớ và chiếm nhiều không gian trên màn hình khiến code càng khó đọc. Mặt khác, các lập trình viên có thể đưa ra lời khuyên này quá xa, chỉ sử dụng tên một từ (hoặc một chữ cái). Vậy bạn nên quản lý sự đánh đổi này như thế nào? Làm thế nào để bạn quyết định giữa việc đặt tên một biến d, ngày hoặc days_since_last_update? Quyết định này là một cuộc gọi phán xét có câu trả lời hay nhất phụ thuộc vào chính xác biến đó là như thế nào đang được sử dụng. Nhưng đây là một số hướng dẫn để giúp bạn quyết định. Tên ngắn nên được sử dụng trong phạm vi ngắn Chúng ta đã nhắc tới hạn chế sử dụng biến tmp và retval, nhưng không hẳn là chúng ta không được dùng. Với các phạm vi ngắn, chỉ vài dòng code, dùng các biến này vẫn có thể dễ hiểu với các lập trình viên. Xem xét ví dụ sau:12345if (debug) { map&lt;string,int&gt; m; LookUpNamesNumbers(&amp;m); Print(m);}Mặc dù biến m không chứa thông tin gì, tuy nhiên nó không hề có vấn đề chi vì người đọc có đầy đủ thông tin họ cần để hiểu đoạn code này. Tuy nhiên nếu m lại là 1 class hoặc là 1 biến global, nhìn kiểu như12LookUpNamesNumbers(&amp;m);Print(m)Code thật khó đọc, nó không cho ta biết m là cái mèo gì @@. Bởi vậy với các phạm vi rộng, tên cần chứa đủ thông tin cho rõ ràng Gõ tên dài - không còn là vấn đề nữaCó rất nhiều lý do tốt để tránh 1 cái tên dài nhưng “chúng khó gõ hơn” không phải là 1 trong số chúng. Mọi lập trình viên có text editor đã có những gợi ý “tự hoàn thành từ”. Nếu bạn không biết, thì hãy tự tìm hiểu trên text editor của mình nhé. Từ viết tắt và viết tắtLập trình viên có xu hướng dùng các từ viết tắt để tên của họ ngắn lại, ví dụ BEManager thay thế BackEndManager? Liệu nó có thể gây sự nhầm lẫn gì đó không? Theo kinh nghiệm của chúng tôi, viết tắt dành riêng cho dự án thường là một ý tưởng tồi. Chúng xuất hiện khó hiểu và đáng sợ với những người mới vào dự án. Cho đủ thời gian, chúng thậm chí bắt đầu xuất hiện khó hiểu và đáng sợ với các tác giả. Nguyên tắc để viết tắt là Liệu một người mới vào dự án có hiểu tên của nó không?. Nếu câu trả lời là có, nó có vẻ OK. Ví dụ, theo chuẩn chung của các LTV thì sử dụng eval viết tắt thay thế evaluation, doc là viết tắt của document, str là viết tắt String. Do vậy nếu 1 thành viên mới nhìn thấy biến FormatStr() hoàn toàn có thể hiểu được nghĩa. Tuy nhiên họ có thể không hiểu nghĩa của biến BEManager Vứt bỏ những từ không cần thiếtĐôi khi các từ bên trong tên có thể bị xóa mà không mất bất kỳ thông tin nào cả. Ví dụ ConvertToString có thể thay thế bằng tên ToString hơn mà không làm mất thông tin. Tương tự có thể thay thế DoServerLoop()bằng ServeLoop()cũng rõ ràng. Sử dụng định dạng tên để truyền đạt ý nghĩa (convention trong tên)Cách bạn sử dụng dấu gạch dưới, dấu gạch ngang và viết hoa cũng có thể đóng gói thêm thông tin trong một tên. Ví dụ, đây là một số mã C ++ tuân theo các quy ước định dạng được sử dụng cho các dự án nguồn mở của Google:12345678static const int kMaxOpenFiles = 100;class LogReader { public: void OpenFile(string local_file); private: int offset_; DISALLOW_COPY_AND_ASSIGN(LogReader);};Sử dụng các định dạng code khác nhau cho các đầu vào khác nhau tạo sự khác biệt cho các cú pháp và làm code của bạn dễ hiểu hơn. Một số loại format tên biến khá phổ biến là CamelCase cho tên lớp và lower_separated cho tên biến nhưng cũng có một số convention khác làm cho bạn ngạc nhiên. (convention công ty :D) Other Formatting ConventionsDựa vào ngữ cảnh trong project của bạn, chúng ta có thể có 1 vài convention với các format khác bạn có thể sử dụng để thêm thông tin. Ví dụ cuốn JavaScript: The Good Parts (Douglas Crockford, O’Reilly, 2008), tác giả có gợi ý “hàm tạo” nên là viết hoa và các hàm thông thường nên bắt đầu bằng chữ thường:12var x = new DatePicker(); // DatePicker() is a &quot;constructor&quot; functionvar y = pageHeight(); // pageHeight() is an ordinary functionĐây là ví dụ khác về JavaScript, khi bạn gọi các hàm trong thư viện jQuery (tên của nó là 1 kí tự $), 1 convention hữu ích là thêm kết quả với $ ở đầu:12var $all_images = $(&quot;img&quot;); // $all_images is a jQuery objectvar height = 250; // height is notXuyên suốt mã, sẽ rõ ràng $all_images là 1 đối tượng kết quả của jQuery. Đây là ví dụ cuối cùng, nó nói về HTML/CSS: khi chúng ta nhận vào 1 thẻ HTML tag với 1 thuộc tính id hoặc class, cả 2 kí tự gạch dưới và gạch ngang đều là các giá trị hợp lệ. Một convention có thể thì bạn hãy sử dụng gạch dưới để phân tách các từ trong IDs và gạch ngang để phân tách các từ trong class:1&lt;div id=&quot;middle_column&quot; class=&quot;main-content&quot;&gt; ...Cho dù bạn quyết định sử dụng các quy ước như thế này là tùy thuộc vào bạn và team của bạn. Nhưng bất cứ hệ thống nào bạn sử dụng, hãy nhất quán trong dự án của bạn. TÓM LẠI:Chủ đề duy nhất trong chương này là pack information into your names. Bằng cách này, có nghĩa là người đọc có thể trích xuất rất nhiều thông tin chỉ từ việc đọc tên. Một vài tips chúng tôi đã giới thiệu: Sử dụng các từ xác định rõ ragf: Get - Fetch hay Download Tránh các từ chung chung như tmp hay retval, không sử dụng chúng nếu không có lý do đặc biệt Sử dụng tên cụ thể để mô tả chi tiết hơn 1 cái gì đó the name ServerCanStart() is vague compared to CanListenOnPort() Thêm các thông tin quan trọng vào tên (ví dụ đơn vị) Sử dụng tên dài hơn cho phạm vi rộng hơn. Đừng sử dụng tên 1,2 kí tự cho nhiều màn hình. Tên ngắn tốt nhất là nên chỉ xuất hiện ở 1 vài dòng =)) Sử dụng các format tạo sự ý nghĩa cho tên :D Tài liệu tham khảoChapter 2","link":"/2020/05/24/Chapter-2-Packing-Information-into-Names/"},{"title":"Chapter 3: Names That Can’t Be Misconstrued","text":"Trong chương trước, chúng ta đã khám phá việc làm sao để đóng gói các thông tin vào tên của bạn. Trong chương này, chúng ta sẽ tập trung vào 1 chủ đề khác: coi chừng những cái tên có thể bị hiểu nhầm KEY IDEAD Chủ động xem xét các tên của bạn bằng cách hỏi chính mình “liệu có nghĩa khác có thể làm cho ai đó giải thích từ tên này” Thực sự bạn nên thử sự sáng tạo ở đây, tích cực tìm ra những “diễn giải sai”. Bước này giúp bạn phát hiện ra những cái tên mơ hồ để từ đó bạn có thể thay đổi chúng. Example: Filter()Giả sử bạn đang viết đoạn code dùng để lấy 1 tập kết quả trong database:1results = Database.all_objects.filter(&quot;year &lt;= 2011&quot;)result bây giờ chứa cái gì? Những đối tượng có năm &lt;= 2011? Những đối tượng có năm không &lt;= 2011? Vấn đề là filter là 1 từ mập mờ. Nó không rõ ràng như là “to pick out“ (lấy ra) hoặc “to get rid of“ (loại bỏ). Tốt nhất là bạn nên tránh dùng tên filter vì nó dễ gây hiểu nhầm. Nếu bạn muốn “to pick out”, một cái tên tốt hơn sẽ là select(). Nếu bạn muốn “to get rid of”, một cái tên tốt hơn sẽ là exclude(). Example: Clip(text, length)Giả sử bạn có 1 hàm giữ thông tin của đoạn văn123# Cuts off the end of the text, and appends &quot;...&quot;def Clip(text, length): ...Có 2 cách hiểu bạn có thể tưởng tượng với hành động Clip(): Nó sẽ xóa độ dài từ cuối. Nó cắt ngắn text đến độ dài tối đa. Cách hiểu thử 2 sẽ chiếm đa số nhưng bạn cũng không biết chắc. Để cho sự hoài nghi không còn, bạn có thể sử dụng một cái tên tốt hơn là Truncate(text, length). Tuy nhiên, tham số tên length cũng bị đổ lỗi. Nếu nó mà max_length, tên đã sẽ rõ ràng hơn. Nhưng chúng ta vẫn chưa xong. Tên max_length vẫn để lại 1 số cách hiểu khác: Số lượng bytes Số lượng kí tự Số lượng từ Như bạn đã thấy từ chương trước, đây là 1 trường hợp mà đơn vị nên được thêm vào tên. Trong trường hợp này, chúng ta muốn sử dụng “số lượng kí tự”, do đó thay vì đặt tên là max_length, hãy sử dụng max_chars. Prefer min and max for (Inclusive) LimitsỨng dụng mua sẵn của bạn không cho phép người dùng mua quá 10 sản phẩm trong 1 lần shopping123CART_TOO_BIG_LIMIT = 10if shopping_cart.num_items() &gt;= CART_TOO_BIG_LIMIT: Error(&quot;Too many items in cart.&quot;)Đoạn code này bị 1 lỗi kinh điển off-by-one. Chúng ta có thể dễ dàng sửa nó bằng cách thay thế &gt;= bằng &gt;:1if shopping_cart.num_items() &gt; CART_TOO_BIG_LIMIT:(Hoặc sửa CART_TOO_BIG_LIMIT lên 11). Nhưng vấn đề tận gốc là CART_TOO_BIG_LIMIT là 1 cái tên mơ hồ - nó không rõ ràng là bạn muốn “up to” (lớn hơn hẳn) hay “up to and including” (lớn hơn và bằng). ADVICE Cách rõ ràng nhất để đặt tên 1 giới hạn là đặt tên nó max_ hoặc min_ vào trước Trong trường hợp này, tên nên là MAX_ITEMS_IN_CART. Code mới sẽ đơn giản và rõ ràng:123MAX_ITEMS_IN_CART = 10if shopping_cart.num_items() &gt; MAX_ITEMS_IN_CART: Error(&quot;Too many items in cart.&quot;) Prefer first and last for Inclusive Ranges Đây là 1 ví dụ khác khi bạn không thể sử dụng lớn hơn hoặc lớn hơn hoặc bằng12print integer_range(start=2, stop=4)# Does this print [2,3] or [2,3,4] (or something else)?Mặc dù start là 1 cái tên hợp lý nhưng stop lại không hề rõ ràng và có thể có 1 vài cách hiểu. Đối với các phạm vi bao gồm như vậy (nơi mà phạm vi nên bao gồm cả điểm bắt đầu và điểm kết thúc), một sự lựa chọn tốt với tên first/last. Ví dụ1set.PrintKeys(first=&quot;Bart&quot;, last=&quot;Maggie&quot;)Không giống như stop, từ last ở đây đã rõ nghĩa. Thêm vào đó, first/last, tên min/max cũng có thể hoạt động trong phạm vi bao gồm này miễn là nghĩa phù hợp trong bối cảnh. Prefer begin and end for Inclusive/Exclusive Ranges Trong quá trình code, thường xuyên chúng ta gặp các phạm vi bao gồm/loại trừ. Ví dụ, nếu bạn muốn in ra tất cả các sự kiện xảy ra vào 16 tháng 10, chúng ta dễ dàng viết như sau:1PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 17 12:00am&quot;)Hơn là viết kiểu như:1PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 16 11:59:59.9999pm&quot;)Do đó một cặp tên tốt với tham số này là gì? Well, theo quy ước của lập trình chung, tên của phạm vi bao gồm/loại trừ là begin/end Nhưng từ end có 1 chút chưa rõ nghĩa. Ví dụ, trong câu văn “I’m at the end of the book,”, từ “end“ là đã bao gồm. Không may, tiếng anh không có từ nào ngắn gọn thay thế cho cụm từ “just past the last value” Bởi vì begin/end cũng là quốc ngữ (ít nhất, nó đã được sử dụng trong các thư viện chuẩn cho C++ và hầy hết những nơi mà 1 mảng cần phải được “cắt” theo cách này), nó vẫn là 1 sự lựa chọn tốt nhất. Naming BooleansKhi chọn 1 tên cho giá trị biến boolean hoặc 1 hàm sẽ trả về boolean, hãy chắc chắn rằng nó rõ ràng true và false thực sự có nghĩa. Đây là 1 ví dụ nguy hiểm1bool read_password = true;Tùy thuộc vào cách bạn đọc nó (không tính chơi chữ), có 2 cách có thể hiểu: Bạn cần đọc password Password đã được đọc Trong trường hợp này, cách tốt nhất để tránh từ “read” và đặt tên nó là need_password hoặc user_is_authenticated thay thế. Nói chung, thêm những từ như is, has, can, hoặc should có thể làm cho các giá trị boolean rõ ràng hơn. Ví dụ, một hàm được đặt tên là SpaceLeft() nhìn như nó sẽ trả về 1 số. Nếu nó có nghĩa là trả về boolean, một cái tên tốt hơn sẽ là HasSpaceLeft(). Cuối cùng, tốt nhất để tránh các từ phủ nhận trong 1 tên. Ví dụ, thay vì1bool disable_ssl = false;Nó nên dễ dàng được đọc hơn nếu nói là1bool use_ssl = true; Matching Expectations of Users: Phù hợp với mong đợi của người dùngMột vài cái tên gây hiểu nhầm di người dùng đã có những dự đoán trước về nghĩa của tên đó, mặc dù bạn có thể có nghĩa khác. Trong trường hợp này, cách tốt nhất là chỉ “chịu thua” và thay đổi tên nó để không gây hiểu nhầm Example: get*()Rất nhiều lập trình viên đã từng quy ước rằng phương thức bắt đầu với get sẽ là “lightweight accessors” (dịch tạm là lấy dữ liệu đơn giản, nhanh và nhẹ ý), cái mà đơn giản trả về 1 phần tử bên trong. Đi ngược lại quy ước này có khả năng đánh lừa người dùng đó. Đây là ví dụ trong java, cái mà không làm vậy12345678public class StatisticsCollector { public void addSample(double x) { ... } public double getMean() { // Iterate through all samples and return total / num_samples } ...}Trong trường hợp này, khi thực thi getMean, nó sẽ thực hiện vòng lặp qua các dữ liệu từ trước và tính toán giá trị trung bình. Bước này trả giá rất đắt nếu có rất nhiều dữ liệu. Nhưng 1 lập trình viên không nghĩ ngờ gì có thể gọigetMean() 1 cách bất cẩn, vì nghĩa nó là 1 lời gọi không đắt. Thay vào đó, phương thức nên được đặt tên như computeMean(), cái mà sẽ nói lên toán tử tốn kém. Example: list::size()Đây là 1 ví dụ trong thư viện chuẩn C++. Đoạn code dưới đây là nguyên nhân gây ra rất nhiều bug khó phát hiện, khiến servers của chúng ta chậm hoặc sập:123456void ShrinkList(list&lt;Node&gt;&amp; list, int max_size) { while (list.size() &gt; max_size) { FreeNode(list.back()); list.pop_back(); }}Lỗi ở đây là tác giả không biết list.size() là 1 toán tử O(n) - nó đến qua các node liên kết trong danh sách, thay vì chỉ trả về 1 phép đếm trước, điều này làm cho ShrinkList() là 1 toán tử O(n2). Đoạn code “đúng” về mặt kỹ thuật và trên thực tế pass tất cả unit test. Nhưng khi ShrinkList() được gọi với 1 dánh sách 1 triệu phần tử, nó sẽ tốn 1 giờ để kết thúc. Có thể bạn đang nghĩ “Đó là lỗi của người gọi - anh ta hoặc cô ta nên phải đọc document của hàm này 1 cách cẩn thận”. Điều đó đúng nhưng trong trường hợp này, thực tế là list.size không phải là toán tử có thời gian cố định là 1 sự ngạc nhiên. Tất cả các phần khác trong C++ có size là phương thức thời gian cố định. Nếu size được đặt tên là countSize() hoặc countElements(), thì các lỗi tương tự sẽ ít xảy ra hơn. Người viết thư viện chuẩn của C++ có thể muốn đặt tên phương thức là size() để dùng cho tất cả các phần chưa nó như vector và map. Nhưng vì họ đã làm nnos, lập trình viên dễ dàng mắc lỗi nó là 1 toán tử nhanh, như cách của các containers khác. Rất may, trong thư viện mới nhất của C++, bây giờ thời gian size đã là O(1). WHO’S THE WIZARD? A while ago, one of the authors was installing the OpenBSD operating system. During the disk formatting step, a complicated menu appeared, asking for disk parameters. One of the options was to go to “Wizard mode.” He was relieved to find this user-friendly option and selected it. To his dismay, it dropped the installer into a low-level prompt waiting for manual disk formatting commands, with no clear way to get out of it. Evidently “wizard” meant you were the wizard! Example: Evaluating Multiple Name CandidatesKhi bạn quyết định chọn 1 tên tốt, bạn phải có nhiều thí sinh để cân nhắc. High-traffic website thường xuyên sử dụng “thí nghiệm” để kiểm tra xem1 thay đỏi trên trang web có cải thiện được kinh doanh hay không? Đây là 1 ví dụ của file cấu hình kiểm soát 1 vài thí nghiệm: experiment_id: 100description: “increase font size to 14pt“traffic_fraction: 5%… Mỗi thí nghiệm được định nghĩa bởi 15 cặp thuộc tính/giá trị. Không may, khi bạn định nghĩa 1 thí nghiệm khác tương tự, bạn phải copy và paste lại nhiều dòng: experiment_id: 101description: “increase font size to 13pt“[other lines identical to experimentid 100] Giả sử bạn muốn fix vấn đề này bằng cách đưa ra 1 cách để có 1 thí nghiệm có thể tái sử dụng các thuộc tính cho các thí nghiệm khác (Nó được gọi là mẫu “prototype inheritance”). Kết quả cuối cùng bạn sẽ chỉ gõ như sau: experiment_id: 101the_other_experiment_id_I_want_to_reuse: 100[change any properties as needed] Câu hỏi đặt ra là: the_other_experiment_id_I_want_to_reuse thực sự nên được đặt tên là gì? Đây là 4 sự cân nhắc cho tên này: template reuse copy inherit Bất cứ tên nào trong số này cũng có nghĩa đối với chúng ta. Nhưng chúng ta phải tưởng tượng rằng, tên nào sẽ ra sao đối với với 1 ai đó đọc code và không biết về chức năng này. Hãy phân tích từng tên, nghĩ ra 1 vài cách ai đó có thể giải thích sai nó: Xem xét tên template experiment_id: 101template: 100… template có 1 vài vấn đề. Đầu tiên, nó không rõ ràng khi nó đang nói rằng “Tôi là 1 bản mẫu” hoặc “Tôi đang sử dụng mẫu khác”. Cách hiểu thứ 2, một “template” thường là thứ gì đó trừu tượng, cái mà phải được “điền vào” trước khi nó thành cụ thể hóa. Ai đó có thể nghĩ 1 thí nghiệm không phải là 1 thí nghiệm “thực sự”. Còn reuse thì sao? experiment_id: 101reuse: 100… reuse là 1 từ okay nhưng với người viết, ai đó có thể hiểu nó đang nói “Thí nghiệm có thể được tái sử dụng hơn 100 lần”. Thay đổi tên thành reuse_id sẽ giúp giải quyết điều này. Nhưng nó lại làm bối rối cho người đọc hiểu reuse_id: 100 nghĩa mà “my id for reuse is 100”. Hãy cân nhắc về copy: experiment_id: 101copy: 100… copy là 1 từ tốt. Nhưng bản thân nó, copy: 100 dường như đang nói rằng “copy thí nghiệm này 100 lần” hoặc “đây là bản copy thứ 100 của cái mèo gì đó”. Để làm nó rõ ràng khái niệm này đang tham chiếu tới 1 thí nghiệm khác, chúng ta có thể đổi tên là copy_experiment. Đây có thể là 1 cái tên tốt nhất cho đến thời điểm này. Và bây giờ hãy xem xét inherit experiment_id: 101inherit: 100… Từ inherit phổ biến với nhiều lập trình viên và nó được hiểu là sửa đổi thêm sau khi được kế thừa. Với lớp kế thừa, bạn sẽ nhận tất cả các phương thức và thành phần của lớp khác và sau đó định nghĩa lại chúng hoặc thêm mới. Thậm chí trong thế giới thực, khi bạn kế thừa tài sản từ người thân, nó cũng được hiểu là mạn có thể bán chúng hoặc sở hữu những thứ khác nữa. Nhưng quay trở lại vấn đề, hãy làm cho rõ ràng chúng ta đang kế thừa từ thí nghiệm khác. Chúng ta có thêt cải thiện tên này với cái tên inherit_from hoặc thậm chí là inherit_from_experiment_id. Nhìn chung copy_experiment và inherit_from_experiment_id là những cái tên tốt nhất vì chúng mô tả rõ ràng nhất cái mà thực sự đang diễn ra và ít bị hiểu nhầm nhất. Tổng kếtNhững tên tốt nhất chỉ nên có 1 nghĩa để không thể bị hiểu nhầm - người đọc code của bạn sẽ hiểu nó như cách bạn hiểu và không có cách khác. Thiếu may mắn, rất nhiều từ trong tiếng Anh không rõ nghĩa khi chúng ta sử dụng nó trong lập trình như là filter, length, và limit. Trước khi bạn quyết định 1 cái tên, hãy biện hộ và tưởng tượng rằng tên của bạn có thể bị hiểu nhầm như thế nào? Tên tốt nhất có khả năng chống lại giải thích sai ý nghĩa. Khi bạn định nghĩa giới hạn trên dưới, max_ và min_ là những tiền tố tốt. Đối với các phạm vi bao gồm, first và last là sự lựa chọn. Đối với các phạm vi bao gồm/loại trừ, begin và end là tốt nhất vì chúng là quốc ngữ =)). Khi tên của bạn là 1 boolean, sử dụng những từ như is và has để làm rõ nghĩa nó là boolean. Tránh sử dụng các từ có nghĩa phủ định (ví dụ như disable_ssl) Coi chừng từ kì vọng của người dùng về những từ nhất định. Ví dụ, người dùng sẽ mong đợi get() và size() là các phương thức nhẹ (Beware of users’ expectations about certain words.) Từ khóa mới: lightweight accessors, lightweight operator =&gt; ý nói các toán tử nhẹ và nhanh, không có xử lý logic phức tạp Tài liệu tham khảoChapter 3 -Names That Can’t Be Misconstrued","link":"/2020/05/24/Chapter-3-Names-That-Can%E2%80%99t-Be-Misconstrued/"},{"title":"Chapter 4: Aesthetics","text":"Hãy nghĩ 1 chút về layouts (bố cục) của 1 tờ tạp chí - độ dài đoạn văn, chiều rộng của các cột, thứ tự của bài viết và bìa. A good magazine makes it easy to skip around from page to page, but also easy to read straight through.. Code tốt nên dễ nhìn (easy on the eyes). Trong chương này chúng ta sẽ chỉ ra cách sử dụng space, căn chỉnh và sắp xếp code cho dễ đọc Chi tiết, có 3 nguyên tắc chúng ta sẽ sử dụng Sử dụng bố cục thống nhất với mẫu chung là người đọc có thể sử dụng được Làm cho các đoạn mã tương tự nhìn tương tự nhau Nhóm các đoạn code liên quan với nhau thành các khối code Cách thay đổi này dễ dàng thực hiện mà nó cải thiện đáng kể khả năng đọc code của bạn đó &lt;3 AESTHETICS VS. DESIGN In this chapter, we’re concerned only with simple “aesthetic” improvements you can make to your code. These types of changes are easy to make and often improve readability quite a bit. There are times when larger refactoring of your code (such as splitting out new functions or classes) can help even more. Our view is that good aesthetics and good design are independent ideas; ideally you should strive for both. Why Do Aesthetics Matter?Thư giãn 1 chút, bạn có muốn mình là nhân vật trong bức ảnh này :D. Thử tưởng tượng code của bạn:12345678910111213class StatsKeeper {public:// A class for keeping track of a series of doubles void Add(double d); // and methods for quick statistics about them private: int count;/* how many so far*/ public: double Average();private: double minimum;list&lt;double&gt; past_items ;double maximum;};Nó sẽ rất khó để hiểu thay vì bạn clean code thay thế như sau:12345678910111213// A class for keeping track of a series of doubles// and methods for quick statistics about them.class StatsKeeper { public: void Add(double d); double Average(); private: list&lt;double&gt; past_items; int count; // how many so far double minimum; double maximum;};Chắc chắn dễ dàng hơn khi làm việc với các đoạn code có thẩm mỹ. Nếu bạn đang nghĩ về nó, phần lớn thời gian lập trình của bạn dành cho việc nhìn code! Sẽ nhanh hơn bạn có thể đọc lướt qua code, dễ dàng với mọi người khi sử dụng nó nữa. Sắp xếp lại các ngắt dòng để được nhất quán và nhỏ gọnGiả sử bạn đang viết code Java tính toán hành vi chương trình của bạn hoạt động với 1 vài tốc độ mạng khác nhau. Bạn có TcpConnectionSimulator nhận vào 4 tham số trong hàm tạo: Tốc độ kết nối (Kbps) Độ trễ trung bình (ms) The “jitter” của độ trễ (ms) Tỉ lệ mất gói tin (phần trăm) Đoạn code của bạn cần 3 instance TcpConnectionSimulator khác nhau:12345678910111213141516171819public class PerformanceTester { public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator( 500, /* Kbps */ 80, /* millisecs latency */ 200, /* jitter */ 1 /* packet loss % */); public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator( 45000, /* Kbps */ 10, /* millisecs latency */ 0, /* jitter */ 0 /* packet loss % */); public static final TcpConnectionSimulator cell = new TcpConnectionSimulator( 100, /* Kbps */ 400, /* millisecs latency */ 250, /* jitter */ 5 /* packet loss % */);}Đoạn code cần rất nhiều kí tự xuống dòng bổ sung để phù hợp với yêu cầu giới hạn 80 kí tự trên 1 dòng (tiêu chuẩn của công ty). Không may mắn, chúng ta nhìn dòng định nghĩa t3_fiber nhìn rất khác với các “hàng xóm” của nó. Điều này có nghĩa nó đang không theo nguyên tắc “similar code should look similar”. Để làm cho các đoạn code của bạn thống nhất, chúng ta có thể giới thiệu thêm các dấu ngắt dòng (và xếp hàng các comment khi chúng ta làm việc với nó):12345678910111213141516171819202122public class PerformanceTester { public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator( 500, /* Kbps */ 80, /* millisecs latency */ 200, /* jitter */ 1 /* packet loss % */); public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator( 45000, /* Kbps */ 10, /* millisecs latency */ 0, /* jitter */ 0 /* packet loss % */); public static final TcpConnectionSimulator cell = new TcpConnectionSimulator( 100, /* Kbps */ 400, /* millisecs latency */ 250, /* jitter */ 5 /* packet loss % */);}Đoạn code đã có mẫu thống nhất đẹp và dễ dàng để quét qua. Nhưng không may, nó sử dụng rất nhiều dấu cách. Nó cũng lặp comment 3 lần. Đây là cách gọn nhẹ hơn để viết class trên12345678910public class PerformanceTester { // TcpConnectionSimulator(throughput, latency, jitter, packet_loss) // [Kbps] [ms] [ms] [percent] public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(500, 80, 200, 1); public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(45000, 10, 0, 0); public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(100, 400, 250, 5);}Chúng ta đã di chuyển comment lên top và sau đó để tất cả các tham số vào 1 dòng. Bây giờ, thậm chí comment không còn cho mỗi dòng, “dữ liệu” được sắp xếp thành 1 bảng gọn nhẹ hơn. Use Methods to Clean Up Irregularity: Sử dụng các phương thức để dọn dẹp các thứ bất thườngGiả định bạn có 1 cơ sở dữ liệu cung cấp các hàm như sau:123// Turn a partial_name like &quot;Doug Adams&quot; into &quot;Mr. Douglas Adams&quot;.// If not possible, 'error' is filled with an explanation.string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);Và hàm này được test với 1 vài ví dụ:123456789101112DatabaseConnection database_connection;string error;assert(ExpandFullName(database_connection, &quot;Doug Adams&quot;, &amp;error) == &quot;Mr. Douglas Adams&quot;);assert(error == &quot;&quot;);assert(ExpandFullName(database_connection, &quot; Jake Brown &quot;, &amp;error) == &quot;Mr. Jacob Brown III&quot;);assert(error == &quot;&quot;);assert(ExpandFullName(database_connection, &quot;No Such Guy&quot;, &amp;error) == &quot;&quot;);assert(error == &quot;no match found&quot;);assert(ExpandFullName(database_connection, &quot;John&quot;, &amp;error) == &quot;&quot;);assert(error == &quot;more than one result&quot;);Đoạn code này không có tính chất thẩm mỹ. Một vài dòng quá dài và chèn xuống cả dưới. Đoạn code xấu xí và không theo 1 mẫu nhất quán. Nhưng đây là 1 trường hợp mà sắp xếp lại các dấu ngắt dòng như trên sẽ có rất nhiều. Vấn đề lớn hơn là có rất nhiều các string lặp lại như assert(ExpandFullName(database_connection... ,&quot; và “error” cái mà nếu cố theo cách này. Để thực sự cải thiện đoạn code này, chúng ta cần 1 phương thức helper để code có thể nhìn như:1234CheckFullName(&quot;Doug Adams&quot;, &quot;Mr. Douglas Adams&quot;, &quot;&quot;);CheckFullName(&quot; Jake Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);CheckFullName(&quot;No Such Guy&quot;, &quot;&quot;, &quot;no match found&quot;);CheckFullName(&quot;John&quot;, &quot;&quot;, &quot;more than one result&quot;);Bây giờ, mọi thứ đã rõ ràng hơn, có 4 tests đang diễn ra, mỗi test với tham số khác nhau. Mặc dù tất cả các “dirty work” đã bên trong CheckFullName(), hàm này cũng không quá tệ123456789void CheckFullName(string partial_name, string expected_full_name, string expected_error) { // database_connection is now a class member string error; string full_name = ExpandFullName(database_connection, partial_name, &amp;error); assert(error == expected_error); assert(full_name == expected_full_name);}Mặc dù mục đích của chúng ta là cho code có thẩm mỹ hơn, điều này có 1 vài lợi ích khác: Nó loại bỏ rất nhiều các đoạn code lặp lại trước đó, làm cho code nhỏ gọn hơn. Phần quan trọng của mỗi test case (tên và chuỗi error) bây giờ đã được bọc lại, dễ theo dõi. Trước đó, các chuỗi này xem kẽ với các dấu hiệu riêng như database_connection và error Bây giờ, thêm những test mới sẽ trở nên dễ dàng hơn Nội dung của câu chuyện là làm cho code “nhìn đẹp mắt” thường dẫn đến nhiều kết quả hơn chỉ là cải tiến về bề mặt (surface) - nó có thể giúp bạn có cấu trúc code tốt hơn Use Column Alignment When Helpful: Sử dụng căn chỉnh cột khi hữu íchChỉnh sửa góc và các cột làm code của bạn dễ đọc hơn và có thể quét (scan) qua text - scan through text. Đôi khi bạn có thể giới thiệu “căn chỉnh cột” để làm code dễ đọc hơn. Ví dụ, như phần trước bạn có thể thêm dấu cách, xếp hàng cho các đối số của hàm:1234CheckFullName(&quot;Doug Adams&quot; , &quot;Mr. Douglas Adams&quot; , &quot;&quot;);CheckFullName(&quot; Jake Brown &quot; , &quot;Mr. Jake Brown III&quot; , &quot;&quot;);CheckFullName(&quot;No Such Guy&quot; , &quot;&quot; , &quot;no match found&quot;);CheckFullName(&quot;John&quot; , &quot;&quot; , &quot;more than one result&quot;);Trong đoạn code này, đã dễ dàng phân biệt được đối số thứ 2 và thứ 3 của hàm CheckFullName() Đây là 1 ví dụ đơn giản lớp 1 tập lớn các biến được định nghĩa:123456# Extract POST parameters to local variablesdetails = request.POST.get('details')location = request.POST.get('location')phone = equest.POST.get('phone')email = request.POST.get('email')url = request.POST.get('url')Bạn có nhận thấy, định nghĩa thứ 3 lỗi chính tả, là (equest thay vì request). Lỗi như vậy dễ phát hiện khi bạn mọi thứ được sắp xếp gọn gàng. Trong wget codebase, các tùy chọn có sẵn của command-line (khoảng hơn 100 dòng) được liệt kê như dưới đây:123456789commands[] = { ... { &quot;timeout&quot;, NULL, cmd_spec_timeout }, { &quot;timestamping&quot;, &amp;opt.timestamping, cmd_boolean }, { &quot;tries&quot;, &amp;opt.ntry, cmd_number_inf }, { &quot;useproxy&quot;, &amp;opt.use_proxy, cmd_boolean }, { &quot;useragent&quot;, NULL, cmd_spec_useragent }, ...};Tiêu chuẩn này làm danh sách rất dễ để đọc lướt qua và nhảy từ cột này sang cột khác. Should You Use Column Alignment?Căn cạnh các cột cung cấp “các hành lang trực quan” làm code dễ dàng quét qua. Nó là 1 một ví dụ tốt để “làm cho code tương tự nhau nhìn tương đương nhau”. Nhưng một vài lập trình viên không thích nó. Một lý do là tạo thêm việc khi set up và maintain các căn chỉnh này. Một lý do khác là nó tạo ra “một sự thay đổi” lớn hơn khi tạo 1 thay đổi - 1 dòng thay đổi có nghĩa là 5 dòng khác cũng cần thay đổi (thường sẽ là cần chỉnh lại các khoảng trống) Lời khuyên của chúng tôi là cứ thử nó. Theo kinh nghiệm của chúng tôi, nó không mất nhiều công sức mà lập trình viên phải sợ. Và nếu có, bạn có thể đơn giản là dừng lại. Pick a Meaningful Order, and Use It ConsistentlyCó rất nhiều trường hợp có thứ tự trong code không ảnh hưởng đến tính đúng đắn. Ví dụ, đây là 1 cách khai báo biến có thể được viết theo 1 vài thứ tự:12345details = request.POST.get('details')location = request.POST.get('location')phone = request.POST.get('phone')email = request.POST.get('email')url = request.POST.get('url')Trong các trường hợp như vậy, sẽ hữu ích hơn nếu bạn đặt chúng thành 1 thứ tự có nghĩa, không phải là ngẫu nhiên. Dưới đây là 1 vài ý tưởng: Trùng với thứ tự của biến được sắp xếp trong các trường &lt;input&gt; tương ứng trong HTML form. Sắp xếp chúng từ “quan trọng nhất” đến “ít quan trọng nhất” Sắp xếp chúng theo thứ tự bảng chữ cái. Khi bạn sắp xếp, bạn nên sử dụng thứ tự giống nhau xuyên suốt code của bạn. Như vậy thì tránh gây nhầm lẫn thay đổi thứ tự sau đó:12345if details: rec.details = detailsif phone: rec.phone = phone # Hey, where did 'location' go?if email: rec.email = emailif url: rec.url = urlif location: rec.location = location # Why is 'location' down here now? Organize Declarations into BlocksNão của chúng ta tự nhiên sẽ nghĩ các khái niệm trong nhóm và thứ bậc, do đó bạn giúp người đọc dễ dàng đọc code nhất theo cách này. Ví dụ trong lớp C++ frontend server, với các phương thức được khai báo:12345678910111213class FrontendServer { public: FrontendServer(); void ViewProfile(HttpRequest* request); void OpenDatabase(string location, string user); void SaveProfile(HttpRequest* request); string ExtractQueryParam(HttpRequest* request, string param); void ReplyOK(HttpRequest* request, string html); void FindFriends(HttpRequest* request); void ReplyNotFound(HttpRequest* request, string error); void CloseDatabase(string location); ~FrontendServer();};Đoạn code này không gây sợ hãi nhưng cách bố trí không giúp người đọc phân loại được tất cả các phương thức. Thay vì liệt kê tất cả các phương thức trong 1 khối khổng lồ, chúng nên được tổ chức lại thành các nhóm, như sau:12345678910111213141516171819class FrontendServer { public: FrontendServer(); ~FrontendServer(); // Handlers void ViewProfile(HttpRequest* request); void SaveProfile(HttpRequest* request); void FindFriends(HttpRequest* request); // Request/Reply Utilities string ExtractQueryParam(HttpRequest* request, string param); void ReplyOK(HttpRequest* request, string html); void ReplyNotFound(HttpRequest* request, string error); // Database Helpers void OpenDatabase(string location, string user); void CloseDatabase(string location);};Phiên bản này dễ hiểu hơn nhiều khi đã được phân loại. Nó cũng dễ đọc hơn, mặc dù tốn nhiều dòng code hơn. Lý do bạn có thể dễ dàng tìm ra 1 phần high-level và sao đó đọc chi tiết mỗi phần nếu cần thiết. Break Code into “Paragraphs”Văn bản viết được chia thành các đoạn vì 1 số lý do sau: Nó là các để nhóm các ý tưởng chung lại với nhau và đặt chúng cách nhau với các ý tưởng khác. Nó cung cấp “bước đệm” trực quan- không có nó, bạn dễ dàng đánh mấy vị trí của bạn trên trang. Nó tạo điều kiện để điều hướng từ 1 trang đến trang khác. Code cũng nên tách thành các “đoạn văn” vì lý do như vậy. Ví dụ, không ai muốn đọc 1 đoạn code khổng lổ như vậy:12345678910111213# Import the user's email contacts, and match them to users in our system.# Then display a list of those users that he/she isn't already friends with.def suggest_new_friends(user, email_password): friends = user.friends() friend_emails = set(f.email for f in friends) contacts = import_contacts(user.email, email_password) contact_emails = set(c.email for c in contacts) non_friend_emails = contact_emails - friend_emails suggested_friends = User.objects.select(email__in=non_friend_emails) display['user'] = user display['friends'] = friends display['suggested_friends'] = suggested_friends return render(&quot;suggested_friends.html&quot;, display)Nó có thể không rõ ràng, nhưng hàm này trải qua 1 số bước. Do đó nó đặc biệt hữu ích để ngắt các dòng này thành các đoạn văn:12345678910111213141516171819def suggest_new_friends(user, email_password): # Get the user's friends' email addresses. friends = user.friends() friend_emails = set(f.email for f in friends) # Import all email addresses from this user's email account. contacts = import_contacts(user.email, email_password) contact_emails = set(c.email for c in contacts) # Find matching users that they aren't already friends with. non_friend_emails = contact_emails - friend_emails suggested_friends = User.objects.select(email__in=non_friend_emails) # Display these lists on the page. display['user'] = user display['friends'] = friends display['suggested_friends'] = suggested_friends return render(&quot;suggested_friends.html&quot;, display)Nhận thấy rằng chúng ta cũng thêm các comment tóm tắt cho mỗi đoạn văn, cái giúp người đọc dễ đọc đọc qua code (Xem thêm chương 5 để biết những gì bạn nên comment) Như khi viết văn, có nhiều cách để chia nhỏ code và lập trình viên có thể thích các đoạn văn dài hơn hoặc ngắn hơn =)). Personal Style versus ConsistencyCó 1 vài sự lựa chọn nhất định cho tính thẩm mĩ, cái mà nổi bọt hơn cả personal style. Ví dụ, dấu mở ngoặc khi định nghĩa 1 lớp nên là:123class Logger { ...};Hoặc1234class Logger{ ...};Nếu 1 style nào hơn style nào, nó không ảnh hưởng đáng kể đến khả năng đọc code. Nhưng nếu có 2 style này trộn lẫn với nhau trong code, nó sẽ gây ra khó đọc code. Chúng tôi đã làm việc với nhiều dự án mà chúng tôi cảm thấy team đang sử dụng “sai” style nhưng chúng tôi cho phép các quy ước này trong project vì chúng tôi biết rằng tính nhất quán quan trọng hơn nhiều. KEY IDEAConsistent style is more important than the “right” style. Đối với mọi người nhìn vào, nó là 1 cái phòng trọ nhưng với những chú lợn thì nó chỉ là 1 cái chuồng lợn :D Tóm lạiMọi người thích đọc code có thẩm mỹ. Bằng “formatting” code theo 1 sự thống nhất, 1 cách có nghĩa, bạn sẽ làm nó đọc dễ dàng và nhanh chóng hơn. Dưới đây là 1 số kĩ thuật cụ thể chúng ta đã thảo luận: Nếu nhiều khối code đang làm những thứ tương tự nhau, hãy để chúng hình có vẻ giống nhau :D. Căn chỉnh các phần của code vào trong các “cột” để làm code dễ dàng có thể đọc lướt qua. Nếu code của bạn nhắc tới A,B và C trong 1 chỗ, đừng nói B,C và A ở 1 chỗ khác. Chọn 1 thứ tự có nghĩa và gắn bó với nó. Sử dụng các dòng trống để phá vỡ các khối code lớn vào các “đoạn văn” cùng logical Tài liệu tham khảoChapter 4 - The Art of Readable Code","link":"/2020/05/24/Chapter-4-Aesthetics/"},{"title":"Chapter 5: Knowing What to Comment","text":"Mục đích của chương này là giúp bạn nhận ra những gì bạn nên comment. Bạn nên nghĩ mục đích của comment là “giải thích cái mà code đang thực hiện” nhưng đó chỉ là 1 phần nhỏ của nó. K E Y I D E AThe purpose of commenting is to help the reader know as much as the writer did. Khi bạn đang viết code, bạn có rất nhiều thông tin có giá trị trong đầu bạn. Khi mà người khác đọc code của bạn, các thông tin đó bị mất - tất cả họ có là code trước mặt. Trong chương này, chúng tôi sẽ chỉ ra rất nhiều ví dụ để viết ra những thông tin đó trong đầu bạn. Chúng ta sẽ bỏ lại những điểm “trần tục” về comment, thay vào đó chúng ta sẽ thảo luận những thứ thú vị hơn là không được quan tâm nhiều của comment. Chúng tôi tổ chức chương này với các phần sau: Hiểu về cái nào không comment Ghi lại những cái bạn nghĩ khi viết code Tự đặt bạn vào trường hợp người đọc, tưởng tượng những thứ họ sẽ cần biết What NOT to CommentĐọc 1 comment sẽ mấy thời gian cùng với đọc code và mỗi comment sẽ tốn không gian màn hình. Do đó, tốt hơn hết là nó nên có giá trị. Tất cả các comment trong code này đều không có giá trị123456789101112// The class definition for Accountclass Account { public: // Constructor Account(); // Set the profit member to a new value void SetProfit(double profit); // Return the profit from this Account double GetProfit();};Những comment này không có giá trị vì nó không cung cấp thông tin mới hoặc giúp người đọc hiểu hơn code K E Y I D E ADon’t comment on facts that can be derived quickly from the code itself. Từ “quickly” là 1 đích đến quan trọng, xem xét các comment sau trong Python12# remove everything after the second '*'name = '*'.join(line.split('*')[:2])Về mặt công nghệ, đoạn comment không thêm bất kì thông tin mới nào. Nếu bạn nhìn code, bạn thậm chí còn biết ngay code đang làm gì. Nhưng với đa số lập trình viên, đọc comment của code sẽ nhanh hơn là hiểu code mà không cần nó. Don’t Comment Just for the Sake of Commenting: Đừng comment chỉ vì phải làm Một vài giáo sư yêu cầu sinh viên của họ có 1 comment cho mỗi hàm trong phần code bài tập về nhà của họ. Và kết quả, 1 vài lập trình viên cảm thấy có lỗi khi viết 1 hàm mà không có comment và cuối cùng viết lại hàm và tên đối số của nó ở dạng câu:12// Find the Node in the given subtree, with the given name, using the given depth.Node* FindNodeInSubtree(Node* subtree, string name, int depth);Cái này rơi vào những comment vô giá trị - khai báo hàm và comment đang gần như giống nhau. Comment này nên được xóa đi hoặc cải thiện. Nếu bạn muốn có 1 comment ở đây, nó cũng có thể nên là các giải thích chi tiết quan trọng hơn:1234// Find a Node with the given 'name' or return NULL.// If depth &lt;= 0, only 'subtree' is inspected.// If depth == N, only 'subtree' and N levels below are inspected.Node* FindNodeInSubtree(Node* subtree, string name, int depth); Don’t Comment Bad Names—Fix the Names InsteadMột comment không nên là 1 thứ trang trí cho 1 cái tên tồi. Ví dụ, xem xét hàm với tên CleanReply()123// Enforce limits on the Reply as stated in the Request,// such as the number of items returned, or total byte size, etc.void CleanReply(Request request, Reply reply);Phần lớn nội dung của comment chỉ đơn giản giải thích nghĩa của từ “clean”. Thay vì vậy, “enforce limits” nên được đưa vào tên của hàm:12// Make sure 'reply' meets the count/byte/etc. limits from the 'request'void EnforceLimitsFromRequest(Request request, Reply reply);Nên của hàm giờ đây đã có nhiều ý nghĩa “tự mô tả” hơn. Một cái tên tốt hơn là 1 comment tốt bởi vì nó sẽ được thấy mọi nơi mà hàm được sử dụng. Đây là 1 ví dụ khác của 1 comment cho 1 tên hàm tệ:12// Releases the handle for this key. This doesn't modify the actual registry.void DeleteRegistry(RegistryKey* key);Tên DeleteRegistry nghe như 1 hàm nguy hiểm (nó xóa sự đăng kí). Comment “This doesn’t modify the actual registry” đang cố gắng làm sáng tỏ sự nhầm lẫn này. Thay vào đó chúng ta có thể sử dụng 1 tên tự làm tài liệu như:1void ReleaseRegistryHandle(RegistryKey* key);Nói chung, bạn không muốn “crutch comments” (bình luận làm cái nạng chống cho tên) - những comment đang cố gắng trang trí cho những đoạn code không thể đọc được. Coders thường được khuyến khích theo rule: goog code &gt; bad code + good comments. Recording Your ThoughtsBây giờ chúng ta biết cái gì thì không nên comment, phần tiếp theo sẽ thảo luận cái nên được comment (nhưng thường không có). Rất nhiều good comments có đến từ thứ đơn giản “ghi lại những suy nghĩ của bạn” - những suy nghĩ quan trong bạn có trong quá trình bạn đang viết code. Include “Director Commentary”Phim thì thường có những dấu hiệu “director commentary” nơi mà các nhà làm phim có được sự hiểu biết và nói về câu chuyện giúp bạn hiểu hơn nội dung bộ phim làm về gì? Tương tự như bạn, bạn bên có các comment để ghi lại những cái nhìn có giá trị về code. Ví dụ:12// Surprisingly, a binary tree was 40% faster than a hash table for this data.// The cost of computing a hash was more than the left/right comparisons.This comment teaches the reader something and stops any would-be optimizer from wasting their time. Đây là 1 ví dụ khác:1// This heuristic might miss a few words. That's OK; solving this 100% is hard.Không có comment này, người đọc có thể nghĩ đây là 1 bug và có thể tốn thời gian để đưa ra các test cases làm cho nó lỗi hoặc tắt và cố gắng sửa lỗi này. Một comment có thể cũng giải thích code tại sao không có khuôn dạng tuyệt vời 12// This class is getting messy. Maybe we should create a 'ResourceNode' subclass to// help organize things. Đoạn comment này thừa nhận code đoạn mã lộn xộn nhưng cũng khuyến khích người tiếp theo sửa nó (chỉ ra bắt đầu fix như thế nào). Không có comment này, rất nhiều người đọc sẽ sợ hãi khi thấy nó là đoạn mã lộn xộn và tránh động vào nó. Comment the Flaws in Your Code: Comment những điểm chưa tốt, khuyết điểm trong code của bạnCode thì không ngùng phát tiển và chắc chắn sẽ có những sai sót trong quá trình đó. Đừng xấu hổ khi bạn ghi lại những sai sót. Ví dụ, note lại những cải thiện nên được thực hiện:1// TODO: use a faster algorithmHoặc khi code của bạn chưa hoàn tất1// TODO(dustin): handle other image formats besides JPEGCó 1 vài kiểu đánh dấu phổ biến cho các lập trình viên như sau: Marker Typical meaning TODO: Stuff I haven’t gotten around to yet FIXME: Known-broken code here HACK:: Admittedly inelegant solution to a problem XXX: Danger! major problem here Team của bạn nên có những convention riêng để biết khi nào sử dụng các marker trên. Ví dụ, TODO: nên được giành cho các issue show-stopping (tạm dừng). Nếu vậy, các mỗi nhỏ trong code của bạn có thể sử dụng một marker khác để thay thế như todo (kí tự thường) hoặc maybe-later Điều quan trọng bạn có thể cảm thấy tự do để lại những comment ghi lại suy nghĩ như vậy là để code nên được thay đổi như thế nào trong tương lai. Comments để gửi đến cho người đọc cái nhìn có giá trị trong chất lượng và trạng thái code và có thể chỉ ra 1 số hướng khác để cải thiện nó. Comment on Your ConstantsKhi định nghĩa một biến cố định, thường sẽ có 1 “câu chuyện” về lý do của giá trị cố định này và tại sao nó lại có giá trị như vậy. Ví dụ. bạn phải nhìn các giá trị cố định trong code của bạn:1NUM_THREADS = 8Có vẻ dòng này không cần bình luận, nhưng bạn có thể thêm tại sao lập trình viên chọn và cung cấp nhiều thông tin hơn về nó:1NUM_THREADS = 8 # as long as it's &gt;= 2 * num_processors, that's good enough.Bây giờ ai đó đọc đoạn code này đã có một vài hướng dẫn để điều chỉnh giá trị này (ví dụ, setting nó thành 1 có thể rất chậm và setting thành 50 thì quá mức cần thiết). Hoặc đôi khi giá trị chính xác của hằng số không quan trọng. Một comment cho điều này vẫn rất hữu ích:12// Impose a reasonable limit - no human can read that much anyway.const int MAX_RSS_SUBSCRIPTIONS = 1000;Đôi khi nó có 1 giá trị hay được điều chỉnh và có thể không nên sửa nhiều1image_quality = 0.72; // users thought 0.72 gave the best size/quality tradeoffTrong tất cả các ví dụ trên, không ai yêu cầu bạn thêm các comment nhưng nó là các thông tin khá hữu ích. Có 1 vài hằng số không cần comment, bởi vì tên của nó đã đủ rõ ràng (ví dụ như SECONDS_PER_DAY) nhưng theo kinh nghiệm của chúng tôi, đa số các hằng số nên được cải thiện bằng cách thêm 1 comment. Nó chỉ là 1 vấn đề cái mà bạn đang nghĩ khi bạn quyết định về giá trị hằng số đó. Put Yourself in the Reader’s Shoes: Đặt bạn vào vị trí người đọcMột kĩ thuật chung chúng ta sử dụng trong cuốn sách này là tưởng tượng code của bạn nhìn ra sao với người ngoài cuộc - một ai đó không hề quen thuộc với project của bạn như bạn. Kỹ thuật này hữu ích đặc biệt để giúp bạn tổ chức những thứ cần comment lại. Anticipating Likely Questions (Các câu hỏi có thể dự đoán trước)Khi một ai đó đọc code của bạn, sẽ có những phần làm họ nghĩ, Huh? What’s this all about. Nhiệm vụ của bạn là comment những phần này Ví dụ hãy xem xét định nghĩa Clear(): 1234567struct Recorder { vector&lt;float&gt; data; ... void Clear() { vector&lt;float&gt;().swap(data); // Huh? Why not just data.clear()? }}; Đa số các lập trình viên C++ nhìn đoạn code này họ sẽ nghĩ Tại sao không chỉ dùng data.clear() thay vì hoán đổi chúng với 1 vector rỗng. Well, nó chỉ ra rằng, đây là cách duy nhất để buộc 1 vector thực sự giải phóng bộ nhớ của nó cho bộ cấp phát bộ nhớ :D. Nó là một kĩ thuật chi tiết của C++ mà không được biến đến nhiều.12// Force vector to relinquish its memory (look up &quot;STL swap trick&quot;)vector&lt;float&gt;().swap(data); Advertising Likely Pitfalls: Dịch tạm là đưa ra các cảnh báo, cạm bẫy Khi viết tài liệu cho function hoặc class, 1 câu hỏi tốt là bạn tự hỏi chính mình What is surprising about this code? How might it be misused? Cái gì đáng ngạc nhiên về đoạn code này? Sẽ ra sao nếu bạn lạm dụng sử dụng nó? Về cơ bản, bạn muốn “nghĩ trước” và dự đoán vấn đề mà mọi người có thể gặp phải khi sử dụng code của bạn Ví dụ, giả định bạn viết 1 hàm để gửi email đến user:1void SendEmail(string to, string subject, string body);Khi thực thi, hàm này sẽ kết nối đến dịch vụ email bên ngoài có thể mất 1 khoảng thời gian. Ai đó viết 1 ứng dụng web có thể không nhận ra điều này và hiểu sai gọi hàm này trong khi đang xử lý 1 HTTP Request (Có thể làm web của bạn bị treo nếu dịch vụ email oẳng). Để ngăn chặn tai nạn nghề nghiệp này, bạn nên comment cách thức chi tiết để thực thi:12// Calls an external service to deliver email. (Times out after 1 minute.)void SendEmail(string to, string subject, string body);Đây là 1 ví dụ khác, giả sử bạn đang có 1 hàm FixBrokenHtml() cố gắng viết lại các đoạn HTML bị hỏng bằng cách chèn các thẻ đóng vị thiếu:1def FixBrokenHtml(html): ...Hàm này hoạt động rất tốt trừ việc cảnh báo rằng thời gian thực thi có thể tăng lên khi có nhiều thẻ lồng nhau và các thẻ không trùng. Đối với các thẻ HTML bẩn thỉu, hàm này có thể mất tới cả phút để thực hiện. Thay vì để người dùng tự khám phá điều này sau này, tốt hơn hết bạn nên thông báo trước:12// Runtime is O(number_tags * average_tag_depth), so watch out for badly nested inputs.def FixBrokenHtml(html): ... “Big Picture” CommentsMột trong những thứ khó nhất của 1 thành viên mới trong team là hiểu được “big picture” - các class tương tác với nhau ra sao, luồng dữ liệu trong cả hệ thống truyền như thế nào và đâu là điểm vào ra. Người thiết kế hệ thống thường quên comment những nội dung này vì anh ta đã quá rõ với nó. Hãy cân nhắc suy nghĩ: someone new just joined your team, she’s sitting next to you, and you need to get her familiar with the codebase Khi bạn cung cấp cho cô ấy 1 “vòng du dịch” qua codebase, bạn phải chỉ ra 1 số tệp tin hoặc class và nói 1 số thứ như: “Đây là đoạn code kết nối giữa business logic và database. Không có mã nào của ứng dụng này nên sử dụng trực tiếp” “Lớp này trông thì phức tạp, nhưng nó thực sự chỉ là mã xử lý cache. Nó không biết gì về phần còn lại của hệ thống” Sau 1 vài phút nói chuyện tình cờ, thành viên mới trong team của bạn sẽ biết nhiều hơn là cô ấy nên tự đọc source code của ứng dụng. This is exactly the type of information that should be included as high-level comments. Đây là 1 ví dụ đơn giản về file-level comment: 12// This file contains helper functions that provide a more convenient interface to our// file system. It handles file permissions and other nitty-gritty details. Đừng choảng ngợp với suy nghĩ rằng bạn phải viết document chính thức, và rộng rãi. A few well-chosen sentences are better than nothing at all. Summary CommentsThậm chí rằng sâu trong hàm, 1 ý tưởng tốt của comment là 1 “bigger picture”. Đây là 1 ví dụ của comment tóm tắt gọn gàng đoạn code ở dưới đó:12345# Find all the items that customers purchased for themselves.for customer_id in all_customers: for sale in all_sales[customer_id].sales: if sale.recipient == customer_id: ...Không có đoạn comment này, đọc mỗi dòng code là 1 chút bí ẩn (“Tôi thấy chúng ta đang thực hiện 1 vòng lặp qua all_customers …. nhưng để làm gì?”) Nó rất hữu ích để có được những dòng comment tóm tắt này trong 1 hàm dài hơn, trong đó có 1 vài khối nhỏ hơn bên trong:12345678def GenerateUserReport(): # Acquire a lock for this user ... # Read user's info from the database ... # Write info to a file ... # Release the lock for this userNhững comment như hoạt động như 1 bản tóm tắt gạch đầu dòng về các phần function sẽ thực hiện, để người đọc có thể có được ý chính về chức năng của hàm trước khi đi đâu vào chi tiết qua việc đọc code (nhưng nếu các khối này có thể dễ dàng tách ra, bạn có thể tạo chúng thành các hàm riêng. Như đã nhắc tới từ trước đó, good code sẽ tốt hơn là 1 bad code với những good comments) SHOULD YOU COMMENT THE WHAT, THE WHY, OR THE HOW? Có thể bạn đã nghe những lời khuyên như “Comment the why, not the what (or the how)”. Mặc dù có vẻ đúng, nhưng chúng tôi cảm thấy rằng những tuyên bố này quá đơn giản và có nghĩa những thứ khác nhau với những người khác nhau. Lời khuyên của chúng tôi là làm bất cứ điều gì giúp ích cho người đọc có thể hiểu code 1 cách dễ dàng hơn. Điều này có thể liên quan đến các comment the what, the how hoặc the why (hoặc cả 3) Final Thoughts—Getting Over Writer’s BlockRất nhiều lập trình viên không thích viết comments vì cảm thấy cần nhiều việc để có 1 comment tốt. Khi các nhà văn có loại “write’s block” thì giải pháp tốt nhất là bắt đầu viết. Do đó, lần tới, khi bạn ngần ngại viết comment, chỉ cần tiếp tục và comment những gì bạn đang nghĩ, tuy nhiên half-baked (dịch tạm là xào xáo nó, kiểu xem xét kĩ và chỉnh sửa) nó Ví dụ giả định bạn đang làm việc với 1 hàm và tự nghĩ Oh crap, this stuff will get tricky if there are ever duplicates in this list. Hãy viết chúng ra: 1// Oh crap, this stuff will get tricky if there are ever duplicates in this list. Nhìn xem, có gì khó khăn đâu? Nó thực sự không phải là 1 bad comment - còn hơn là không có gì. Ngôn ngữ tuy 1 chút gì đó mơ hồ. Để sửa nó, chúng ta chỉ cần đi quan từng cụm từ và thay thế nó với 1 cái gì đó cụ thể hơn: “oh crap”, ý bạn là “Careful: this is something to watch out for.” “this stuff”, ý bạn là “the code that’s handling this input”. “will get tricky”, ý bạn là “will be hard to implement” Và comment mới sẽ như sau:1// Careful: this code doesn't handle duplicates in the list (because that's hard to do)Bạn có thể thấy chúng ta đã chia nhiệm vụ viết 1 commnet vào các bước đơn giản sau: Viết ra bất cứ những thứ comment trong đầu bạn Đọc comment và xem (nếu có) những thứ cần cải thiện Cải thiện chúng Như vậy bạn comment thường xuyên hơn, bạn sẽ tìm ra chất lượng bình luận từ bước 1 trở nên tốt hơn và tốt hơn và sau cùng có thể không cần chỉnh sửa gì cả. Comment sớm và thường xuyên, bạn tránh được những tình huống khó chịu của sự cần thiết viết 1 loạt các comment sau cùng, khi code đã hoàn tất =)) SummaryMục đích của 1 comment là giúp người đọc biết được cái mà người viết biết khi đang viết code. Trong cả chương này là về việc hiện thực hóa tất cả các thông tin không rõ ràng mà bạn có về code và viết chúng ra. Cái gì không comment: Thực tế có thể đọc nhanh từ chính code. “Crutch comments” cái mà trang trí thêm cho bad code (như là 1 cái tên hàm tồi) - sửa nó bằng code thay thế. Suy nghĩ của bạn nên được ghi lại bao gồm: Thông tin chi tiết lý do code theo cách này mà không phải cách khác - “director commentary”. Điểm yếu trong code của bạn, bằng cách sử dụng các markers như TODO hoặc XXX Các “câu chuyện” xung quanh việc giá trị các hằng số.Đặt bạn vào vị trí người đọc Dự đoán các phần mà code của bạn sẽ khiến người đọc “Huh?” và comment những đoạn đó. Mô tả về 1 vài hành vi có thể gây bất ngờ mà người đọc không mong đợi Sử dụng “big picture” comments về file/class level để giải thích làm thế nào để tất cả các phần tương tác với nhau. Các khối tóm tắt của code với những comment để người đọc không bị “lạc trôi” trong phần chi tiết của mã. Tài liệu tham khảoChapter 5 - Knowing What to Comment Keywords crutch comments: các comment sử dụng để chống nạng cho một cái tên tồi Director Commentary: Các comment đạo diễn cho 1 đoạn code, nó nên có trong code của bạn “Big Picture” Comments: Các comment tổng quát về codebase, các lớp, thư mục của bạn được tổ chức như thế nào cho các người mới :D","link":"/2020/05/24/Chapter-5-Knowing-What-to-Comment/"},{"title":"Chapter 7: Making Control Flow Easy to Read","text":"Nếu code của bạn không có điều kiện, vòng lặp hay một vài câu lệnh phân chia luồng (control flow statements), nó sẽ rất dễ để đọc. Những lần nhảy code, chia nhánh làm code nhanh chóng trở nên khó đọc. Trong chương này, chúng ta sẽ tìm cách để viết các đoạn mã chia luồng dễ đọc hơn K E Y I D E AMake all your conditionals, loops, and other changes to control flow as “natural” as possible—written in a way that doesn’t make the reader stop and reread your code. The Order of Arguments in ConditionalsCái nào trong 2 đoạn mã này dễ đọc hơn1if (length &gt;= 10)hay 1if (10 &lt;= length) Đa số lập trình viên, đoạn code đầu tiên dễ đọc hơn. Nhưng xem xét 1 dòng tiếp theo1while (bytes_received &lt; bytes_expected)hay1while (bytes_expected &gt; bytes_received)Thì ngược lại, phiên bản đầu tiên khó đọc hơn? Tại sao vậy? Liệu có một rule chung nào ở đâu? Làm sao bạn quyết định được khi nào tốt hơn khi viết a &lt; a hay b &gt; a? Đây là 1 vài hướng dẫn chúng tôi tìm được hữu ích Left-hand side Right-hand side The expression “being interrogated,” whose value is more in flux. The expression being compared against, whose value is more constant. Left-hand side: Biểu thức “đang được tra hỏi” có giá trị cao hơn giá trị thông lượng (giá trị chung)Right-hand side: Biểu thức được so sánh với giá trị không đổi. Hướng dẫn này trùng với việc sử dụng tiếng Anh - nó giống với ngôn ngữ nói tự nhiên: “nếu bạn kiếm được ít hơn 100$/năm” hoặc “nếu bạn nhỏ hơn 18 tuổi”. Sẽ không thuận tai lắm khi nói “nếu 18 ít hơn tuổi của bạn”. Điều này giải thích tại sao while (bytes_received &lt; bytes_expected) là dễ đọc hơn. bytes_received là giá trị chúng ta đang kiểm tra, và nó tăng lên sau mỗi vòng lặp. bytes_expected là 1 giá trị “cố định” để so sánh. “YODA NOTATION”: STILL USEFUL? Trong 1 vài ngôn ngữ (bao gồm C và C++ nhưng không có Java), bạn có thể đặt một phép gán trong 1 điều kiện:1if (obj = NULL) ...Rất có thể đây là 1 bug, và cái mà lập trình viên thực sự muốn sẽ là1if (obj == NULL) ...Để chặn những bug kiểu này, rất nhiều lập trình viên thay đổi thứ tự đối số như:1if (NULL == obj) ...Cách này, nếu == là vô tình viết thành =, biểu thức if (NULL = obj) sẽ báo lỗi Không may, đổi thứ tự làm code có 1 chút không tự nhiên (Như Yoda sẽ nói “Không có gì để nói về nó”). May mắn thay, các trình biên dịch hiện tại đã có thể đưa ra các cảnh báo if (obj = NULL) do đó “Yoda Notation” trở thành 1 phần của quá khứ. The Order of if/else Blocks Khi bạn viết 1 đoạn mã if/else, bạn thường luôn luôn tự do để thay đổi thứ tự của các khối. Ví dụ bạn có thể viết12345if (a == b) { // Case One ...} else { // Case Two ...}Hoặc12345if (a != b) { // Case Two ...} else { // Case One ...}Bạn có thể không nghĩ nhiều về điều này trước đó, nhưng trong 1 vài trường hợp, có 1 số lý do để ưu tiên 1 thứ tự sắp xếp hơn: Ưu tiên xử lý với positive case đầu tiên thay vì negative. Ví dụ if(debug) thay vì if (!debug) Ưu tiên xử lý với các trường hợp simpler case - đơn giản hơn đầu tiên để đưa nó ra khỏi đường đi. Cách tiếp cận này cũng có thể cho phép cả if và else hiển thị trên màn hình cùng 1 lúc, điều này thì thật tuyệt. Ưu tiên xử lý với các trường hợp cần quan tâm hơn hoặc dễ thấy hơn trước. Một vài tham chiếu ở trên có thể mẫu thuẫn và bạn cần xem xét gọi cái nào. Nhưng trong rất nhiều trường hợp, có 1 lựa chọn sẽ chiến thắng rõ ràng. Ví dụ giả định bạn có 1 web server và xây dựng 1 response dựa vào cái mà URL chứa các tham số truy vấn expand_all:123456789if (!url.HasQueryParameter(&quot;expand_all&quot;)) { response.Render(items); ...} else { for (int i = 0; i &lt; items.size(); i++) { items[i].Expand(); } ...}Khi mà nguowifd dọc lướt qua từ lần đầu, não của anh ấy lập tức nghĩ về trường hợp expand_all. Nó giống như khi ai đó nói “Đừng nghĩ về 1 con voi màu hồng”. Bạn không thể giúp nhưng nghĩ về nó - the “don’t” bị nhấn chìm bởi một sự khác thường “con voi màu hồng”. Ở đây, expand_all là con voi màu hồng của chúng ta. Bởi vì nó rơi vào trường hợp đang được chú ý (và nó cũng là positive case), hãy xử nó đầu tiên:123456789if (url.HasQueryParameter(&quot;expand_all&quot;)) { for (int i = 0; i &lt; items.size(); i++) { items[i].Expand(); } ...} else { response.Render(items); ...}Mặc khác, đây là trường hợp mà case phủ định đơn giản hơn và quan tâm/nguy hiểm hơn, do đó chúng ta xử nó đầu tiên:1234if not file: # Log the error ...else: # ...Một lần nữa, tùy thuộc vào các chi tiết, đây có thể là 1 sự xem xét. Tóm lại, lời khuyên của chúng tôi là đơn giản chú ý đến các yếu đố này và xem xét các trường hợp if/else của bạn đang ở 1 trật tự khó xử. The ?: Conditional Expression (a.k.a. “Ternary Operator”)Trong ngôn ngữ như C, bạn có thể viết biểu thức điều kiện như cond ? a : b cái mà tương đương với cách viết (cond) { a } else { b }. Ảnh hưởng của nó đến khả năng đọc code thì gây tranh cãi. Người đề xướng thì nghĩ nó đẹp khi viết 1 cái gì đó trong 1 dòng thay vì nhiều dòng. Những người phản đối thì cho rằng nó có thể gây nhầm lẫn khi đọc và có thể khó để debug. Đây là ví dụ các biểu thức này có thể đọc và ngắn gọn:1time_str += (hour &gt;= 12) ? &quot;pm&quot; : &quot;am&quot;;Thay vì chúng ta phải viết:12345if (hour &gt;= 12) { time_str += &quot;pm&quot;;} else { time_str += &quot;am&quot;;}Tuy nhiên, đôi khi chính cách viết này lại rất khó để đọc1return exponent &gt;= 0 ? mantissa * (1 &lt;&lt; exponent) : mantissa / (1 &lt;&lt; -exponent);Ở đây các biểu thức điều kiện không chỉ còn là sự lựa chọn giữa 2 giá trị đơn thuần. Động lực để viết code như vậy chỉ là “cố gắng nhồi nhét mọi thứ trên 1 dòng”. K E Y I D E AInstead of minimizing the number of lines, a better metric is to minimize the time needed for someone to understand it. Hãy trả đoạn code trên về tự nhiên:12345if (exponent &gt;= 0) { return mantissa * (1 &lt;&lt; exponent);} else { return mantissa / (1 &lt;&lt; -exponent);}A D V I C EBy default, use an if/else. The ternary ?: should be used only for the simplest cases. Avoid do/while Loops Rất nhiều các ngôn ngữ lập trình được tôn trọng, như Perl, có 1 vòng lặp do { expression } while (condition). expression ở đây thực thi ít nhất 1 lần. Và đây là ví dụ:1234567891011// Search through the list, starting at 'node', for the given 'name'.// Don't consider more than 'max_length' nodes.public boolean ListHasNode(Node node, String name, int max_length) { do { if (node.name().equals(name)) return true; node = node.next(); } while (node != null &amp;&amp; --max_length &gt; 0); return false;}Điều kì lạ về một vòng lặp do/while là đoạn code có thể hoặc không thể thực thi lại dựa vào điều kiện bên dưới của nó. Vì bạn thường đọc code từ trên xuống dưới, điều này khiến do/while có 1 chút không được tự nhiên. Một vài người đọc cuối cùng đã đọc code tới 2 lần. Vòng lặp while thì dễ dàng đọc hơn vì bạn biết các điều kiện cho tất cả vòng lặp trước khi bạn đọc code bên trong. Nhưng nó cũng có thể ngớ ngẩn khi lặp code chỉ để xóa do/while:123456// Imitating a do/while — DON'T DO THIS!bodywhile (condition) { body (again)}May mắn thay, chúng ta đã tìm được 1 cách phổ biến đề đa số vòng lặp do/while có thể được viết như là vòng lặp while:1234567public boolean ListHasNode(Node node, String name, int max_length) { while (node != null &amp;&amp; max_length-- &gt; 0) { if (node.name().equals(name)) return true; node = node.next(); } return false;}Phiên bản này cũng mang lại những vợi ích khi vẫn làm việc nếu max_length là 0 hoặc nếu node là null. Một vài lí do khác để tránh sử dụng do/while là câu lệnh continue có thể gây nhầm lẫn bên trong nó. Ví dụ, đoạn code sau làm gì?123do { continue;} while (false);Nó lặp mãi mãi hay chỉ 1 lần. Đa số các lập trình viên phải dừng và nghĩ về nó (Nó nên lặp lại 1 lần) Nhìn chung, Bjarne Stroustrup, người tạo ra C++ nói rằng nó tốt nhất (trong cuốn The C++ Programming Language)): In my experience, the do-statement is a source of errors and confusion. … I prefer the condition “up front where I can see it.” Consequently, I tend to avoid do-statements Returning Early from a FunctionMột vài coders tin rằng hàm không bao giờ nên có nhiều trạng thái return. Điều này vô lý. Trả về sớm nhất từ 1 hàm thì hoàn toàn tốt - và thường được mong muốn. Ví dụ:12345public boolean Contains(String str, String substr) { if (str == null || substr == null) return false; if (substr.equals(&quot;&quot;)) return true; ...}Thực thi hàm này mà không vào những “mệnh đề bảo vệ” này sẽ rất không tự nhiên Một trong những sự giải thích muốn 1 điểm thoát để tất cả sự dọn dẹp mã ở cuối cùng của hàm được đảm bảo được gọi. Nhưng các ngôn ngữ hiện đại cung cấp nhiều cách tinh vi hơn để đạt được sự đảm bảo này: Language Structured idiom for cleanup code C++ destructors Java, Python try finally Python with with using Chia buồn với C, không có cơ chế kích hoạt mã cụ thể khi hàm exit. Do đó nếu 1 hàm với với rất nhiều sự dọn dẹp code, trả về sớm nhất có thể khó để thực hiện chính xác. Trong trường hợp này, một tùy chọn khác bao gồm tái cấu trúc lại hàm này hoặc thậm chí khôn ngoan hơn là sử dụng goto cleanup; The Infamous gotoTrong các ngôn ngữ khác C, sẽ ít khi cần goto vì có nhiều cách tốt hơn để làm tốt việc hoàn tất. gotos cũng rõ ràng nhanh chóng để code ra khỏi tầm tay và làm code khó để theo dõi hơn. Nhưng bạn có thể vẫn nhìn thấy goto trong 1 vài projects C - đáng chú ý nhất trong Linux kernel. Trước khi bạn bỏ qua tất cả sử dụng, sẽ rất hữu ích phân tích lý do tại sao sử dụng goto lại tốt hơn 1 vài cách khác. Đơn giản nhất, rất ngây thơ sử dụng goto với 1 exit đơn ở cuối hàm:1234567 if (p == NULL) goto exit; ...exit: fclose(file1); fclose(file2); ... return;Nếu đây là chỗ duy nhất mà goto được phép, goto sẽ không thành vấn đề. Vấn đề xuất hiện khi có nhiều mục tiêu đến goto, đặc biệt là trên những con đường mà nó qua. Đặc biệt, goto có thể tạo thành các đoạn code “mỳ ống” thực sự, và chúng chắc chắn có thể được thay thể bằng cách vòng lặp có cấu trúc. Trong hầu hết thời gian, goto nên được tránh sử dụng. Minimize NestingCode với các phần lồng nhau sâu rất khó để hiểu. Mỗi tầng của vòng lồng nhau thêm 1 điều kiện vào “ngăn xếp tinh thần” của người đọc. Khi người đọc nhìn thấy dấu đóng đúng (})) nó có thể gây khó khăn để “pop” ra khỏi ngăn xếp và nhớ điều kiện nào ở bên dưới. Đây là 1 ví dụ tương đối đơn giản - nếu bạn tự nhận thấy bạn phải nhìn lên xem các điều kiện có bị chặn không?1234567891011if (user_result == SUCCESS) { if (permission_result != SUCCESS) { reply.WriteErrors(&quot;error reading permissions&quot;); reply.Done(); return; } reply.WriteErrors(&quot;&quot;);} else { reply.WriteErrors(user_result);}reply.Done();Khi bạn nhìn dấu đóng đầu tiên, bạn phải tự nghĩ, Oh, permission_result != SUCCESS đã vừa xong, bây giờ permission_result == SUCCESS và điều này nằm trong khối với user_result == SUCCESS. Nhìn chung, bạn phải giữ giá trị user_result và permission_result trong đầu ở mọi lúc. Và mỗi khối if { } đóng lại, bạn phải chuyển đổi giá trị tương ứng trong suy nghĩ của mình. Đoạn mã này thậm chí còn tồi tệ hơn vì nó cứ xem kẽ giữa trường hợp SUCCESS và non-SUCCESS. How Nesting AccumulatesTrước khi bạn thử sửa code ví dụ trước đó, hãy nói về cách nó sẽ kết thúc. Ban đầu, code sẽ đơn giản:123456if (user_result == SUCCESS) { reply.WriteErrors(&quot;&quot;);} else { reply.WriteErrors(user_result);}reply.Done();Đoạn code này quá dễ hiểu. Nhưng lập trình viên đã thêm toán tử thử 2 vào:123456789if (user_result == SUCCESS) { if (permission_result != SUCCESS) { reply.WriteErrors(&quot;error reading permissions&quot;); reply.Done(); return; } reply.WriteErrors(&quot;&quot;);...Sự thay đổi này có ý nghĩa - lập trình viên có 1 khối code chèn vào và cô ấy tìm nơi dễ dàng nhất để chèn nó. Đoạn code mới này rất mới mẻ và “in đậm” và tinh thần của cô ấy. Và “sự khác biệt” này rất rõ ràng - nó là 1 sự thay đổi đơn giản. Nhưng khi 1 ai đó đọc code sau đó, tất cả bối cảnh đó đã biến mất. Đây là cách khi bạn lần đầu nìn vào code từ bắt đầu phần này - bạn đã nhận được tất cả code trong cùng 1 lúc. K E Y I D E ALook at your code from a fresh perspective when you’re making changes. Step back and look at it as a whole. Removing Nesting by Returning EarlyOkay, hãy cải tiến đoạn code này. Code lồng nhau có thể bị xóa đi bằng cách xử lý “trường hợp lỗi” sớm nhất có thể và trả về sớm nhất kết quả từ hàm:12345678910111213if (user_result != SUCCESS) { reply.WriteErrors(user_result); reply.Done(); return;}if (permission_result != SUCCESS) { reply.WriteErrors(permission_result); reply.Done(); return;}reply.WriteErrors(&quot;&quot;);reply.Done();Code giờ chỉ còn 1 level lồng nhau thay vì 2 như trước. Nhưng điều quan trọng nhất, người đọc không còn phải “pop” bất cứ gì từ trong stack tinh thần của họ - mỗi khối if kết thúc với 1 return rồi. Removing Nesting Inside LoopsKĩ thuật trả về sớm không phải lúc nào cũng được áp dụng. Ví dụ, đây là trường hợp code trong vòng lặp:12345678910for (int i = 0; i &lt; results.size(); i++) { if (results[i] != NULL) { non_null_count++; if (results[i]-&gt;name != &quot;&quot;) { cout &lt;&lt; &quot;Considering candidate...&quot; &lt;&lt; endl; ... } }}Bên trong vòng lặp, kỹ thuật tương tự với return sớm và continue123456789for (int i = 0; i &lt; results.size(); i++) { if (results[i] == NULL) continue; non_null_count++; if (results[i]-&gt;name == &quot;&quot;) continue; cout &lt;&lt; &quot;Considering candidate...&quot; &lt;&lt; endl; ...}Nhìn chung, continue cũng có thể gây hiểu nhầm, vì nó dẫn người đọc đi 1 vòng tương tự goto. Nhưng trong trường hợp này, mỗi vòng lặp độc lập nhau, do vậy mà người đọc có thể dễ dàng nhìn thấy continue chỉ có nghĩa là “bỏ qua các item này”. Can You Follow the Flow of Execution? Chương này đã nói về low-level của điều khiển luồng: làm sao để tạo ra các vòng lặp, điều kiện và jumps code khác dễ đọc. Nhưng bạn cũng nên nghĩ về “flow” trong chương trình của chúng ta ở mức high level.Lý tưởng nhất, nó nên dễ dàng để theo dõi toàn bộ luồng thực hiện trong chương trình - bạn đã bắt đầu ở main() và nghĩ rằng qua từng dòng cả code, như 1 hàm gọi hàm khác cho đến khi chương trình kết thúc. Tuy nhiên, trong thực tế, các ngôn ngữ lập trình và thư việc có cấu trúc làm cho code thực thi “behind the sences” hoặc làm cho nó khó có thể theo dõi. Đây là 1 vài ví dụ Programming construct How high-level program flow gets obscured threading It’s unclear what code is executed when. signal/interrupt handlers Certain code might be executed at any time. exceptions Execution can bubble up through multiple function calls. function pointers &amp; anonymous functions It’s hard to know exactly what code is going to run because that isn’t known at compile time. virtual methods object.virtualMethod() might invoke code of an unknown subclass. Một vài cấu trúc này rất hữu ích và chúng thậm chí còn làm code của bạn dễ đọc hơn và code ít bị dư thừa. Nhưng đối với lập trình viên, đôi khi họ sử dụng nó 1 cách quá mức mà không nhận ra nó đã gây khó khăn cho người đọc như thế nào để hiểu code sau đó. Và các cấu trúc nào cũng tạo ra các lỗi rất khó để truy xuất. Điều quan trọng nhất là không nên để quá nhiều phần trăm code của bạn sử dụng các cấu trúc này. Nếu bạn lạm dụng những tính năng này, nó có thể làm đoạn mã của bạn được xem như 1 trò chơi Three-Card Monte (như trong phim hoạt hình) Phần này tôi đang hiểu ý muốn nói phần thiết kế code chung cũng nên tránh sử dụng quá nhiều các cấu trúc phức tạp từ bảng trên, vì như vậy code của bạn sẽ khó mà theo dõi. Nếu sử dụng nhiều quá, nó sẽ như trò tráo 3 lá bài ý @@, lằng nhằng lắm :v. Túm lạiCó một vài thứ bạn có thể làm để code kiểm soát luồng dễ dàng đọc hơn Khi bạn viết 1 phép so sánh (while (bytes_expected &gt; bytes_received)), tốt hơn là bạn nên để các giá trị thay đổi sang bên trái và những giá trị cố định sang bên phải (while (bytes_received &lt; bytes_expected)). Bạn cũng có thể sắp xếp lại các khối trong câu lệnh if/else. Nói chung, cố gắng thử xử lý trường hợp positive/easier/interesting đầu tiên. Đôi khi những tiêu chí này mâu thuẫn, nhưng sẽ có 1 nguyên tắc vượt trội hơn. Một số cấu trúc lập trình như toán tử điều hành (:?), do/while, và goto thường gây ra kết quả là code khó đọc. Tốt nhất là không nên sử dụng chúng, những sự thay thế rõ ràng hơn luôn tồn tại. Các khối code lồng nhau yêu cầy nhiều sự tập trung hơn để theo dõi xuyên suốt. Mỗi đoạn lồng như vậy yêu cầu nhiều ngữ cảnh và “đẩy nó vào trong ngăn xếp tinh thần” của người đọc. Thay vào đó, tùy chọn code “tuyến tính” sẽ tránh được các sự lồng nhau này. Trả về sớm có thể tránh được các sự lồng nhau và dọn dẹp code nói chung. “Guard statements” (xử lý các trường hợp đơn giản ở đầu các hàm như check null, check empty các thứ ấy) đặc biệt hữu ích.","link":"/2020/05/24/Chapter-7-Making-Control-Flow-Easy-to-Read/"},{"title":"Chapter 8: Breaking Down Giant Expressions","text":"Một con mực khổng lồ là loài động vật tuyệt vời và thông minh nhưng thiết kế body của nó gần hoàn hảo có 1 lổ hổng chết người: nó có 1 cái não mềm dẻo (donut-shaped brain) bọc trong thực quản. Do đó nếu nó nuốt quá nhiều thức ăn trong 1 lần, não của nó sẽ hư hại. Điều này làm chúng ta phải làm gì với code? Well, code đến từ các “chunks” cái mà quá lớn, có thể có cùng hiệu ứng. Các nghiên cứu gần đây gợi ý rằng đa số chúng ta chỉ có thể nghĩ về 3 hoặc 4 “thứ” trong cùng 1 lúc. (Ref: Cowan, N. (2001). The magical number 4 in short-term memory: A reconsideration of mental storage capacity. Behavioral and Brain Sciences, 24, 97–185.). Chỉ cần đặt đơn giản, 1 biểu thức lớn hơn trong code, đã rất khó hơn để hiểu. K E Y I D E ABreak down your giant expressions into more digestible pieces. 1Trong chương này, chúng ta sẽ suy nghĩ 1 vài cách bạn có thể vận dụng và ngắt các đoạn code của bạn để dễ dàng nuốt được =)). Explaining VariablesCách đơn giản nhất để phá vỡ các biểu thức là giới thiệu thêm biến cái mà nhận từ các biểu thức con nhỏ hơn. Các biến thêm này đôi khi được gọi là “explaining variable”. Đây là 1 ví dụ:12if line.split(':')[0].strip() == &quot;root&quot;: ...Cũng là đoạn code trên nhưng bây giờ sử dụng các biến giải thích:123username = line.split(':')[0].strip()if username == &quot;root&quot;: ... Summary VariablesNgay cả khi 1 biểu thức không cần giải thích (vì bạn đã hiểu ý nghĩa của nó) nó có thể vẫn hữu ích để ghi lại biểu thức này ra 1 biến mới. Chúng ta gọi nó là summary variable nếu mục đích của nó đơn giản là thay thế một khối chunk lớ trong code bằng 1 cái tên nhỏ hơn, cái có được quản lý và nghĩ đơn giản hơn. Ví dụ, cân nhắc biểu thức sau trong đoạn code này:1234567if (request.user.id == document.owner_id) { // user can edit this document...}...if (request.user.id != document.owner_id) { // document is read-only...}Biểu thức request.user.id == document.owner_id có thể không lớn nhưng nó có 5 biến, do đó, mất 1 chút thời gian để nghĩ về nó. Nội dung chính của đoạn code này là “Người dùng này có phải là chủ của tài liệu?”. Nội dung có thể được trình bày chi tiết hơn bằng cách thêm 1 summary variable:12345678910final boolean user_owns_document = (request.user.id == document.owner_id);if (user_owns_document) { // user can edit this document...}...if (!user_owns_document) { // document is read-only...}Nó có vẻ không nhiều nhưng đoạn code if (user_owns_document) lại có 1 chút dễ hiểu hơn. Bằng cách này, có 1 định nghĩa user_owns_document ở đầu nói cho người đọc trước rằng “đây là khái niệm chúng ta sẽ tham chiếu trong suốt hàm này”. Using De Morgan’s LawsNếu bạn đã từng tham gia 1 khóa học về đại số, bạn chắc hẳn vẫn còn nhớ nguyên tắc De Morgan. Chúng ta có 2 cách để viết lại 1 biểu thức boolean vào trong 1 biểu thức tương đương.121) not (a or b or c) ⇔ (not a) and (not b) and (not c)2) not (a and b and c) ⇔ (not a) or (not b) or (not c)Nếu bạn có 1 vấn đề để nhớ về nguyên tắc này, 1 thứ đơn giản hơn “Chia not và chuyển đổi and/or” (Hoặc 1 cách khác, bạn đặt “thừa số chung cho not”) Đôi khi bạn có thể sử dụng nguyên tắc này để làm cho biểu thức boolean của bạn dễ đọc hơn. Ví dụ nếu code của bạn:1if (!(file_exists &amp;&amp; !is_protected)) Error(&quot;Sorry, could not read file.&quot;);Nó nên được viết lại thành:1if (!file_exists || is_protected) Error(&quot;Sorry, could not read file.&quot;); Abusing Short-Circuit LogicTrong đa số các ngôn ngữ lập trình, toán tử boolean thực hiện đánh giá ngắn (short-circuit). Ví dụ, câu lệnh if (a || b) không được xem xét b nữa nếu a là true. Hành vi này rất tiện dụng nhưng đôi khi nó có thể bị lạm dụng để thực hiện các logic phức tạp. Đây là 1 ví dụ:1assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied());Trong tiếng Anh, đoạn code này đang nói rằng “Lấy bucket với key này. Nếu bucket không null, sau đó hãy chắc chắc rằng nó chưa bị chiếm” Mặc dù nó chỉ cần 1 dòng code nhưng thực sự làm cho ai đó đọc code của bạn phải dừng lại và nghĩ. Bây giờ so sánh với đoạn code này:12bucket = FindBucket(key);if (bucket != NULL) assert(!bucket-&gt;IsOccupied());Mọi thức là như nhau và thậm chí mất tới 2 dòng để code, nhưng nó dễ hiểu hơn nhiều. Vậy tại sao đoạn code với biểu thức khổng lồ lại ở vị trí đó đầu tiên? Lúc đó, nhìn nó rất thông minh và ngầu. Có 1 niềm vui nào đó trong việc đã phân tích được logic xuống 1 đoạn mã ngắn gọn. Nó có thể hiểu được - nó giống như giải 1 câu đố nhỏ và tất cả chúng ta đều vui vẻ với nó. Vấn đề là đoạn code này là 1 vấn đề về tốc độ tinh thần cho ai đó đọc qua code của bạn. K E Y I D E ABeware of “clever” nuggets of code—they’re often confusing when others read the code later. Thế có nghĩa là chúng ta nên tránh sử dụng các hành vi short-circuit? Không. Có rất nhiều trường hợp nó được sử dụng rất hữu ích và rõ ràng, như ví dụ sau:1if (object &amp;&amp; object-&gt;method()) ...Đây cũng là 1 điều đang nói đến: trong các ngôn ngữ như Python, JavaScript, Ruby, toán tử “or” trả về 1 trong các đối số của nó (nó không chuyển đổi sang boolean), do đó code của bạn:1x = a || b || ccó thể được sử dụng để chọn 1 giá trị “đúng” từ 3 giá trị a,b, hoặc c Example: Wrestling with Complicated LogicGiả sử bạn đang thực thi 1 lớp Range:123456struct Range { int begin; int end; // For example, [0,5) overlaps with [3,8) bool OverlapsWith(Range other);};Hình dưới chỉ ra 1 vài phạm vi ví dụ: Nhận thấy rằng end là không bao gồm. Do đó A,B và C không chồng chéo với nhau nhưng D lại chồng chéo lên tất cả. Đây là 1 sự cố gắng thực thi OverlapsWith() - nó kiểm tra nếu 1 trong 2 điểm cuối của có trong cùng khác:12345bool Range::OverlapsWith(Range other) { // Check if 'begin' or 'end' falls inside 'other'. return (begin &gt;= other.begin &amp;&amp; begin &lt;= other.end) || (end &gt;= other.begin &amp;&amp; end &lt;= other.end);}Mặc dù đoạn code chỉ có 1 dòng, nhưng có rất nhiều điều đang diễn ra. Hình dưới chỉ ra tất cả các logic tham gia vào. Có rất nhiều trường hợp và điều kiện để nghĩ rằng nó dễ dàng bị bug lọt qua Nói về mà, đó là 1 bug. Code phần trước sẽ yêu cầu Range [0,2) chồng chéo lên [2,4) trong khi thực tế không phải vậy. Vấn đề này bạn phải cẩn thận khi so sánh giá trị begin/end sử dụng &lt;= hoặc chỉ &lt;. Đây là cách sửa vấn đề này:12return (begin &gt;= other.begin &amp;&amp; begin &lt; other.end) || (end &gt; other.begin &amp;&amp; end &lt;= other.end);Bây giờ nó đã đúng? Thực tế, nó vẫn còn 1 bug khác. Đoạn cdoe này bỏ qua trường hợp begin/end hoàn toàn bao quát 1 thứ khác. Đây là cách fix trường hợp này:123return (begin &gt;= other.begin &amp;&amp; begin &lt; other.end) || (end &gt; other.begin &amp;&amp; end &lt;= other.end) || (begin &lt;= other.begin &amp;&amp; end &gt;= other.end);Yikes - đoạn code này đã trở thành cách phức tạp. Bạn không thể mong đợi ai đó đọc đoạn code này và tự tin biết rằng nó đúng. Vậy chúng ta làm gì bây giờ? Chúng ta có thể ngắn biểu thức siêu to khổng lồ này như thế nào? Finding a More Elegant ApproachCó 1 khoảng thời gian bạn nên dừng lại và cân nhắc những cách tiếp cận khác nhau. Khi bắt đầu như với 1 vấn đề đơn giản (kiểm tra 2 khoảng có bị ghi đè) đã trở thành 1 phần logic cuốn lại với nhau đáng ngạc nhiên. Điều này thường là 1 dấu hiệu có 1 cách đơn giản hơn. Nhưng tìm được 1 giải pháp thanh lịch cần sự sáng tạo. Làm sao để bạn biết nó? Một kĩ thuật để tiếp cận nếu bạn có thể giải quyết vấn đề với cách “ngược lại”. Dựa vào vấn đề bạn đang gặp phải, điều này có thể có nghĩa lặp các mảng theo chiều ngược lại hoặc điền vào 1 số cấu trúc dữ liệu lạc hậu hơn là chuyển tiếp. Ở đây ngược lại với OverlapsWith() là “đừng chồng chéo lên nhau”. Để xem nếu 2 khoảng không chồng chéo hóa ra và 1 vấn đề đơn giản hơn, bởi vì chỉ có 2 khả năng: Phạm vi phần khác kết thúc trước bắt đầu của phần còn lại Phạm vi phần khác bắt đầu sau khi phần còn lại Chúng ta có thể biến đoạn mã này thành dễ dàng như sau:123456bool Range::OverlapsWith(Range other) { if (other.end &lt;= begin) return false; // They end before we begin if (other.begin &gt;= end) return false; // They begin after we end return true; // Only possibility left: they overlap}Mỗi dòng code đơn giản - nó chỉ cần 1 phép toán so sánh duy nhất. Điều này cho phép người đọc đủ trí tuệ (brainpower) để tập trung vào chỗ &lt;= là đúng. Breaking Down Giant StatementsChương này đang nói về phá vỡ các biểu thức riêng biệt, nhưng kĩ thuật tương tự cũng được áp dụng để phá vỡ các statements. Ví dụ, đoạn mã dưới đây có nhiều thứ đưa vào 1 lúc:123456789101112var update_highlight = function (message_num) { if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Up&quot;) { $(&quot;#thumbs_up&quot; + message_num).addClass(&quot;highlighted&quot;); $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;); } else if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Down&quot;) { $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highlighted&quot;); $(&quot;#thumbs_down&quot; + message_num).addClass(&quot;highlighted&quot;); } else { $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highighted&quot;); $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;); }};Biểu thức riêng lẻ trong đoạn code này không lớn nhưng khi đặt chúng cạnh nhau, nó tạo thành 1 statement khổng lồ đập vào bạn trong cùng 1 lúc. May mắn thay, rất nhiều biểu thức này giống nhau, điều đó có nghĩ chúng ta có thể thêm 1 biến chung trên đầu của hàm (nó cũng là 1 cách thực thi nguyên lý DRY - Don’t Repeat Yourself)1234567891011121314151617var update_highlight = function (message_num) { var thumbs_up = $(&quot;#thumbs_up&quot; + message_num); var thumbs_down = $(&quot;#thumbs_down&quot; + message_num); var vote_value = $(&quot;#vote_value&quot; + message_num).html(); var hi = &quot;highlighted&quot;; if (vote_value === &quot;Up&quot;) { thumbs_up.addClass(hi); thumbs_down.removeClass(hi); } else if (vote_value === &quot;Down&quot;) { thumbs_up.removeClass(hi); thumbs_down.addClass(hi); } else { thumbs_up.removeClass(hi); thumbs_down.removeClass(hi); }};Sự sáng tạo của var hi = &quot;highlighted&quot; không thực sự cần thiết nhưng nó cũng là 6 lần copy, có những lợi ích hấp dẫn: Nó giúp tránh các lỗi gõ phím (Trên thực tế, trong ví dụ đầu tiên, bạn có thấy sai “highighted” ở trường hợp 5) Nó thu nhỏ chiều rộng dòng hơn, làm code dễ dàng đọc lướt qua Nếu tên lớp cần thay đổi, bạn chỉ cần đặt vào 1 chỗ để thay đổi nó. Another Creative Way to Simplify Expressions: Một cách sáng tạo hơn để đơn giản hóa các biểu thứcĐây là 1 ví dụ khác với rất nhiều thứ diễn ra trong mỗi biểu thức, lần này là trong C++12345678void AddStats(const Stats&amp; add_from, Stats* add_to) { add_to-&gt;set_total_memory(add_from.total_memory() + add_to-&gt;total_memory()); add_to-&gt;set_free_memory(add_from.free_memory() + add_to-&gt;free_memory()); add_to-&gt;set_swap_memory(add_from.swap_memory() + add_to-&gt;swap_memory()); add_to-&gt;set_status_string(add_from.status_string() + add_to-&gt;status_string()); add_to-&gt;set_num_processes(add_from.num_processes() + add_to-&gt;num_processes()); ...}Một lần nữa, mắt của bạn phải đối diện với mã dài và tương tự nhau nhưng không thực sự giống nhau. Sau 10s với sự xem xét cẩn thận, bạn nhận thấy mỗi dòng làm cái gì đó giống nhau, chỉ khác nhau mỗi trường:1add_to-&gt;set_XXX(add_from.XXX() + add_to-&gt;XXX());Và trong C++, bạn có thể định nghĩa 1 marco để làm việc này:1234567891011void AddStats(const Stats&amp; add_from, Stats* add_to) { #define ADD_FIELD(field) add_to-&gt;set_##field(add_from.field() + add_to-&gt;field()) ADD_FIELD(total_memory); ADD_FIELD(free_memory); ADD_FIELD(swap_memory); ADD_FIELD(status_string); ADD_FIELD(num_processes); ... #undef ADD_FIELD}Bây giờ chúng ta đã bỏ đi các sự lộn xộn, bạn có thể nhìn thấy code và lập tức hiểu bản chất thứ đang diễn ra. Nó rất rõ ràng cho mỗi dòng làm 1 thứ gì đó giống nhau. Lưu ý rằng, chúng tôi không ủng hộ việc sử dụng marcos thường xuyên - trên thực tế, chúng ta thường xuyên tránh sử dụng chúng vì bạn có thể làm code hiểu nhầm và bị các lỗi tinh tế. Nhưng thỉnh thoảng, trong trường hợp này, nó đơn giản và chỉ cung cấp lợi ích rõ ràng cho việc đọc code. SummaryBiểu thức khổng lồ làm ta khó khi nghĩ về nó. Chương này chỉ ra 1 vài cách ngắt chúng nhỏ đi để người đọc có thể “tiêu hóa” nó thành từng phần. Một kĩ thuật đơn giản được giới thiệu là “explaining variables” cái mà nhận giá trị của 1 vài biểu thức con lớn. Tiêu chuẩn này có 3 lợi ích: Ngắt các biểu thức lớn thành từng phần Nó là tài liệu của code bằng cách mô tả các biểu thức con với 1 cái tên cô đọng. Nó giúp người đọc xác định được “các khái niệm” chính trong code. Một kỹ thuật khác để vận dụng logic của bạn, sử dụng nguyên lý De Morgan - kĩ thuật này có thể đôi khi viết lại các biểu thức boolean với các sạch sẽ hơn (ví dụ if (!(a &amp;&amp; !b)) có thể trở thành if(!a || b)))). Chúng tôi cũng chỉ ra 1 điều kiện logic phức tạp có thể phá vỡ thành các statement nhỏ như if (a &lt; b) .... Thực tế tất cả các ví dụ code đã cải thiện trong chương này,có statement if không quá 2 giá trị bên trong. Thiết lập này là ý tưởng. Nó có thể không phải lúc nào cũng đơn giản để thực hiện - đôi khi nó yêu cầu “phủ nhận” vấn đề hoặc cân nhắc hướng ngược lại mục đích của bạn Cuối cùng, mặc dù chương này nói về phá vỡ các biểu thức riêng lẻ, kĩ thuật tương tự này thường xuyên áp dụng có các khối code lớn. Bởi vậy, hãy tích cức phá vỡ các logic phức tạp bất cứ khi nào bạn thấy nó.","link":"/2020/05/24/Chapter-8-Breaking-Down-Giant-Expressions/"},{"title":"Chapter 9: Variables and Readability","text":"Trong chương này, bạn sẽ thấy sẽ cẩu thả sử dụng biến trong lập trình làm khó hiểu hơn. Cụ thể, có 3 vấn đề cần tranh luận: Khi có nhiều biến, sẽ khó hơn cho việc theo dõi tất cả. Một phạm vi biến lớn hơn, bạn phải theo dõi nó lâu hơn. Khi thường xuyên thay đổi biến, sẽ khó hơn để theo dõi giá trị hiện tại của nó. Eliminating Variables: Loại bỏ các biến.Trong chương 8, phần phá vỡ các biểu thức khổng lồ, chúng ta đã giới thiệu làm sao để “exlaining” hoặc “summary” biến có thể làm cho code dễ đọc. Các biến này hữu ích vì chúng phá vỡ các biểu thức khổng lồ và hoạt động như 1 dạng của tài liệu nữa :D Trong phần này, chúng ta đang quan tâm đến loại bỏ các biến KHÔNG cải thiện khả năng đọc code. Khi 1 biến như vậy được xóa bỏ, code mới ngắn gọn hơn và thật dễ hiểu. Trong phần dưới đây là 1 vài ví dụ tại sao các biến không cần thiết. Useless Temporary VariablesTrong đoạn trích sau của Python code, xem xém biến now:12now = datetime.datetime.now()root_message.last_view_time = nowBiến now có đáng để giữ? Ở đây có 3 lí do: Nó không giúp phá vỡ các biểu thức phức tạp. Nó không làm rõ thêm gì - biểu thức datetime.datetime.now() đã đủ rõ ràng. Nó được sử dụng chỉ có 1 lần, bởi vậy nó không nén hoặc cắt giảm code. Không sử dụng now, đoạn code lại dễ hiểu hơn:1root_message.last_view_time = datetime.datetime.now()Các biến như now thường được gọi là “leftovers” (dịch tạm là đồ thừa) cái mà thừa thãi sau khi code đã được chỉnh sửa. Biến now nên được sử dụng trong nhiều nơi từ ban đầu. Hoặc có thể người code dự đoán sử dụng now nhiều lần nhưng không bao giờ thực sự cần nó. Eliminating Intermediate Results: Loại bỏ các kết quả tạm trung gian Đây là 1 ví dụ về hàm JavaScript loại bỏ 1 giá trị từ 1 mảng:123456789101112var remove_one = function (array, value_to_remove) { var index_to_remove = null; for (var i = 0; i &lt; array.length; i += 1) { if (array[i] === value_to_remove) { index_to_remove = i; break; } } if (index_to_remove !== null) { array.splice(index_to_remove, 1); }};Biến index_to_remove chỉ được sử dụng để giữ kết quả trung gian. Những biến như vậy có thể đôi khi nên được loại bỏ bằng cách xử lý kết quả sớm nhất khi bạn có nó:12345678var remove_one = function (array, value_to_remove) { for (var i = 0; i &lt; array.length; i += 1) { if (array[i] === value_to_remove) { array.splice(i, 1); return; } }};Bằng cách cho phép code trả về sớm, chúng ta không cần index_to_remove và đơn giản code hơn 1 chút. Nói chunng, nó là 1 chiến lực tốt để hoàn thành nhiệm vụ nhanh nhất có thể. Eliminating Control Flow VariablesĐôi khi bạn nhìn thấy mẫu code trong vòng lặp:123456789boolean done = false;while (/* condition */ &amp;&amp; !done) { ... if (...) { done = true; ontinue; }}Biến done thậm chí có thể được set giá trị nhiều vị trí trong vòng lặp này. Code như vậy thường đáp ứng 1 số nguyên tắc bất thành văn bạn cái mà bạn không nên thoát ra ở giữa vòng lặp. Nó không phải là 1 nguyên tắc như vậy. Biến như done được gọi là “control flow variables“. Mục đích duy nhất của nó là chỉ đạo sự thực thi của chương trình - chúng không chứa 1 vài dữ liệu lập trình thực tế . Theo kinh nghiệm của chúng tôi, các biến kiểm soát luồng có thể thường được loại bỏ để tốt hơn sử dụng ở lập trình cấu trúc: 123456while (/* condition */) { ... if (...) { break; }} Trường hợp này có vẻ dễ dàng để fix, nhưng điều gì sẽ xảy ra nếu nhiều vòng lặp lồng nhau trong mà không đơn giản để phá vỡ? Trong nhiều trường hợp phức tạp như vậy, giải pháp thường là moving chỗ code đó vào trong 1 hàm mới (trong hoặc ngoài vòng lặp tùy bạn) DO YOU WANT YOUR COWORKERS TO FEEL LIKETHEY’RE IN AN INTERVIEW ALL THE TIME? Eric Brechner của Microsoft đã nói chuyện về làm thế nào để có 1 câu hỏi phỏng vấn hay nên liên quan đến ít nhất 3 biến, p. 166.*). Nó có thể là vì giao dịch với 3 biến trong cùng 1 lúc buộc bạn phải suy nghĩ kĩ. Điều này có ý nghĩa trong 1 cuộc phỏng vấn, nơi mà bạn đang thử đẩy ứng viên đến các giới hạn. Nhưng bạn có muốn đồng nghiệp của bạn làm thấy chúng ta đang trong 1 cuộc phỏng vấn khi họ đang đọc code của bạn. :D Shrink the Scope of Your Variables: Thu nhỏ phạm vi biến của bạnChúng ta đã nghe đến lời khuyên “tránh các biến toàn cục”. Đây là 1 lời khuyên tốt vì nó khó theo dõi chỗ nào và các biến toàn cục này đang được sử dụng như thế nào. Và “gây ô nhiễm không gian tên” (đặt 1 loạt các tên đó có thể mẫu thuẩn với các biến local của bạn), có thể vô tình sửa đổi các biến toàn cục khi nó dự định sử dụng 1 biến local hoặc phần khác xung quanh. Trên thực tế, 1 ý tưởng tốt là “co phạm vi lại” cho tất cả các biến của bạn, không chỉ biến toàn cục. KEY IDEAMake your variable visible by as few lines of code as possible. Rất nhiều ngôn ngữ lập trình phục vụ các scope/access levels bao gồm module, class, function và block scope. Sử dụng rất nhiều truy cập hạn chế là tốt hơn vì nó có nghĩa biến có thể “nhìn thấy” bởi ít dòng code hơn. Tại sao lại cần làm vậy? Vì nó giảm đáng kể số lượng biến người đọc cần nghĩ trong cùng 1 lúc. Nếu bạn đang co tất cả các biến của bạn lại theo hệ số 2, sau đó trung bình sẽ có một nửa số biến trong phạm vi tại một thời điểm. Ví dụ giả định bạn có 1 lớp rất lớn với 1 biến thành viên cái mà được sử dụng chỉ bởi 2 phương thức:1234567891011121314class LargeClass { string str_; void Method1() { str_ = ...; Method2(); } void Method2() { // Uses str_ } // Lots of other methods that don't use str_ ...};Theo 1 số ý nghĩa, các biến thành viên cũng được coi là “mini-global” trong địa bàn của class. Đối với các lớp lớn hơn, rất khó để theo dõi tất cả các biến thành viên và phương thức nào định nghĩa lại mỗi chúng. Các mini-globale ít đi, điều đó sẽ tốt hơn. Đối với trường hợp này nó có thể có hợp lý để “giáng cấp” str_to thành biến local:123456789101112class LargeClass { void Method1() { string str = ...; Method2(str); } void Method2(string str) { // Uses str } // Now other methods can't see str.};Một cách khác để hạn chế truy cập với các thành viên của class là tạo ra nhiều phương thức static nhất có thể. Các phương thức tĩnh là cách tốt để cho người đọc biết “những dòng code này bị cô lập với các biến đó”. Một cách tiếp cận khác là phá vỡ các lớp lớn vào các lớp nhỏ hơn. Cách tiếp cận này hữu ích chỉ khi các lớp nhỏ hơn thực tế cô lập với nhau. Nếu bạn đang tạo 2 class mà truy cập mỗi thành phần của lớp khác, bạn chưa thực sự hoàn thành bất cứ điều gì. Tương tự như vậy phá vỡ file lớn vào trong các file nhỏ, các hàm lớn thành các hàm nhỏ hơn. Một động lực lớn để làm như vậy là cô lập dữ liệu (ví dụ: các biến). Nhưng ngôn ngữ khác nhau có những nguyên tắc khác nhau để định nghĩa chính xác các phạm vi. Chúng tôi muốn chỉ muốn chỉ ra 1 vài điểm thú vị, đáng quan tâm trong nguyên tắc phạm vi của biến =)) if Statement Scope in C++Giả sử bạn có 1 đoạn mã C++ như sau:123456PaymentInfo* info = database.ReadPaymentInfo();if (info) { cout &lt;&lt; &quot;User paid: &quot; &lt;&lt; info-&gt;amount() &lt;&lt; endl;}// Many more lines of code below ...Biến info sẽ còn lại trong phạm vi cho đoạn code còn lại của hàm, do đó mọi người đọc code sẽ giữ info trong đầu, tự hỏi nó sẽ sử dụng lại trong trường hợp nào, như thế nào? Nhưng trong trường hợp này, info chỉ được sử dụng trong if. Trong C++ chúng ta có thể định nghĩa info với biểu thức điều kiện123if (PaymentInfo* info = database.ReadPaymentInfo()) { cout &lt;&lt; &quot;User paid: &quot; &lt;&lt; info-&gt;amount() &lt;&lt; endl;}Bây giờ người đọc đã có thể dễ dàng quên biến info ngoài phạm vu if này :D. Creating “Private” Variables in JavaScriptGiả sử bạn có 1 biến cố chấp biến mà được sử dụng chỉ bởi 1 hàm:123456789submitted = false; // Note: global variablevar submit_form = function (form_name) { if (submitted) { return; // don't double-submit the form } ... submitted = true;};Biến toàn cục như submitted có thể gây ra cho người đọc đoạn code này rất nhiều sự sợ hãi. Dường như chỉ có hàm submit_form() sử dụng submitted nhưng bạn không biết chắc về điều đó. Trên thực tế, đoạn JavaScript khác cũng có thể sử dụng biến này với mục đích khác. Bạn có thể chặn vấn đề này bằng cách bọ nó trong 1 closure1234567891011var submit_form = (function () { var submitted = false; // Note: can only be accessed by the function below return function (form_name) { if (submitted) { return; // don't double-submit the form } ... submitted = true; };}());Nhận thấy rằng dấu ngoặc đơn ở dòng cuối là để thàm bên ngoài không teenn được thực thi ngay lập tức, trả về hàm bên trong nó. Nếu bạn chưa từng gặp kỹ thuật này trước đó, nó nhìn có vẻ lại trong lần đầu gặp. Nó có hiệu ứng tạo ra các phạm vi “private” cái mà chỉ cho các hàm trong nó truy cập. Bây giờ người đọc không phải tự hỏi Liệu submitted có được sử dụng ở đâu nữa không? và lo lắng về mâu thuẫn khi về các biến toàn cục khác cùng tên (Xem thêm về JavaScript The Good Part để hiểu thêm về kĩ thuật này). JavaScript Global ScopeTrong JavaScript, nếu bạn bỏ sót từ khóa var từ khai báo biến (ví dụ x = 1 thay vì var x = 1) biến đó sẽ trở thành biến toàn cục, và tất cả chỗ trong file JavaScript, khối &lt;script&gt; đều truy cập được nó. Đây là 1 ví dụ:12345678&lt;script&gt; var f = function () { // DANGER: 'i' is not declared with 'var'! for (i = 0; i &lt; 10; i += 1) ... }; f();&lt;/script&gt;Đoạn code vô tình để i thành biến toàn cục, do đó khối sau vẫn nhìn thấy nó:123&lt;script&gt; alert(i);&lt;/script&gt;Rất nhiều lập trình viên không nhận thức được nguyên tắc về phạm vi này và nó gây ra các hành vi không mong muốn, có thể tạo ra các bug dị =)). Một biểu hiện chung của code này 2 hàm cùng có cả 2 biến local với cùng tên nhưng quên sử dụng var. Những hàm này sẽ vô tình “cross-talk” (nói chuyện chéo) và thương thay lập trình viên có thể kết luận rằng máy tính của anh ta đã chị chiếm hữu bởi ai đó hoặc RAM đã hỏng =)). “Best practice” cho JavaScript là luôn luôn định nghĩa biến sử dụng từ khóa var (ví dụ var x = 1). Cách này sẽ giới hạn phạm vi của biến bên trong hàm nó được định nghĩa. No Nested Scope in Python and JavaScriptNgôn ngữ như C++ và Java có các khái niệm block scope - phạm vi khối, khi mà các biến được định nghĩa bên trong 1 if, for, try, hoặc các cấu trúc tương tự hạn chế phạm vi bên trong khối đó:12345if (...) { int x = 1;}x++; // Compile-error! 'x' is undefined.Nhưng Python và JavaScriptm biến được định nghĩa trong 1 khối “tràn ra ngoài” cả hàm. Ví dụ, nhận thấy sử dụng example_value trong Python là hoàn toàn hợp lệ:123456789# No use of example_value up to this point.if request: for value in request.values: if value &gt; 0: example_value = value breakfor logger in debug.loggers: logger.log(&quot;Example:&quot;, example_value)Nguyên tắc về scope này ngạc nhiên với nhiều lập trình viên và code như vậy rất khó để đọc. Trong 1 vài ngôn ngữ khác, dễ dàng tìm ra example_value trong lần định nghĩa đầu tiên - bạn có thể nhìn dọc “theo cạnh trái” của hàm bạn đang theo dõi. Trong ví dụ trước cũng đang lỗi: nếu example_value không được set trong phần đầu của code, phần thứ 2 sẽ ném ra 1 ngoại lệ &quot;NameError: ‘example_value’ is not defined&quot;. Chúng ta có thể sửa điều này, làm code có thể đọc được bằng cách định nghĩa example_value tại “tổ tiên chung gần nhất” (khái niệm của lồng nhau) nơi nó được sử dụng:12345678910example_value = Noneif request: for value in request.values: if value &gt; 0: example_value = value breakif example_value: for logger in debug.loggers: logger.log(&quot;Example:&quot;, example_value)Tuy nhiên, đây là trường hợp nơi example_value có thể loại bỏ hoàn toàn. example_value chỉ giữ kết quả trung gian và bạn có nhớ loại bỏ biến trung gian chúng ta đã thảo luận ở trang 95, biến như vậy có thể loại bỏ bằng cách “hoàn thành nhiệm vụ sớm nhất có thể”. Trong trường hợp này, nó có nghĩa log giá trị của ví dụ sớm nhất khi chúng ta tìm thấy nó. Đây là đoạn code mới:12345678def LogExample(value): for logger in debug.loggers: logger.log(&quot;Example:&quot;, value)if request: for value in request.values: if value &gt; 0: LogExample(value) # deal with 'value' immediately break Moving Definitions DownNgôn ngữ lập trình gốc C yêu cầu tất cả các biến được định nghĩa trên đầu của hàm và block. Yêu cầu này thật không may, vì đối với các hàm dài với nhiều biến, nó buộc người đọc nghĩ về tất cả các biến này, thậm chí chúng không được sử dụng (C99 và C++ đã loại bỏ yêu cầu này) Đoạn code dưới đây, tất cả các biến mặc nhiên được định nghĩa trên đầu hàm:1234567891011121314def ViewFilteredReplies(original_id): filtered_replies = [] root_message = Messages.objects.get(original_id) all_replies = Messages.objects.select(root_id=original_id) root_message.view_count += 1 root_message.last_view_time = datetime.datetime.now() root_message.save() for reply in all_replies: if reply.spam_votes &lt;= MAX_SPAM_VOTES: filtered_replies.append(reply) return filtered_repliesVấn đề của ví dụ trên là nó buộc người đọc nghĩ về 1 biến trong 1 lúc, chuyển qua chuyển lại giữa chúng. Vì người đọc không cần biết về tất cả chúng cho đến sau này. Sẽ dễ dàng hơn chỉ chuyển mỗi khai báo nào đúng trước khi nó được sử dụng trong lần đầu:12345678910111213def ViewFilteredReplies(original_id): root_message = Messages.objects.get(original_id) root_message.view_count += 1 root_message.last_view_time = datetime.datetime.now() root_message.save() all_replies = Messages.objects.select(root_id=original_id) filtered_replies = [] for reply in all_replies: if reply.spam_votes &lt;= MAX_SPAM_VOTES: filtered_replies.append(reply) return filtered_repliesBạn có thể tự hỏi liệu biến all_replies là 1 biến cần thiết, hoặc nếu có thể xóa đi như sau:12for reply in Messages.objects.select(root_id=original_id):...Trong trường hợp này, all_replies đang là 1 biến explaining rất tốt, bởi vậy chúng tôi quyết định giữ nó. Prefer Write-Once Variables&gt; Write-Once Variables - Biến ghi 1 lần: tôi đang hiểu là gán giá trị 1 lần, và nghĩa rộng ra là gán giá trị cho nó ít nhất =)) Cho đến bây giờ trong chương này, chúng ta đã thảo luận là khó hơn để hiểu 1 chương trình với nhiều biến “trong cuộc chơi”. Thậm chí là còn khó hơn khi nghĩ về các biến thay đổi liên tục. Theo dõi giá trị của chúng làm tăng thêm 1 mức độ khó. Để chống lại vấn đề này, chúng tôi gợi ý cho bạn 1 thứ nghe có chút lạ ưu tiên các biến ghi 1 lần Biến “cố định vĩnh viễn” dễ dàng để nghĩ đến hơn. Chắc chắn, một biến hằng như:1static const int NUM_THREADS = 10;Không yêu cầu người đọc phải nghĩ nhiều. Và với lý do giống nhau, sử dụng const trong C++ (và final trong Java) được khuyến khích cao nhất. Trên thực tế, rất nhiều ngôn ngữ (bao gồm cả Python và Java), 1 vài kiểu build-in như string thì là bất biến. Theo như James Gosling (người tạo ra Java) nói “[Bất biến] có xu hướng gặp thường xuyên hơn hơn cả các vấn đề tự do” @@ Nhưng thậm chí nếu bạn không thể làm cho biến của bạn write-once, vẫn ưu ích nếu biến thay đổi ở ít chỗ hơn KEY IDEACàng nhiều chỗ 1 biến được thao tác, càng khó lập luận, xem xét về giá trị hiện tại của nó Vậy chúng ta làm như thế nào? Làm sao bạn thay đổi 1 biến trở thành write-once? Well, nó cần rất nhiều lần nó yêu cầu tái cấu trúc lại code 1 chút, bạn sẽ thấy trong ví dụ tiếp theo. A Final ExampleTrong ví dụ cuối cùng của chương này, chúng tôi muốn chỉ ra 1 ví dụ chứng minh nhiều nguyên lý chúng ta đã thảo luận Giả sử bạn có 1 trang web với số lượng input text fileds được sắp xếp như sau:12345&lt;input type=&quot;text&quot; id=&quot;input1&quot; value=&quot;Dustin&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;input2&quot; value=&quot;Trevor&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;input3&quot; value=&quot;&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;input4&quot; value=&quot;Melissa&quot;&gt;...Như bạn đã thấy ids bắt đầu với input1 và tăng lên trong form. Công việc của bạn là viết 1 hàm với tên setFirstEmptyInput() cái mà lấy 1 chuỗi và đặt nó vào &lt;input&gt; trống đầu tiên trên web (trong ví dụ trên là “input3”). Hàm này nên trả về DOM element đã được cập nhật (hoặc null nếu không còn đầu vào trống). Đây là 1 vài code cần làm, không áp dụng các nguyên tắc trong chương này:123456789101112131415161718var setFirstEmptyInput = function (new_value) { var found = false; var i = 1; var elem = document.getElementById('input' + i); while (elem !== null) { if (elem.value === '') { found = true; break; } i++; elem = document.getElementById('input' + i); } if (found) elem.value = new_value; return elem;};Đoạn code hoạt động tốt nhưng chưa được đẹp. Điều gì đang có vấn đề và làm sao chúng ta có thể cải thiện chúng? Có rất nhiều cách để nghĩ về cải thiện đoạn code này nhưng chúng ta sẽ xem xét từ quan điểm của các biến: var found var i var elem Tất cả các biến này đều tồn tại từ đầu vào của hàm, và được dùng lại nhiều lần. Hãy thử cải thiện mỗi biến này. Như chúng ta đã thảo luận từ đầu của chương, các biến trung gian như found thường được loại bỏ bằng cách trả về sớm. Do đó đây là sự cả thiện:12345678910111213var setFirstEmptyInput = function (new_value) { var i = 1; var elem = document.getElementById('input' + i); while (elem !== null) { if (elem.value === '') { elem.value = new_value; return elem; } i++; elem = document.getElementById('input' + i); } return null;};Tiếp theo là biến elem. Nó được sử dụng nhiều lần trong code với vòng lặp và rất khó để giữ giá trị của nó. Đoạn code làm cho nó như nếu elem là 1 giá trị chúng ta đang lặp đi lặp lại, trong khi thực tế nó chỉ tăng giá trị của i. Do đó hãy tái cấu trức lại đoạn code vòng lặp while vào trong vòng lặp for với i:123456789101112var setFirstEmptyInput = function (new_value) { for (var i = 1; true; i++) { var elem = document.getElementById('input' + i); if (elem === null) return null; // Search Failed. No empty input found. if (elem.value === '') { elem.value = new_value; return elem; } };}Đặc biệt, chúng ta thấy cách elem hoạt động như 1 biến ghi 1 lần với vòng đời cố định trong vòng lặp. Sử dụng true trong 1 vòng lặp for không thường xuyên gặp, nhưng đổi lại chúng ta có thể xem được các khai báo và định nghĩa lại của i trong 1 dòng duy nhất. (Khi mà 1 while(true) cũng có thể hợp lý :D) Túm lạiTrong chương này chúng ta nói về cách sử dụng biến trong lập trình có thể dồn lại nhanh chóng và trở nên khó theo dõi. Bạn có thể làm code của bạn dễ đọc hơn bằng cách đọc ít biến và làm cho chúng “lightweight” (nhẹ cân, kiểu tránh dùng nó làm nhiều thứ) nhất có thể. Cụ thể: Loại bỏ các biến cản trở. Đặc biệt, chúng tôi đã chỉ ra 1 vài ví dụ làm sao để loại bỏ “các biến trung gian” bằng cách trả về ngay lập tức. Giảm phạm vi của mỗi biến nhỏ nhất có thể. Di chuyển mỗi biến tới các vị trí nơi mà ít dòng nhất nhìn thấy nó. Không nhìn thấy là khỏi suy nghĩ =)) (Out of sight is out of mind.) Ưu tiên các biến viết 1 lần. Các biến chỉ được set 1 lần (hoặc const, final hoặc các bất biến khác) làm code dễ hiểu hơn.","link":"/2020/05/24/Chapter-9-Variables-and-Readability/"},{"title":"[Collection] Practice 13: Ranking a Competition","text":"Đây là 1 project tôi viết 1 vài tháng trước. Ứng dụng quản lý cuộc thi và tôi cần viết code để làm sao để tính rank các team sau khi cuộc thi kết thúc.Tôi bắt đầu nhận với collection là điểm các đội như sau12345678910$scores = collect([ ['score' =&gt; 76, 'team' =&gt; 'A'], ['score' =&gt; 62, 'team' =&gt; 'B'], ['score' =&gt; 82, 'team' =&gt; 'C'], ['score' =&gt; 86, 'team' =&gt; 'D'], ['score' =&gt; 91, 'team' =&gt; 'E'], ['score' =&gt; 67, 'team' =&gt; 'F'], ['score' =&gt; 67, 'team' =&gt; 'G'], ['score' =&gt; 82, 'team' =&gt; 'H'],]);Nó có vẻ đơn giản bằng cách sử dụng method sortByDesc, cái mà sẽ nhận vào tên trường và sắp xếp nó như 1 tham số1234567891011$rankedScores = $scores-&gt;sortByDesc('score');// =&gt; [// ['score' =&gt; 91, 'team' =&gt; 'E'],// ['score' =&gt; 86, 'team' =&gt; 'D'],// ['score' =&gt; 82, 'team' =&gt; 'C'],// ['score' =&gt; 82, 'team' =&gt; 'H'],// ['score' =&gt; 76, 'team' =&gt; 'A'],// ['score' =&gt; 67, 'team' =&gt; 'F'],// ['score' =&gt; 67, 'team' =&gt; 'G'],// ['score' =&gt; 62, 'team' =&gt; 'B'],// ];Bây giờ chúng đã được sắp xếp, chúng ta chỉ có thể sử dụng chỉ số của mảng cộng thêm 1 như là rank, đúng ko? Không hẳn, bởi vì sortByDesc thực sự vẫn giữ lại key cũ, do vậy mặc dù $rankedScores đã được sắp xếp đúng thứ tự nhưng chúng thực sự , chúng vẫn có key rõ ràng không phải là ranking mong đợi1234567891011$rankedScores = $scores-&gt;sortByDesc('score');// =&gt; [// 4 =&gt; ['score' =&gt; 91, 'team' =&gt; 'E'],// 3 =&gt; ['score' =&gt; 86, 'team' =&gt; 'D'],// 2 =&gt; ['score' =&gt; 82, 'team' =&gt; 'C'],// 7 =&gt; ['score' =&gt; 82, 'team' =&gt; 'H'],// 0 =&gt; ['score' =&gt; 76, 'team' =&gt; 'A'],// 5 =&gt; ['score' =&gt; 67, 'team' =&gt; 'F'],// 6 =&gt; ['score' =&gt; 67, 'team' =&gt; 'G'],// 1 =&gt; ['score' =&gt; 62, 'team' =&gt; 'B'],// ];Một cách đơn giản để fix chỗ này là gọi phương thức values, nó sẽ xóa các key đã tồn tại đi và reset chúng về dạng bình thường1234567891011$rankedScores = $scores-&gt;sortByDesc('score')-&gt;values();// =&gt; [// 0 =&gt; ['score' =&gt; 91, 'team' =&gt; 'E'],// 1 =&gt; ['score' =&gt; 86, 'team' =&gt; 'D'],// 2 =&gt; ['score' =&gt; 82, 'team' =&gt; 'C'],// 3 =&gt; ['score' =&gt; 82, 'team' =&gt; 'H'],// 4 =&gt; ['score' =&gt; 76, 'team' =&gt; 'A'],// 5 =&gt; ['score' =&gt; 67, 'team' =&gt; 'F'],// 6 =&gt; ['score' =&gt; 67, 'team' =&gt; 'G'],// 7 =&gt; ['score' =&gt; 62, 'team' =&gt; 'B'],// ];Có vẻ tốt hơn 1 chút rồi nhưng ranking thực tế vẫn bị giảm đi 1 đúng không? Tôi nghĩ nó sẽ tốt hơn nếu bạn có thể thêm trường rank cho mỗi điểm để lấy rank thực sự, bắt đầu từ 1 thay vì 0. 1. Zipping-in the RanksMột cách để làm việc này là dùng zip điểm số với danh sách ranks. Chúng ta có thể sinh danh sách các ranks bằng cách sử dụng range($start, $end)123456789101112$rankedScores = $scores-&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count()));// =&gt; [// [['score' =&gt; 91, 'team' =&gt; 'E'], 1],// [['score' =&gt; 86, 'team' =&gt; 'D'], 2],// [['score' =&gt; 82, 'team' =&gt; 'C'], 3],// [['score' =&gt; 82, 'team' =&gt; 'H'], 4],// [['score' =&gt; 76, 'team' =&gt; 'A'], 5],// [['score' =&gt; 67, 'team' =&gt; 'F'], 6],// [['score' =&gt; 67, 'team' =&gt; 'G'], 7],// [['score' =&gt; 62, 'team' =&gt; 'B'], 8],// ];Một cách tốt khi sử dụng theo hướng này là chúng ta có thể bỏ lời gọi values, chúng ta không phải thực sự lo về vấn đề keys thêm 1 lần nào nữa. Sau khi zip điểm số với rank của họ, chúng ta có thể sử dụng map để thêm rank vào như 1 trường thực sự:123456789101112131415161718$rankedScores = $scores-&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); });// =&gt; [// ['rank' =&gt; 1, 'score' =&gt; 91, 'team' =&gt; 'E'],// ['rank' =&gt; 2, 'score' =&gt; 86, 'team' =&gt; 'D'],// ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'],// ['rank' =&gt; 4, 'score' =&gt; 82, 'team' =&gt; 'H'],// ['rank' =&gt; 5, 'score' =&gt; 76, 'team' =&gt; 'A'],// ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'F'],// ['rank' =&gt; 7, 'score' =&gt; 67, 'team' =&gt; 'G'],// ['rank' =&gt; 8, 'score' =&gt; 62, 'team' =&gt; 'B'],// ]; 2. Dealing with Ties (Giao dịch với điểm bằng nhau)Nếu bạn nhìn kỹ điểm đã được sắp xếp, bạn sẽ nhận thấy có 2 tập có điểm bằng nhau12['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'],['rank' =&gt; 4, 'score' =&gt; 82, 'team' =&gt; 'H'],Liệu có thực sự chơi đẹp không khi team C nhận vị trí thứ 3 còn team H nhận ví trí thứ 4 mặc dù 2 đội bằng điểm? Tại sao không có cách xử ý nào khác? Cách xử lý có thể áp dụng luật xếp rank https://en.wikipedia.org/wiki/Ranking#Standard_competition_ranking_.28.221224.22_ranking.29 khi 2 đội bằng điểm, bỏ qua thứ hạng và những điểm số khác. Và đây là cái theo như chuẩn ranking sẽ cần điều chỉnh:12345678910[ ['rank' =&gt; 1, 'score' =&gt; 91, 'team' =&gt; 'E'], ['rank' =&gt; 2, 'score' =&gt; 86, 'team' =&gt; 'D'], ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'], ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'H'], ['rank' =&gt; 5, 'score' =&gt; 76, 'team' =&gt; 'A'], ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'F'], ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'G'], ['rank' =&gt; 8, 'score' =&gt; 62, 'team' =&gt; 'B'],];OK, ý tưởng là vậy, nhưng làm sao chúng ta có thể thực thi chúng? 3. One Step at a TimeTôi có chút thú nhận khi làm: Mất rất nhiều thời gian khi tôi giải quyết vấn đề này với collection pipelines, tôi không có ý tưởng gì để giải quyết vấn đề này. Một trong những thứ tốt đẹp nhất mà collection pipeline mang lại là mỗi bước nhỏ và rời rạc. Chúng ta đã nói 1 chút về nó, về cách mà nó làm cho code trở nên dễ theo dõi hơn nhưng không dễ để viết. Thay vì tìm ra tất cả các thuật toán, tôi chỉ chưa bao giờ phải lo lắng về việc nhận 1 bước nào đó gần hơn cho vấn đề tôi đang gặp phải. Nếu có đủ thời gian, tôi đã có thể kết thúc vấn đề. Nhưng tôi đang cố cần thực hiện bước nào để thực thi được việc sắp xếp rank theo chuẩn? 4. Grouping by ScoreNếu team bạn đang có các điểm giống nhau và hỗ trợ nhận các rank giống nhau, sẽ sắp xếp kết quả theo score có giải là đủ để giải quyết vấn đề:12345678910$rankedScores = $scores-&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); }) -&gt;groupBy('score');Kết quả chúng ta nhận được sẽ như sau:12345678910111213141516171819202122[ 91 =&gt; [ ['rank' =&gt; 1, 'score' =&gt; 91, 'team' =&gt; 'E'] ], 86 =&gt; [ ['rank' =&gt; 2, 'score' =&gt; 86, 'team' =&gt; 'D'] ], 82 =&gt; [ ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'], ['rank' =&gt; 4, 'score' =&gt; 82, 'team' =&gt; 'H'], ], 76 =&gt; [ ['rank' =&gt; 5, 'score' =&gt; 76, 'team' =&gt; 'A'] ], 67 =&gt; [ ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'F'], ['rank' =&gt; 7, 'score' =&gt; 67, 'team' =&gt; 'G'], ], 62 =&gt; [ ['rank' =&gt; 8, 'score' =&gt; 62, 'team' =&gt; 'B'] ],]; 5. Adjusting the RanksNhư vậy chúng ta có tất cả kết quả đã được nhóm theo điểm và chúng ta muốn chắc chắn rằng 1 vài team có điểm giống nhau sẽ có rank tốt nhất có thể. Hãy nhìn xem 1 phần của các cặp điểm giống nhau và chúng ta có thể nghỉ cách nào để làm việc với nó:1234$tiedScores = collect([ ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'], ['rank' =&gt; 4, 'score' =&gt; 82, 'team' =&gt; 'H'],]);Với nhóm kết quả này, làm sao chúng ta chắc chắn rằng cả 2 đều ở vị trí thứ 3. Đầu tiên chúng ta cần tìm ra rank tốt nhất trong nhóm. Chúng ta có thể làm điều này bằng cách sử dụng pluck để lấy tập collection của mỗi rank và sử dụng min để lấy rank nhỏ nhất của collection:1$lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min();Đủ dễ rồi! Bây giờ chúng ta cần gán rank giống nhau với mỗi team. Chúng ta có thể sử dụng map cho mỗi team để chuyển đổi mỗi kết quả:123456$lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min();$adjustedScores = $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { $rankedScore['rank'] = $lowestRank; return $rankedScore;}) Chúng ta có 1 chút cẩn thận vì chúng ta không được phép biến đổi trong hàm map, bạn nhớ chứ? Trong trường hợp này, sự thay đổi rank key không biến đổi gì về mặt kỹ thuật ngoài hàm closure vì hàm trong PHP được pass by value nhưng nếu chúng ta làm việc với objects, nó sẽ là vấn đề lớn.Với sự lợi ích nhất quán, chúng tôi khuyên bạn nên trả về hàm mới, sử dụng array_merge để thay thế rank cũ bằng 1 hàm mới:123456$lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min();$adjustedScores = $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]);})Sau khi áp dụng việc chuyển đổi, chúng ra nhận được tập các điểm mới nhìn như sau:1234[ ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'], ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'H'],];Bây giờ, cả 2 team có điểm giống nhau với vị trí thứ 3, đúng như chúng ta muốn, perfect!Để áp dụng việc chuyển đổi cho mỗi nhóm điểm, chúng ta chỉ cần map mỗi nhóm là được. 6. Collapse and Sort: Thu gọn và sắp xếpBây giờ kết quả của chúng ta đã được sắp xếp theo điểm. Chúng ta có thể làm phẳng chúng xuống bằng cách sử dụng collapse. Kết quả thu được sẽ như sau:12345678910[ ['rank' =&gt; 1, 'score' =&gt; 91, 'team' =&gt; 'E'], ['rank' =&gt; 2, 'score' =&gt; 86, 'team' =&gt; 'D'], ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'C'], ['rank' =&gt; 3, 'score' =&gt; 82, 'team' =&gt; 'H'], ['rank' =&gt; 5, 'score' =&gt; 76, 'team' =&gt; 'A'], ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'F'], ['rank' =&gt; 6, 'score' =&gt; 67, 'team' =&gt; 'G'], ['rank' =&gt; 8, 'score' =&gt; 62, 'team' =&gt; 'B'],];Tuyệt vời, chúng ta đã có kết quả như chúng ta mong đợi. Sau đó chúng ta có thể sắp xếp rank theo ý. 7. Cleaning UpĐây là những thứ chặt chẽ tôi sẽ đẩy vào trong hàm1234567891011121314151617181920212223function rank_scores($scores){ return collect($scores) -&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); }) -&gt;groupBy('score') -&gt;map(function ($tiedScores) { $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); }); }) -&gt;collapse() -&gt;sortBy('rank');}Hãy nhìn chỗ code này, phần hàm map thứ 2 hoàn toàn có thể thay thế bởi 1 hàm với tên gọi apply_min_rank12345678910111213141516171819202122232425262728/**function rank_scores($scores){ return collect($scores) -&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); }) -&gt;groupBy('score')**/ -&gt;map(function ($tiedScores) { $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); }); })/** -&gt;collapse() -&gt;sortBy('rank');}**/Thay thế bằng:1234567891011121314151617181920212223242526272829303132/**function rank_scores($scores){ return collect($scores) -&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); }) -&gt;groupBy('score')**/ -&gt;map(function ($tiedScores) { return apply_min_rank($tiedScores); })/** -&gt;collapse() -&gt;sortBy('rank');}**/function apply_min_rank($tiedScores){ $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); });}Nhìn có vẻ đẹp hơn 1 chút xíu, Nhưng chúng chưa thực sự giàu tính biểu đạt. 8. Grouping OperationsPhần map ở trên được sử dụng để gán và khởi tạo rank cho mỗi điểm.1234567891011121314151617181920212223242526function rank_scores($scores){ return collect($scores) -&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); })/** -&gt;groupBy('score') -&gt;map(function ($tiedScores) { $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); }); }) -&gt;collapse() -&gt;sortBy('rank');}**/Tương tự 3 bước ở dưới đang chỉnh sửa rank có cùng điểm số.1234567891011121314151617181920212223242526/**function rank_scores($scores){ return collect($scores) -&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); })**/ -&gt;groupBy('score') -&gt;map(function ($tiedScores) { $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); }); }) -&gt;collapse() -&gt;sortBy('rank');}Chúng ta có thể xử chúng không nhỉ? 9. Breaking the ChainNhư đã nói ở trên, hàm assign_initial_rankings sẽ có dạng như sau:1234567891011function assign_initial_rankings($scores){ return $scores-&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); });}Và hàm adjust_rankings_for_ties:12345678function adjust_rankings_for_ties($scores){ return $scores-&gt;groupBy('score') -&gt;map(function ($tiedScores) { return apply_min_rank($tiedScores); }) -&gt;collapse();}Cả 2 đều đơn giản và dễ dàng để hiểu khi chúng ta tách ta nhưng chúng ta sẽ kết hợp chúng vào pipeline như thế nào? Hóa ra chúng là không thể, chúng ta phải ngắt pipeline và sử dụng biến tạm thời1234567function rank_scores($scores){ $rankedScores = assign_initial_rankings(collect($scores)); $adjustedScores = adjust_rankings_for_ties($rankedScores); return $adjustedScores-&gt;sortBy('rank');}Nhìn hơi tù nhỉ. Chúng ta có thể thêm những phần này như là các method vào collection của chúng ta bằng cách sử dụng macros nhưng chúng không thực sự có ý nghĩa như csac phương thức của collection. Cả 2 đều thực hiện các mục đích khác nhau và chúng không thực sự thuộc về mục đích chung của các toán tử collection Mất một khoảng thời gian dài, tôi chỉ chấp nhận những hạn chế này và thoát nó ra khỏi pipeline khi tôi cần, nhưng gần đây tôi đã vấp ngã trong 1 tiêu chuẩn cái mà làm cho tôi làm tốt cả 2 vấn đề này. 10. The Pipe MacroChúng ta sẽ có macro đơn giản như sau:123Collection::macro('pipe', function ($callback) { return $callback($this);});Tất cả nó làm là gọi phương thức pipe cái mà nhận vào 1 callback, truyền collection vào callack và trả lại kết quả. Khi đó code sẽ đơn giản như sau:1234567891011function rank_scores($scores){ return collect($scores) -&gt;pipe(function ($scores) { return assign_initial_rankings($scores); }) -&gt;pipe(function ($rankedScores) { return adjust_rankings_for_ties($rankedScores); }) -&gt;sortBy('rank');}Như vậy chúng ta lại nhận được 1 pipeline! PHP cho phép ta đối xử với string như là 1 callback nếu nó trùng với tên function Do vậy chúng ta thậm chí cho thể viết:1234567function rank_scores($scores){ return collect($scores) -&gt;pipe('assign_initial_rankings') -&gt;pipe('adjust_rankings_for_ties') -&gt;sortBy('rank');}Không thể có nhiều biểu cảm hơn nữa. Và đây là luồng chung của cả công việc phân rank:123456789101112131415161718192021222324252627282930313233function rank_scores($scores){ return collect($scores) -&gt;pipe('assign_initial_rankings') -&gt;pipe('adjust_rankings_for_ties') -&gt;sortBy('rank');}function assign_initial_rankings($scores){ return $scores-&gt;sortByDesc('score') -&gt;zip(range(1, $scores-&gt;count())) -&gt;map(function ($scoreAndRank) { list($score, $rank) = $scoreAndRank; return array_merge($score, [ 'rank' =&gt; $rank ]); });}function adjust_rankings_for_ties($scores){ return $scores-&gt;groupBy('score')-&gt;map(function ($tiedScores) { return apply_min_rank($tiedScores); })-&gt;collapse();}function apply_min_rank($tiedScores){ $lowestRank = $tiedScores-&gt;pluck('rank')-&gt;min(); return $tiedScores-&gt;map(function ($rankedScore) use ($lowestRank) { return array_merge($rankedScore, [ 'rank' =&gt; $lowestRank ]); });}Thật không tệ với một vấn đề phức tạp phải không nào!!!","link":"/2019/12/27/Collection-Practice-13-Ranking-a-Competition/"},{"title":"[Docker] Dockerfile instructions","text":"Cùng tìm hiểu một vài instructions được sử dụng nhiều trong Dockerfile. Phần này tôi tổng hợp chủ yếu từ Dockerfile best pratice luôn, chỉ có 1 ít đá ké sang Dockerfile reference. Do đó nếu muốn xem chi tiết instruction đó cú pháp và hoạt động chi tiết, hãy vào Dockerfile reference để đọc. FROMImage được sử dụng làm basic. Bạn có thể sử dụng nó kết hợp với ARG. Tuy nhiên, các ARG được khai báo trước FROM thì sẽ không được sử dụng trong các bước build tiếp theo, do đó bạn cần khai báo lại:1234ARG VERSION=latestFROM busybox:$VERSIONARG VERSIONRUN echo $VERSION &gt; image_versionChúng tôi khuyên bạn nên sử dụng các Alpine image vì nó được kiểm soát chặt chẽ hơn, kích thước nhỏ (dưới 5MB) so với các bản Linux đầy đủ. LABELPhần này có thể sử dụng để bổ sung lưu trữ các thông tin, thông tin sở hữu hoặc bất cứ thông tin gì bạn muốn mô tả thêm về docker. Khi sử dụng string, nó cần đặt trong dấu “” và cần escape nếu kí tự đặc biệt:123456# Set one or more individual labelsLABEL com.example.version=&quot;0.0.1-beta&quot;LABEL vendor1=&quot;ACME Incorporated&quot;LABEL vendor2=ZENITH\\ IncorporatedLABEL com.example.release-date=&quot;2015-02-12&quot;LABEL com.example.version.is-production=&quot;&quot; RUNRUN thường sử dụng để cài phần mềm hoặc package như bạn cần cài trên ubuntu ấy RUN sẽ thực thi 1 vài lệnh trên 1 tầng mới ở đầu image hiện tại và commit kết quả. Kết quả được ghi lại và sử dụng ở các bước tiếp theo trong Dockerfile RUN sẽ có 2 cấu trúc: RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows) RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form) (Mặc định thì nó sẽ là shell form) exec form cũng được sử dụng nhiều, nó cũng có thể sử dụng để chạy shell form:1RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] Note: Không giống như shell form, exec form không gọi 1 command shell. Điều đó có nghĩa các xử lý shell thông thường sẽ không diễn ra. Ví dụ RUN [ “echo”, “$HOME” ] sẽ không thay thế biến $HOME. Nếu bạn muốn thực thi shell thì sử dụng shell form hoặc thực thi shell 1 cách trực tiếp, ví dụ RUN [ “sh”, “-c”, “echo $HOME” ]. Khi sử dụng exec for và thực thi shell trực tiếp như shell form, nó là shell làm việc với mở rộng với biến môi trường chứ không phải docker. Note (Bản gốc): Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, RUN [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: RUN [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker. Cache của RUN không bị tự động vô hiệu trong quá trình build tiếp theo (tức là được sử dụng lại). Cache của lệnh RUN apt-get dist-upgrade -y sẽ được sử dụng lại trong lần build tiếp theo. Cache sẽ vô hiệu hóa khi bạn build lại với tùy chọn --no-cache như docker build --no-cache APT-GETĐa số trường hợp sử dụng RUN là để chạy ứng dụng của apt-get. Bởi vì nó để cài đặt các package chạy lệnh RUN apt-get, tuy nhiên cũng có 1 vài chú ý với lệnh này: Tránh RUN apt-get upgrade và dist-upgrade vì nhiều package trong số các package thiết yếu của image cha không thể nâng cấp bên trong 1 container không có đặc quyền. Nếu 1 package được chứa trong parent image đã out-of-date, liên hệ đội ngũ maintain nó Hãy sử dụng kết hợp RUN apt-get update kết hợp với apt-get install như ví dụ sau: 1234567891011121314RUN apt-get update &amp;&amp; apt-get install -y \\ aufs-tools \\ automake \\ build-essential \\ curl \\ dpkg-sig \\ libcap-dev \\ libsqlite3-dev \\ mercurial \\ reprepro \\ ruby1.9.1 \\ ruby1.9.1-dev \\ s3cmd=1.1.* \\ &amp;&amp; rm -rf /var/lib/apt/lists/* Chạy các lệnh như thực thi trong container. Sử dụng dấu phân cách để tách biệt nhiều lệnh trên nhiều dòng cho dễ đọc và maintain: 12RUN /bin/bash -c 'source $HOME/.bashrc; \\ echo $HOME' USING PIPES Một vài lệnh RUN phụ thuộc vào kết quả output của 1 vài lệnh khác, lúc đó, hãy sử dụng pipe (|)1RUN wget -O - https://some.site | wc -l &gt; /numberIf you want the command to fail due to an error at any stage in the pipe, prepend set -o pipefail &amp;&amp; to ensure that an unexpected error prevents the build from inadvertently succeeding. For example:1RUN set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number Note: Không hỗ trợ tùy chọn -o pipefail CMDThe CMD instruction has three forms: CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form) CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT) CMD command param1 param2 (shell form) Hai cách đầu thường được sử dụng nhiều, đặc biệt là các số 2. Nó thường kết hợp với ENTRYPOINT và bạn nên đọc ở phần sau. Lệnh CMD nên được sử dụng để chạy phần mềm được chứa trong image của bạn cùng với 1 vài tham số (ví dự như chạy nodejs: node tenfile, hay php artisan serve trong Laravel ấy =)). CMD đa số nên được sử dụng dưới dạng :1CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;…]Ví dụ như apache1CMD [&quot;apache2&quot;,&quot;-DFOREGROUND&quot;]Trong đa số các trường hợp khác, CMD được sử dụng như 1 sự tích hợp shell, như bash, python và perl. Ví dụ CMD [&quot;perl&quot;, &quot;-de0&quot;], CMD [&quot;python&quot;], or CMD [&quot;php&quot;, &quot;-a&quot;]. Sử dụng các lệnh như trên tương đương với việc bạn thực thi docker như docker run -it python. CMD sẽ rất hiếm khi được sử dụng theo cách CMD [&quot;param&quot;, &quot;param&quot;] kết hợp với ENTRYPOINT, trừ khi bạn và người dùng đã quá khen thuộc với cách sử dụng ENTRYPOINT hoạt động như thế nào EXPOSE1EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] Bình thường các Docker container hoạt động độc lập, không chia sẽ cho nhau cái gì, ai biết nhà nấy (MySQL biết MySQL, Nginx biết Nginx, không mở lắng nghe kết nối từ đâu đến). Nhưng như vậy không ổn, chúng cần lắng nghe và kết nối với nhau để tạo được 1 ứng dụng. EXPOSE giúp chúng ta làm việc này. Lệnh EXPOSE chỉ ra cổng nào mà 1 container lắng nghe kết nối. Do đó bạn nên sử dụng các cổng truyền thống và chung nhất cho ứng dụng của mình. Ví dụ như Apache sẽ EXPOSE cổng 80 trong khi image của MongoDB sẽ sử dụng EXPOSE 27017 12EXPOSE 80/tcpEXPOSE 80/udp Để truy cập bên ngoài (như local machine chẳng hạn), bạn có thể sử dụng docker run với với ánh xạ cổng được chỉ định đến cổng mà bạn lựa chọn, với tùy chọn -p. Đối với các conatianer liên kết với nhau, Docker cung cấp các biến môi trường đối với đường dẫn từ container nhận được trở về container nguồn (ví dụ như biến MYSQL_PORT_3306_TCP). 1docker run -p 80:80/tcp -p 80:80/udp ... It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. Giải thích: EXPOSE có thể có hoặc không, container của bạn vẫn chạy và có thể vẫn được expose bình thường với docker-compose. Tuy nhiên hãy thêm nó, vì cũng chẳng tốn công gì, và coi nó như 1 dạng của tài liệu truyền đạt thông tin giữa người xây dựng container và người chạy container, về những cổng nào mà sẽ được publish ENV12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ... Cho phép phần mềm của bạn dễ dàng chạy, bạn có thể sử dụng ENV cập nhật PATH trong biến môi trường cho những phần mềm được cài trong container. Ví dụ ENV PATH /usr/local/nginx/bin:$PATH để chắc chắn rằng CMD [&quot;nginx&quot;] hoạt động. Lệnh ENV cũng hữu ích khi cung cấp các biến môi trường cho bạn, như các const trong khi lập trình, hoặc các phiên bản để bạn dễ dàng bảo trì hơn:1234ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATHMỗi dòng ENV tạo 1 ra 1 tầng trung gian mới, tương tự như RUN. Điều đó có nghĩa, thậm chí bạn đã unset biến môi trường ở 1 tầng nào đó trong tương lai, nó vẫn tồn tại ở layer này và giá trị của nó không bị hủy bỏ. Bạn có thể build Dockerfile sau và kiểm tra nó1234FROM alpineENV ADMIN_USER=&quot;mark&quot;RUN echo $ADMIN_USER &gt; ./markRUN unset ADMIN_USER123$ docker run --rm test sh -c 'echo $ADMIN_USER'markĐể ngăn chặn việc này, hãy xử nó ở chính layer đơn đó bằng ; hoặc &amp;&amp;12345FROM alpineRUN export ADMIN_USER=&quot;mark&quot; \\ &amp;&amp; echo $ADMIN_USER &gt; ./mark \\ &amp;&amp; unset ADMIN_USERCMD sh1$ docker run --rm test sh -c 'echo $ADMIN_USER' ADD or COPY12ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] (this form is required for paths containing whitespace) Cả 2 lệnh này đều thực hiện copy new files, thư mục từ &lt;src&gt; và thêm nó vào thư mục filesystem &lt;dest&gt; trong image. The ADD instruction copies new files, directories or remote file URLs from &lt;src&gt; and adds them to the filesystem of the image at the path &lt;dest&gt;. The COPY instruction copies new files or directories from &lt;src&gt; and adds them to the filesystem of the container at the path &lt;dest&gt;. Mặc dù nhìn thì ADD và COPY tương tự về chức năng, nhưng nói chung COPY vẫn được ưa chuộng hơn. Đó là bởi vì nó minh bạch nhiều hơn ADD. COPY chỉ hỗ trợ các phép sao chép cơ bản các file local vào trong container trong khi ADD có 1 vài chức năng (như giải nén file tar, remote URL support) cái mà không được minh bạch ngay lập tức. Do đó, cách sử dụng tốt nhất cho ADD là tự động trích xuât tệp tar local vào image như ADD rootfs.tar.xz / Nếu bạn có nhiều bước trong Dockerfile sử dụng các file khác nhau trong context của bạn, COPY từng file một hơn là copy tất cả trong 1 lần. Điều này để chắc chắn rằng mỗi bước build, cache sẽ bị vô hiệu hóa (buộc các bước này phải chạy lại) nếu các tệp được yêu cầu cụ thể thay đổi (thay vì chạy lại hết mà 1 file có thể không liên quan thay đổi). Ví dụ:123COPY requirements.txt /tmp/RUN pip install --requirement /tmp/requirements.txtCOPY . /tmp/Kết quả việc vô hiệu hóa cache của RUN sẽ ít hơn bến bạn đặt COPY . /tmp/ trước nó (vì khi thay đổi requirements.txt mới bị vô hiệu hóa cache. Bạn đặt COPY . /tmp/ trước thì thay đổi bất kì file nào đều vô hiệu hóa cache) Do vấn đề kích thước (size) của image, việc sử dụng ADD để nạp các package từ remote URLs KHÔNG được khuyến khích. Thay vào đó, bạn nên sử dụng curl hoặc wget. Và bằng cách này, bạn có thể xóa file đi sau khi bạn giải nén và sử dụng để không ảnh hưởng đến các layer khác trong image. Ví dụ thay vì như vậy:123ADD http://example.com/big.tar.xz /usr/src/things/RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/thingsRUN make -C /usr/src/things allThì bạn nên:1234RUN mkdir -p /usr/src/things \\ &amp;&amp; curl -SL http://example.com/big.tar.xz \\ | tar -xJC /usr/src/things \\ &amp;&amp; make -C /usr/src/things all ENTRYPOINTENTRYPOINT có 2 kiểu: ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form, preferred) ENTRYPOINT command param1 param2 (shell form) Một ENTRYPOINT cho phép bạn cấu hình để thực thi container Ví dụ start nginx với cổng 80:1docker run -i -t --rm -p 80:80 nginxdocker run &lt;image&gt; sẽ được thêm vào sau tất cả các thành phần với exec form ENTRYPOINT và sẽ ghi đè tất cả các thành phần được chỉ định sử dụng CMD shell form chặn 1 vài CMD hoặc lệnh run với 1 vài tham số nhưng nhược điểm của kiểu ENTRYPOINT này sẽ bắt đầu như là 1 subcommand của /bin/sh -c, cái mà sẽ không có tín hiệu. Điều đó có nghĩa thực thi này sẽ không phải là PID của container 1 và sẽ không nhận được các tín hiệu từ Unix - do đó sự thực thi container này sẽ không nhận một SIGTERM từ docker stop &lt;container&gt; Chỉ lệnh ENTRYPOINT cuối cùng trong Dockerfile là có hiệu lực. Exec form ENTRYPOINT exampleBạn có thể sử dụng exec form của ENTRYPOINT để thiết lập lệnh mặc định và các đối số và sau đó sử dụng CMD để thiết lập thêm các tham số có nhiều khả năng thay đổi 123FROM ubuntuENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]CMD [&quot;-c&quot;] Và khi bạn chạy container, bạn sẽ nhìn thấy top chỉ là 1 tiến trình:123456789$ docker run -it --rm --name test top -Htop - 08:25:00 up 7:27, 0 users, load average: 0.00, 0.01, 0.05Threads: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.1 us, 0.1 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem: 2056668 total, 1616832 used, 439836 free, 99352 buffersKiB Swap: 1441840 total, 0 used, 1441840 free. 1324440 cached MemPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND1 root 20 0 19744 2336 2080 R 0.0 0.1 0:00.04 topĐể xem kết quả nhiều hơn nữa, bạn có thể sử dụng docker exec1234$ docker exec -it test ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 2.6 0.1 19752 2352 ? Ss+ 08:24 0:00 top -b -Hroot 7 0.0 0.1 15572 2164 ? R+ 08:25 0:00 ps auxVà bạn có thể gửi 1 request top để tắt docker đang sử dụng đi docker stop test. Một ví dụ khác sử dụng ENTRYPOINT để chạy Apache: 12345FROM debian:stableRUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2EXPOSE 80 443VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;] Nếu bạn cần viết 1 script khởi động của 1 sự thực thi đơn, bạn có thể chắc chắn rằng lệnh cuối cùng nhận được tín hiệu Unix bằng cách sử dụng exec và gosu commands1234567891011121314#!/usr/bin/env bashset -eif [ &quot;$1&quot; = 'postgres' ]; then chown -R postgres &quot;$PGDATA&quot; if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then gosu postgres initdb fi exec gosu postgres &quot;$@&quot;fiexec &quot;$@&quot;Cuối cùng, nếu bạn cần thêm 1 số sự dọn dẹp (hoặc kết nối với container khác) khi shutdown hoặc đang có nhiều hơn 1 sự thực thi, bạn có thể cần chắc chắn rằng script ENTRYPOINT nhận Unix signals, vượt qua chúng và sau đó thực hiện 1 số công việc khác:123456789101112131415161718#!/bin/sh# Note: I've written this using sh so it works in the busybox container too# USE the trap if you need to also do manual cleanup after the service is stopped,# or need to start multiple services in the one containertrap &quot;echo TRAPed signal&quot; HUP INT QUIT TERM# start service in background here/usr/sbin/apachectl startecho &quot;[hit enter key to exit] or run 'docker stop &lt;container&gt;'&quot;read# stop service and clean up hereecho &quot;stopping apache&quot;/usr/sbin/apachectl stopecho &quot;exited $0&quot;If you run this image with docker run -it --rm -p 80:80 --name test apache, you can then examine the container’s processes with docker exec, or docker top, and then ask the script to stop Apache:123456789101112131415161718$ docker exec -it test ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.1 0.0 4448 692 ? Ss+ 00:42 0:00 /bin/sh /run.sh 123 cmd cmd2root 19 0.0 0.2 71304 4440 ? Ss 00:42 0:00 /usr/sbin/apache2 -k startwww-data 20 0.2 0.2 360468 6004 ? Sl 00:42 0:00 /usr/sbin/apache2 -k startwww-data 21 0.2 0.2 360468 6000 ? Sl 00:42 0:00 /usr/sbin/apache2 -k startroot 81 0.0 0.1 15572 2140 ? R+ 00:44 0:00 ps aux$ docker top testPID USER COMMAND10035 root {run.sh} /bin/sh /run.sh 123 cmd cmd210054 root /usr/sbin/apache2 -k start10055 33 /usr/sbin/apache2 -k start10056 33 /usr/sbin/apache2 -k start$ /usr/bin/time docker stop testtestreal 0m 0.27suser 0m 0.03ssys 0m 0.03sMột vài chú ý tương tự RUN Note: The exec form is parsed as a JSON array, which means that you must use double-quotes (“) around words not single-quotes (‘). Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, ENTRYPOINT [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: ENTRYPOINT [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker. Shell form ENTRYPOINT exampleThực thi các lệnh shell Understand how CMD and ENTRYPOINT interactCả CMD và ENTRYPOINT đều được sử dụng để định nghĩa ra các lệnh sẽ được thực thi để chạy container. Tuy nhiên có 1 vài rules kết hợp 2 lệnh này bạn cần biết: Dockerfile nên chỉ có 1 lệnh CMD hoặc ENTRYPOINT ENTRYPOINT nên được xác định khi sử dụng container như là một thực thi. CMD nên được sử dụng như 1 cách định nghĩa các đối số mặc định của 1 ENTRYPOINT hoặc là để thực thi 1 ad-hoc comamnd trong 1 container CMD sẽ bị ghi đè khi chạy container với các đối số thay thế Bảng sau sẽ chỉ ra lệnh được thực thi thực sự cho mỗi sự kết hợp ENTRYPOINT / CMD Chú ý: Nếu CMD được xác định từ 1 base image, setting ENTRYPOINT sẽ reset CMD về 1 giá trị trống. Trong trường hợp này, CMD cần phải được xác định trong current image để có giá trị VOLUMEThe VOLUME instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers Lệnh này để tạo 1 điểm liên kết (mount point) với tên rõ ràng và đánh dấu nó như là nơi lưu trữ volumes được mount ra ngoài từ host lưu trữ hoặc containers khác. Giá trị của nó có thể là mảng JSON VOLUME [&quot;/var/log/&quot;] hoặc plain string với nhiều đối số như VOLUME /var/log or VOLUME /var/log /var/db Lệnh docker run khởi tạo 1 volume được tạo mới với 1 vài dữ liệu đã tồn tại trong location được chỉ định từ base image. Ví dụ:1234FROM ubuntuRUN mkdir /myvolRUN echo &quot;hello world&quot; &gt; /myvol/greetingVOLUME /myvolKết quả Dockerfile trong 1 image khi chạy docker run tạo ra 1 điểm liên kết tại thư mục /myvol và copy greeting file vào trong volumn được tạo mới đó. Notes about specifying volumes Volumes on Windows-based containers: Khi sử dụng Windows-based containers, đích của 1 volumn trong 1 container phải là 1 trong: a non-existing or empty directory a drive other than C: Changing the volume from within the Dockerfile: Nếu 1 vài bước build thay đổi dữ liệu bên trong volumne sau khi nó được khai báo, các thay đổi này sẽ bị loại bỏ(Hiểu là đã VOLUMNE rồi mà lệnh sau trong Dockerfile thay đổi file trong thư mục đó nữa thì không được cập nhật đâu :D =&gt; chưa thử) JSON formatting: Khi sử dụng JSON array bạn phải sử dụng dấu nháy kép “ thay vì nháy đơn ‘ The host directory is declared at container run-timer: Thư mục host (mountpoint) về bản chất, phụ thuộc vào host (host-dependent). Điều này để bảo vệ tính di động của image, vì một thư mục của host không thể đảm bảo rằng nó đã có trên tất cả các hosts. Vì lí do này, bạn không thể mount 1 thư mục host từ trong Dockerfile. Lệnh VOLUME không hỗ trợ việc chỉ định một tham số host-dir. Bạn phải chỉ định mountpoint được bạn tạo ra hoặc khi chạy container (tôi đang hiểu phần này là các thư mục có sẵn của host thì không mount được, ví dụ như không mount thư mục /var từ container ubuntu sang được vì nó thuộc về host, chỉ mount những file, thư mục mình tạo ra thôi :D) USER12USER &lt;user&gt;[:&lt;group&gt;] orUSER &lt;UID&gt;[:&lt;GID&gt;] Lệnh này tạo tập người dùng (hoặc UID) và nhóm người dùng (GID) để sử dụng khi chạy image cho các lệnh RUN, CMD và ENTRYPOINT trong Dockerfile Warning: When the user doesn’t have a primary group then the image (or the next instructions) will be run with the root group. On Windows, the user must be created first if it’s not a built-in account. This can be done with the net user command called as part of a Dockerfile. 12345FROM microsoft/windowsservercore# Create Windows user in the containerRUN net user /add patrick# Set it for subsequent commandsUSER patrick WORKDIR1WORKDIR /path/to/workdir Lệnh này chỉ ra tập các thư mục để làm việc với các lệnh RUN, CMD, ENTRYPOINT, COPY và ADD trong Dockerfile. Nếu WORKDIR không tồn tại, nó sẽ được tạo thậm chí nếu nó không được sử dụng trong 1 các bước của Dockerfile. Lệnh WORKDIR có thể sử dụng nhiều lần trong 1 Dockerfile. Nếu là một đường dẫn tuyệt đối, nó sẽ có liên quan đến đường dẫn của lệnh WORKDIR trước đó Ví dụ:1234WORKDIR /aWORKDIR bWORKDIR cRUN pwdThì lệnh pwd sẽ được thực thi trong thư mục /a/b/c Lệnh WORKDIR có thể phân giải được các biến môi trường sử dụng bởi ENV123ENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAMERUN pwd ARG1ARG &lt;name&gt;[=&lt;default value&gt;] Sử dụng để định nghĩa các biến mà người dùng có thể truyền động khi build với lệnh docker build sử dụng flag –build-arg =. Hoặc có thể sử dụng trong Dockerfile1234FROM busyboxARG user1ARG buildno... Tổng kết FROM chỉ ra chúng ta base image chúng ta sử dụng, LABEL bổ sung các thông tin liên quan đến bản quyền, bổ sung thông tin RUN được sử dụng kết hợp apt-get, thường được sử dụng cài đặt package. Ngoài ra nó cũng được sử dụng chạy các bash hoặc các php, go, python script ENV sử dụng để gán các biến CONST như lập trình, như vậy code của bạn sẽ dễ dàng theo dõi hơn. CMD và ENTRYPOINT được sử dụng để chạy các lệnh bật container của bạn (như bật Apache2, nginx, nodejs …) Một container được tạo ra sẽ độc lập với các container khác. Do đó cần có 1 số tham số để giao tiếp với nhau EXPOSE: mở 1 cổng lắng nghe kết nối ra bên ngoài VOLUME: chia sẻ file, thư mục ra ngoài host hoặc các container khác ADD, COPY: copy thư mục từ host vào container RUN, ENTRYPOINT, CMD có 2 dạng và exec form và shell form. (CMD có thêm 1 dạng nữa chỉ nhận tham số từ ENTRYPOINT). Chúng ta thử xem 2 form này có gì khác biệt nhé: Exec form rộng hơn shell form, trỏ được thư mục nào để thực thi lệnh. Shell form lệnh sẽ chạy trong 1 shell, cái mà được định nghĩa là /bin/sh -c trên Linux hoặc cmd /S /C trên Windows123# Shell formRUN /bin/bash -c 'source $HOME/.bashrc; \\echo $HOME'123456# Exec formFROM debian:stableRUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2EXPOSE 80 443VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;Shell cũng có thể sử dụng từ exec form1RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]Và một note nữa là dùng exec form RUN [ &quot;echo&quot;, &quot;$HOME&quot; ] Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, ENTRYPOINT [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: ENTRYPOINT [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker. Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, CMD [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: CMD [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker. Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, RUN [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: RUN [ “sh”, “-c”, “echo $HOME” ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker. Có 1 sự kết hợp CMD và ENTRYPOINT rất hay nhé (Xem lại ảnh :D). Và trong 1 Dockerfile, chỉ nên có 1 CMD và ENTRYPOINT nhé (note tại Understand how CMD and ENTRYPOINT interact) Một ví dụ Dockerfile cho Apache212345678910111213141516171819202122232425FROM ubuntu:16.04# Note: MAINTAINER đã không còn được sử dụng nữa nhéMAINTAINER James Turnbull &lt;james@example.com&gt;ENV REFRESHED_AT 2016-06-01 RUN apt-get -yqq updateRUN apt-get -yqq install apache2 VOLUME [ &quot;/var/www/html&quot; ]WORKDIR /var/www/html ENV APACHE_RUN_USER www-dataENV APACHE_RUN_GROUP www-dataENV APACHE_LOG_DIR /var/log/apache2ENV APACHE_PID_FILE /var/run/apache2.pidENV APACHE_RUN_DIR /var/run/apache2ENV APACHE_LOCK_DIR /var/lock/apache2 RUN mkdir -p $APACHE_RUN_DIR $APACHE_LOCK_DIR $APACHE_LOG_DIR EXPOSE 80 ENTRYPOINT [ &quot;/usr/sbin/apache2&quot; ]CMD [&quot;-D&quot;, &quot;FOREGROUND&quot;] Tài liệu tham khảo: Dockerfile best paractices Dockerfile reference","link":"/2020/04/12/Docker-Dockerfile-instructions/"},{"title":"[JS] Event","text":"Thái Bình, chiều 30 Tết, trời âm u, se se lạnh … Sự kiện và actions hoặc occurrences (sự kiện) xảy ra trong hệ thống bạn đang lập trình, cái mà hệ thống nói cho bạn biết để bạn có thể response với nó trong 1 vài cách nếu bạn mong muốn. Ví dụ nếu bạn người dùng click 1 button trên trang web, bạn có thể muốn response 1 hành động để hiển thị thông tin gì đó. Mỗi sự kiện khả dụng có 1 event handler, cái là 1 khối code (thường sẽ là JavaScript function do bạn tạo ra) sẽ chạy khi sự kiện kích hoạt. Chú ý rằng đôi khi nó được gọi là event listeners - chúng có thể hoán đổi cho nhau vì mục đích của chúng tôi, mặc dù nói đúng ra, chúng hoạt động cùng nhau. Note: Web events are not part of the core JavaScript language — they are defined as part of the APIs built into the browser. Ways of using web eventsCó 1 vài cách để chúng ta thêm event listener code vào trang web. Trong phần này, chúng ta review 1 vài cách và thảo luận xem chúng ta nên dùng cách nào. Event handler propertiesCÓ rất nhiều properties tồn tại chứa event handler code chúng ta có thể gặp thường xuyên:123456const btn = document.querySelector('button');btn.onclick = function() { const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; document.body.style.backgroundColor = rndCol;}Thuộc tính onclick như trên là một ví dụ, ngoài ra nó còn rất nhiều các thuộc tính khác. btn.onfocus and btn.onblur — The color changes when the button is focused and unfocused; try pressing tab to focus on the button and press tab again to focus away from the button. These are often used to display information about how to fill in form fields when they are focused, or display an error message if a form field has just been filled in with an incorrect value. btn.ondblclick — The color changes only when the button is double-clicked. window.onkeypress, window.onkeydown, window.onkeyup — The color changes when a key is pressed on the keyboard. The keypress event refers to a general press (button down and then up), while keydown and keyup refer to just the key down and key up parts of the keystroke, respectively. Note that it doesn’t work if you try to register this event handler on the button itself — we’ve had to register it on the window object, which represents the entire browser window. btn.onmouseover and btn.onmouseout — The color changes when the mouse pointer is moved so it begins hovering over the button, or when pointer stops hovering over the button and moves off of it, respectively. Có 1 vài sự kiện rất phổ biến và khả dụng cho bất kì element nào (ví dụ onclik handler có thể đăng kí gần như với bất kì element), tuy nhiên có 1 vài thuộc tính đặt biệt chỉ hữu ích với tình huống nhất định (ví dụ onplay chỉ khả dụng với các thẻ nhất định, như &lt;video&gt;) Inline event handlers — don’t use theseBạn cũng có thể thấy mẫu code như thế này trong code của bạn:123456&lt;button onclick=&quot;bgChange()&quot;&gt;Press me&lt;/button&gt;function bgChange() { const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; document.body.style.backgroundColor = rndCol;}Hoặc thêm trực tiếp code JavaScript vào trong thuộc tính như ví dụ:12&lt;button onclick=&quot;alert('Hello, this is my old-fashioned event handler!');&quot;&gt;Press me&lt;/button&gt;Bạn có thể tìm nhiều thuộc tính HTML tương đương cho nhiều event handler properties, tuy nhiên bạn không nên sử dụng nó - nó là một bad practice. Nó thực sự khó để quản lý code và không hiệu quả. Với 1 người bắt đầu, không nên trộn lẫn file HTML với JS của bạn làm 1 vì nó rất khó phân tích cú pháp, để tất cả các file JS của bạn ở 1 chỗ khác sẽ tốt hơn, bạn có thể áp dụng mỗi file JS với nhiều file HTML khác nhau. Kể cả khi để chúng trong 1 file, inline event handlers cũng không phải là 1 ý tưởng tốt. Một button thì OK, nhưng chuyện gì xảy ra nếu có 100 buttons, bạn sẽ phải thêm 100 thuộc tính vào file, lúc đó bảo trì code sẽ trở thành 1 cơn ác mộng. Với JS, bạn có thể thêm 1 hàm event handler với tất cả các button trong trang web không vấn đề bao nhiêu lần bằng cách sử dụng như sau:12345const buttons = document.querySelectorAll('button');for (let i = 0; i &lt; buttons.length; i++) { buttons[i].onclick = bgChange;}Hay một tùy chọn khác sử dụng forEach built-in method có sẵn của NodeList objects:123buttons.forEach(function(button) { button.onclick = bgChange;}); addEventListener() and removeEventListener()Loại mới nhất của chế event được định nghĩa trong đối tượng DOM level 2 cái mà cung cấp trình duyệt với 1 hàm mới addEventListener(). Hàm này là 1 cách tương tự event handler properties nhưng cú pháp có đôi chút khác biệt12345678const btn = document.querySelector('button');function bgChange() { const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; document.body.style.backgroundColor = rndCol;} btn.addEventListener('click', bgChange);Trong hàm addEventListener() function, có 2 tham số, tên sự kiện chúng ta muốn đăng kí và đoạn code bao gồm handler function chúng ta muốn chạy để phản hồi lại sự kiện. Chú ý rằng hoàn toàn có thể đặt toàn bộ code trong hàm addEventListener() như 1 hàm vô danh như sau:1234btn.addEventListener('click', function() { var rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; document.body.style.backgroundColor = rndCol;});Cơ chế này có 1 vài lợi ích so với 2 cơ chế trước đó. Đầu tiên là nó có 1 hàm đối tác removeEventListener() cái mà sẽ xóa listener trước đó đã được thêm. Ví dụ sau sẽ xóa listener được thêm ở trên:1btn.removeEventListener('click', bgChange);Điều này không có ý nghĩa lắm đối với các chương trình nhỏ, nhưng đối với chương trình lớn hơn, phức tạp hơn có có thể cực kì hiệu quả để dọn dẹp event handlers không sử dụng. Ngoài ra, ví dụ, điều này cho phép bạn có cùng một button thực hiện các hành động khác nhau trong các trường hợp khác nhau - tất cả những gì bạn phải làm là thêm hoặc xóa các event handlers. Thứ 2, bạn cũng có thể đăng kí nhiều handlers cho listener giống nhau. Hai handlers dưới đây không thể được áp dụng:12myElement.onclick = functionA;myElement.onclick = functionB;Dòng thứ 2 đã overwrites giá trị onclick được set bởi dòng đầu. Lúc đó bạn cần12myElement.addEventListener('click', functionA);myElement.addEventListener('click', functionB);Khi đó cả 2 hàm đều được thực thi khi element được click. Ngoài ra nó còn nhiều lợi ích khác thông qua các tùy chọn của sự kiện, bạn có thể tìm hiểu thêm tại trang chủ của nó. What mechanism should I use?Trong cả 3 cơ chế, bạn không nên sử dụng HTML event handler attributes, nó đã outdated, và là 1 bad practice như đã đề cập ở trên. Hai cái còn lại tương đối có thể thay thế cho nhau, ít nhất là cho những mục đích đơn giản: Event handler properties ít sức mạnh và tùy chọn hơn nhưng nó lại có khả năng tương thích với trình duyệt (hỗ trợ trình duyệt IE8). Bạn nên bắt đầu với cơ chế này nếu bạn đang học JS. DOM Level 2 Events (addEventListener(), etc.) có nhiều sức mạnh hơn nhưng cũng phức tạp và không phải tương thích với nhiều trình duyệt (hỗ trỡ IE9). Bạn nên sử dụng khi bạn đã có kinh nghiệm. Lợi ích chính của cơ chế thứ 3 là bạn có thể xóa event handler code nếu cần, sử dụng removeEventListener() và thêm nhiều listeners với 1 sự kiện cho element nếu yêu cầu. Ví dụ bạn có thể gọi addEventListener('click', function() {...}) trên 1 element nhiều lần với nhiều hàm khác nhau trong đối số thứ 2. Nó là điều không thể với event handler properties vì một vài việc gán trong các lần tiếp theo sẽ ghi đè lần trước đó, ví dụ:123element.onclick = function1;element.onclick = function2;etc. Note: Nếu bạn được yêu cầu hỗ trợ các trình duyệt cũ hơn Internet Explorer 8 trong công việc của mình, bạn có thể gặp khó khăn, vì các trình duyệt cổ này sử dụng các mô hình sự kiện khác nhau từ các trình duyệt mới hơn. Nhưng không bao giờ sợ hãi, hầu hết các thư viện JavaScript (ví dụ jQuery) đều có các hàm dựng sẵn giúp loại bỏ sự khác biệt giữa các trình duyệt. Đừng lo lắng về điều này quá nhiều ở giai đoạn này trong hành trình học tập của bạn. Other event conceptsEvent objectsĐôi khi chúng ta truyền vào hàm xử lý event một đối tượng với tên đại loại như event, evt hay đơn giản chỉ là e. Nó được gọi là event object và nó tự động truyền vào hàm xử lý sự kiện để thêm các chức năng và thông tin. Ví dụ:1234567function bgChange(e) { const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')'; e.target.style.backgroundColor = rndCol; console.log(e);} btn.addEventListener('click', bgChange);Bạn có thể xem fullcode tại https://github.com/mdn/learning-area/blob/master/javascript/building-blocks/events/random-color-eventobject.html Note: You can use any name you like for the event object — you just need to choose a name that you can then use to reference it inside the event handler function.e/evt/event are most commonly used by developers because they are short and easy to remember. It’s always good to be consistent — with yourself, and with others if possible. Event bubbling and captureChủ đề cuối cùng chúng tôi muốn nói là thứ mà bạn có thể không gặp thường xuyên nhưng nó có thể thực sự gây hoảng loạn cho bạn nếu bạn không hiểu.Event bubbling and capture và 2 cơ chế mô tả cái diễn ra khi 2 hàm xử lý cho 1 sự kiện thông nhau được kích hoạt trong 1 element. Xem ví dụ sau để hiểu nó: Ví dụ cực kì đơn giản shows và hides 1 &lt;div&gt; với &lt;video&gt; bên trong:123456789&lt;button&gt;Display video&lt;/button&gt;&lt;div class=&quot;hidden&quot;&gt; &lt;video&gt; &lt;source src=&quot;rabbit320.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;rabbit320.webm&quot; type=&quot;video/webm&quot;&gt; &lt;p&gt;Your browser doesn't support HTML5 video. Here is a &lt;a href=&quot;rabbit320.mp4&quot;&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt; &lt;/video&gt;&lt;/div&gt;Khi bạn click &lt;button&gt;, video sẽ hiểu thị bằng cách thay đổi thuộc tính class trong &lt;div&gt; từ hidden thành showing:123btn.onclick = function() { videoBox.setAttribute('class', 'showing');}Sau đó có 2 thêm sự kiện onclick event handlers - 1 cho &lt;div&gt; và cái thứ 2 cho &lt;video&gt;. Ý tưởng là khi khu vực &lt;div&gt; ngoài video được click, box này sẽ ẩn lại, còn khi video click, video sẽ bắt đầu chạy:1234567videoBox.onclick = function() { videoBox.setAttribute('class', 'hidden');};video.onclick = function() { video.play();};Nhưng mà lại có 1 vấn đề - hiện tại, khi bạn click video để bắt đầu chạy nhưng nó cũng là&lt;div&gt; bị ẩn đi trong cùng thời điểm. Đó là bởi vì &lt;video&gt; bên trong thẻ &lt;div&gt;, vì vậy khi bạn click video thì thực chất nó chạy cả 2 sự kiện. Bubbling and capturing explainedKhi 1 sự kiện được phát ra từ 1 element, cái mà có parent elements (như ví dụ &lt;video&gt; có thẻ &lt;div&gt; là cha), các browsers hiện đại sẽ chạy 1 giai đoạn khác nhau: the capturing phase and the bubbling phase. In the capturing phase: Trình duyệ kiểm tra nếu tổ tiên bên ngoài gần nhất &lt;html&gt; (outer-most ancestor) có sự kiện onclick được đăng kí trong giai đoạn bắt sự kiện và chạy nó nếu có Sau đó nó di chuyển vào phần tử tiếp theo bên trong &lt;html&gt; và làm tương tự, sau đó tiếp tục cho đến khi nó chạm đến thành phần cái mà thực sự được click vào In the bubbling phase, the exact opposite occurs: Trình duyệt sẽ kiểm tra để xem nếu thành phần thực sự được click có 1 onclick event handler được đăng kí trong giai đoạn sủi bọt, chạy nó nếu có Sau đó nó di chuyển vào các element tổ tiên lập tức và thực hiện tương tự, tiếp tục như vậy cho đến &lt;html&gt; element Trong các browers hiện đại, mặc định tất cả event handlers được đăng kí trong giai đoạn sủi bọt. Bởi vậy trong ví dụ hiện tại, khi bạn click video, sự kiện sủi bọt từ &lt;video&gt; sẽ được hướng ra tới thẻ &lt;html&gt;. Chi tiết sẽ như sau: Nó tìm video.onclick … handler và chạy nó do vậy đầu tiên video sẽ bắt đầu chạy Sau đó tìm kiếm videoBox.onclik… handler và chạy nó, do vậy video sẽ bị ẩn đi Fixing the problem with stopPropagation()Đây là 1 hành vi khó chịu nhưng có 1 cách để fix nó. Đối tượng Event chuẩn có 1 hàm khả dụng là stopPropagation(), khi được gọi trong 1 handlers của event object, handler đầu tiên sẽ chạy nhưng sự kiện không sủi bọt một lần nào nữa, vì vậy không có thêm handlers nào sẽ được chạy:1234video.onclick = function(e) { e.stopPropagation(); video.play();}; Note: Tại sao chúng ta phải quan tâm cả capturing and bubbling? Well, vào 1 ngày tồi tệ, trình duyệt ít các tương thích hợn như chúng ta có bây giờ, Netscape chỉ sử dụng event capturing và Internet Explorer chỉ sử dụng event bubbling. Khi W3C quyết định cố gắng chuẩn hóa hành vi và đạt được sự đồng thuận, họ đã kết thúc với hệ thống này bao gồm cả hai, đó là một trình duyệt hiện đại được triển khai Note: Như đã đề cập ở trên, mặc định tất cả các event handlers được đăng kí trong bubbling phase và điều này làm ý nghĩa hơn cho hầu hết thời gian. Nếu bạn thực sự muốn đăng kí 1 sự kiện trong phase capturing, bạn có thể đăng ký hanlder của bạn bằnh cách sử dụng addEventListener() và setting tùy chọn thứ 3 là true Event delegation: Ủy quyền sự kiệnBubbling cũng cho phép chúng ta tận dụng lợi thế của event delegation - khái niệm này dựa vào 1 thực tế nếu bạn muốn 1 vài đoạn code chạy khi bạn click vào 1 vài số lượng lớn các child elements, bạn có thể set event listener cho cha của chúng và có sự kiện cái mà diễn ra ở chúng nổi bọt hơn cha có thể phải set event listener trong mỗi thẻ con. Nhớ rằng trước đó chúng nó nói bubbling liên quan đến việc kiểm tra element sự kiện được kích hoạt for an event handler first mà moving up to đến element cha của nó? Một ví dụ tốt là có nhiều danh sách items - nếu bạn muốn mỗi chúng hiển thị 1 message khi click, bạn có thể set click event listener trên thẻ cha &lt;ul&gt; và sự kiện sẽ nổi bọt từ mỗi items đến &lt;ul&gt; Even delegation cho phép bạn tránh được thêm sự kiện cho mỗi nodes riêng biệt, thay vào đó event listener được thêm vào 1 thẻ cha. Event listener phân tích từ event được nổi bọt để tìm ra thẻ con. Khái niêm cơ bản khá đơn giản nhưng nhiều người không hiểu cách thức hoạt động của event delegation. Hãy để tôi giải thích nhé Xem đoạn mã UL với 1 vài thẻ con12345678&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt;Bây giờ chúng ta gán sự kiện cho mỗi thẻ con khi được click. Bạn có thể thêm các event listener riêng biệt cho mỗi thẻ LI riêng, nhưng nếu LI thường xuyên được thêm hoặc xóa thì sao? Thêm và xóa event listeners sẽ trở thành 1 cơn ác mộng đặc biệt là khi đoạn code thêm và xóa ở các vị trí khác nhau trong ứng dụng của bạn. Giải pháp tốt để thêm event listener là thêm vào thẻ cha UL. Nhưng nếu bạn thêm vào thẻ cha, làm bạn biết được element nào được click? Đơn giản: khi sự kiện nổi bọt lên cho UL element, bạn sẽ kiểm tra thuộc tính target của đối tượng event để có được 1 tham chiếu đến node được click thực tế. Đây là ví dụ cơ bản JavaScrit minh họa event delagation:123456789// Get the element, add a click listener...document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;, function(e) { // e.target is the clicked element! // If it was a list item if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) { // List item found! Output the ID! console.log(&quot;List item &quot;, e.target.id.replace(&quot;post-&quot;, &quot;&quot;), &quot; was clicked!&quot;); }});Bắt đầu bằng cách thêm 1 click event listener tới thẻ cha. Khi event listener được kích hoạt, kiểm tra event element để chắc chắn nó là loại element đang bắt. Nếu nó là LI element, boom: đúng cái tao cần đây rồi. Nếu không phải element ta cân, sự kiện sẽ bị bỏ qua. Ví dụ cực kì đơn giản -UL và LI sự so sánh thẳng tiến. Hãy thử 1 vài thứ khó hơn. Hãy xem xét thẻ cha DIV có nhiều con nhưng chúng ta chỉ quan tâm 1 nhãn A với class CSS classA:1234567// Get the parent DIV, add click listener...document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,function(e) { // e.target was the clicked element if (e.target &amp;&amp; e.target.matches(&quot;a.classA&quot;)) { console.log(&quot;Anchor element clicked!&quot;); }});Bạn có thể xem Element.matches API tại đây: https://davidwalsh.name/element-matches-selector Vì hầu hết các nhà phát triển sử dụng thư viện JavaScript để xử lý sự kiện và phần tử DOM của họ, tôi khuyên bạn nên sử dụng phương pháp ủy quyền sự kiện của thư viện, vì họ có khả năng xác định ủy nhiệm và phần tử nâng cao. Hi vọng bài viết hữu ích cho bạn về những khái niệm xung quanh ủy quyền sự kiện và các thuận tiện xung quanh sức mạnh của sự ủy quyền này. Tài liệu tham khảo: Các sự kiện cho 1 trang web: Event reference Introduction to events","link":"/2020/01/24/JS-Event/"},{"title":"[JS] Making asynchronous programming easier with async and await","text":"Thái Bình, chiều 30 Tết, trời âm u, se se lạnh … Async/await mới được thêm gần đây, 1 phần của so-callled ECMAScript 2017 JavaScript edition. Chức năng này cải thiện cú pháp của Promises, làm cho code bất đồng bộ dễ dàng viết và đọc hơn. Nó làm cho async code nhìn giống old-school code đồng bộ do đó chúng rất đáng để học. Bài viết này chỉ cho bạn cái bạn cần biết. The basics of async/awaitCó 2 phần để sử dụng async/await trong code của bạn The async keywordCái đầu tiên chúng ta có là từ khóa async, cái mà đặt trước khai báo hàm để tạo một hàm bất đồng bộ. Thử làm quen nào :12function hello() { return &quot;Hello&quot; };hello();Gọi hàm bây giờ sẽ trả về 1 promise. Đây là 1 trong đặc điểm của async functions - nó biến bất kỳ một hàm nào thành 1 promise. Bạn cũng có thể viết async function expression như sau:12let hello = async function() { return &quot;Hello&quot; };hello();Hay arrow functions:1let hello = async () =&gt; { return &quot;Hello&quot; };Đó là tất cả những thứ đơn giản giống nhau. Để thực sự lấy giá trị trả về của 1 promise hoàn thành, vì nó trả về một promise, chúng ta có thể sử dụng khối .then()1hello().then((value) =&gt; console.log(value))Hay thậm chị có thể viết ngắn hơn:1hello().then(console.log)Túm cái váy lại, từ khóa async được thêm vào các hàm để nói rằng chúng trả về 1 promise thay vì trả về trực tiếp kết quả. Thêm vào đó, nó cũng cho phép các hàm đồng bộ tránh được các chi phí phát sinh khi chạy với sự hỗ trợ khi sử dụng await. Bạn chỉ cần thêm từ khóa async khi khai báo, JavaScript có thể tối ưu hóa chương trình của bạn cho bạn. Sweet! The await keywordƯu điểm thực sự của async function trở nên rõ ràng khi bạn kết hợp nó với từ khóa await. Nó có thể được đặt trước 1 vài async promise-based function để dừng code của bạn tại dòng đó cho tới khi promise hoàn tất, sau đó trả về giá trị kết quả. Trong khi đó, các mã khác vẫn được thực thi. Bạn cũng có thể sử dụng await khi gọi 1 vài hàm cái mà trả về Promise trong các web API functions.12345async function hello() { return greeting = await Promise.resolve(&quot;Hello&quot;);};hello().then(alert);Tất nhiên ví dụ trên là vô nghĩa, nó chỉ dùng làm ví dụ minh họa về cú pháp. Rewriting promise code with async/awaitHãy nhìn lại ví dụ từ bài trước về fetch(), chúng ta đã viết theo async functions:1234567891011fetch('coffee.jpg').then(response =&gt; response.blob()).then(myBlob =&gt; { let objectURL = URL.createObjectURL(myBlob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image);}).catch(e =&gt; { console.log('There has been a problem with your fetch operation: ' + e.message);});Nhưng bây giờ bạn nên có 1 thành 1 chuyên gia xử lý promise và có thể áp dụng async/await, viết lại nhìn đơn giản hơn biết bao nhiêu:1234567891011async function myFetch() { let response = await fetch('coffee.jpg'); let myBlob = await response.blob(); let objectURL = URL.createObjectURL(myBlob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image);}myFetch();Đoạn code đã trở nên đơn giản hơn và dễ dàng để hiểu - không có khối .then() nào nữa. Từ khi từ khóa async biến 1 hàm trở thành promise, bạn có thể refactor đoạn code của bạn sử dụng kết hợp promise và await, đưa nửa sau đoạn code của bạn vào trong khối mới linh hoạt hơn.1234567891011async function myFetch() { let response = await fetch('coffee.jpg'); return await response.blob();}myFetch().then((blob) =&gt; { let objectURL = URL.createObjectURL(blob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image);}); But how does it work?Bạn được chú ý rằng chúng ta sẽ nhóm đoạn code bên trong hàm và chúng sẽ khai báo async trước từ khóa function. Điều này thực sự cần thiết, bạn phải tạo ra 1 hàm async cái mà sẽ chạy code bất đồng bộ, await chỉ làm việc trong hàm async functions. Trong hàm myFetch(), bạn có thể thấy đoạn code khá giống với phiên bản promise trước đó, nhưng có 1 số khác biệt. Thay vì cần xâu chuỗi khối .then() cuối mỗi phương thức promise, bạn chỉ cần thêm 1 từ khóa await trước phương thức được gọi và sau đó gán kết quả vào 1 biến. Từ khóa await sẽ làm đoạn code của bạn dừng lại ở dòng đó, cho phép các đoạn code khác thực thi trong lúc đó, cho đến khi async function đã trả về kết quả của nó. Một khi điều này hoàn tất, code của bạn tiếp túc thực thi dùng tiếp theo. Ví dụ1let response = await fetch('coffee.jpg');Response sẽ được trả về khi hoàn tất fetch() promise và được gán cho biến response khi đã phản hồi và trình phân tích cú pháp tạm dừng trên dòng này cho đến khi điều đó xảy ra. Một khi đã phản hồi, trình phân tích sẽ di chuyển tới dòng tiếp theo, cái mà sẽ tạo Blob. Dòng này cũng gọi đến async promise-based method, vì chúng ta sử dụng await ở đây là đúng. Khi kết quả của toán tử trả về, chúng ta sẽ trả nó ra ngoài hàm myFetch(). Điều đó có nghĩa là khi chúng ta gọi hàm myFetch(), nó sẽ trả về 1 promise, do đó chúng ta cần 1 chuỗi .then() sau đó để hiện thị blod ra màn hình. Bạn có thể đã nghĩ “this is really cool!” và bạn đã đúng - ít khối .then() hơn bọc code của bạn và nó nhìn cũng như code đồng bộ và trực quan hơn. Adding error handlingNếu bạn muốn thêm 1 xử lý lỗi, sẽ có 1 vài tùy chọn cho bạn. Bạn có thể sử dụng khối try/catch với async/await123456789101112131415async function myFetch() { try { let response = await fetch('coffee.jpg'); let myBlob = await response.blob(); let objectURL = URL.createObjectURL(myBlob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image); } catch(e) { console.log(e); }}myFetch();Khối catch truyền vào 1 error object, cái mà chúng ta gọi là e, hiện tại chỉ hiển thị ra, bạn có thể xử lý khác Nếu bạn muốn sử dụng cách thứ 2 (đã refactor), bạn có thể sử dụng khối .catch() cuối cùng khối .then()1234567891011121314async function myFetch() { let response = await fetch('coffee.jpg'); return await response.blob();}myFetch().then((blob) =&gt; { let objectURL = URL.createObjectURL(blob); let image = document.createElement('img'); image.src = objectURL; document.body.appendChild(image);}).catch((e) =&gt; console.log(e));Bạn có thể xem cả 2 ví dụ này tạisimple-fetch-async-await-try-catch.html (see source code) vàsimple-fetch-async-await-promise-catch.html (see source code) Awaiting a Promise.all()async/await là built on top of promise, bởi vậy nó tương thích với tất cả các tính năng của Promises. Chức năng này bao gồm Promise.all() - bạn có thể khá hạnh phúc khi await 1 Promise.all() lấy tất cả kết quả được trả về vào 1 biến, code giống như đồng bộ1234567891011121314151617181920212223242526272829303132333435363738394041async function fetchAndDecode(url, type) { let response = await fetch(url); let content; if(type === 'blob') { content = await response.blob(); } else if(type === 'text') { content = await response.text(); } return content;}async function displayContent() { let coffee = fetchAndDecode('coffee.jpg', 'blob'); let tea = fetchAndDecode('tea.jpg', 'blob'); let description = fetchAndDecode('description.txt', 'text'); let values = await Promise.all([coffee, tea, description]); let objectURL1 = URL.createObjectURL(values[0]); let objectURL2 = URL.createObjectURL(values[1]); let descText = values[2]; let image1 = document.createElement('img'); let image2 = document.createElement('img'); image1.src = objectURL1; image2.src = objectURL2; document.body.appendChild(image1); document.body.appendChild(image2); let para = document.createElement('p'); para.textContent = descText; document.body.appendChild(para);}displayContent().catch((e) =&gt; console.log(e));Bạn có thể thấy rằng fetchAnDecode() function đã được chuyển thành async function và dòng1let values = await Promise.all([coffee, tea, description]);Bằng cách sử dụng await, chúng ta có thể nhận tất cả kết quả trả về của 3 promises trong mảng values khi mà tất cả chúng đều có giá trị, cách này nhìn rất giống code đồng bộ. Chúng ta có thể bọc tất cả code trong bất đồng bộ displayContent() làm code trở nên dễ đọc hơn rất nhiều. Để xử lý error, chúng ta có khối .catch() trong displayContent(), khối này sẽ xử lý các lỗi xuất hiện ở cả 2 functions Note: Bạn cũng có thể sử dụng khối finally với async function to show a final report on how the operation went The downsides of async/await: Nhược điểm của async/awaitAsync/await thực sự hữu ích như chúng ta đã biết, nhưng nó vẫn có 1 vài nhược điểm. Async/await làm code của bạn nhìn như đồng bộ và trong 1 vài cách nó làm cho code đồng bộ hơn. Khối từ khóa await thực thi tất cả code đến khi promise hoàn tất chính xác như nó sẽ làm với một hoạt động đồng bộ. Nó cũng cho phép các tasks khác tiếp tục chạy trong lúc đó nhưng code của bạn thì bị chặn. Điều đó có nghĩa code của bạn sẽ chậm hơn bởi 1 số lượng đáng kể các promise đang đợi ngay sau đó. Mỗi await sẽ chờ promise trước đó kết thúc, trong khi thực tế cái mà bạn muốn là các promises sẽ xử lý đồng thời. Có một cách hữu hiệu có thể xử lý vấn đề này - đặt tất cả các quá trình xử promise trong một Promise objects, gán nó vào biến và sau đó await tất cả chúng sau. Bạn có thể xem 2 ví dụ sau để thấy sự khác biệt, cùng phần tích nhé. Cả 2 đều bắt đầu với 1 custom promise function cái mà xử lý bất đồng bộ với setTimeout():1234567function timeoutPromise(interval) { return new Promise((resolve, reject) =&gt; { setTimeout(function(){ resolve(&quot;done&quot;); }, interval); });};Sau đó hàm async timeTest() sẽ chờ 3 timeoutPromise():123async function timeTest() { ...}Sau mỗi lần sẽ đo thời gian thực thi của timeTest() promise và in kết quả ra:123456let startTime = Date.now();timeTest().then(() =&gt; { let finishTime = Date.now(); let timeTaken = finishTime - startTime; alert(&quot;Time taken in milliseconds: &quot; + timeTaken);})Bây giờ chúng ta sẽ có timeTest() cho mỗi trường hợp. Trong ví dụ slow-async-await.html, timeTest() nhìn như sau:12345async function timeTest() { await timeoutPromise(3000); await timeoutPromise(3000); await timeoutPromise(3000);}Đây là việc sử dụng await đơn giản cho 3 lời gọi timeoutPromise() trực tiếp, mối cái mất 3s, cái sau chờ cái trước chạy xong như vậy sẽ mất 9s. Hơi tù nhỉ, nhưng trong fast-async-await.html, timeTest() sẽ như sau:123456789async function timeTest() { const timeoutPromise1 = timeoutPromise(3000); const timeoutPromise2 = timeoutPromise(3000); const timeoutPromise3 = timeoutPromise(3000); await timeoutPromise1; await timeoutPromise2; await timeoutPromise3;}Bây giờ chúng ta lưu 3 Promise objects vào biến, có tác dụng thiết lập các tiến trình liên quan của chúng, tất cả chạy đồng thời. Tiếp theo chúng ta chờ đợi kết quả, bởi vì các promises bắt đầu quá trình thời gian giống nhau, tất cả sẽ kết thúc cùng 1 lúc và khi bạn chạy ví dụ thứ 2 này, bạn sẽ thấy chỉ mất 3s! Hãy nhớ điều này nhé, vì nó ảnh hưởng đến hiệu suất đó :D Còn 1 sự bất tiện nữa là bạn phải bọc await 1 promises bên trong một hàm async. Async/await class methodsPhần chú ý cuối cùng trước khi chúng ta sang chủ đề mới là bạn có thể thêm async vào class/objetcs methods để làm cho chúng trả về promise sau đó await các promise bên trong chúng123456789101112131415161718192021class Person { constructor(first, last, age, gender, interests) { this.name = { first, last }; this.age = age; this.gender = gender; this.interests = interests; } async greeting() { return await Promise.resolve(`Hi! I'm ${this.name.first}`); }; farewell() { console.log(`${this.name.first} has left the building. Bye for now!`); };}let han = new Person('Han', 'Solo', 25, 'male', ['Smuggling']);Sau đó có thể sử dụng như sau:1han.greeting().then(console.log); Browser supportBạn hãy cân nhắc khi quyết định sử dụng async/await hỗ trợ các trình duyệt cũ. Chúng chỉ khả dụng với các phiên bản trình duyệt mới, như promise, có thể không hỗ trợ với Internet Explorer và Opera Mini. Nếu bạn muốn sử dụng async/await trên các trình duyệt cũ, hãy xem xét sử dụng BabelJS library, cái mà cho phép bạn viết ứng dụng với kỹ thuật JavaScript mới nhất và để Babel tìm ra những thay đổi cần thiết của trình duyệt của bạn. Khi gặp một trình duyệt không hỗ trợ async / await, polyfill của Babel có thể tự động cung cấp các dự phòng hoạt động trong các trình duyệt cũ hơn. Tổng kết: async/await là cú pháp refactor cho các Promise, rất hữu ích. Nó làm code cho bạn dễ đọc, như luồng đồng bộ, loại bỏ các khối .then(). Khi gặp await keywork, code của bạn sẽ dừng ở đó, các task khác (code ngoài khối asyn/await này) vẫn chạy. Khi nào hàm async đang await trả về kết quả, code bên trong khối async này sẽ chạy dòng tiếp theo. The await keyword blocks execution of all the code that follows until the promise fulfills, exactly as it would with a synchronous operation. It does allow other tasks to continue to run in the meantime, but your own code is blocked. The await keyword causes the JavaScript runtime to pause your code on this line, allowing other code to execute in the meantime, until the async function call has returned its result. Once that’s complete, your code continues to execute starting on the next line Có một cách khắc phục nhược điểm chờ đợi của async rất hay đó là gán các async function vào các biến và chờ chúng sau đó. Nhắc lại Promise chạy như thế này ở bài trước để hiểu về async/await chạy nhé, vì async/await thực chất là Promise mà: Promise được đặt trong hàng đợi sự kiện và xử lý khi luồng chính đã kết thúc để tránh block luồng chính (JS ngôn ngữ đơn luồng nhé). Tài liệu tham khảoMaking asynchronous programming easier with async and await","link":"/2020/01/24/JS-Making-asynchronous-programming-easier-with-async-and-await/"},{"title":"[Laravel] Event vs Notification","text":"Có hai khái niệm mọi người hay lúng túng khi sử dụng, đó là sự kiện (Event) và thông báo (Notification). Hai khái niệm này khá tương đồng, nó được sử dụng để quảng bá (broadcast) một thông điệp gì đó từ server đến cho người dùng. Đôi khi trong ứng dụng của bạn, bạn có thể áp dụng cái này thay cho cái kia, và tất nhiên ứng dụng vẫn hoạt động bình thường. Tuy nhiên để cho đúng ngữ nghĩa, tôi xin so sánh qua về sự khác nhau của 2 khái niệm này và các áp dụng nó trong Laravel. Sự kiện (Event)Sự kiện theo mình hiểu là một điều gì đó xảy ra trong hệ thống và cần có các phản ứng lại (lắng nghe) sự kiện đó. Khái niệm này không chỉ với Laravel, nó rộng hơn là với cả JavaScript, bên JS có lẽ còn sử dụng nhiều hơn, các listener thường được truyền dưới dạng callback. Trong cuộc sống hằng ngày chúng ta cũng có rất nhiều sự kiện: ví dụ như khi bạn mua hàng, bạn đã đặt hàng xong, đó sẽ là 1 sự kiện với cửa hàng, họ cần lắng nghe sự kiện này sau đó thực hiện các nhiệm vụ ghi hóa đơn, gửi thông báo mua hàng cho bạn qua email, thực hiện thanh toán. Như vậy rất rõ ràng, 1 sự kiện sẽ bao gồm 2 phần chính: Đăng ký sự kiện và Lắng nghe - khi sự kiện xảy ra thì xử lý như thế nào. Laravel sử dụng sự kiện như thế nàoĐầu tiên để đăng kí sự kiện trong Laravel, bạn sử dụng lệnh artisan để tạo:1php artisan make:event EventNameBạn có để ý 1 chú ý nhỏ trên docs và các bài hướng dẫn Laravel, EventName thường sẽ ở dạng quá khứ, ví dụ như: sản phẩm đã được mua, bài viết đã được click, người dùng đã đăng kí tài khoản …Do đó đây cũng là lưu ý nhỏ khi bạn đặt tên các sự kiện. Một vài ví dụ về tên sự kiện bạn có thể gặp: ProductPurchased OrderShipped UserRegistered Khi đã đăng kí sự kiện rồi, công việc tiếp theo là đăng kí Listenner để xử lý khi sự kiện xảy ra:1php artisan make:listener ListenerNameLại một chú ý nữa, tên của listener thì vẫn như các phương thức bình thường =)). Một vài tên listener bạn có thể tham khảo: SendEmailVerificationNotification AwardAchievements SendShipmentNotification Tiếp theo chúng ta cần đăng kí event với listener. Như vậy chúng ta đã có Event và Listener, tuy nhiên chúng đang tồn tại độc lập mà không có sự liên kết. Để liên kết chúng lại với nhau, chúng ta sẽ đăng kí trong file App\\Providers\\EventServiceProvider. Một sự kiện có thể được đăng kí nhiều listener là một listener cũng có thể thuộc nhiều event, nhưng trường hợp này có lẽ hiếm:123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Providers;use App\\Events\\ProductPurchased;use App\\Listeners\\AwardAchievements;use Illuminate\\Auth\\Events\\Registered;use Illuminate\\Auth\\Listeners\\SendEmailVerificationNotification;use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;use Illuminate\\Support\\Facades\\Event;class EventServiceProvider extends ServiceProvider{ /** * The event listener mappings for the application. * * @var array */ protected $listen = [ Registered::class =&gt; [ SendEmailVerificationNotification::class, ], ProductPurchased::class =&gt; [ AwardAchievements::class, ], ]; /** * Register any events for your application. * * @return void */ public function boot() { parent::boot(); // }} Một vài thông tin khác về sự kiện trong Laravel1. Sự kiện này có thể được đăng kí bằng cách khác. Bạn đăng kí tên event, listener class vào luôn file EventServiceProvider rồi sau đó sinh sự kiện bằng:1php artisan event:generateHãy sử dụng cả namespace file đó để tạo file đúng như dự kiến nhé.12use App\\Events\\ProductPurchased;use App\\Listeners\\AwardAchievements;Vì nếu không có use này nó sẽ tạo luôn ở thư mục với EventServiceProvider. 2. Laravel có thể tự tìm kiếm được sự kiện và listener Bạn không cần đăng kí vào $listen trong file EventServiceProvider (không khuyến khích cách này vì khó theo dõi sự kiện)Để làm việc này, bạn hãy sử dụng thêm phương thức trong EventServiceProvider123456789/** * Determine if events and listeners should be automatically discovered. * * @return bool */public function shouldDiscoverEvents(){ return true;}3. Các Event trong Laravel hoàn toàn có thể đẩy vào hàng đợi giúp tăng tốc độ xử lý (ví dụ như thao tác gửi mail có thể mất nhiều thời gian) 4. Dispatching Events Để phát ra sự kiện, có thể sử dụng phương thức dispatch() của event. Tuy nhiên để cú pháp đơn giản, bạn sử dụng luôn helper event cho tiện :D12ProductPurchased::dispatch('toy');event(new ProductPurchased('toy'));5. Xem danh sách các sự kiện và listener tương ứng1php aritsan event:listNgoài ra còn có các lệnh sau liên quan đến event:12345event event:cache Discover and cache the application's events and listeners event:clear Clear all cached events and listeners event:generate Generate the missing events and listeners based on registration event:list List the application's events and listeners6. Event Subscribers Event Subscribers sử dụng để theo dõi các sự kiện trong chính các class đó, cho phép bạn định nghĩa các event handlers trong 1 lớp đơn. Phần này bạn hiểu là không cần sử dụng nhiều listener cho mỗi sự kiện mà sử dụng nó thành 1 lớp đơn … Tạo Event Subscribers12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Listeners;class OrderEventSubscriber{ /** * Handle user buy a product. */ public function handleBuyProduct($event) {} /** * Handle order are shipped. */ public function handleSendOrderEmail($event) {} /** * Register the listeners for the subscriber. * * @param \\Illuminate\\Events\\Dispatcher $events */ public function subscribe($events) { $events-&gt;listen( 'App\\Events\\ProductPurchased', 'App\\Listeners\\UserEventSubscriber@handleBuyProduct' ); $events-&gt;listen( 'App\\Events\\OrderShipped', 'App\\Listeners\\UserEventSubscriber@handleSendOrderEmail' ); }} Đăng kí Event Subscribers Sử dụng biến $subscribers nhé:1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Providers;use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;class EventServiceProvider extends ServiceProvider{ /** * The event listener mappings for the application. * * @var array */ protected $listen = [ // ]; /** * The subscriber classes to register. * * @var array */ protected $subscribe = [ 'App\\Listeners\\OrderEventSubscriber', ];}Phần này được sử dụng khi mà các tập sự kiện có liên quan đến nhau, như vậy sẽ tiện theo dõi hơn. Như ví dụ ở trên, người ta nhóm các tập sự kiện liên quan đến đơn hàng vào 1 listener duy nhất :D Tổng kết về sự kiện Như vậy 1 sự kiện có 2 phần: Đăng kí event (thư mục App\\Events) và Xử lý sự kiện dưới dạng Listener (App\\Listeners). Sự kiện có thể đẩy vào hàng đợi. Laravel có cung cấp chức năng discover events. Khi có 1 tập sự kiện liên quan mà không muốn chia nhỏ Listener (Ví dụ như authentication, xử lý đơn hàng), bạn có thể nhóm chngs lại với Event Subscribers tạo 1 listener duy nhất). NotificationHãy trở lại bài toán mua hàng ở bên trên. Khi mà một người dùng mua hàng, chúng ta tạo ra một thông báo. Thông báo này có nhiệm vụ gửi một tin nhắn đến cho người dùng, tin nhắn này có thể là SMS/Slack-messgae/Email hoặc một thông báo lên web như facebook. Chúng ta chọn thông báo vì chúng ta muốn gửi một “message” giống nhau thông qua nhiều channel. Khoan hãy so sánh về sự kiện và thông báo, hãy cùng xem Laravel thực hiện nó như thế nào Tạo một thông báoĐể tạo 1 thông báo trong Laravel, khá đơn giản, bạn sử dụng lệnh artisan 1php artisan make:notification InvoicePaid Mặc định, class Notification này sẽ có 1 phương thức cho 2 channel để gửi thông báo là email và database. Về cách sử dụng của các channel này mình sẽ đề cập trong phần sau Gửi thông báoThông báo có thể gửi bằng 2 cách: sử dụng phương thức notify của trait Notifiable hoặc sử dụng Notification facade:123use App\\Notifications\\InvoicePaid;$user-&gt;notify(new InvoiceaymentPaid($invoice));Hoặc1Notification::send(request()-&gt;user(), new InvoiceaymentPaid()); Một vài thông tin khác về notification trong Laravel1. Bạn có thể chọn kênh gửi, một hoặc nhiều Nó phụ thuộc vào biến $notification thông qua phương thức via. Có thể thêm điều kiện nha :D12345678910/** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */public function via($notifiable){ return $notifiable-&gt;prefers_sms ? ['nexmo'] : ['mail', 'database'];}2. Queueing Notifications Cũng giống như sự kiện, bạn hoàn toàn có thể đặt thông báo của mình vào queue để tăng tốc độ xử lý 3. Gửi thông báo theo yêu cầu Đôi khi bạn cần gửi thông báo tới 1 vài người không được lưu trữ như là 1 “user” trong ứng dụng của bạn. Hãy sử dụng phương thức Notification::route, bạn có thể chỉ định được người nhận thông báo:123Notification::route('mail', 'taylor@example.com') -&gt;route('nexmo', '5555555555') -&gt;notify(new InvoicePaid($invoice)); Kênh chuyển tiếp thông tinLaravel cung cấp cho bạn rất nhiều các channel cho phép bạn chuyển tiếp thông báo tới người dùng. Trong phạm vi bài viết, mình giới thiệu 2 kênh cơ bản là Database và Email, các channel.Tất cả các channel để gửi thông báo bạn chỉ cần thực hiện 2 việc: đầu tiên, khai báo channel bạn muốn sử dụng đó vào phương thức via và sau đó sử dụng phương thức tương ứng trong class Notification để xử lý các gửi mail hoặc nội dung thông báo. Mail NotificationsĐể sử dụng gửi thông báo qua email, bạn đăng kí nó trong via trước (cái này mặc định laravel đã sử dụng)1234public function via($notifiable){ return ['mail'];}Sau đó thực hiện gửi mai như thế nào, gửi tới ai và nội dung gì, bạn hoàn toàn thực hiện trong phương thức toMail của lớp Notification:12345678910111213141516/** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */public function toMail($notifiable){ $url = url('/invoice/'.$this-&gt;invoice-&gt;id); return (new MailMessage) -&gt;greeting('Hello!') -&gt;line('One of your invoices has been paid!') -&gt;action('View Invoice', $url) -&gt;line('Thank you for using our application!');}Bạn hoàn toàn có thể tùy biến việc gửi mail này như chọn template, xử lý lỗi, chọn người gửi, người nhận, xử lý queue. Chi tiết có thể xem tại trang chủ. Database NotificationsPhần này mình cũng thấy khá hay. Database channel sẽ lưu trữ thông tin thông báo vào database. Bảng này sẽ chưa các thông tin như loại thông báo cũng như dữ liệu dạng JSON tùy chỉnh mô tả cho thông báo. Đầu tiên bạn tạo bảng và migrate dữ liệu123php artisan notifications:tablephp artisan migrateBảng notification sẽ có những trường cơ bản sau: id: khóa type: Tham chiếu tới Notification class. Bạn có thể check type này để hiển thị thông báo phù hợp. Như ví dụ trên trường này sẽ là App\\Notifications\\PaymentReceived notifiable_type: Class nào phát ra thông báo. Ví dụ thường là user: App\\User notifiable_id: id của notifiable_type data: dữ liệu dạng JSON về các thông tin của thông báo. Ví dụ 1234{ &quot;amount&quot;: 90, &quot;customer_name&quot;: &quot;Ming&quot;} Từ data này bạn có thể tạo ra các nội dung thông báo phù hợp. read_at: trường này để xác định thông báo đã được đọc lúc nào, tất nhiên mặc định nó sẽ là null. Các thông báo chưa đọc hay đã đọc sẽ được load dựa vào trường này. created_at, updated_at: lưu tời gian và update thông báo Đăng kí channel trong phương thức via 1234public function via($notifiable){ return ['mail', 'database'];} Format thông báo dựa vào 2 phương thức toDatabase và toArray. Các phương thức này sẽ nhận vào $notifiable và sẽ trả về dạng mảng. Kết quả mảng trả về sẽ được encoded như JSON được lưu trữ trong cột data của bảng notifications:12345678910111213/** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */public function toArray($notifiable){ return [ 'invoice_id' =&gt; $this-&gt;invoice-&gt;id, 'amount' =&gt; $this-&gt;invoice-&gt;amount, ];} toDatabase Vs. toArray The toArray method is also used by the broadcast channel to determine which data to broadcast to your JavaScript client. If you would like to have two different array representations for the database and broadcast channels, you should define a toDatabase method instead of a toArray method. Lấy dữ liệu thông báo Một vài phương thức lấy dữ liệu thông báo: Lấy hết12345$user = App\\User::find(1);foreach ($user-&gt;notifications as $notification) { echo $notification-&gt;type;}Lấy các thông báo chưa đọc12345$user = App\\User::find(1);foreach ($user-&gt;unreadNotifications as $notification) { echo $notification-&gt;type;}Đánh dấu đã đọc thông báo12345$user = App\\User::find(1);foreach ($user-&gt;unreadNotifications as $notification) { $notification-&gt;markAsRead();}Hoặc1$user-&gt;unreadNotifications-&gt;markAsRead();Xóa thông báo1$user-&gt;notifications()-&gt;delete();Ngoài ra Laravel còn cung cấp các channel khác giúp bạn gửi thông báo tiện dụng SMS Notifications: Gửi thông báo qua tin nhắn SMS. Bạn có thể tham khảo thêm tại: https://laravel.com/docs/5.8/notifications#sending-notifications và https://laracasts.com/series/laravel-6-from-scratch/episodes/48 Slack Notifications: Gửi thông báo qua hệ thống chat Slack. Broadcast Notifications: Quảng bá thông báo với Pusher và Laravel Echo. Tổng kết về thông báo Thông báo có thể được xem là cách thức gửi 1 thông điệp đến người dùng bằng nhiều kênh khác nhau. Hoặc nó cũng là gửi 1 thông điệp giống nhau đến nhiều người dùng khác nhau. Chọn kênh gửi qua phương thức via, format nội dung và thực hiện gửi thông qua các phương thức toArray, toMail,… tương ứng Thông báo hoàn toàn có thể đặt vào hàng đợi để tránh block ứng dụng. Laravel cung cấp đầy đủ các hàm cho thông báo: lấy tất cả thông báo, lấy các thông báo đã đọc, chưa đọc, hay các hàm đọc thông báo, đánh dấu chưa đọc, xóa :D Tản mạn về sự kiện vs thông báoChúng ta có thể thấy rằng, khi đặt xong 1 đơn hàng, server cần gửi 1 email về thông tin đơn hàng đến cho client, và lúc này chúng ta dùng event hay notification để thực hiện đều được. Tuy nhiên để cho đúng ngữ nghĩa, tôi nghĩ chúng ta nên sử dụng thông báo. Sự kiện nên được sử dụng khi chúng ta cần làm 1 số việc gì đó khi điều kiện cho trước xảy ra và các công việc phản ứng lại sự kiện này PHẢI được thực hiện trong luồng làm việc, ví dụ Sự kiện gửi email kích hoạt khi người dùng đăng kí Sự kiện cập nhật lượng view bài viết khi 1 bài viết được click vào … (trong các ví dụ trên, sự kiện mà không thực hiện thì sai logic). Sự kiện thường là các thao tác database, đôi khi là gửi email Thông báo thì khác, nó nên được sử dụng để ghi lại cái đã xảy ra, ví dụ như: 1 ai đó đã thích ảnh của bạn =&gt; ghi lại hành động này thông báo tới client, 1 hàng động đặt hàng của bạn vừa hoàn tất =&gt; ghi lại việc đặt hàng và gửi tới cho client qua email, SMS, không cần user xác nhận gì mà chỉ xem lại nếu muốn =)) Như vậy thông báo chỉ là bổ sung chức năng cho ứng dụng, không cần phản hồi từ người dùng. Thông báo là 1 cách tốt để gửi 1 thông điệp qua nhiều kênh hoặc gửi 1 thông điệp tới nhiều người dùng khác nhau. Cái này chỉ là tự bản thân mình thấy thôi, tùy vào ứng dụng mà bạn chọn event hay notification cho hợp lý nhé. Tất nhiên cũng đừng sử dụng event kiểu như sau khi đơn hàng được tạo thì tạo chuỗi event: gửi email tới client, gửi SMS tới client thì cũng hơi kì :D Tài liệu tham khảo Notifications Laravel Events Laravel Laracast Laravel Broadcasting: Notification vs Event - StackOverFlow","link":"/2020/04/02/Laravel-Event-Notification/"},{"title":"React with redux-saga Testing","text":"Testing ứng dụng của bạn là một phần quan trọng đối với sự phát triển phần mềm chuyên nghiệp. Có 1 vài thứ bạn nên test. Một vài kỹ thuật được sử dụng để test tôi xin giới thiệu khi test ứng dụng react kết hợp redux, saga là Unit Testing, Snapshot Testing, Shallow rendering.Note: Framework sử dụng demo Ứng dụng React kết hợp redux-saga: Để cho đơn giản, tôi sử dụng React Boilerplate để demo vì nó đã được setup một ứng dụng đầy đủ với các kỹ thuật đã kể trên. Framework test: JEST kết hợp Sinon Trước tiên chúng ta liệt kê qua một số thành phần cần test có trong ứng dụng React, redux-saga: Action. Reducer: Nơi tiếp nhận action và xử lý. Saga: middleware. React component. Các kỹ thuật testingUnit testingUnit testing là 1 thực hành việc test với đơn vị nhỏ nhất có thể trong code và các hàm của chúng ta. Chúng ta chạy các test và kiểm tra tự động các hàm của chúng ta làm việc có đúng như chúng ta mong đợi chúng làm. Chúng ta assert (yêu cầu, đòi hỏi) rằng gửi 1 tập đầu vào và hàm của chúng ta trả về các giá trị phù hợp và xử lý các vấn đề. Boilerplate đã hỗ trợ sẵn Jest test framework để chạy test và tạo xác sự xác nhận. Thư viện làm cho chúng ta viết test đơn giản như các lời nói: bạn mô tả (describe) 1 đơn vị trong code của bạn và mong đợi (expect) nó (it) làm việc gì đó đúng: 123456789describe('add()', () =&gt; { it('adds two numbers', () =&gt; { expect(add(2, 3)).toEqual(5); }); it(&quot;doesn't add the third number&quot;, () =&gt; { expect(add(2, 3, 5)).toEqual(add(2, 3)); });}); Snapshot TestingĐây là một kỹ thuật rất hữu ích được JEST hỗ trợ để test bất cứ khi nào bạn muốn đảm bảo rằng giao diện người dùng (UI) của bạn không có các thay đổi bất ngờ. Ý tưởng của kỹ thuật này là với mỗi test case, bạn sẽ renders các component, ghi nhận lại 1 snapshot và so sánh nó với snapshot đã được lưu lại từ trước với cùng test case đó. Test không thành công nếu 2 snapshot không khớp nhau. Tuy nhiên trong trường hợp 2 snapshot không khớp nhau, nếu bạn thấy sự thay đổi đó là đúng như cái bạn dự kiến (không bất ngờ) thì bạn có thể cập nhật snapshot, chạy lại để test case trở thành đúng là cập nhật phiên bản snapshot này cho các lần test sau đó :D Kỹ thuật này không chỉ được sử dụng để test UI, nó có thể được sử dụng để test saga, lưu các trạng thái của action, chúng ta sẽ xem xét nó chi tiết trong phần Saga Testing. Shallow renderingKỹ thuật này tạm dịch là render “nông”. Khi bạn chỉ muốn viết unit test cho React, kỹ thuật này có thể hữu ích. Kỹ thuật cho phép bạn kết xuất một thành phần sâu ở một cấp độ (“one level deep”) và xác nhận giá trị trả về từ phương thức render của nó trả về mà không phải lo lắng về các hành vi của các thành phần con không được khởi tạo hoặc hiển thị. Điều này có nghĩa, nó không yêu cầu DOM. Kỹ thuật này có thể được coi là unit test cho các component của React (chỉ quan tâm kết quả trả về hàm render, không quan tâm các hành vi và thẻ con). Tuy nhiên đó cũng chính là điểm yếu của nó Vì không render ra DOM nên nó không thể test được các hành vi với các component (click, change …) Bạn phải thực hiện test thủ công với từng commponent Kỹ thuật này cá nhân mình thấy ít được sử dụng. Để test các component trong React, kỹ thuật snapshot testing với sự giúp đỡ của 1 vài thư viện có vẻ hữu ích hơn. Action, reducer testingReducerVới reducer bạn có thể sử dụng unit test hoặc snapshot để test. Unit test được sử dụng nếu state ít thay đổi (để tránh cập nhập code liên tục), nếu không, hãy cân nhắc sử dụng snapshot testing. Ví dụ khi test init state reducer: 123456789describe('NavBarReducer', () =&gt; { it('returns the initial state', () =&gt; { expect(NavBarReducer(undefined, {})).toEqual({ open: false, }); }); it('handles the toggleNav action', () =&gt; {});}); Với init state là: 123{ open: false,} Tuy nhiên phương pháp test này có 1 điểm yếu là khi có 1 ai đó thay đổi init state =&gt; bạn phải thay đổi code??Thay vào đó có thể sử dụng snapshot, khi ai đó thay đổi init state =&gt; báo lỗi change snapshot. Từ đó bạn có thể so sánh để cập nhật snapshot khi test mà không phải cập nhật code 1234567describe('NavBarReducer', () =&gt; { it('returns the initial state', () =&gt; { expect(NavBarReducer(undefined, {})).toMatchSnapshot(); }); it('handles the toggleNav action', () =&gt; {});}); ActionsMột Redux action là 1 các hàm thuần túy vì vậy không khó để test nó, sử dụng unit test, truyền input và expect output thôi :D 12345it('should return the correct constant', () =&gt; { expect(toggleNav()).toEqual({ type: TOGGLE_NAV, });}); Saga TestingCó 2 cách chính để test Sagas: test hàm generator từng bước một hoặc chạy full saga và kiểm tra các effects được tạo ra từ saga Testing the Saga Generator FunctionĐể test từng bước một các hàm generator bạn có thể sử dụng hàm next().value để lấy ra các giá trị trả về từ yield, sau đó kết hợp kỹ thuật snapshot hoặc các kết quả trả về đó để so sánh với kết quả mong đợi.Chúng ta cùng xem xét ví dụ về saga sau: 12345678910111213141516/** * Github repos request/response handler */export function* getRepos() { // Select username from store const username = yield select(makeSelectUsername()); const requestURL = `https://api.github.com/users/${username}/repos?type=all&amp;sort=updated`; try { // Call our request helper (see 'utils/request') const repos = yield call(request, requestURL); yield put(reposLoaded(repos, username)); } catch (err) { yield put(repoLoadingError(err)); }} Chúng ta sẽ dùng next().value để lấy ra các giá trị từ yield và so sánh với kết quả ta mong muốn: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Tests for HomePage sagas */import { put, takeLatest } from 'redux-saga/effects';import { LOAD_REPOS } from 'containers/App/constants';import { reposLoaded, repoLoadingError } from 'containers/App/actions';import githubData, { getRepos } from '../saga';const username = 'mxstbr';/* eslint-disable redux-saga/yield-effects */describe('getRepos Saga', () =&gt; { let getReposGenerator; // We have to test twice, once for a successful load and once for an unsuccessful one // so we do all the stuff that happens beforehand automatically in the beforeEach beforeEach(() =&gt; { getReposGenerator = getRepos(); const selectDescriptor = getReposGenerator.next().value; expect(selectDescriptor).toMatchSnapshot(); const callDescriptor = getReposGenerator.next(username).value; expect(callDescriptor).toMatchSnapshot(); }); it('should dispatch the reposLoaded action if it requests the data successfully', () =&gt; { const response = [ { name: 'First repo', }, { name: 'Second repo', }, ]; const putDescriptor = getReposGenerator.next(response).value; expect(putDescriptor).toEqual(put(reposLoaded(response, username))); }); it('should call the repoLoadingError action if the response errors', () =&gt; { const response = new Error('Some error'); const putDescriptor = getReposGenerator.throw(response).value; expect(putDescriptor).toEqual(put(repoLoadingError(response))); });}); Branching SagaThỉnh thoảng, saga của bạn lại có một vài kết quả khác nhau. Khi đó để test các nhánh khác nhau, bạn cần truyền giá trị trả về mong đợi từ yield trước đó vào hàm next để thực hiện vào các branch. Chi tiết cách test này tham khảo tại đây. Testing the full SagaMặc dù rất hữu ích khi test từng bước một với saga, nhưng trên thực tế nó có thể làm cho test của saga đơn giản và ngắn. Thay vào đó một cách thích hợp hơn để test cho cả saga và mong đợi các effects đã xảy ra. Chúng ta cùng quay lại với ví dụ trên. Chúng ta sẽ test cả hành động call API lấy repos của 1 người dùng trong trường hợp thành công và mong đợi hành động put(reposLoaded(repos, username)) được xảy ra.Trước hết chúng ta cần mock function request. Việc làm này để mô phỏng giá trị trả về thành công API thay vì ta gọi API thực tế, một kỹ thuật phổ biến được sử dụng trong test. 123456789const dispatched = [];const saga = runSaga( { dispatch: action =&gt; dispatched.push(action), getState: () =&gt; ({ state: 'test' }), }, getRepos,); Và rồi test cả saga thôi: 12345678910111213141516171819202122232425describe('getRepos fullSaga', () =&gt; { it('should put expected event', async () =&gt; { const dispatched = []; const response = [ { name: 'First repo', }, { name: 'Second repo', }, ]; sinon.stub(request, 'default').callsFake(function fakeFn() { return response; }); await runSaga( { dispatch: action =&gt; dispatched.push(action), getState: () =&gt; ({ state: 'test' }), }, getRepos, ).toPromise(); expect(dispatched).toEqual([reposLoaded(response, '')]); });}); Component TestingUnit Tesing với action và reducer là ngon, nhưng bạn có thể làm thậm chí là nhiều hơn để chắc chắn rằng không gì bị break trong ứng dụng của bạn. Vì React là tầng view của ứng dụng, hãy xem xét các test Components Shallow rendering react-testing-library Snapshot testing Behavior testing Shallow renderingNhư đã đề cập trong lý thuyết, nó là kỹ thuật Unit Test với các component của React mà không cần dùng DOM. Ưu điểmHãy xem xét nó có nghĩa gì với thẻ đơn giản &lt;Button&gt; 1234567891011121314// Button.jsimport React from 'react';import CheckmarkIcon from './CheckmarkIcon';function Button(props) { return ( &lt;button className=&quot;btn&quot; onClick={props.onClick}&gt; &lt;CheckmarkIcon /&gt; {React.Children.only(props.children)} &lt;/button&gt; );}export default Button; =&gt; Note: This is a stateless (“dumb”) component Điều đó có nghĩa 1 component khác sử dụng nó sẽ có dạng: 1234567// HomePage.jsimport Button from './Button';function HomePage() { return &lt;Button onClick={this.doSomething}&gt;Click me!&lt;/Button&gt;;} =&gt; Note: This is a stateful (“smart”) component! Khi render thông thường với hàm chuẩn ReactDOM.render, đây sẽ là HTML output (Nhận xét được thêm song song để so sánh các cấu trúc trong HTML từ nguồn JSX) 1234&lt;button&gt; &lt;!-- &lt;Button&gt; --&gt; &lt;i class=&quot;fa fa-checkmark&quot;&gt;&lt;/i&gt; &lt;!-- &lt;CheckmarkIcon /&gt; --&gt; Click Me! &lt;!-- { props.children } --&gt;&lt;/button&gt; &lt;!-- &lt;/Button&gt; --&gt; Trái lại, khi render với shallow render, chúng ta sẽ nhận chuỗi string với đoạn HTML như sau: 1234&lt;button&gt; &lt;!-- &lt;Button&gt; --&gt; &lt;CheckmarkIcon /&gt; &lt;!-- NOT RENDERED! --&gt; Click Me! &lt;!-- { props.children } --&gt;&lt;/button&gt; &lt;!-- &lt;/Button&gt; --&gt; Nếu chúng ta test Button với render thông thường, khi có 1 vấn đề với CheckmarkIcon sau đó test với Button sẽ fail. Điều này rất khó khăn để tìm nguyên nhân (không biết CheckmarkIcon lỗi hay Button lỗi). Sử dụng shallow renderder, chúng ta cô lập được các sự cố do chúng ta không render 1 vài thẻ nào khác ngoài thẻ chúng ta đang test. Đây có thể coi là ưu điểm duy nhất của kỹ thuật này so với các kỹ thuật test component khác. Nhược điểmVấn đề của shallow renderer là tất cả các assertions phải làm thủ công, và bạn có thể không bất cứ điều gì cần DOM. react-testing-libraryĐể viết được nhiều test có thể maintain cái mà sẽ giống hơn cách mà chúng ta sử dụng component ở thực tế, chúng có có cái gọi là react-testing-library. Thư viện này renders component của chúng ta với DOM thực tế và cung cấp các tiện ích để truy vấn nó. Hãy xem xét component &lt;Button /&gt;. Đầu tiên, hãy check xem nó có được renders với con của nó, nếu có, và thứ 2 là nó có xử lý sự kiện click? 123456789import React from 'react';import { render, fireEvent } from 'react-testing-library';import Button from '../Button';describe('&lt;Button /&gt;', () =&gt; { it('renders and matches the snapshot', () =&gt; {}); it('handles clicks', () =&gt; {});}); Snapshot testingHãy bắt đầu bằng cách chắc chắn rằng nó render ra các component và không thay đổi nào được xảy ra kể từ lần cuối, lần mà nó được test thành công. Chúng ta sẽ làm vậy bằng cách render nó và tạo 1 snapshot cái mà có thể so sánh với snapshot đã được commit trước đó. Nếu không có snapshot nào tồn tại, 1 cái mới sẽ được tạo. Do đó, đầu tiên chúng ta sẽ call render. Nó sẽ render component &lt;Button /&gt; vào container, và mặc định là 1 &lt;div&gt;được thêm vào document.body. Chúng ta sau đó sẽ tạo ra 1 snapshot và expect snapshot đó giống với snapshot đã tồn tại (nhận vào từ lần chạy trước đó của test này) và commit nó lên repo. 123456it('renders and matches the snapshot', () =&gt; { const text = 'Click me!'; const { container } = render(&lt;Button&gt;{text}&lt;/Button&gt;); expect(container.firstChild).toMatchSnapshot();}); render trả về 1 đối tượng với thuộc tính container cái sẽ chứa được render từ &lt;Button /&gt; componentVì đây là render với DOM thông thường, chúng ta có thể truy vấn vào component bằng cách sử dụng container.firseChild. Cái này sẽ là snapshot, được chứa trong thư mục __snapshots__ trong folder tests. Chắc chắn rằng bạn đã commit snapshots này lên repo của bạn. Tuyệt vời. Bây giờ nếu bạn thực hiện 1 vài thay đổi với component &lt;Button /&gt;, test của bạn sẽ trả về fail và bạn sẽ nhận được thông báo cái gì đã thay đổi. Nếu thay đổi đó đúng với cái mà bạn muốn, hãy update snapshots và commit nó vào repo thôi :D. Test các hành viTest các sự kiện như click vào button. Chúng ta sẽ sử dụng mock function để làm việc này. Một mock function là 1 hàm sẽ theo dõi: nếu, sự thường xuyên và các đối số nào sẽ được gọi (if, how often and with what arguments). Chúng ta truyền hàm này như là hàm xử lý sự kiện onClick, mô phỏng 1 lần nhấp và cuối cùng, kiểm tra hàm mock đã được gọi: 12345678it('handles clicks', () =&gt; { const onClickMock = jest.fn(); const text = 'Click me!'; const { getByText } = render(&lt;Button onClick={onClickMock}&gt;{text}&lt;/Button&gt;); fireEvent.click(getByText(text)); expect(onClickSpy).toHaveBeenCalledTimes(1);}); Và cuối cùng, test đầy đủ của chúng ta sẽ có dạng: 123456789101112131415161718192021import React from 'react';import { render, fireEvent } from 'react-testing-library';import Button from '../Button';describe('&lt;Button /&gt;', () =&gt; { it('renders and matches the snapshot', () =&gt; { const text = 'Click me!'; const { container } = render(&lt;Button&gt;{text}&lt;/Button&gt;); expect(container.firstChild).toMatchSnapshot(); }); it('handles clicks', () =&gt; { const onClickMock = jest.fn(); const text = 'Click me!'; const { getByText } = render(&lt;Button onClick={onClickMock}&gt;{text}&lt;/Button&gt;); fireEvent.click(getByText(text)); expect(onClickSpy).toHaveBeenCalledTimes(1); });}); Tổng kết Khi test action và reducer: sử dụng Unit Testing Khi test component: sử dụng snapshot Khi test saga: sử dụng snapshot, có thể test full saga hoặc step-by-step Tài liệu tham khảo React Boilerplate JEST Shallow Renderer Generator Function Sinon JS My demo github link Q&amp;A Stack Overflow","link":"/2019/09/02/React-with-redux-saga-Testing/"},{"title":"[Sưu tầm] 5 kĩ năng giải quyết vấn đề của một kĩ sư phần mềm","text":"Để trở nên hiệu quả trong công việc, kĩ sư phần mềm cần phải rèn giũa các kĩ năng giải quyết vấn đề của bản thân và thành thạo các ngón nghề phức tạp, yêu cầu hàng năng trời học hỏi và luyện tập. Mặc cho những người mới gia nhập nghĩ gì, thì thực tế là việc hiểu một ngôn ngữ lập trình, một framework hoặc kể cả là các giải thuật KHÔNG phải là phần khó trong việc xây dựng phầm mềm. Đây là bài dịch, bài gốc các bạn có thể xem ở đây: https://dev.to/lpasqualis/the-5-problem-solving-skills-of-great-software-developers-4e6 Bài viết này lần đầu được đăng trên trang CoderHood dưới cái tên : The 5 Problem-Solving Skills of Great Software Developers. CoderHood là một trang blog chuyên về phương diện con người của ngành công nghệ phần mềm. Để trở nên hiệu quả trong công việc, kĩ sư phần mềm cần phải rèn giũa các kĩ năng giải quyết vấn đề của bản thân và thành thạo các ngón nghề phức tạp, yêu cầu hàng năng trời học hỏi và luyện tập. Mặc cho những người mới gia nhập nghĩ gì, thì thực tế là việc hiểu một ngôn ngữ lập trình, một framework hoặc kể cả là các giải thuật KHÔNG phải là phần khó trong việc xây dựng phầm mềm. Lấy ví dụ, hiểu các ngôn ngữ lập trình thì dễ, đặc biệt là các ngôn ngữ hướng thủ tục giống như C. Chỉ có 32 keywords trong C, và ý nghĩa của chúng thì rất dễ để hiểu: auto double int struct break else long switch case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if static while Đồng thời C cũng có 11 chỉ thị tiền xử lý, cũng không quá khó để hiểu: #define #error #import #elif #if #include #else #ifdef #line #ifndef #pragma Hiểu về ngôn ngữ lập trình thì không khó, nhưng ghép nối các chỉ thị với nhau để tạo thành một dòng lệnh có nghĩa thì phức tạp hơn rất nhiều. Về mặt concept, nó giống như việc viết lách với ngôn ngữ của loài người - như là tiếng Anh chẳng hạn. Từng từ trong tiếng Anh có thể hiểu được một cách dễ dàng, nhưng cách để ghép chúng lại cùng một chỗ để tạo ra các câu và đoạn văn giàu ý nghĩa, đúng ngữ pháp và dễ hiểu thì lại là vấn đề khác. Lúc đó chúng ta sẽ phải học hỏi từ nhiều chỗ, nhiều người, đồng thời tốn rất nhiều thời gian để luyện tập. Việc xây dựng phần mềm, tương tự như vậy, sẽ yêu cầu nhiều hơn về kỹ năng giải quyết vấn đề so với viết code hoặc là hiểu biết về công nghệ. Nhưng để giỏi trong việc giải quyết vấn đề, chúng ta sẽ cần rất nhiều thời gian để luyện tập và tích luỹ kinh nghiệm. Một người kỹ sư phần mềm, trước hết, là một người giải quyết vấn đề, và sau đó, mới là một thợ code. Những thứ như ngôn ngữ lập trình, framework, giải thuật là các công cụ mà chúng ta có thể nắm được thông qua việc học tập. Còn giải quyết vấn đề, thì phức tạp hơn và khó học hơn, khi chúng ta cần phải luyện tập trong thời gian dài và cần cả người hướng dẫn nữa. Làm thế nào để nghĩ như một kĩ sư phần mềmThông qua luyện tập, kỹ sư phần mềm học được cách suy nghĩ để cho phép họ tìm ra các giải pháp hiệu quả cho các vấn đề cần giải quyết. Việc học thường diễn ra một cách tự nhiên trong quá trình làm việc, nhưng nó mất thời gian. Bạn có thể tăng tốc quá trình học của mình bằng cách xác định và tập trung cải thiện các kĩ năng cần thiết để suy nghĩ giống như một kĩ sư phần mềm có nhiều kinh nghiệm. Trong bài viết này, thông qua một vấn đề không liên quan đến kỹ thuật, tôi sẽ giải thích 5 kĩ năng giải quyết vấn đề mà bạn cần học. Và vấn đề có tên là: Làm thế nào để pha cà phê cho bốn người với 4 khẩu vị khác nhau? Bài toán Pha cà phêCó bốn người - A, B, C và D muốn uống cà phê, và họ có yêu cầu cụ thể như sau: A: Cà phê đen B: Chỉ có kem C: Đường và kem D: Chỉ có đường Bạn sẽ phải tìm ra một cách thức, hoặc giải thuật, để làm cà phê giống như yêu cầu và nhanh nhất có thể. Mục tiêu là tìm ra một cách để bạn có thể phục vụ cà phê cho cả 4 người cùng một lúc, và càng nóng càng tốt. Năm kĩ năng giải quyết vấn đềChia một vấn đề to và phức tạp ra thành các vấn đề nhỏ và đơn giản hơn. Làm cà phê cho 4 người theo yêu cầu là yêu cầu tổng thể cho vấn đề chúng ta đang nói đến trong ví dụ này. Tuy nhiên, bạn không thể đơn giản là làm cà phê với một thao tác duy nhất được. Như bất kì người nào biết cách pha cà phê sẽ nói cho bạn, bạn sẽ cần phải chia nhỏ công việc ra nhiều task nhỏ hơn. Mỗi task sẽ cần phải đủ đơn giản để có thể dễ dàng xử lý. Dưới đây là danh sách các task cần phải hoàn thành để có thể pha cà phê thoả mãn yêu cầu đưa ra: Khả năng chia nhỏ công việc thành các task là một điều tự nhiên với con người, và là một kĩ năng cần thiết để hoàn thành công việc. Đồng thời việc làm ra danh sách các task ở trên không yêu cầu bất kì một kĩ năng học tập hoặc luyện tập cụ thể nào khác ngoài việc biết cách làm cà phê. Nói cách khác, ai cũng có thể làm ra được danh sách đó, dù ít hay nhiều. Tuy nhiên, sự khác nhau giữa các vấn đề gặp phải hàng ngày như là pha cà phê so với các yêu cầu phức tạp hơn như là xây dựng phần mềm ở chỗ, các bước dùng để xây dựng phần mềm hiếm khi được trau dồi và luyện tập một cách cẩn thận. Để có thể đưa ra được danh sách các task cần thiết cho việc tạo ra một phần cụ thể của phần mềm yêu cầu chúng ta phải làm nó rất nhiều lần trước đó. Việc này không thường xuyên xảy ra lắm trong thế giới phần mềm. Và đó cũng là lý do tại sao mà các kĩ sư phần mềm có kinh nghiệm không nhảy ngay lập tức vào viết danh sách các task. Thay vào đó, họ chia vấn đề ra thành các phần đơn giản và cụ thể hơn. Kĩ sư sẽ xác định vấn đề cần giải quyết là Cái gì, và danh sách các task để giải quyết các vấn đề là Làm thế nào. Trong ví dụ về việc pha cà phê, danh sách các mục tiêu phụ (phần Cái gì) có thể được xác định như sau: Mục tiêu phụ Có cốc sẵn sàng để chứa cà phê Có đủ cà phê để pha Máy pha cà phê có đủ nước Có phễu lọc với cà phê ở trong. Mục tiêu này yêu cầu mục tiêu 2 cần hoàn thành Phễu lọc có cà phê được đặt ở trong máy pha cà phê. Mục tiêu này cần mục tiêu 4 hoàn thành Máy pha cà phê đang pha cà phê, yêu cầu mục tiêu 3 và 5 hoàn thành Máy pha cà phê hoàn thành pha cà phê, yêu cầu mục tiêu 6 hoàn thành, và sau một khoảng thời gian Có cốc được đổ cà phê, yêu cầu mục tiêu 7 và 1 hoàn thành Kem được thêm vào 2 cốc cà phê; yêu cầu mục tiêu 8 được hoàn thành Đường được thêm vào 1 cốc có kem, và một cốc không có kem, yêu cầu 1 và 9 hoàn thành Đồ uống trong từng cốc được khuấy và mix hợp lý, yêu cầu 8 9 10 hoàn thành Để ý rằng không hề có mô tả cụ thể cho các công việc cần phải làm trong task, chỉ có mô tả cho kết quả cần đạt được và các task phụ thuộc. Chúng ta cũng có thể tạo một biểu đồ để trực quan hoá danh sách ở trên. Các hình hộp đại diện cho các mục tiêu phục, và các mũi tên đi đến từng hình đại diện cho các yêu cầu cần thoả mãn để nhiệm vụ phụ có thể hoàn thành: Trong trường hợp công việc là pha cà phê, việc viết ra list các task cần hoàn thành là vừa đủ. Danh sách sẽ hoạt động tốt với các vấn đề đơn giản, và bạn biết cách để giải quyết vấn đề đó mà không cần lên kế hoạch quá nhiều. Tuy nhiên trong việc xây dựng phần mềm, hiếm khi chúng ta gặp các vấn đề đơn giản như vậy. Lên kế hoạch cho các mục tiêu phụ cho phép chúng ta trừu tượng hoá kết quả với hành động, và đó là một sự khác biệt quan trọng. Ví dụ như ở mục tiêu phụ số #4: chúng ta có phễu lọc được đổ đầy cà phê, có thể sẽ khiến chúng ta phải đến cửa hàng và mua phễu lọc. Điều cần quan tâm ở đây là mục tiêu cần đạt được, là cái gì cần hoàn thành, trong khi làm thế nào là một chuỗi các lựa chọn phù hợp với hoàn cảnh (Vd đã có phễu lọc chưa hay chúng ta phải tự đi mua). Suy nghĩ song song Các mục tiêu phụ phía trên có thể hoàn thành lần lượt theo danh sách, tuy nhiên điều đó không thực sự tối ưu. Sự phụ thuộc giữa các mục tiêu này cho chúng ta một gợi ý về các công việc cần hoàn thành theo một trật tự nhất định và các công việc không cần theo thứ tự. Lấy ví dụ, bạn có thể bắt đầu xay hạt cà phê, và trong khi máy xay cà phê đang hoạt động, chúng ta có thể đổ nước vào máy pha cà phê. Nguyên nhân là vì việc cho nước vào máy pha cà phê không bắt buộc chúng ta phải có cà phê đã được xay xong. Đồng thời, việc xay cà phê chỉ yêu cầu chúng ta một thao tác bật máy, còn lại là thời gian chờ máy xay hoạt động xong. Tuy nhiên nếu máy xay cà phê là thủ công và bắt buộc phải động tay động chân, thì đó hoàn toàn là một câu chuyện khác. Hơn nữa, trong khi chờ máy pha cà phê hoàn thành công việc của nó, chúng ta có thể lấy cốc ra khỏi chạn bếp. Thực tế thì, không gì phụ thuộc vào việc cốc cần phải sẵn sàng cho đến khi chúng ta bắt đầu đổ các thành phần của từng cốc cà phê vào. Bạn cũng có thể cho đường và kem vào cốc rỗng, trước khi cả cà phê làm xong. Làm như thế này sẽ khiến việc khuấy cốc cà phê không còn cần thiết nữa. Nếu bạn đổ nhiều cà phê vào một cốc đã có sẵn một chút kem và đường, các thành phần sẽ tự hoà trộn với nhau một cách tự nhiên mà không cần phải khuấy. Ngược lại, nếu bạn đổ đường hay kem vào một cốc đã có nhiều cà phê, bạn cần phải khuấy để chúng hoà trộn vào với nhau. Sắp xếp lại taskChúng ta sẽ sắp xếp lại danh các task với mục tiêu tạo ra tối đa các tác vụ có thể làm song song, nhằm rút ngắn thời gian và bỏ qua một số bước không cần thiết. Danh sách các task với thứ tự tối ưu sẽ là. Tìm máy xay cà phê và khởi động nó Trong khi máy xay cà phê đang hoạt động, đổ nước vào máy pha cà phê Khi máy xay hoạt động xong, đổ cà phê vào trong bộ lọc Đặt bộ lọc vào máy pha cà phê Khởi động máy pha cà phê Trong khi cà phê đang được pha, lấy 4 cốc ra khỏi chạn bếp Cho kem vào 2 cốc Cho đường vào 1 cốc không có kem và 1 cốc có kem Chờ cà phê được pha xong Đổ cà phê vào 4 cốc Hoặc có thể biểu diễn dưới dạng biểu đồ tuần tự như sau: Mục tiêu làm cà phê như trong ví dụ là khá cụ thể và trong phạm vi hẹp. Nếu như vấn đề đổi thành bạn phải pha cà phê cho 5 người thay vì 4, và một số người thì muốn có si-rô vani trong cà phê, và một người thì lại muốn bỏ hết caffein, thì danh sách các mục tiêu phụ và công việc sẽ cần phải làm lại. Lập trình viên được học cách thiết kế các giải pháp để họ không phải tái thiết kế chúng mỗi khi có một vài tham số thay đổi. Họ cũng học được cách trừu tượng hoá các vấn đề để một giải pháp có thể giải quyết được bất kỳ bộ vấn đề nào tương tự như vấn đề đã làm. Trừu tượng hoá việc pha cà phêTrong ví dụ về việc pha cà phê, bạn có thể muốn trừu tượng hoá mục tiêu phụ để hoàn thành việc pha cà phê cho N người chứ không cố định là 4 người. Đồng thời bạn cũng muốn trừu tượng hoá các thành phần thêm vào cà phê như là kem hay đường, và gọi nó là phần thêm. Danh sách các thành phần này có thể thay đổi theo thời gian, như là si-rô, các loại hạt, rượu vodka và bất cứ thứ gì người ta có thể cho vào cà phê. Việc trừu tượng hoá như này cho phép số lượng X các phần thêm có thể thêm vào N cốc cà phê. Một kiểu trừu tượng khác có thể là loại cà phê. Cà phê có và không có caffein là 2 loại rõ ràng nhất, nhưng cũng có thể có các loại khác như là cà phê rang cháy, rang vừa, rang nhẹ, cà phê Columbian, cà phê pha cho buổi sáng, … Trong khi đó máy pha cà phê chỉ có thể pha một loại cà phê trong một thời điểm, bạn có thể thấy việc này có thể khiến vấn đề trở nên phức tạp như thế nào. Nếu một vài trong số 4 người muốn uống cà phê thường, và số còn lại uống cà phê không có caffein, yêu cầu phục vụ cà phê cho cả 4 người trong cùng 1 lúc và đảm bảo cà phê càng nóng càng tốt sẽ trở nên rất phức tạp để hoàn thành. Ở thời điểm đó, bạn sẽ phải trừu tượng hoá định nghĩa về số lượng máy cà phê bạn có - Y cái nếu bạn có Y loại cà phê khác nhau. Đồng thời, nếu như bạn có Y máy pha cà phê hoạt động độc lập thì việc thực hiện các tác vụ song song sẽ yêu cầu thêm chút tinh tế. Lúc này, lập trình viên có thể muốn trừu tượng hoá số lượng người pha cà phê. Nếu bạn có K người pha cà phê hoạt động cùng nhau, thì mọi việc sẽ thay đổi như thế nào? Trừu tượng hơn nữaĐến một lúc, bạn có thể nhận ra cà phê cũng chỉ là một loại thành phần của cốc cà phê, vì thế sao phải làm nó khác biệt với các phần thêm khác nhỉ? Bạn có thể quyết định cà phê cũng là một thành phần thêm vào, và loại bỏ hoàn toàn các dữ liệu cụ thể cho cà phê. Tuy nhiên, cà phê yêu cầu xử lý và chuẩn bị một cách đặc biệt, do đó tất cả các phần thêm khác cũng nên cho phép có xử lý và chuẩn bị chung. Ví dụ, nếu rượu nóng đánh với trứng là một phần thêm, sẽ có thể có hẳn một luông xử lý mô phỏng việc làm ra nó. Nhưng ở thời điểm này, bạn có thể trừu tượng hoá sự chuẩn bị của bất kỳ thứ gì, và do đó rượu nóng đánh trứng cũng chỉ đơn thuần là một thứ mà bạn có thể tạo ra. Trừu tượng quáLiệu bạn đã bắt đầu thấy đau đầu chưa? Chào mừng đến với thế giới xoắn quẩy của việc trừu tượng quá. Bạn có thể thấy rằng việc trừu tướng hoá có thể làm phức tạp bức tranh tổng thể nhanh đến thế nào nếu như bạn khiến nó đi quá giới hạn? Chúng ta bắt đầu với một kiểu cà phê, 4 người cần phục vụ, thành phần thêm vào cố định và một người pha chế. Công việc thật đơn giản và tự nhiên. Nếu bạn thử trừu tượng hoá bất kì mặt nào của việc làm cà phê và suy ngẫm đến khả năng có thể có N người để phục vụ, X loại thành phần thêm vào, Y loại cà phê, K người pha chế… thì mọi thứ bỗng trở nên thật phức tạp, đặc biệt khi bạn muốn tối ưu chi phí và tốc độ thực hiện. Bạn đã đi từ việc làm cà phê sang làm bất kỳ sản phẩm nào dưới ánh mặt trời sử dụng bất kì quy trình nào. Wao!!! Một kĩ sư phần mềm cầu toàn sẽ cố để trừu tượng hoá mọi thứ và kết thúc với một cỗ máy phức tạp rất nhiều so với mục tiêu ban đầu là phục vụ cà phê cho một gia đình 4 người. Một kĩ sư phần mềm có kinh nghiệm, thì ngược lại, sẽ trừu tượng hoá các thứ có thể giải quyết các trường hợp thuộc về bản chất, và có thể suy nghĩ đến các khả năng trừu tượng hoá khác, nhưng chỉ với mục đích để đảm bảo các quyết định ở thời điểm hiện tại sẽ không gây cản trở cho các nhu cầu trong tương lai. Cân bằngKhi nào chúng ta cần dùng trừu tượng hoá? Đó là một nghệ thuật yêu cầu rất nhiều luyện tập. Kinh nghiệm thực tế là bạn chỉ nên trừu tượng hoá các trường hợp mà bạn nghĩ rằng nó sẽ chỉ yêu cầu ngắn hạn, và hãy cố để không gây cản trở việc trừu tượng hoá trong tương lai với các suy nghĩ cụ thể ở hiện tại có tầm nhìn hẹp. Cân nhắc về việc tái sử dụng các giải pháp đã có Không việc gì phải phát minh lại cái bánh xe. Không phải mọi thứ đều yêu cầu phải làm từ đầu. Kĩ sư phần mềm có kinh nghiệm luôn luôn cân nhắc sử dụng các công cụ đã có trước khi bắt đầu thiết kế một giải pháp từ đầu. Ví dụ, thay vì phải pha cà phê, bạn có thể đến ngay Starbuck mua lấy 4 cốc và mang về cho bạn mình? Nếu bạn không có cốc, cà phê, máy pha cà phê, thì việc đến Starbucks là một giải pháp rẻ và nhanh hơn rất nhiều, đặc biệt nếu bạn không có ý định pha cà phê hàng ngày trong thời gian dài. Tìm và sử dụng các giải pháp sẵn có là một trong các kĩ năng mà lập trình viên cần có khi giải quyết vấn đề. Suy nghĩ theo luồng dữ liệu Sau nhiều năm luyện tập, lập trình viên có kinh nghiệm bắt đầu suy nghĩ về phần mềm, và cách giải quyết vấn đề theo luồng xử lý dữ liệu trong một hệ thống. Trong vấn đề về máy pha cà phê, hãy suy nghĩ về luồng của nước, cà phê, cốc và các thành phần thêm vào, bắt đầu từ nguồn của chúng cho đến mục tiêu cuối cùng (Cốc cà phê). Nước bắt đầu từ bồn, cà phê bắt đầu từ một túi đóng gói sẵn trong bếp của bạn - trước đó là ở một cửa hàng thực phẩm. Cốc bắt đầu từ chạn đựng cốc và các thành phần thêm vào thì xuất phát từ nhiều nguồn khác nhau tuỳ thuộc vào nó là cái gì. Các nguyên liệu này (dữ liệu) đi theo một dòng chảy thông qua một loạt các bước xử lý, biến đổi và pha trộn. Trạng thái đầu tiên là nguyên liệu thô được xác định ở chỗ chứa của từng thành phần, và trạng thái cuối cùng là một loạt các cốc cà phê được pha chế thành công. Và địa chỉ cuối cùng là trong miệng của 1 ai đó. Suy nghĩ theo luồng dữ liệu cho phép chúng ta trực quan hoá mục tiêu quan trọng nhất và các mục tiêu phụ với một series các hình khối và mũi tên. Các hình khối đại diện cho từng hành động ảnh hưởng đến các nguyên liệu trong luồng của hệ thống, và các mũi tên sẽ giống như các đường ống để vận chuyển các nguyên liệu từ nơi này đến nơi khác.","link":"/2020/05/02/Suu-tam-5-ki-nang-giai-quyet-van-de-cua-mot-ki-su-phan-mem/"},{"title":"[Laravel] Useful Laravel Packages","text":"Một vài package hữu ích được tổng hợp từ: https://codewithdre.com/useful-laravel-packages Laravel CashierLaravel DuskLaravel EnvoyLaravel HorizonLaravel SocialiteLaravel PassportLaravel Passport w/ SocialiteLaravel ScoutLaravel Telescope (*) Đây có thể coi là trợ thử đắc lực của laravel giúp cho việc debug, đặc biệt cung cấp khả năng UI đẹp mắt và thân thiện. Tuy nhiên nó lại cần thao tác với DB và publish code font end cho ứng dụng của bạn. Telescope phân tích đầu đủ và chi tiết cho bạn những request đến ứng dụng exceptions, log entries, database queries, queued jobs, mail, notifications, cache operations, scheduled tasks, variable dumps và còn nhiều hơn nữa. Telescope là 1 công cụ, môi trường tuyệt vời để phát triển ứng dụng Laravel. Telescope makes a wonderful companion to your local Laravel development environment. Laravel Nova (sẽ thử)Ref: https://nova.laravel.com/ Master You Universe Nove là 1 thiết kế đẹp cho người quản trị viên quản lý ứng dụng Laravel. Nó được tạo ra 1 cách cẩn thận bởi những người đã tạo ra Laravel để giúp bạn trở thành 1 developer năng suất hơn :D Laravel EchoLaravel Valet (*)Valet is a Laravel development environment for Mac minimalists. No Vagrant, no /etc/hosts file. You can even share your sites publicly using local tunnels. Yeah, we like it too. Khi nào có MAC sẽ thử nhé =)) Laravel Valet được cấu hình trên Mac của bạn, luôn luôn chạy Nginx. Valet còn là môi trường phát triển nhanh hơn cho Laravel, sử dụng khoảng 7MB RAM. Valet không phải là sự thay thế hoàn toàn cho Vagrant hoặc Homested, nhưng cung cấp 1 sự thay thế tuyệt vời có những thứ cơ bản linh hoạt, thích tốc độ cao hoặc đang làm việc với những máy có dung lượng RAM hạn chế. Laravel SanctumInertia.jsJigsaw (*)Ref: https://github.com/tightenco/jigsaw Đây là một công cụ khác để render file view tương tự như Laravel blade. Jigsaw is a framework for rapidly building static sites using the same modern tooling that powers your web applications. Chúng ta có thể sử dụng cả blade template với các markdown, kĩ thuật mới với jigsaw 12345678910111213141516---title: &quot;Jigsaw is awesome!&quot;---@extends('layouts.master')@section('content')&lt;h1&gt;{{ $page-&gt;title }}&lt;/h1&gt;&lt;p&gt;Contact us at {{ $page-&gt;contact_email }}&lt;/p&gt;@endsection Livewire (sẽ thử, chưa hiểu lắm)Ref: https://laravel-livewire.com/ Một công cụ cho full-stack framework cho Laravel, giúp việc building các giao diện đơn giản, mà không cần các sự gò bó từ Laravel. Nó thiên về xây dựng các giao diện động mà không cần qua quá nhiều bước trong Laravel thì phải, sử dụng được sức mạnh to lớn như Vue và React. Hãy xem ví dụ nàyhttps://laravel-livewire.com/docs/quickstart Bạn không cần phải quá nhiều route, controller mà vẫn thực hiện được các thao tác chuyển hướng, cập nhật dữ liệu vào database, cấu trúc đơn giản hơn. Wink (*)Ref: https://github.com/writingink/wink Wink tích hợp trình soạn thảo, dễ dàng giúp bạn viết và trình bày các nội dung với style. Wink được xây dựng dựa trên Laravel framework, giúp mọi người dễ dàng cài đặt, bảo trì trên mọi nền tảng cloud Nếu bạn đang viết blog, hãy thử nó xem sao CachetLarecipe (sẽ thử)Ref: https://github.com/saleem-hadad/larecipe LaRecipe giúp bạn viết phần tài liệu (document) rõ ràng và đẹp hơn, sử dụng Markdown cho dự án và giữ các tài liệu này trong source code của bạn LaRecipe is simply a code-driven package provides an easy way to create beautiful documentation for your product or application inside your Laravel app. Tất cả các phần docs cho dự án sẽ được sinh ra và đính kèm trong source code luôn :D. 12345678.├─ config│ └─ larecipe.php└─ resources └─ docs └─ 1.0 │─ index.md └─ overview.md Laravel Zero (*)Ref: https://laravel-zero.com/ Laravel Zero: Micro-framework for console applications Nếu bạn chỉ muốn xây dựng 1 ứng dụng chỉ có console (cửa sổ dòng lệnh) mà vẫn dùng các component của Laravel, micro-framework này là dành cho bạn. Đây là một project cộng đồng, không phải từ officical của Laravel duwojd tạo và maitain bởi Nuno Maduro - thanh niên này làm luôn Laravel Mojito nữa @@ Ví dụ đơn giản là chỉ tạo logo cho ứng dụng =)) 1php &lt;your-app-name&gt; app:install logo FlarumOctober CMSLaravel VoyagerLaravel Google Maps (*) Ref: https://github.com/farhanwazir/laravelgooglemaps Package này có vẻ chưa được sử dụng nhiều, mới chỉ nhận được 99 stars trên Gihub, bạn cân nhắc có cần sử dụng nó không nhé. Package tích hợp các chức năng của Google map vào ứng dụng của bạn :D 123456789Route::get('/', function(){ $config = array(); $config['center'] = 'New York, USA'; GMaps::initialize($config); $map = GMaps::create_map(); echo $map['js']; echo $map['html'];}); Nexmo &amp; Twilio (*)Package phục vụ gửi thông báo thông qua số điện thoại Pwned Validator (*) Ref: https://github.com/valorin/pwned-validator Nếu bạn muốn cảnh báo và xem xét độ mạnh yếu của mật khẩu, package này có thể giúp bạn. Pwned Password là nửa tỉ mật khẩu trong thế giới thực trước đây đã bị lộ trong phạm vi dữ liệu. Việc so sánh đánh giá với chúng sẽ đưa ra được nguy cơ mật khẩu hiện tại đã đủ mạnh chưa? 1'password' =&gt; 'required|string|min:6|pwned:150|confirmed', Laravel AnalyticsLaravel Google Translate (*)Ref: https://github.com/JoggApp/laravel-google-translate Package sử dụng Google Translate API vào ứng dụng của bạn một cách dễ dàng với tối thiểu đến không cần cấu hình, cú pháp rõ ràng và API nhất quán. Ngon. Stripe LaravelLaravel Debugbar (*) Sở hữu 10.3k star trên Github repository, đây chắc hẳn là tool hỗ trợ dubug cho Laravel được yêu thích và sử dụng rộng rãi nhất. Với sự dễ dàng khi cài đặt và sử dụng, không quá khó hiểu khi nó lại được ưa chuộng đến vậy. Tuy nhiên nó lại cung cấp các thông tin debug trên front-end do đó nó có vẻ không hữu ích để debug cho các ứng dụng Laravel về API (Nếu bạn đang sử dụng Laravel Debugbar để debug ứng dụng cung cấp API, hãy cho mình hướng dẫn thêm ở phần comment nhé) Laravel Debugbar thêm 1 thanh bar thông minh dưới trình duyệt chứa các thông tin phục vụ debug (ví dụ số lượng queries). Với Eloquent, có thể dễ dàng thực hiện các yêu cầu cơ sở dữ liệu không cần thiết để Debugbar giúp xác định mã không hiệu quả. Clockwork (*)Ref: https://github.com/itsgoingd/clockwork Một tool hữu hiệu cho việc debug Clockwork là một extension của trình duyệt, cung cấp tools để debug và ghi lại các hoạt động trong ứng dụng PHP, bao gồm request data, application log, database queries, routes, visualisation of application runtime and more. Clockwork sử dụng một thành phần server-side, tập hợp tất cả dữ liệu và dễ dàng tích hợp với bất kỳ dự án PHP nào, bao gồm hỗ trợ ngoài luồng cho các frameworks Bạn có thể xem giao diện dữ liệu được thu thập được thông qua extension Clockwork được tích hợp trên Chrome và Firefox. Laravel N+1 Query Detector (*) Ref: https://github.com/beyondcode/laravel-query-detector Package này giúp bạn tăng hiệu năng cho ứng dụng bằng cách giảm số lượng truy vấn thực thi. Package sẽ theo dõi truy vấn của bạn với thời gian thực, và sẽ thông báo khi bạn nên sử dụng eager loading (N+1 queries). Laravel Self Diagnosis (*)Ref: https://github.com/beyondcode/laravel-self-diagnosis Package này cho phép bạn tự thực hiện các kiểm tra chẩn đoán ứng dụng Laravel. Nó sẽ có rất nhiều checks và cho phép bạn tự custom các checks này. Đây không phải là lệnh của Unit test, nó test ứng dụng, key, migrate các thứ các thứ ấy =)) Laravel Health Panel (chắc cần thử) Ref: https://github.com/antonioribeiro/health Package giúp bạn theo dõi “sức khỏe” ứng dụng của bạn và xem nó có chạy như đúng sự mong đợi và tạo ra các bảng thông báo trạng thái của các dịch vụ: Khả năng cấu hình và mở rộng cao: Bạn có thể tạo các trình kiểm tra và thông báo mới rất dễ dàng, và bạn cũng có thể thay đổi mọi thứ trên đó. Dễ dàng cấu hình với file YAML Nhận thông báo qua các hệ thống thông báo như: mail, slack, telegram hoặc bất cứ gì bạn muốn. Routes cho: panel, json result, string result và resource Có thể cấu hình với thiết kế panel Cache Lịch trình kiểm tra để tự động nhận thông báo khi service lỗi. Xem lỗi của ứng dụng trên bảng điều khiển Http phản hồi mã 200, 500 và các mã lỗi khác như Envoye Laravel Log Viewer (*)Ref: https://github.com/rap2hpoutre/laravel-log-viewer Package này hộ trợ cho việc đọc log PHP Insights (*)Ref: https://github.com/nunomaduro/phpinsights Homepage: https://phpinsights.com/ PHP Insights được tạo ra cẩn thận để đơn giản hóa việc phân tích code của bạn từ termial và nó là điểm khởi đầu hoàn hảo để phân tích chất lượng code PHP của bạn trong project.Các tính năng: Phân tích code quality và coding style Hiển thị đẹp với code architecture và complexity của nó Được thiết kế làm việc với nhiều framework: Laravel, Symfony, Yii, Magento và hơn thế nữa Chứa các built-in checks cho việc làm cho mã đáng tin cậy, các liên kết lỏng lẻo, đơn giản và rõ ràng. Guzzle (*) Ref: https://github.com/guzzle/guzzle Đây là package được sử dụng nhiều trong PHP để tạo HTTP Request, call API. Guzzle là 1 PHP HTTP client được tạo 1 cách dễ dàng để gửi HTTP Request tích hợp trong dịch vụ web 1234567891011121314$client = new \\GuzzleHttp\\Client();$response = $client-&gt;request('GET', 'https://api.github.com/repos/guzzle/guzzle');echo $response-&gt;getStatusCode(); // 200echo $response-&gt;getHeaderLine('content-type'); // 'application/json; charset=utf8'echo $response-&gt;getBody(); // '{&quot;id&quot;: 1420053, &quot;name&quot;: &quot;guzzle&quot;, ...}'// Send an asynchronous request.$request = new \\GuzzleHttp\\Psr7\\Request('GET', 'http://httpbin.org');$promise = $client-&gt;sendAsync($request)-&gt;then(function ($response) { echo 'I completed! ' . $response-&gt;getBody();});$promise-&gt;wait(); Thư viện này chắc hẳn các bạn đã sử dụng cực kì nhiều, nên mình không giới thiệu chi tiết quá ở đây Zttp (*) Ref: https://github.com/kitetail/zttp Zttp tương tự như Guzzle nhưng nó đơn giản hơn 123456789101112131415$response = Zttp::withHeaders(['Fancy' =&gt; 'Pants'])-&gt;post($url, [ 'foo' =&gt; 'bar', 'baz' =&gt; 'qux',]);$response-&gt;status();// int$response-&gt;isOk();// true / false$response-&gt;json();// =&gt; [// 'whatever' =&gt; 'was returned',// ]; Laravel Cors (*) Ref: https://github.com/fruitcake/laravel-cors Package laravel-cors cho phép bạn gửi Cross-Origin Resource Sharing header với cấu hình Laravel middleware Laravel Stats (*) Ref: https://github.com/stefanzweifel/laravel-stats Lấy các thông tin chi tiết về dự án Laravel và Lumen (khá giống với PHP Insights) Laravel Backup (*) Ref: https://github.com/spatie/laravel-backup Package này tạo 1 bản backup cho ứng dụng của bạn. Bản backup là file zip chứa tất cả file trong thư mục bạn chỉ định với 1 bản dump database của bạn. Bản backup có thể lưu trữ 1 vài filesystems bạn đã cấu hình trong Laravel 5. This Laravel package creates a backup of your application. The backup is a zip file that contains all files in the directories you specify along with a dump of your database. The backup can be stored on any of the filesystems you have configured in Laravel 5. Bạn cảm thấy hoang mang về sao lưu? Không vấn đề! Bạn có thể sao lưu ứng dụng của mình vào nhiều filesystem cùng 1 lúc. 1php artisan backup:run BladeX (*)Ref: https://github.com/spatie/laravel-blade-x Package cho phép bạn định nghĩa các component trên view như React hay Vue ấy :D Một vài chú ý về hiệu năng: Bởi vì package hoạt động trước khi Blade biên dịch ra views, không có ảnh hưởng đến hiệu suất. Blade có thể chỉ cache tất cả các view Nó là các thẻ được render trên server (serverside) nên nó không tương thích với các clientside framework như Vue Hay React 12345{{-- resources/views/components/myAlert.blade.php --}}&lt;div class=&quot;{{ $type }}&quot;&gt; {{ $message }}&lt;/div&gt; AppServiceProvider boot()1BladeX::component('components.myAlert'); 123&lt;h1&gt;My view&lt;/h1&gt;&lt;my-alert type=&quot;error&quot; :message=&quot;$message&quot; /&gt; Blade Filters (*)Ref: https://github.com/thepinecode/blade-filters Use string filters easily in Laravel Blade. 1234567891011{{ 'john' | ucfirst }} // John{{ 'john' | ucfirst | substr:0,1 }} // J{{ '1999-12-31' | date:'Y/m/d' }} // 1999/12/31{{ 'This is a title' | slug }} // this-is-a-title{{ 'This is a title' | title }} // This Is A Title{{ 'foo_bar' | studly }} // FooBar Lambo (*)Ref: https://github.com/tightenco/lambo Một cách tạo ứng dụng khác, super-powered laravel new đối với Laravel và Valet. 123lambo new superApplication --path=~/Siteslambo new superApplication --auth Artisan View (*)Ref: https://github.com/svenluijten/artisan-view Bình thường các lệnh artisan không có tạo view. Packge này giúp bạn thêm các lệnh sinh ra các blade files, có thể extend các views khác, thêm các section, thêm các template hoặc nhiều hơn thế. 12345678# Create a view 'index.blade.php' in the default directory$ php artisan make:view index# Create a view 'index.blade.php' in a subdirectory ('pages')$ php artisan make:view pages.index# Create a view with a different file extension ('index.html')$ php artisan make:view index --extension=html Mail Eclipse (*)Ref: https://github.com/Qoraiche/laravel-mail-editor MailEclipse là 1 mailable editor package cho ứng dụng Laravel để tạo và quản lý các mẫu emails sử dụng web UI. Bạn có thể sử dụng package này để phát triển các mẫu mailables mà không cần sử dụng command line và chỉnh sửa các mẫu email trực tiếp với WYSIWYG editor cùng với nhiều tính năng khác. SEO Tools (*)Ref: https://github.com/artesaos/seotools Phần này giúp bạn sinh ra các đoạn mã phục vụ cho SEO. Bạn làm tech, không biết các kĩ thuật SEO, đây là 1 packge không tồi :D. 123456789101112131415161718192021222324&lt;?phpnamespace App\\Http\\Controllers;use Artesaos\\SEOTools\\Traits\\SEOTools as SEOToolsTrait;class CommomController extends Controller{ use SEOToolsTrait; public function index() { $this-&gt;seo()-&gt;setTitle('Home'); $this-&gt;seo()-&gt;setDescription('This is my page description'); $this-&gt;seo()-&gt;opengraph()-&gt;setUrl('http://current.url.com'); $this-&gt;seo()-&gt;opengraph()-&gt;addProperty('type', 'articles'); $this-&gt;seo()-&gt;twitter()-&gt;setSite('@LuizVinicius73'); $this-&gt;seo()-&gt;jsonLd()-&gt;setType('Article'); $posts = Post::all(); return view('myindex', compact('posts')); }} Và kết quả ở phần view 123456789101112131415161718192021222324252627282930313233&lt;html&gt;&lt;head&gt; &lt;title&gt;Title - Over 9000 Thousand!&lt;/title&gt; &lt;meta name='description' itemprop='description' content='description...' /&gt; &lt;meta name='keywords' content='key1, key2, key3' /&gt; &lt;meta property='article:published_time' content='2015-01-31T20:30:11-02:00' /&gt; &lt;meta property='article:section' content='news' /&gt; &lt;meta property=&quot;og:description&quot;content=&quot;description...&quot; /&gt; &lt;meta property=&quot;og:title&quot;content=&quot;Title&quot; /&gt; &lt;meta property=&quot;og:url&quot;content=&quot;http://current.url.com&quot; /&gt; &lt;meta property=&quot;og:type&quot;content=&quot;article&quot; /&gt; &lt;meta property=&quot;og:locale&quot;content=&quot;pt-br&quot; /&gt; &lt;meta property=&quot;og:locale:alternate&quot;content=&quot;pt-pt&quot; /&gt; &lt;meta property=&quot;og:locale:alternate&quot;content=&quot;en-us&quot; /&gt; &lt;meta property=&quot;og:site_name&quot;content=&quot;name&quot; /&gt; &lt;meta property=&quot;og:image&quot;content=&quot;http://image.url.com/cover.jpg&quot; /&gt; &lt;meta property=&quot;og:image&quot;content=&quot;http://image.url.com/img1.jpg&quot; /&gt; &lt;meta property=&quot;og:image&quot;content=&quot;http://image.url.com/img2.jpg&quot; /&gt; &lt;meta property=&quot;og:image&quot;content=&quot;http://image.url.com/img3.jpg&quot; /&gt; &lt;meta property=&quot;og:image:url&quot;content=&quot;http://image.url.com/cover.jpg&quot; /&gt; &lt;meta property=&quot;og:image:size&quot;content=&quot;300&quot; /&gt; &lt;meta name=&quot;twitter:card&quot;content=&quot;summary&quot; /&gt; &lt;meta name=&quot;twitter:title&quot;content=&quot;Title&quot; /&gt; &lt;meta name=&quot;twitter:site&quot;content=&quot;@LuizVinicius73&quot; /&gt; &lt;script type=&quot;application/ld+json&quot;&gt;{&quot;@context&quot;:&quot;https://schema.org&quot;,&quot;@type&quot;:&quot;Article&quot;,&quot;name&quot;:&quot;Title - Over 9000 Thousand!&quot;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; Laravel Collection Macros (*)Ref: https://github.com/spatie/laravel-collection-macros Package thêm rất nhiều marcos, methods hữu ích cho collection trong Laravel 1234$data = new Collection([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$data-&gt;third(); // 3$data-&gt;fourth(); // 4 Collect.js (*)Ref: https://github.com/ecrmnn/collect.js/Nếu bạn muốn sử dụng Collection của Laravel trên Javascript, đây chính là thư viện JS giúp bạn làm việc này Collect.js được coi là một phần của Laravel Collections nhưng được phát triển bằng javascript. Nếu là một phần của Laravel Collections thì chắc chắn về hoạt động sẽ tương đồng với Laravel Collections. Collect.js phiên bản Laravel Collections javascript hoạt động tốt với kiểu giữ liệu mảng (array) và đối tượng (object). Cài đặtnpm1npm install collect.js --save yarn1yarn add collect.js From CDNVisit: https://cdnjs.com/libraries/collect.js API1234567const collection = collect([1, 2, 3, 4, 5, 6, 7]);const chunks = collection.chunk(4);chunks.all();// [[1, 2, 3, 4], [5, 6, 7]] Laravel Frontend Presets (*)Refhttps://github.com/laravel-frontend-presets Đây là một tính năng mới trong Laravel 5.5. cho phép bạn chọn framework, thư viện frontend cho ứng dụng Laravel của mình hoặc gỡ bỏ chúng, quản lý thông qua lệnh artisan preset React1php artisan preset react Bootstrap1php artisan preset bootstrap Remove All Scaffolding1php artisan preset none Laravel View Models (*) Ref: https://github.com/spatie/laravel-view-models Đã bao giờ tạo 1 controller và bạn phải làm rất nhiều việc chuẩn bị các biến để truyền vào view? Bạn có thể chuyển những công việc này vào 1 thứ gọi là view mode. Về bản chất, view modes là các lớp đơn giản lấy 1 số dữ liệu và chuyển đổi nó thành cái gì đó có thể sử dụng được ở view. Phần này giúp giảm tải logic Controller bằng cách thêm 1 phần xử lý logic của view là Model, tái sử dụng lại. Chi tiết bạn có thể tham khảo tại blog: https://stitcher.io/blog/laravel-view-models Phần này có thể không được ưu tiên dùng lắm, mới có 600 stars trên GitHub, có thể có nhiều cách clean code tốt hơn ER Diagram Generator (*)Ref: https://github.com/beyondcode/laravel-er-diagram-generator Package cho phép bạn sinh sơ đồ thực thể liên kết bằng cách dựa vào quan hệ được định nghĩa trong model của bạn. Nó rất tùy biến. Bạn có thể sử dụng GraphViz để tạo biểu đồ :D. Laravel Enum (*) Ref: https://github.com/BenSampo/laravel-enum Package hỗ trợ việc liệt kê các giá trị trong ứng dụng, các phương thức đa dạng để truy cập key/value của các giá trị này. Ngoài ra nó cũng hỗ trợ Localization và Macros. Laravel Collective HTML (*) Ref: https://laravelcollective.com/docs/6.0/html Package này giúp bạn render các form, input của Laravel một cách tốt hơn Ziggy (*)Ref: https://github.com/tightenco/ziggy Ziggy - Use your Laravel Named Routes inside JavaScript Ziggy tạo thêm các lệnh, helper cho Blade cái mà bạn có thể sử dụng trong views. Điều này sẽ export 1 đối tượng JavaScript ứng với routes đã được đặt tên, gán chúng với các key là tên của chúng (aliases) cũng như một helper toàn cục route(), cho phép bạn truy cập route trong file JavaScript. Ví dụ cho file JavaScript của bạn: 1234567891011121314route('posts.index') // Returns '/posts'route('posts.show', {id: 1}) // Returns '/posts/1'route('posts.show', [1]) // Returns '/posts/1'route('posts.show', 1) // Returns '/posts/1'// Practical AJAX example:var post = {id: 1, title: 'Ziggy Stardust'};return axios.get(route('posts.show', post)) .then((response) =&gt; { return response.data; }); TinkerwellBear Sync (*) Ref: https://github.com/calebporzio/bear-sync Package cung cấp một model Eloquent được gọi là BearNote, cái mà có thể truy cập Bear notes trên máy local của bạn mà không cần cấu hình tất cả. BearNote model truy cập database SQLite của Bear Notes dựa vào driver database của Laravel. 1234567891011121314151617$note = BearSync\\BearNote::whereTitle('Some Note Title')-&gt;first();App\\Post::create([ 'title' =&gt; $note-&gt;title, 'content' =&gt; $note-&gt;content,])/* Example API */// Search all your Bear notes.$notes = BearSync\\BearNote::searchByTitle('Some Note Title');// Find a specific note.$note = BearSync\\BearNote::whereTitle('Some Note Title')-&gt;first();// Get tags by note$tags = $note-&gt;tags Sushi (*)Refhttps://github.com/calebporzio/sushi Sushi Eloquent Model không hỗ trợ drive “array” Đôi khi bạn muốn sử dụng Eloquent, nhưng không phải thao tác với database Use123456789101112131415class State extends Model{ use \\Sushi\\Sushi; protected $rows = [ [ 'abbr' =&gt; 'NY', 'name' =&gt; 'New York', ], [ 'abbr' =&gt; 'CA', 'name' =&gt; 'California', ], ];} 1$stateName = State::whereAbbr('NY')-&gt;first()-&gt;name; Các hàm whereAbbr nếu không sử dụng Sushi sẽ là thao tác với database để tìm kiếm. Ở đây, vẫn sử dụng được các hàm của Eloquent nhưng với thao tác mảng :D. Nó cũng có thể áp dụng cho quan hệ nữa nhé, chi tiết xem lại trang chủ. Nhưng chú ý, quan hệ sẽ không dùng được whereHas do 2 models sử dụng 2 database khác riêng biệt. How it worksUnder the hood, this package creates and caches a SQLite database JUST for this model. It creates a table and populates the rows. If, for whatever reason, it can’t cache a .sqlite file, it will default to using an in-memory sqlite database. Như vậy nó đang sử dụng SQLiite jenssegers date (*) Ref: https://github.com/jenssegers/date Thư viện này mở rộng của Carbon với hỗ trợ đa ngôn ngữ. Các phương thức như format, diffForHumans, parse, createFromFormat và thêm phương thức mới timespan sẽ được dịch sang ngôn ngữ địa phương của bạn. 1234567use Jenssegers\\Date\\Date;Date::setLocale('nl');echo Date::now()-&gt;format('l j F Y H:i:s'); // zondag 28 april 2013 21:58:16echo Date::parse('-1 day')-&gt;diffForHumans(); // 1 dag geleden Laravel Shared Data (*)Ref: https://github.com/coderello/laravel-shared-data Laravel Shared Data cung cấp cách dễ dàng để chia sẻ dữ liệu từ backend tới JavaScript. 123456789101112131415161718192021use Coderello\\SharedData\\Facades\\SharedData;// using the facadeSharedData::put([ 'user' =&gt; auth()-&gt;user(), 'post' =&gt; Post::first(), 'app' =&gt; [ 'name' =&gt; config('app.name'), 'environment' =&gt; config('app.env'), ],]);// using the helpershare([ 'user' =&gt; auth()-&gt;user(), 'post' =&gt; Post::first(), 'app' =&gt; [ 'name' =&gt; config('app.name'), 'environment' =&gt; config('app.env'), ],]); Và sử dụng ở frontend từ window.shareData:1const user = window.sharedData.user;Hoặc sử dụng global built-in helper:1const user = shared('user');Và kết quả thu được Blueprint (*)Ref: https://github.com/laravel-shift/blueprint Blueprint là 1 tool mã nguồn mở để tạo ra nhanh chóng nhiều các thành phần của Laravel từ 1 file duy nhất, dễ đọc với mọi người Bạn định nghĩa các components trong Laravel mà bạn muốn tạo trong Laravel, gõ 1 lệnh, Blueprint sẽ sinh code cho bạn :D. Ví dụ dưới đây bạn định nghĩa Models và Controllers sử dụng các diễn đạt rất rõ nghĩa, mọi người đều có thể đọc được. draft.yaml1234567891011121314151617181920models: Post: title: string:400 content: longtext published_at: nullable timestampcontrollers: Post: index: query: all render: post.index with:posts store: validate: title, content save: post send: ReviewNotification to:post.author with:post dispatch: SyncMedia with:post fire: NewPost with:post flash: post.title redirect: post.index Và sau đó bạn chạy1php artisan blueprint:build [draft]Tất cả code cho model, controller sẽ được tạo cho bạn. Laravel WebsocketsLaravel Console Menu (*)Ref: https://github.com/nunomaduro/laravel-console-menu Laravel Console Menu cải thiện giao diện artisan command, nó được bọc trong Laravel Console Commands. Laravel Shopping Cart (*) Ref: https://github.com/Crinsane/LaravelShoppingcart Một package hỗ trợ làm việc với giỏ hàng trong Laravel. Dữ liệu giỏ hàng này sẽ được lưu trong Session.1234Cart::add($product, 1, ['size' =&gt; 'large']);Cart::update($rowId, ['name' =&gt; 'Product 1']); // Will update the nameCart::remove($rowId);Cart::get($rowId); Laravel Searchable https://github.com/nicolaslopezj/searchablehttps://github.com/spatie/laravel-searchable Laravel FakeId (*)Nếu bạn không muốn hiển thị ID thật của các Model lên ứng dụng của bạn, có một số package giúp bạn fake hoặc băm id này ra Laravel Hashids Laravel FakeID Laravel CommentsLaravel Breadcrumbs (*)Ref: https://github.com/davejamesmiller/laravel-breadcrumbs A simple Laravel-style way to create breadcrumbs. Đầu tiên bạn tạo file đăng ký breadcrumbs routes/breadcrumbs.php1234567891011121314151617181920212223242526272829303132&lt;?php// HomeBreadcrumbs::for('home', function ($trail) { $trail-&gt;push('Home', route('home'));});// Home &gt; AboutBreadcrumbs::for('about', function ($trail) { $trail-&gt;parent('home'); $trail-&gt;push('About', route('about'));});// Home &gt; BlogBreadcrumbs::for('blog', function ($trail) { $trail-&gt;parent('home'); $trail-&gt;push('Blog', route('blog'));});// Home &gt; Blog &gt; [Category]Breadcrumbs::for('category', function ($trail, $category) { $trail-&gt;parent('blog'); $trail-&gt;push($category-&gt;title, route('category', $category-&gt;id));});// Home &gt; Blog &gt; [Category] &gt; [Post]Breadcrumbs::for('post', function ($trail, $post) { $trail-&gt;parent('category', $post-&gt;category); $trail-&gt;push($post-&gt;title, route('post', $post-&gt;id));}); Rồi sau đó sử dụng trên views thôi123{{ Breadcrumbs::render('home') }}{{ Breadcrumbs::render('category', $category) }} Laravel Befriended (*)Ref: https://github.com/renoki-co/befriended Package này hỗ trợ chức năng như các mạng xã hội, như theo dõi, chặn, lọc nội dung dựa vào những model đã theo dõi và chặn @@ 1234567891011$alice = User::where('name', 'Alice')-&gt;first();$bob = User::where('name', 'Bob')-&gt;first();$tim = User::where('name', 'Tim')-&gt;first();$alice-&gt;follow($bob);$alice-&gt;following()-&gt;count(); // 1$bob-&gt;followers()-&gt;count(); // 1User::followedBy($alice)-&gt;get(); // Just Bob shows upUser::unfollowedBy($alice)-&gt;get(); // Tim shows up Laravel Honeypot (*)Ref: https://github.com/spatie/laravel-honeypotPackage này ngăn chặn spam thông qua việc submit forms. Nó sẽ sinh ra các giá trị ngẫu nhiên, ngăn chặn việc này 1234&lt;form method=&quot;POST&quot; action=&quot;{{ action(App\\Http\\Controllers\\ContactFormSubmissionController::class, 'create') }}&quot;)&gt; @honeypot &lt;input name=&quot;myField&quot; type=&quot;text&quot;&gt;&lt;/form&gt; Laravel DatatablesLaravel Money (*)Ref: https://github.com/cknow/laravel-money Package này giúp bạn cung cấp các phương thức lưu trữ và sử dụng các giá trị tiền tệ 1 cách dễ dàng 123456789101112131415161718192021222324252627282930313233343536373839404142434445use Cknow\\Money\\Money;Money::USD(500)-&gt;add(Money::USD(500)); // $10.00Money::USD(500)-&gt;add(Money::USD(500), Money::USD(500)); // $15.00Money::USD(500)-&gt;subtract(Money::USD(400)); // $1.00Money::USD(500)-&gt;subtract(Money::USD(200), Money::USD(100)); // $2.00Money::USD(500)-&gt;multiply(2); // $10.00Money::USD(1000)-&gt;divide(2); // $5.00Money::USD(830)-&gt;mod(Money::USD(300)); // $2.30 -&gt; Money::USD(230)Money::USD(-500)-&gt;absolute(); // $5.00Money::USD(500)-&gt;negative(); // $-5.00Money::USD(30)-&gt;ratioOf(Money::USD(2)); // 15Money::USD(500)-&gt;isSameCurrency(Money::USD(100)); // trueMoney::USD(500)-&gt;equals(Money::USD(500)); // trueMoney::USD(500)-&gt;greaterThan(Money::USD(100)); // trueMoney::USD(500)-&gt;greaterThanOrEqual(Money::USD(500)); // trueMoney::USD(500)-&gt;lessThan(Money::USD(1000)); // trueMoney::USD(500)-&gt;lessThanOrEqual(Money::USD(500)); // trueMoney::USD(500)-&gt;isZero(); // falseMoney::USD(500)-&gt;isPositive(); // trueMoney::USD(500)-&gt;isNegative(); // falseMoney::USD(500)-&gt;getMoney(); // Instance of \\Money\\Money// AggregationMoney::min(Money::USD(100), Money::USD(200), Money::USD(300)); // Money::USD(100)Money::max(Money::USD(100), Money::USD(200), Money::USD(300)); // Money::USD(300)Money::avg(Money::USD(100), Money::USD(200), Money::USD(300)); // Money::USD(200)Money::sum(Money::USD(100), Money::USD(200), Money::USD(300)); // Money::USD(600)// FormattersMoney::USD(500)-&gt;format(); // $5.00Money::USD(199)-&gt;format(null, null, \\NumberFormatter::DECIMAL); // 1,99Money::XBT(41000000)-&gt;formatByBitcoin(); // \\xC9\\x830.41Money::USD(500)-&gt;formatByDecimal(); // 5.00Money::USD(500)-&gt;formatByIntl(); // $5.00Money::USD(199)-&gt;formatByIntl(null, null, \\NumberFormatter::DECIMAL); // 1,99Money::USD(500)-&gt;formatByIntlLocalizedDecimal(); // $5.00Money::USD(199)-&gt;formatByIntlLocalizedDecimal(null, null, \\NumberFormatter::DECIMAL) // 1.99// ParsersMoney::parse('$1.00'); // Money::USD(100)Money::parseByBitcoin(&quot;\\xC9\\x830.41&quot;); // Money::XBT(41000000)Money::parseByDecimal('1.00', 'USD'); // Money::USD(100)Money::parseByIntl('$1.00'); // Money::USD(100)Money::parseByIntlLocalizedDecimal('1.00', 'USD'); // Money::USD(100) Laravel Avatar (*)Ref: https://github.com/laravolt/avatar Package này giúp bạn hiển thị avatart duy nhất cho mỗi người dùng dựa vào tên (khởi tạo) của họ Laravel Menu (*)Ref: https://github.com/spatie/laravel-menu Package này giúp hiển thị menu sidebar một cách dễ dàng1234567Menu::macro('main', function () { return Menu::new() -&gt;action('HomeController@index', 'Home') -&gt;action('AboutController@index', 'About') -&gt;action('ContactController@index', 'Contact') -&gt;setActiveFromRequest();});123&lt;nav class=&quot;navigation&quot;&gt; {!! Menu::main() !!}&lt;/nav&gt; Laravel MessengerFeature FlagsLaravel TranslatableLaravel Lang (*)Ref: https://github.com/caouecs/Laravel-lang Package hỗ trợ dịch các file sang nhiều loại ngôn ngữ khác nhau Các file ngỗn ngữ ở trong thư mục “vendor/caouecs/laravel-lang” Copy thư mục ngôn ngữ mà bạn muốn vào trong thư mục resources/lang để sử dụng trong ứng dụng của bạn. Laravel Stats Tracker (*)Ref: https://github.com/antonioribeiro/tracker Packge mạnh thực sự, theo dõi RẤT NHIỀU thông tin từ các request đến ứng dụng và lưu trữ lại. Các thông tin theo dõi bao gồm: Sessions Page Views (hits on routes) Users (logged users) Devices (computer, smartphone, tablet…) Languages (preference, language range) User Devices (by, yeah, storing a cookie on each device) Browsers (Chrome, Mozilla Firefox, Safari, Internet Explorer…) Operating Systems (iOS, Mac OS, Linux, Windows…) Geo Location Data (Latitute, Longitude, Country and City) Routes and all its parameters Events Referers (url, medium, source, search term…) Exceptions/Errors Sql queries and all its bindings Url queries and all its arguments Database connections Package này đáng để tìm hiểu xem nó hoạt động như thế nào hơn là việc áp dụng nữa, chắc tích hợp nhiều thứ lắm :v Laravel Vue SPA (*)Ref: https://github.com/cretueusebiu/laravel-vue-spaĐúng như tên gọi của nó, phần này xây dựng các template sẵn, kết hợp Laravel và Vue Đây là cả 1 project chứ không phải là package tích hợp nhé Laravel Sweet Alert (*) Ref: https://github.com/realrashid/sweet-alert Package giúp hiển thị sweet alert cho Laravel123456789101112public function store(PostRequest $request){ $post = Post::create($request-&gt;all()); if ($post) { alert()-&gt;success('Post Created', 'Successfully'); // hoặc có thể dùng alert('Post Created','Successfully', 'success'); } else { alert()-&gt;error('Post Created', 'Something went wrong!'); // hoặc có thể dùng alert('Post Created','Something went wrong!', 'error'); } return redirect()-&gt;route('posts.index');} Laravel GravatarSimple QrCode (*) Ref: https://github.com/SimpleSoftwareIO/simple-qrcode Simple QrCode rất dễ dàng được sử dụng trong Laravel khi làm việc với Bacon/BaconQrCode. Chúng tôi có tạo ra các interface thân thiện và dễ dàng cài đặt cho các người dùng Laravel. Laravel Trix (*)Ref: https://github.com/Te7a-Houdini/laravel-trix Package này giúp bạn có thể cấu hình Basecamp Trix Editor để sử dụng trong ứng dụng Laravel. 12345678910&lt;html&gt; &lt;head&gt; @trixassets &lt;/head&gt; &lt;body&gt; &lt;!-- notice that content field isn't presented in Post model --&gt; @trix(\\App\\Post::class, 'content') &lt;/body&gt;&lt;/html&gt; Laravel Exchange Rates (*)Ref: https://github.com/ash-jc-allen/laravel-exchange-rates Package này tích hợp các API từ trang exchangeratesapi.io. Laravel Exchange Rates cho phép bạn nhận các lịch sủ tỉ giá trao đổi hoặc mới nhất, và có thể chuyển đổi tiền tệ giữa các đơn vị khác nhau. Exchange Rates Between Date Range 12$exchangeRates = new ExchangeRate();$exchangeRates-&gt;exchangeRateBetweenDateRange('GBP', 'EUR', Carbon::now()-&gt;subWeek(), Carbon::now()); Convert Currencies 12$exchangeRates = new ExchangeRate();$exchangeRates-&gt;convert(100, 'GBP', 'EUR', Carbon::now()); Laravel Kustomer (*)Ref: https://github.com/mydnic/laravel-feedback-component Package này thêm các Feedback từ phía khách hàng dưới dạng popup lên website của bạn Demo Laravel DOMPDF (*)Ref: https://github.com/barryvdh/laravel-dompdf Package cho phép bạn thao tác, export file PDF một cách dễ dàng từ các views của Laravel. Bạn có thể lưu nó dưới dạng 1 file, hoặc 1 stream (hiển thị trên trình duyệt) hoặ tải xuống. 123$pdf = App::make('dompdf.wrapper');$pdf-&gt;loadHTML('&lt;h1&gt;Test&lt;/h1&gt;');return $pdf-&gt;stream(); Or sử dụng facade 12$pdf = PDF::loadView('pdf.invoice', $data);return $pdf-&gt;download('invoice.pdf'); Laravel Excel (*)Có 1 tips riêng Intervention Image (*)Ref: http://image.intervention.io/ Một package xử lý ảnh đã quá quen thuộc với người sử dụng Laravel nhỉ :D. Glide (đáng để thử tí đấy nhỉ)Ref: https://github.com/spatie/laravel-glide Đây cũng là một package cung cấp các lớp dễ dàng thao tác với các ảnh trên Laravel. Phần nhân API nó gọi đến trang Glide, một thư viện xử lý hình ảnh theo các yêu cầu cực kì dễ dàng được viết bằng PHP. Laravel Invoices (*)Ref: https://github.com/LaravelDaily/laravel-invoices Package này cung cấp các interface dễ dàng sinh ra Invoice PDF files với dữ liệu dược cung cấp Hóa đơn có thể được lưu, tải xuống hoặc stream trong 1 vài filesystems bạn đã cấu hình. Hỗ trợ nhiều template và ngôn ngữ Laravel Charts (*)Ref: https://charts.erik.cat/installation.html Nếu bạn muốn vẽ biểu đồ mà không sử dụng các thư viện JavaScript, bạn có thể xem xét sử dụng thư viện này nhé. Thư viện này được API của Chart thiết kế, có thể mở rộng và tùy chỉnh, cho phép mọi tùy chọn trong thư viện JavaScript được sử dụng nhanh chóng mà không tốn nhiều công. 12345678910111213141516171819202122232425&lt;?phpnamespace App\\Http\\Controllers;use App\\Charts\\UserChart;use Illuminate\\Http\\Request;class UserChartController extends Controller{ /** * Display a listing of the resource. * * @return \\Illuminate\\Http\\Response */ public function index() { $usersChart = new UserChart; $usersChart-&gt;labels(['Jan', 'Feb', 'Mar']); $usersChart-&gt;dataset('Users by trimester', 'line', [10, 25, 13]) -&gt;color(&quot;rgb(255, 99, 132)&quot;) -&gt;backgroundcolor(&quot;rgb(255, 99, 132)&quot;); return view('users', [ 'usersChart' =&gt; $usersChart ] ); }} Và đây là kết quả Bạn có thể xem thêm tại đây Laravel Media LibraryLaravel PermissionLaravel Bouncer (*)Ref: https://github.com/JosephSilber/bouncer Lại thêm 1 package hỗ trợ quản lý quyền cho 1 vài ứng dụng sử dụng Eloquent models 123456789// Give a user the ability to create postsBouncer::allow($user)-&gt;to('create', Post::class);// Alternatively, do it through a roleBouncer::allow('admin')-&gt;to('create', Post::class);Bouncer::assign('admin')-&gt;to($user);// You can also grant an ability only to a specific modelBouncer::allow($user)-&gt;to('edit', $post); Laravel Impersonate (*)Ref: https://github.com/404labfr/laravel-impersonate?ref=madewithlaravel.com Laravel Impersonate đơn giản hóa việc xác thực việc xác thực như 1 người dùng nào đó. Tiếng anh impersonate có nghĩa là mạo danh. Cái này chắc để làm chức năng xem tường như 1 vai trò của người khác của Facebook đấy =)) 12345678/* Impersonate a user */Auth::user()-&gt;impersonate($other_user);// You're now logged as the $other_user/* Leave impersonation */Auth::user()-&gt;leaveImpersonation();// You're now logged as your original user. Laravel Masterpass (*)Ref: https://github.com/imanghafoori1/laravel-MasterPass Built with ❤️ for every smart laravel developer Package giúp bạn cài đặt 1 master password trong file .env và login vào bất kỳ tài khoản nào với nó để mạo danh người dùng. Điều đó có nghĩa mỗi tài khoản sẽ có 1 mật khẩu hợp lệ. Một mật khẩu gốc và master password. Điều này cũng giúp bạn trong quá trình develop và testing bạn muốn đăng nhập nhiều usernames và không muốn nhớ tất cả các mật khẩu đúng của họ cho mỗi tài khoản test. Nó cũng hoạt động nếu bạn sử dụng Laravel-passport. 1$bool = Auth::isLoggedInByMasterPass(); Trên view thì sao123@if(Auth::isLoggedInByMasterPass()) Your are here by master password.@endif JWT Auth (*)Laravel Ban (*)Ref: https://github.com/cybercog/laravel-ban Laravel Ban dễ dàng quản lý các Eloquent model bị ban. Trường hợp sử dụng không bị giới hạn với User model, 1 vài Eloquent model có thể bị ban: Tổ chức, Team, Nhóm và 1 vài điều khác. isAuth (*)Ref: https://github.com/spiderwebtr/isauth Package này giúp bạn kiểm tra nếu 1 người dùng hết session trước khi submit forms. Nếu session đã hết, 1 modal sẽ hiển thị lên 1 vài thông tin người dùng và yêu cầu mật khẩu để đăng nhập lại. Laravel Test Factory Generator (*)Package hỗ trợ bạn sinh factories từ các model đã tồn tại sẵn để bạn có thể tiến hành test ứng dụng của mình 1 cách nhanh chóng. Ví dụ kết quả của model 1234567891011121314151617Schema::create('users', function (Blueprint $table) { $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;string('username'); $table-&gt;string('email')-&gt;unique(); $table-&gt;string('password', 60); $table-&gt;integer('company_id'); $table-&gt;rememberToken(); $table-&gt;timestamps();});class User extends Model { public function company() { return $this-&gt;belongsTo(Company::class); }} Sau khi chạy 1php artisan generate:model-factory Sẽ được như sau: 12345678910$factory-&gt;define(App\\User::class, function (Faker\\Generator $faker) { return [ 'name' =&gt; $faker-&gt;name, 'username' =&gt; $faker-&gt;userName, 'email' =&gt; $faker-&gt;safeEmail, 'password' =&gt; bcrypt($faker-&gt;password), 'company_id' =&gt; factory(App\\Company::class), 'remember_token' =&gt; Str::random(10), ];}); Laravel Test Tools (sẽ thử, ít nhất 1 lần)Ref: https://chrome.google.com/webstore/detail/laravel-testtools/ddieaepnbjhgcbddafciempnibnfnakl?hl=en Một extension có khả năng sinh ra các test tích hợp trong khi bạn sử dụng ứng dụng Important note: If you want to use the new “Import Factories” feature, you need to manually allow the chrome extension to access file URLs.You can do so by visiting chrome://extensions , search for the “Laravel TestTools” extension and activate the checkbox “Allow access to file URLs”. Dusk Dashboard (cũng sẽ thử)Ref: https://github.com/beyondcode/dusk-dashboard A beautiful dashboard for your Dusk test suites. Paratest (cũng cần thử luôn =)))Ref: https://github.com/paratestphp/paratest Mục đích của ParaTest là hỗ trợ việc test song song trong PHPUnit. Một khi các PHPUnit của bạn được viết tốt, bạn có thể bỏ qua paratest trong project của mình và bắt đầu sử dụng nó mà không cần thêm bootstrap hoặc cấu hình nào. Lợi ích của việc chạy test song song: Kết quả báo báo sẽ được kết hợp lại. Chạy các test của bạn trong N tiếng trình song song và tất cả các đầu ra sẽ được gộp lại trong 1 report Không cần cấu hình. Sau khi cài đặt, bạn có thể chạy luôn với vendor/bin/paratest -p4 path/to/tests Linh hoạt. Cô lập các files test và tách biệt quá trình riêng, hoặc tận dụng WrapperRunner để chạy test nhanh hơn. Lưu ý khi tối ưu tốc độ: Để nhận được các test song song 1 cách tốt nhất, bạn phải điều chỉnh các tham số thật cẩn thận. Laravel MojitoRef: https://github.com/nunomaduro/laravel-mojito Đây là một package nhẹ phục vụ cho việc testing Laravel views. Mojito được tạo và maintain bởi ]Nuno Maduro](https://nunomaduro.com/), blog nhiều chủ đề hay đấy chứ. Dom CrawlerRef: https://github.com/symfony/dom-crawler Package này “tẩy” DOM cho các tài liệu XML và HTML, tránh bị crawler từ trang web khác. Laravel Translation (nên thử nào)Ref: https://github.com/joedixon/laravel-translation Package quản lý các file đã ngôn ngữ, quốc tế quá trong ứng dụng của bạn. Đặc biệt, nó cung cấp giao diện làm việc hiệu quả. It exposes a user interface allowing you to update existing and add new translations to your application. LarastanRef: https://github.com/nunomaduro/larastan Lại thêm 1 package nữa của thanh niên Nuno Maduro. Larastan tập trung vào việc tìm ra lỗi trong code của bạn mà không thực sự chạy chúng. Nó bắt được tất cả các lớp lỗi thậm chí trước khi bạn viết test cho code. Laravel Phone (nên thử nè)Ref: https://github.com/Propaganistas/Laravel-Phone Package giúp bạn làm việc với số điện thoại. Bạn có thể validate và format số điện thoại. Demo: https://laravel-phone.herokuapp.com/ Laravel Image OptimizerRef: https://github.com/spatie/laravel-image-optimizer Thêm 1 thử viện nữa xử lý ảnh. Khác với các thư viện trước cung cấp các phương thức chỉnh ảnh theo kích thước, xoay ảnh … thì package này tập trung vào việc tối ưu ảnh. Nó có thể tối ưu các ảnh PNGs, JPGs, SVGs, và GIFs bằng cách chạy chúng với các tool tối ưu ảnh CollisionRef: https://github.com/nunomaduro/collision Thêm một công cụ từ Nuno Maduro. Một công cụ báo cáo lỗi đẹp cho ứng dụng dòng lệnh IgnitionRef: https://github.com/facade/ignition Nếu như Collision là công cụ báo lỗi đẹp hơn cho chế độ dòng lệnh thì Ignition lại là công cụ báo lỗi đẹp hơn cho ứng dụng Laravel =)) NestedsetRef: https://packagist.org/packages/kalnoy/nestedset Một package giúp bạn làm việc với dữ liệu đệ quy. Như các category hay làm chẳng hạn 12345678910111213$node = Category::create([ 'name' =&gt; 'Foo', 'children' =&gt; [ [ 'name' =&gt; 'Bar', 'children' =&gt; [ [ 'name' =&gt; 'Baz' ], ], ], ],]); Purifier (nên thử)Ref: https://github.com/mewebstudio/purifier Bộ lọc thẻ HTML cho ứng dụng Laravel 1clean(Input::get('inputname')); Laravel JS LocalizationRef: https://github.com/rmariuzzo/Laravel-JS-Localization Package hỗ trợ I18n cho các file JavaScript 123Lang.get('messages.home');Lang.get('messages.welcome', { name: 'Joe' }); Tài liệu tham khảohttps://codewithdre.com/useful-laravel-packages","link":"/2020/04/26/Laravel-Useful-Laravel-Packages/"},{"title":"The special day 0415","text":"2ddbc3bd71845ae67239e8bd8306a0e4bd7af3ccbcf2befca77ff9e4e27ba55089de1b6226ea0b6709e9a9fd9ac31fcc0cd5ac2d65bedec8aeed10590c0a4d061830f18309410c75b5d435d0db0453548d8d3a8359695e21116e73f65449f96c4362069aa8141f414bf734ab7c9569e35334469efc703bdab61984d3b8ed72b7341ae3fc113af5c96ac819265216e9c6ff58d2d9748cd2b42694b45ce73453c3863d0aeb122113a30cfc1efdeb2965f73f5672a0d4ca20f3712d8c4aad5adf0f40483a19be905979ead94038e08de2ed1cec53a0dea72a3f1506fe19b6139c7998559a8ab90ef5228149ce59976a6df66f36c5c82e911afab4c0d836efc0aca2ccc09814734d423d864486cd81b8536c8aaed751bca88434a7e4c517efbf09abc3a7422cb9fc7a7245f08540655fce232fe14fcddafe5fc58d8cc5804d1a31f6561b12671c40c8923e50fdb6c45b67eeb9265c4f9bd98601ea7f70199bde89fc7e157ccfa875f336305fbbcb2e2b9e5749b1610e1e3b94f05c9b9b4203b5e00db696ef89ea2089c110705aaa76d46c80049d62a8a45b3984e2ccb41968d02f8554db442d14a239f438ba57b0a3453069dd9fe925c9a520e0e8ef7816460690cead444f670ba623a0bd16128c236c743ccde811fa9c0f460ea22d1a8d18fe72c38760d98eeffc6884888688421fab21e110bc16f9ad29f3c6c9aac9a3cca322c009d20dc53b627d9827d56c1d26b9285d4cbcb87d25269b69b0b81e97afdebe85000a9c88dfa8b0d4f62969da494da0cffb3e4b878c7086a5ad987827ca56163f1be5b9e2036b370749113770b1127baf5006e19b0ad078dbcc6dbb25d7487fb32c146d62d497210e18295566b181620a5ff20743cf33e4fec8c37571674a8b287aa9918d251c6d6dfccec1f5e94a494eb0ff305532a8df9ea5bea84504bedfe22b75ef723919a06313a16976e24d1f13efc2c4fd55649ed38c1e1732843db8e78db1a4ba25fab93804bc944980e700682689df6612047a528c230e71293c1ed2644d4dba0836139696a6237b2f62ba93d880bb73b17ba9661cda259c35990c9067a94b733ce07012ee20b214f9a9309f426675f44f831fa9bdf559568e7921c1b9198a7a0210a46aee86467d740ce4a372fa08212c4dde71525395a15658bfa88afd14a59fe47a46fa8570663088dcc9a11b3a9e2b929bc60d2b766c521dc59b30db48c67f65a32449769a05bad1dc37ed152bf4c215e1a83e266b79ff22b49e85f8b658bbfba3233731e2451344796bf115bd3f57c79b59d22435b980832dd0dbd74f7c9be276d6b89916577f4d3b0249a218f82d2c25e596518ced697a7957e071cd169c7b6a51b4ee7d34c2d2f031d903cbdb04f3281f84336ac6d0b210a1 Hey, password is required here.","link":"/2021/04/16/The-special-day-0415/"},{"title":"Section 4: IAM - Identity and Access Management","text":"IAM là viết tắt của Identity and Access Management, service này sẽ có phạm vi region là Global IAM Introduction: Users, Groups, PoliciesUser and Group Tài khoản root sẽ được tạo mặc định, bạn không nên được sử dụng, càng không nên chia sẻ cho ai Users: là mọi người trong cùng một tổ chức và có thể được nhóm lại. Users trong IAM có thể không thuộc về group nào hoặc cũng có thể thuộc về nhiều group. Tuy nhiên, theo best practice thì user vẫn nên thuộc ít nhất 1 group Policies: Định nghĩa bạn được làm gì theo các service của hệ thống. Mặc định AWS cũng đã có rất nhiều Policies, bạn hoàn toàn có thể custom thêm theo ý của mình. Policy có thể được gán với cả Roles và Groups Group: chỉ chứa users, không chứa nhóm khác Lab 01: IAM Users &amp; Groups Hands On? So why do we create users and why do we create groups? PermissionsUser hoặc Groups có thể được gán JSON documents được gọi trong Policies. Định nghĩa các quyền cho users được truy cập tài nguyên nào. Permissions có thể được thể hiện dưới dạng JSON, hoặc giao diện trên AWS Console. 123456789101112131415161718192021222324{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;ec2:Describe*&quot;, &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;elasticloadbalancing:Describe*&quot;, &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;cloudwatch:ListMetrics&quot;, &quot;cloudwatch:GetMetricStatistics&quot;, &quot;cloudwatch:Describe*&quot; ], &quot;Resource&quot;: &quot;*&quot; } ]} Như ở trên ta có thể nhìn thấy một permission được thể hiện dưới dạng JSON Effect: Hành động được phép hoặc không Action: Các actions GET, LIST, DESCRIBE .. được AWS định nghĩa ra Resource: Tài nguyên nào Hãy cố gắng đảm bảo nguyên tắc tối thiểu hóa quyền truy cập - least privilege principle cho các user bạn tạo Lab 02: IAM Policies Hands OnPassword Policy + MFAĐể đảm bảo tài khoản của mình được bảo mật hơn, hãy sử dụng Password Policy và MFA Password Policy là phần đưa ra các chính sách cho mật khẩu của tài khoản đang sử dụng: Set a minimum password length Require specific character types: including uppercase letters lowercase letters numbers non-alphanumeric characters Allow all IAM users to change their own passwords Require users to change their password after some time (password expiration) Prevent password re-use Để setting Password Policy, hãy vào IAM =&gt; Account Setting =&gt; Change Password Policy Multi Factor Authentication: giúp bảo mật tài khoản nhiều lớp hơn. Có rất nhiều thiết bị phần cứng lưu trữ Token tài khoản, tuy nhiên trong hướng dẫn, chúng ta đề cập đến các phần mềm Virtual MFA Application (Authy, Duo Mobie, …) Để enable MFA, từ màn hình Dashboard, bạn có thể thấy nó trong phần Security alerts =)) AWS CLIĐầu tiên để có thể truy cập được AWS, chúng tôi đưa cho bạn 3 tùy chọn AWS Management Console (protected by password + MFA) AWS Command Line Interface (CLI): protected by access keys AWS Software Developer Kit (SDK) - for code: protected by access keys • Access Key ID ~= username • Secret Access Key ~= password Trong đó CLI là một trong số các cách tương tác, sử dụng các cặp access keyss Remember: don’t share your access keys How can users access AWS ?Sử dụng cli1234$ aws configure=&gt; Điền các thông tin login$ aws iam list-users CloudShell=&gt; Tương đồng CLI khi bạn đã configuration IAM Roles for AWS ServicesMột vài các dịch vụ của AWS cần thực hiện các action thay bạn. Để làm được việc đó, chúng ta sẽ gán permission tới các service với IAM Roles Một vài Roles phổ biến bạn sẽ sử dụng: EC2 Instance Roles Lambda Function Roles Roles for CloudFormation So we need to assign permissions to AWS services and to do so, we’re going to create what’s called an IAM Role. So these IAM role will be just like a user, but they are intended to be used not by physical people, but instead they will be used by AWS services. Ví dụ như role EC2, EC2 đó như 1 user, cấp role tương tác với S3 Service (Hoặc các dịch vụ thêm như CloudWatch,…) 27. IAM Security Tools IAM Credentials Report (account-level) =&gt; Ở Dashboard chọn Credential Report A report that lists all your account’s users and the status of their various credentials IAM Access Advisor (user-level) =&gt; Users =&gt; Chọn 1 user cụ thể =&gt; Access Advisor Access advisor shows the service permissions granted to a user and when those services were last accessed. You can use this information to revise your policies. Lab 03: IAM Security Tools Hands On29. IAM Best Practices Don’t use the root account except for AWS account setup One physical user = One AWS user =&gt; 1 user thật dùng 1 tài khoản AWS, bạn có thể tạo nhiều tài khoản nhưng đừng share dùng chung Assign users to groups and assign permissions to groups Create a strong password policy Use and enforce the use of Multi Factor Authentication (MFA) Create and use Roles for giving permissions to AWS services Use Access Keys for Programmatic Access (CLI / SDK) Audit permissions of your account with the IAM Credentials Report Never share IAM users &amp; Access Keys 30. Shared Responsibility Model for IAMHiểu là IAM có nhiệm vụ giúp bạn làm gì =)) AWS =&gt; trách nhiệm phần cứng, hạ tầngBạn =&gt; sử dụng nó như thế nào? 31. IAM Summary Users: mapped to a physical user, has a password for AWS Console Groups: contains users only Policies: JSON document that outlines permissions for users or groups Roles: for EC2 instances or AWS services Security: MFA + Password Policy Access Keys: access AWS using the CLI or SDK Audit: IAM Credential Reports &amp; IAM Access Advisor","link":"/2021/05/04/Section-4-IAM-Identity-and-Access-Management/"},{"title":"Section 5&#x2F; EC2 - Elastic Compute Cloud","text":"EC2 là một trong những dịch vụ phổ biến nhất được yêu cầu trong AWS EC2 = Elastic Compute Cloud = Infrastructure as a Service Một vài dịch vụ liên quan đến EC2: Renting virtual machines (EC2) Storing data on virtual drives (EBS) Distributing load across machines (ELB) Scaling the services using an auto-scaling group (ASG) EC2 sizing &amp; configuration options Operating System (OS): Linux or Windows How much compute power &amp; cores (CPU) How much random-access memory (RAM) How much storage space: Network-attached (EBS &amp; EFS) hardware (EC2 Instance Store) Network card: speed of the card, Public IP address Firewall rules: security group Bootstrap script (configure at first launch): EC2 User Data Lab 01. Create an EC2 Instance with EC2 User Datato have a Website Hands On Khi mà stop rồi start lại EC2 thì public IP thay đổi còn private IP thì không So this really demonstrates the power of the cloud. While my instance is running, I’m going to pay for it. And if I stop it, I’m not going to pay for it And I can terminate my instance at any time I want. I can also request one instance or 100 instances when I want. And so this is really a huge shift in the mindset from traditional IT on-premises. When you’re on-premises, you have to order your servers, get it delivered, you plug it into your infrastructure, and you use them for the next three to five years. But in the cloud, we’re talking about seconds, and you can get rid of it at any time whenever you want. And this huge change, thanks to the cloud, is making IT so flexible that it allows people to run companies with a very, very little IT department. 36. EC2 Instance Types Basicshttps://aws.amazon.com/ec2/instance-types/ General Purpose Compute Optimized Memory Optimized Accelerated Computing Storage Optimized Instance Features Measuring Instance Performance AWS has the following naming convention: m5.2xlarge m: instance class 5: generation (AWS improves them over time) 2xlarge: size within the instance class Compare EC2 Types: https://www.ec2instances.info/ General PurposePhục vụ tốt cho các công việc như web servers hoặc lưu trữ code (code repository) These instances are ideal for applications that use these resources in equal proportions such as web servers and code repositories. Cần cân bằng giữa: Compute Memory Networking Trong phạm vi khoá học, chúng tôi sẽ sử dụng t2.micro như là một General Purpose EC2 instance Compute OptimizedSử dụng cho các tác vụ tính toán đòi hỏi bộ vi xử lý hiệu suất cao Batch processing workloads Media transcoding High performance web servers High performance computing (HPC) Scientific modeling &amp; machine learning Dedicated gaming servers Memory OptimizedHiệu suất nhanh chóng cho khối lượng công việc xử lý tập dữ liệu lớn trong bộ nhớ Một vài trường hợp sử dụng Floating point number calculations Graphic processing Data pattern matching Storage OptimizedSử dụng cho các tác vụ lưu trữ nhiều đòi hỏi quyền truy cập cao, đọc và ghi tuần tự vào các tập dữ liệu lớn trên bộ nhớ cục bộ (local storage) Một vài trường hợp sử dụng High frequency online transaction processing (OLTP) systems Relational &amp; NoSQL databases Cache for in-memory databases (for example, Redis) Data warehousing applications Distributed file systems Security Groups &amp; Classic Ports OverviewSecurity Group là khái niệm cơ bản về network security trên EC2, chúng kiểm soát các luồng mạng ra và vào EC2 Security Group có thể được gán bằng địa chỉ IP hoặc từ security group Security Group hoạt động tương tự Firewall trên EC2 Instance Chúng điều tiết Access to Ports Authorised IP ranges – IPv4 and IPv6 Control of inbound network (from other to the instance) Control of outbound network (from the instance to other) Lab 02: Security Groups Hands OnSSH OverviewVới Windows, sẽ sử dụng PuttySSH TroubleshootingLab 03: EC2 Instance Roles Demo (IAM Roles)EC2 Instances Purchasing Options On-Demand Instance: sử dụng cho các công việc ngắn, chi phí có thể đoán trước Reserved: (MINIMUM 1 year) Reserved Instances: công việc dài Convertible Reserved Instances: công việc dài với instance linh hoạt Scheduled Reserved Instances: example – everyThursday between 3 and 6 pm Spot Instances: công việc ngắn, rẻ, và có thể mất instances (ít độ tin cậy hơn) Dedicated Hosts: đặt toàn bộ máy chủ vật lý (physical server) kiểm soát được nơi đặt instance Dedicated Instances: Không một khách hàng nào khác có thể chia sẻ phần cứng của bạn On-Demand Trả phí tuỳ thuộc bạn sử dụng Linux: trả mỗi giây, sau phút đầu Các hệ điều hành khác (như Windows): trả theo giờ Có chi phí cao nhất nhưng không phải trả trước Không có các cam kết sử dụng lâu dài Khuyến khích với công việc short-term (ngắn hạn) và không bị gián đoạn, nơi mà bạn không thể dự đoán được ứng dụng sẽ hoạt động ra sao EC2 Reserved Instances (Instance đặt trước) Tiết kiệm 72% chi phí so với On-demand Thời gian đặt trước: 1 year = + discount | 3 years = +++ discount Tuỳ chọn thanh toán: Không trả trước | Trả trước 1 phần =+ | Trả trước hết =++ discount Đặt trước 1 loại instance cụ thể Nên dùng với các ứng dụng với trạng thái ổn định (như database) Convertible Reserved Instance - Instance đặt trước có thể chuyển đổi Có thể thay đổi EC2 instance type Giảm 45% Schedule Reserved Instance Khởi chạy trong khoảng thời gian đặt trước Khi bạn yêu cầu phần nhỏ công việc 1 ngày/tuần/tháng Cam kết 1 năm duy nhất EC2 Spot Instances Có thể chiết khẩu tới 90% so với On-demand Các instances có thể “mất” bất cứ lúc nào nếu giá cao nhất của bạn nhỏ hơn giá hiện tại của spot Phiên bản tiết kiệm chi phí nhất trong AWS Hữu ích cho các công việc “resilient to failure”? Batch jobs Phân tích dữ liệu Xử lý ảnh Một vài công việc phân tán Công việc với thời gian bắt đầu và kết thúc linh hoạt Không thích hợp với các công việc và database quan trọng EC2 Dedicated Hosts Máy chủ lưu trữ chuyên dụng Amazon EC2 là máy chủ vật lý có dung lượng phiên bản EC2 hoàn toàn dành riêng cho việc sử dụng của bạn. Máy chủ chuyên dụng có thể giúp bạn giải quyết các yêu cầu tuân thủ và giảm chi phí bằng cách cho phép bạn sử dụng giấy phép phần mềm ràng buộc máy chủ hiện có của mình. Được phân bổ vào tài khoản của bạn để ứng trước 3 năm Chi phí rất đắt Hữu ích cho các phần mềm có mô hình cấp phép phức tạp (BYOL – Bring Your Own License) Hoặc đối với các công ty có nhu cầu tuân thủ hoặc quản lý chặt chẽ EC2 Dedicated Instances Instance chạy trên phần cứng dành riêng cho bạn Có thể chia sẻ phần cứng với các instance khác trong cùng tài khoản Không kiểm soát nơi đặt instance (có thể di chuyển phần cứng sau khi Start/Stop) Which purchasing option is right for me? On-deman: đến và ở lại resort bất cứ khi nào chúng tôi muốn, chúng tôi trả toàn bộ giá Đặt trước: như lên kế hoạch trước và nếu định ở lâu dài thì có thể được chiết khấu tốt. Instance tại chỗ (Spot Instance): khách sạn cho phép mọi người đấu giá các phòng trống và người trả giá cao nhất sẽ giữ phòng. Bạn có thể bị đuổi ra khỏi phòng bất cứ lúc nào. Dedicated Hosts: Chúng tôi đặt toàn bộ tòa nhà của khu nghỉ mát So sánh về giá các Instance Summary EC2 Instance: AMI (OS) + Instance Size (CPU + RAM) + Storage + security groups + EC2 User Data Security Groups: Firewall attached to the EC2 instance EC2 User Data: Script launched at the first start of an instance SSH: start a terminal into our EC2 Instances (port 22) EC2 Instance Role: link to IAM roles Purchasing Options: On-Demand, Spot, Reserved (Standard + Convertible + Scheduled), Dedicated Host, Dedicated Instance","link":"/2021/05/04/Section-5-EC2-Elastic-Compute-Cloud/"},{"title":"Section 6&#x2F; EC2 Instance Storage","text":"An EBS (Elastic Block Store) Volume is a network drive you can attach to your instances while they run Nó cho phép các instance của bạn duy trì dữ liệu, ngay cả khi chúng đã chấm dứt (termination) Chúng chỉ có thể gán vào 1 instance trong 1 thời điểm (CCP level) Chúng bị ràng buộc bởi một availability zone cụ thể Sự tương đồng: Hãy nghĩ chúng như là 1 “network USB stick” Free tier: 30GB free lưu trữ EBS SSD hoặc nhận theo mỗi tháng Nó là một network drive (không phải là drive vật lý) Nó sử dụng mạng để giao tiếp với các instance, điều đó có nghĩa sẽ có độ trễ Nó có thể được detach từ 1 EC2 instance và attech với 1 EC2 khác một cách nhanh chóng Nó “bị khoá” ở 1 Availability Zone (AZ) Một EBS Volume ở us-east-1a không thể attach vào us-east-1b Để di chuyển 1 volume, trước tiên bạn cần tạo snapshot cho nó Có dung lượng được cung cấp (size in GBs và IOPS) Bạn sẽ được lập hoá đơn cho tất cả các dung lượng được cung cấp Bạn có thể tăng dung lượng theo thời gian Lab 01: EBS Hands OnEBS Snaphots Cho phép bạn tạo một bản backup (snapshot) EBS volume của bạn tại 1 thời điểm Không nhất thiết bạn phải detach volume ra để tạo snapshot nhưng đây là lời khuyên Với snapshot, bạn có thể copy volume qua AZ hoặc Region Lab 02: EBS Snapshots Hands OnTổng quan về AMI AMI = Amazon Machine Image AMI là một EC2 Instance đã được tuỳ chỉnh Ví dụ như bạn có thể thêm các phần mềm, cấu hình, hệ điều hành, các chương trình giám sát … vào EC2 Thời gian boot/cấu hình nhanh chóng vì tất cả các phần mềm đã được “đóng gói sẵn” AMI được build đối với một region cụ thể (và có thể được copy giữa các regions) Bạn có thể lauch EC2 Instance từ Một public AMI: AWS cung cấp AMI của bạn: bạn tạo ra và bảo trì nó Một AWS Marketplace AMI: Một AMI do ai đó tạo ra và có thể bán Tạo AMI (Từ EC2 Instance) Đầu tiên bạn sẽ start một EC2 Instance và tuỳ chỉnh nó Stop instance này (để đảm bảo toàn vẹn dữ liệu) Build một AMI - bạn cũng có thể tạo EBS Snapshots Lauch các instance từ các AMIs EC2 Image Builder Được sử dụng để tự động tạo các Virtual Machines hoặc các container images=&gt; Tự động tạo, maintain, validate và test EC2 AMIs Bạn có thể chạy theo một schedule (hằng tuần, bất cứ khi nào các package được cập nhật …) Đây là một dịch vụ miễn phí (chỉ trả tiền cho các tài nguyên cơ bản) Lab 04: EC2 Image Builder Hands OnEC2 Instance Store EBS Volumes là các network drives, rất tuyệt vời nhưng cũng có những hạn chế Nếu bạn cần một ổ cứng (hardware disk) với hiệu suất cao, sử dụng EC2 Instance Store Hiệu suất I/O tốt hơn EC2 Instance Store sẽ mất bộ nhớ nếu chúng bị tạm dừng Nó tốt cho việc sử dụng cho các nội dung buffer / cache / scratch data / nội dung tạm thời Nó có rủi ro với dữ liệu nếu phần cứng lỗi Phần backup và sao lưu là trách nhiệm của bạn EFS - Elastic File System Managed NFS (network file system) that can be mounted on 100s of EC2 EFS làm việc với Linux EC2 Instance trong multi-AZ Highly available, scalable, expensive (3x gp2), pay per use, no capacity planning EBS vs EFS Shared Responsibility Model for EC2 StorageAWS Infrastructure Replication for data for EBS volumes &amp; EFS drives Replacing faulty hardware Ensuring their employees cannot access your data You Setting up backup / snapshot procedures Setting up data encryption Responsibility of any data on the drives Understanding the risk of using EC2 Instance Store Summary EBS volumes: network drives attached to one EC2 instance at a time Mapped to an Availability Zones Can use EBS Snapshots for backups / transferring EBS volumes across AZ AMI: create ready-to-use EC2 instances with our customizations EC2 Image Builder : automatically build, test and distribute AMIs EC2 Instance Store: High performance hardware disk attached to our EC2 instance • Lost if our instance is stopped / terminated EFS: network file system, can be attached to 100s of instances in a region","link":"/2021/05/08/Section-6-EC2-Instance-Storage/"},{"title":"Section 7 - ELB &amp; ASG - Elastic Load Balancing &amp; Auto Scaling Groups","text":"Tìm hiểu 1 chút về ELB và Auto Scaling Group High Availability, Scalability, Elasticity Tính mở rộng có nghĩa là 1 ứng dụng / hệ thống có thể xử lý việc đáp ứng tải tốt hơn. Có 2 loại scale trong AWS Vertical: mở rộng theo chiều dọc, tăng phần cứng từ t2.micro lên t2.large. Kiểu scale này rất phổ biến cho các ứng dụng không phân tán, như database. Horizontal = elasticity: mở rộng theo chiều ngang, tăng số lượng instance/systems cho ứng dụng của bạn. Nó thích hợp cho các ứng dụng phân tán, và sử dụng chung cho các ứng dụng web, ứng dụng hiện đại. Scalability is linked but different to High Availability High Availability Thường đi đôi với việc mở rộng theo chiều ngang High Availability có nghĩa là chạy ứng dụng / hệ thống tại ít nhất 2 Availability Zones Mục đích là tính khả dụng cao, vẫn tồn tại dữ liệu mặc dù sự cố ở dữ liệu trung tâm (thảm hoạ)High Availability &amp; Scalability For EC2 Vertical Scaling: Increase instance size (= scale up / down) From: t2.nano - 0.5G of RAM, 1 vCPU To: u-12tb1.metal – 12.3 TB of RAM, 448 vCPUs Horizontal Scaling: Increase number of instances (= scale out / in) Auto Scaling Group Load Balancer High Availability: Run instances for the same application across multi AZ Auto Scaling Group multi AZ Load Balancer multi AZ Scalability vs Elasticity (vs Agility) Scalability: khả năng đáp ứng tải lớn hơn bằng cách làm cho phần cứng mạnh hơn (mở rộng quy mô - scale up) hoặc bằng cách thêm các nút (mở rộng quy mô - scale out) Elasticity: một khi hệ thống có thể mở rộng, độ co giãn có nghĩa là sẽ có một số “auto-scaling” để hệ thống có thể mở rộng quy mô dựa trên tải. Đây là “cloud-friendly”: trả tiền cho mỗi lần sử dụng, phù hợp với nhu cầu, tối ưu hóa chi phí Agility: (không liên quan đến khả năng mở rộng - đánh lạc hướng) các tài nguyên CNTT mới chỉ cách bạn một cú nhấp chuột, có nghĩa là bạn giảm thời gian cung cấp các tài nguyên đó cho các nhà phát triển của mình từ vài tuần xuống chỉ vài phút. Elastic Load Balancing (ELB)Đằng sau việc cân bằng tải được quản lý bởi AWS, chúng ta sẽ có nhiều EC2 Instances Why use a load balancer? Phân tải tới nhiều Instance Chỉ sử dụng 1 điểm truy cập (DNS) cho ứng dụng của bạn Seamlessly handle failures of downstream instances Health check thường xuyên với các instance của bạn Provide SSL termination (HTTPS) for your websites Khả dụng với các zonesWhy use an Elastic Load Balancer? Một ELB (Elastic Load Balancer) sẽ là một quản lý cho việc cân bằng tải AWS đảm bảo rằng nó sẽ hoạt động AWS quan tâm vụ update, bảo trì và tính khả dụng cao AWS cung cấp chỉ 1 vài cấu hình cho bạn Sẽ tốn ít chi phí hơn để thiết lập bộ cân bằng tải của riêng bạn nhưng sẽ tốn nhiều công sức hơn về phía bạn (bảo trì, tích hợp) 3 loại cân bằng tải mà AWS cung cấp (các layer tính theo TCP method - 7 tầng) Application Load Balancer (HTTP / HTTPS only) – Layer 7 Network Load Balancer (ultra-high performance, allows for TCP) – Layer 4 Classic Load Balancer (slowly retiring) – Layer 4 &amp; 7 Classic Load Balancer là một phần của thế hệ cũ cung cấp từ AWS, nó đang dần ngừng hoạt động.Nó cung cấp cân bằng tải Layer 4 và 7 cùng 1 lúc. Và một ngày đẹp trời, AWS đã quyết định tách Classic Load Balancer thành hai loại mới hơn là Application Load Balance và Network Load Balancer riêng biệt About the Gateway Load Balancer Mới được release vào 10/11/2020 Thông thường, phải mất 6 tháng để một dịch vụ mới được đưa vào kỳ thi. Tôi cũng không nhất thiết tin rằng đây sẽ là trọng tâm của kỳ thi vì nó khá nâng cao. Thêm nữa, phần này sẽ tìm hiểu trong phần VPC sẽ hợp lý hơn Lab 01: ALB Hands onAuto Scaling Groups (ASG) OverviewWhat’s an Auto Scaling Group? Trên thực tế, tải trên web của bạn có thể thay đổi Trên cloud, bạn có thể tạo và thoát khỏi server siêu nhanh Mục đích của Auto Scaling Group: Scale out (thêm EC2 Instances) để phù hợp thêm tải Scale in (xoá EC2 Instance) để phù hợp với việc giảm tải Chắc chắn rằng chúng ta luôn có số lượng tối thiểu và tối đa số lượng machine đang chạy Tự động đăng kí các instance mới vào cân bằng tải Thay thế các unhealthy instances Cuối cùng, trong trường hợp một trong các máy chủ của chúng tôi trở nên không khỏe mạnh,có thể có một lỗi ứng dụng, thì auto scaling group có thể phát hiện ra nó, chấm dứt nó và thay thế bằng một Instance “khoẻ mạnh” Auto Scaling Group In AWS: Chúng tôi có kích thước tối thiểu, có thể đó là một phiên bản EC2. Sau đó, có một cài đặt được gọi là dung lượng mong muốn, cũng thường là kích thước thực tế của Auto Scale Group và cuối cùng, bạn có thể xác định kích thước tối đa của nhóm chia tỷ lệ tự động của bạn và tự động ASG của bạn, có thể mở rộng khi cần thiết hoặc mở rộng quy mô khi cần bằng cách thêm các phiên bản EC2 theo thời gian và nó hoạt động song song với bộ cân bằng tải. Auto Scaling Group in AWS Auto Scaling Group in AWS With Load BalancerTất nhiên rằng Auto Scaling Group không thể hoạt động riêng lẻ, nó cần kết hợp Load Balancer để cân bằng tải cho hệ thống Lab 02: Auto Scaling Groups (ASG) Hands OnELB SummaryHigh Availability - Scalability - ElasticityIt is very important for you to understand, to which concept corresponds to which features. For example, high availability means that you are having your applications across multiple availability zone. Vertical scaling means that you are increasing the size of an instance, and horizontal scaling that, is that you are increasing the number of instances. Elasticity is the ability to scale up and down based on demand. And agility is the concept of the cloud that is going to be able to make you work faster because you can create and delete resources very very quickly. And now our Load Balancer, our ELB, are allowing us to distribute traffic across backend EC2 instances and the ELB and the EC2 instances can be set across multiple availability zone therefore enabling us to be highly available. Tôi hiểu High Availability: Nói về tính khả dụng của hệ thống / ứng dụng cho nhiều zone Scalability: Nói về khả năng mở rộng (các cách để mở rộng ứng dụng). Mở rộng theo chiều dọc, tăng phần cứng cho Instance và mở rộng theo chiều ngang, tăng số lượng instance (chỉ nói tăng để đáp ứng khả năng mở rộng) Elasticity: Tính co giãn, khả năng scale up/down phụ thuộc vào nhu cầuElastic Load Balancers (ELB) Distribute traffic across backend EC2 instances, can be Multi-AZ Supports health checks 3 types: Application LB (HTTP – L7), Network LB (TCP – L4), Classic LB (old)Auto Scaling Groups (ASG) Implement Elasticity for your application, across multiple AZ Scale EC2 instances based on the demand on your system, replace unhealthy Integrated with the ELB","link":"/2021/05/08/Section-7-ELB-ASG-Elastic-Load-Balancing-Auto-Scaling-Groups/"},{"title":"Section 8 - S3","text":"S3 là một trong những phần trung tâm xây dựng lên các khối (blocks) trong AWS Nó được quảng cáo là một bộ nhớ “mở rộng vô hạn” Điều đó có nghĩa là bạn có thể lưu trữ bao nhiêu đối tượng tùy thích lên Amazon S3 và cho đến nay, chưa ai có thể sử dụng hết dung lượng lưu trữ của Amazon S3. Đó là lý do tại sao AWS cho biết đó là khả năng mở rộng bộ nhớ vô hạn. S3 dùng để làm gì Rất nhiều websites sử dụng Amazon S3 như một xương sống Rất nhiều dịch vụ AWS có thể tích hợp tốt với S3. Ví dụ như nếu chúng ta tạo một EBS snapshot, và sau đó thực sự snapshot này được lưu trữ trên Amazon S3. Nhưng chúng ta không nhìn thấy, nhưng đó là những gì diễn ra Trong phạm vi chứng chỉ, chúng ta sẽ không nói sâu về S3. Ở level CCP sẽ yêu cầu sâu hơn. S3 Use cases Backup và lưu trữ Khắc phục thảm hoạ: Copy dữ liệu S3 cho nhiều region khác nhau Archive Hybrid Cloud storage Application hosting Mdia hosting Data lakes &amp; big data analytics Software delivery Static website Amazon S3 Overview - Buckets Amazon S3 cho phép mọi người lưu trữ objects (files) trong “buckets” (thư mục) Các Bucket phải có 1 tên duy nhất phạm vi toàn cục (cho tất cả các region tất cả tài khoản) Bucket được định nghĩa ở region level S3 là 1 dịch vụ global nhưng các bucket lại được trong trong 1 region Các chú ý quy tắc đặt tên Không viết hoa Không có kí tự gạch dưới 3-63 kí tự Không là một IP Phải bắt đầu bằng chữ thường hoặc số Amazon S3 Overview - Objects Objects (files) có 1 key Key này là FULL đường dẫn s3://my-bucket/my_file.txt s3://my-bucket/my_folder1/another_folder/my_file.txt Key bao gồm prefix + object name Không có khái niệm “thư mục” trong các buckets (mặc dù nhìn UI bạn có thể nghĩ như vậy) Chỉ có các keys với tên rất dài thì chứa dấu gạch chéo (“/“) Giá trị của objects là nội dung bên trong Max Object Size là 5TB (5000GB) Nếu bạn upload lớn hơn 5GB, phải sử dụng “multi-part upload” Metadata (danh sách key/value - metadata của người dùng hoặc hệ thống) Tags (cặp khoá Unicode - tối đa 10) - hữu ích cho việc bảo mật / vòng đời Version ID (nếu bạn enabled versioning) Lab 01: S3 Hands On Tạo first bucket (S3 không hỗ trợ Global Region) Upload 1 object Open image Object actions =&gt; Open Quay lại màn Detail object. Kick Object URL =&gt; Access DeniedNguyên nhân là bucket chưa public Hãy để ý link open bằng Object action =&gt; looj các my credentials Tạo images folder, up load ảnh vào thư mục này =&gt; xoá folder S3 Security: Bucket Policy Có 2 thứ liên quan đến Security của S3 User based: Từ phía người dùng =&gt; định nghĩa các IAM cho phép người dùng nhất định truy cập IAM Resource Based: Tạo các Bucket Policies Note: Một IAM có thể truy cập một S3 Object nếu Quyền của user IAM cho phép nó HOẶC resource policy CHO PHÉP nó VÀ không có DENY nào S3 Bucket Policies Policies cụ thể hoá dưới dạng JSON12345678910111213 { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;:[ { &quot;Sid&quot;:&quot;AddCannedAcl&quot;, &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;AWS&quot;: [&quot;arn:aws:iam::111122223333:root&quot;,&quot;arn:aws:iam::444455556666:root&quot;]}, &quot;Action&quot;:[&quot;s3:PutObject&quot;,&quot;s3:PutObjectAcl&quot;], &quot;Resource&quot;:&quot;arn:aws:s3:::DOC-EXAMPLE-BUCKET/*&quot;, &quot;Condition&quot;:{&quot;StringEquals&quot;:{&quot;s3:x-amz-acl&quot;:[&quot;public-read&quot;]}} } ]} Resource: buckets and objetcs Action: Tập các API cho phép hoặc từ chối Effect: Allow / Deny Principal: Tài khoản hoặc user áp dụng policy này S3 Object Lock &amp; Glacier Vault LockS3 Object Lock Áp dụng mô hình WORM (Write Once Read Many) Ngăn chặn việc xoá phiên bản của đối tượng trong một khoảng thời gian nhất định Glacier Vault Lock Áp dụng mô hình WORM (Write Once Read Many) Khoá các policy đối với các việc sửa đổi trong tương lai (không thể thay đổi, xoá được nữa) Hữu ích cho việc tuân thủ và lưu trữ dữ liệu Lab 02: S3 Security: Bucket Policy Hands OnPackage =&gt; PermissionĐể có thể sử dụng Bucket Policy, cần disable public accessSo the bucket policy setting is right here,but to write a public bucket policy, I must firstdisable all the public access settingsthat are turned on for these buckets. Sau khi disbale =&gt; Edit Bucket policy Chọn Pplicy generator để sinh được bucket policy Bucket ARN /* =&gt; Sau đó được generate policy dưới dạng JSON =&gt; Click vào Object URL để xem có public chưa S3 Websites S3 có thể làm một host static websites và chúng có thể được truy cập trên www Website URL sẽ có dạng &lt;bucket-name&gt;.s3-website-&lt;AWS-region&gt;.amazonaws.com OR &lt;bucket-name&gt;.s3-website.&lt;AWS-region&gt;.amazonaws.com Nếu bạn nhận lỗi 403 (Forbidden), hãy kiểm tra và chắc chắn rằng các bucket policy cho phép quyền public readLab 03: S3 Websites Hands on Upload file index.html lên S3 Chọn Propertity =&gt; Static Website hostingEnable nó lên :D Làm sao để có thể test=&gt; Kéo xuống và sẽ thấy Bucket website Endpoint=&gt; URL như slide :v S3 Versioning Khi bạn đã có các file trên S3, bạn có thể đánh version cho chúng Chức năng được hỗ trợ với bucket level Khi bạn ghi đè key giống nhau, version sẽ tăng: 1,2,3 S3 Versioning rất hữu ích cho các buckets của bạn Bảo vệ việc xoá file ngoài ý muốn (khả năng khôi phục lại 1 version) Dễ dàng rollback lại các version trước Note Một vài file khi không có version trước đó, khi enable version sẽ có version là “null” Việc tạm dừng version sẽ không xoá các version trước đó Lab 04: Versioning hands On Đầu tiên, enable Bucket Versioning Upload lại file index.html đã được sửa đổi nội dung Click vào xem file index.html =&gt; Version =&gt; thấy 2 version Rollback version cũ: Enable List version. Chọn file cho version hiện tại =&gt; Delete Xoá thử 1 file ảnh và khôi phục dựa vào list version S3 Server Access LoggingWell, chúng ta xem xét ví dụ, dữ liệu đó có thể được phân tích sau này bằng cách sử dụng công cụ phân tích dữ liệu, để thực sự hiểu điều gì đã xảy ra nếu như một tệp đã bị xóa hoặc bạn nhận được yêu cầu tệp quá nhiều, loại thông tin này. Vì vậy, nhật ký truy cập có thể rất, rất hữu ích. Để phục vụ mục đích kiểm tra, bạn có thể muốn ghi toàn bọ log truy cấp tới S3 buckets Bất kì các request nào được gửi tới S3 từ bất kì tài khoản, chấp nhận hoặc từ chối đều được log lại vào S3 bucket khác Các dữ liệu này có thể được sử dụng làm công cụ phân tích dữ liệu Điều này cực kì hữu ích để tìm ra nguyên nhân gốc rễ của các vấn đề bạn có thể gặp phải hoặc sử dụng làm mục đích kiểm tra sử dụng, các lỗi bất thường … Lab 05: S3 Server Access Logging Hands On Create new Bucket Chọn Bucket =&gt; Property =&gt; Nhìn thấy Server access logging Lúc enable =&gt; target bucket??? Chọn chính nó luôn thêm /logs Testing Mở lại file ảnh Vào lại bucket, thấy sinh ra file trong thư mục /logs S3 Replication Overview (CRR &amp; SRR) Bạn phải enable versioning ở cả nguồn và đích Cross Region Replication (CRR): sử dụng cho các trường hợp tuân thủ dữ liệu, độ trể thấp, nhân rộng trên nhiều tài khoản Same Region Replication (SRR): sử dụng cho các trường hợp tổng hợp log, sao chép trực tiếp giữa tài khoản production và test Buckets có thể trong các tài khoản khác nhau Việc sao chép là không đồng bộ Bạn phải cấp quyền IAM thích hợp cho S3 Lan 06: S3 Replication Hands On Create new bucket - Chọn region tại us-east-1 và sao lưu sang châu Âu =&gt; enable versioning Vào bucket =&gt; managament =&gt; Create replication ruleChọn tule =&gt; This rule applies to all objects in the bucket Sau khi tạo xong, vào replication object =&gt; 0 objects?? Do từ lúc enbale replication thì chưa có file nào Same version luôn Mỗi lần upload bên main bên replication sẽ nhận theo So pretty cool, we’ve just set up a replication between buckets in the region EU Ireland ES West one into a replica buckets in the region US East Northern Virginia, US East one. S3 Durability and AvailabilityTính bền vững High durability (99.999999999%, 11 9’s) of objects across multiple AZ If you store 10,000,000 objects with Amazon S3, you can on average expect to incur a loss of a single object once every 10,000 years Same for all storage classes Tính khả dụng Đo lường tĩnh sẵn có của một dịch vụ Tiêu chuẩn S3 đáp ứng tính khả dụng 99,99%, điều đó có nghĩa là nó chỉ không khả dụng trong 53 phút trong 1 năm Tính khả dụng thay đổi tuỳ thuộc vào class lữu trữ S3 Storage Classes OverviewBây giờ chúng tôi đã lưu trữ tệp của mình vào Amazon S3 nhưng chúng tôi có các tùy chọn khác nhau để lưu trữ tệp của mình trên các lớp lưu trữ khác nhau. Và những điều này có thể giúp chúng tôi tiết kiệm chi phí. Vì vậy, những gì chúng tôi đã sử dụng cho đến nayđược gọi là Amazon S3 General Purpose Storage, lớp này sẽ được sử dụng phổ biến nhưng sau đó bạn có thể tối ưu hóa nó. Ví dụ: nếu bạn đang tải lên một tệp mà bạn biết rằng sẽ không được truy cập thường xuyênVì vậy, truy cập không thường xuyên thì bạn có một tầng mới được gọi là SAmazon S3 Standard-Infrequent Access (IA) 6 class trong S3 Amazon S3 Standard - General Purpose Amazon S3 Standard-Infrequent Access (IA) Amazon S3 One Zone-Infrequent Access Amazon S3 Intelligent Tiering Amazon Glacier Amazon Glacier Deep Archive S3 Standard – General Purposes 99.99% Availability Được sử dụng để lưu trữ các dữ liệu thường xuyên được truy cập Độ trễ thấp và thông lượng cao Sustain 2 concurrent facility failures. Dữ liệu của bạn vẫn an toàn Use cases: Phân tích dữ liệu lớn, ứng dụng mobile và gaming, nội dung phân tán … S3 Standard – Infrequent Access (IA) Thích hợp với các dữ liệu ít truy cập thường xuyên nhưng yêu cầu truy cập nhanh khi cần 99.9% Availability Chi phí thấp hơn Amzon S3 Standard nhưng phát sinh phí truy cập Sustain 2 concurrent facility failures Use cases: Lưu các dữ liệu để khôi phục, sao lưu S3 Intelligent-Tiering 99.9% Availability Độ trễ thấp và thông lượng cao như S3 Standard Tối ưu hóa chi phí bằng cách tự động di chuyển các đối tượng giữa hai cấp truy cập dựa trên việc thay đổi các mẫu truy cập Frequent access Infrequent access Có khả năng chống lại các sự kiện ảnh hưởng đến toàn bộ Availability Zone S3 One Zone - Infrequent Access (IA) Giống với IA nhưng dữ liệu chỉ được lưu trữ trong 1 single AZ 99.5% Availability Độ trễ thấp và hiệu suất dung lượng cao Chi phí thấp hơn S3-IA (khoảng 20%) Use cases: Lưu trữ các bản sao dự phòng thứ cấp của dữ liệu tại chỗ hoặc lưu trữ dữ liệu bạn có thể tạo lại Amazon Glacier &amp; Glacier Deep Archive Chi phí thấp (tính theo GB/tháng) để lưu trữ/sao lưu Dữ liệu được lưu trữ lâu dài (nhiều năm) Các tuỳ chọn truy xuất khác nhau và có phí khi truy suất Amazon Glacier – giá rẻ Nhanh (1 đến 5 phút) Tiêu chuẩn (3 đến 5 giờ) Số lượng lớn (5 đến 12 giờ) Amazon Glacier Deep Archive – rẻ nhất Tiêu chuẩn (12 giờ) Số lượng lớn (48 giờ) S3 Storage Class Comparison S3 – Moving between storage classes Bạn hoàn toàn có thể các objects giữa các storage class Đối với các object ít truy cập, chuyển chúng sang STANDARD_IA Đối với các object bạn lưu trữ mà không cần real-time, GLACIER hoặc DEEP_ARCHIVE Di chuyển các objects có thể làm tự động sử dụng lifecycle configurationLab 07: S3 Storage Classes Hands On Upload 1 file lên S3. Lúc này trong mục Addtional upload options có mục Storage Class Mặc định sẽ là Standard class Sau khi đã upload xong, ấn vào chi tiết, kéo xuống dưới sẽ nhìn thấy mục Storage class Ok check tiếp, mở mục List version thấy được các storage class Việc tiếp theo là bạn muốn chuyển toàn bọ object của bạn sang 1 storage class nhất đinh=&gt; Chọn Tab Managêmnt =&gt; Lifecycle rules =&gt; Create=&gt; Apply all objects in the bucketĐoạn actions tự hiểu Sau khi đã setting hết, nhìn xuống Timeline summary để xem chi tiết =&gt; Tối ưu hoá chi phí nếu bạn có quá nhiều objects trên S3 buckets Shared Responsibility Model for S3AWS Infrastructure (global security, durability, availability, sustain concurrent loss of data in two facilities) Configuration and vulnerability analysis Compliance validation You S3 Versioning S3 Bucket Policies S3 Replication Setup Logging and Monitoring • S3 Storage Classes Data encryption at rest and in transit AWS Snow Family Overview Sử dụng để security cao hơn, 2 cách là Thu thập và xử lý dữ liệu trên edge hoặc migrade data into and out of AWS Data migration: 3 loại (Snowcone, Snowball Edge, Snowmobile) Edge computing: 2 loại (Snowcone, Snowball Edge) Why Data Migration with AWS Snow FamilyCác thách thức được đặt ra Kết nối hạn chế Băng thông hạn chế Chi phí mạng cao Băng thông được chia sẻ (không thể tối đa hóa đường truyền) Kết nối ổn định AWS Snow Family: offline devices to perform data migration. (thiết bị ngoại tuyến để thực hiện việc di chuyển dữ liệu) Nếu mất hơn 1 tuần để chuyển dữ liệu qua network, hãy sử dụng Snowball devices! DiagramsThực tế thì cách tranfer dữ liệu này là qua tầng vật lý chứ không phải qua network Lab 08 - AWS Snow Family Hands OnVào AWS Service =&gt; AWS Snow Family =&gt; Order an AWS Snow family device=&gt; Import to S3 Note: Bước 7, review a job và ĐỪNG CLICK CREATE vì phí cao và đây không phải là dịch vụ miễn phí Nếu là computing =&gt; Lúc Order =&gt; Local compute and storage only Phần này còn khá nhiều, khi nào cần sẽ tổng hợp thêm To be continue …. AWS OpsHub Trước đây, để sử dụng các Snow Family devices, bạn cần một CLI (Command Line Interface tool) Hiện nay bạn có thể sử dụng AWS OpsHub (một phần mềm bạn có thể cài trên máy / laptop) để quản lý các Snow Family Device: Mở khoá và định các cấu hình riêng lẻ hoặc theo cluster Chuyển files Khởi chạy và quản lý các phiên bản chạy trên Snow Family Device Giám sát thông số thiết bị Khởi chạy các dịch vụ tương thích với thiết bị của bạn (ví dụ như Amazon EC2 Instance AWS DataSunc, Network File System (NFS)) Hybrid Cloud for StorageAWS đang thúc đẩy “đám mây lai” Một phần cơ sở hạ tầng của bạn là “tại chỗ” (on-premises” Một phần cơ sở hạ tầng của bạn là trên đám mây Điều này có thể là do Long cloud migrations Yêu cầu bảo mật Yêu cầu các tuân thủ Chiến lược IT S3 là công nghệ lưu trữ độc quyền (không như EFS / NFS), vậy làm sao để hiển thị dữ liệu S3 tại chỗ? =&gt; AWS Storage Gateway! AWS Storage Gateway Đây là cầu nối giữa dữ liệu “tại chỗ” và dữ liệu trên cloud trong S3 Dịch vụ lưu trữ kết hợp để cho phép tại chỗ sử dụng liền mạch AWS Cloud Phần này sẽ tìm hiểu sau … S3 Summary Buckets vs Objects: global unique name, tied to a region S3 security: IAM policy, S3 Bucket Policy (public access), S3 Encryption S3 Websites: host a static website on Amazon S3 S3 Versioning: multiple versions for files, prevent accidental deletes S3 Access Logs: log requests made within your S3 bucket S3 Replication: same-region or cross-region, must enable versioning S3 Storage Classes: Standard, IA, 1Z-IA, Intelligent, Glacier, Glacier Deep Archive • S3 Lifecycle Rules: transition objects between classes S3 GlacierVault Lock / S3 Object Lock:WORM (Write Once Read Many) Snow Family: import data onto S3 through a physical device, edge computing OpsHub: desktop application to manage Snow Family devices Storage Gateway: hybrid solution to extend on-premises storage to S3","link":"/2021/05/08/Section-8-S3/"},{"title":"Section 9- Databases &amp; Analytics","text":"Lưu trữ dữ liệu ra ổ đĩa (EFS, EBS, EC2 Instance Store, S3) có thể có giới hạn riêng (giới hạn ở đây không ý là size, nhiều vấn đề khác) Đôi khi bạn cần lưu trữ dữ liệu ra database, các dữ liệu có cấu trúc. Bạn cần build indexes, làm cho việc query / search dữ liệu. Bạn cũng có thể cần định nghĩa các quan hệ giữa các tập dữ liệu Database được tối ưu cho các mục đích đó cùng với nhiều chức năng xịn xò hơn …. Databases &amp; Shared Responsibility on AWSAWS cung cấp nhiều cách quản lý cho các database khác nhau Các lợi ích bao gồm Cung cấp nhanh chóng, tính khả dụng cao, mở rộng theo chiều dọc và chiều ngang Tự động sao lưu, khôi phục, hoạt động và nâng cấp Bản vá các hệ điều hành được quản lý bởi AWS Giám sát và cảnh báo Chú ý: Rất nhiều các database có thể chạy trên EC2, nhưng bạn phải tự xử lý khả năng phục hồi, sao lưu, vá lỗi, tính sẵn sàng cao, khả năng chịu lỗi, mở rộng quy mô … RDS &amp; Aurora OverviewRDS viết tắt của Relational Database Service, được quản lý DB server sử dụng SQL làm ngôn ngữ truy vấn Trên AWS, nó bao gồm các loại Postgres MySQL MariaDB Oracle Microsoft SQL Server Aurora (AWS Proprietary database) Ưu điểm RDS Cung cấp tự động, các bản vá hệ điều hành Sao lưu liên tục và khôi phục về mốc thời gian cụ thể (Khôi phục thời điểm)! Dashboard giám sát Đọc bản sao để cải thiện hiệu suất đọc Multi AZ setup for DR (Disaster Recovery) Maintenance windows for upgrades Scaling capability (vertical and horizontal) Storage backed by EBS (gp2 or io1) RDS Solution Architecture Amazon Aurora Aurora là công nghệ độc quyền của AWS (không phải nguồn mở) PostgreSQL and MySQL are both supported as Aurora DB Aurora là “đám mây AWS được tối ưu hóa” và tuyên bố cải thiện hiệu suất gấp 5 lần so với MySQL trên RDS, hơn gấp 3 lần hiệu suất của Postgres trên RDS Bộ nhớ Aurora tự động tăng lên 10GB, lên đến 64 TB Aurora tốn nhiều tiền hơn RDS (hơn 20%) - nhưng hiệu quả hơn Không trong free tierLab 01: RDS Hands On RDS Deployments Options: Read Replicas, Multi-AZ, Multi-RegionĐọc các bản sao Scale các bản database của bạn để đọc Có thể tạo tối đa 15 bản Read (Read Replicas) Dữ liệu chỉ được ghi trên main DB Multi-AZ Chuyển đổi dự phòng trong trường hợp AZ “mất điện” (tính khả dụng cao) Dữ liệu chỉ đọc/ghi trên main database Có thể chỉ có 1 AZ khác làm dự phòng Read Replicas: tạo bản sao (chỉ read) Multi A-Z: Chuyển đổi dự phòng Multi-Region (Read Replicas) Khôi phục thảm hoa trong trường hợp region gặp sự cố Hiệu năng local cho các truy cập toàn cầu (đang hiểu là đưa về region phù hợp) Tiết kiệm chi phí ElastiCache OverviewBây giờ ElastiCache sẽ hữu ích để giảm tải cơ sở dữ liệu có khối lượng công việc đọc nhiều. Ý tưởng là nếu chúng ta có cơ sở dữ liệu RDSvà chúng tôi đang thực hiện rất nhiều truy vấn về nó và chúng luôn là những truy vấn giống nhau, chúng tôi đặt một chút áp lực lên cơ sở dữ liệu RDS đó. Thay vào đó, những gì chúng tôi có thể làm, là sử dụng bộ nhớ đệm để giảm áp lựcra khỏi cơ sở dữ liệu bằng cách đảm bảo các truy vấn đang trực tiếp vào cơ sở dữ liệu trong bộ nhớ của tôi thông qua ElastiCache The same way RDS is to get managed Relational Databases… ElastiCache dùng để quản lí Redis hoặc Memcached Cache là in-memory database với hiệu suất cao, độ trễ thấp AWS takes care of OS maintenance / patching, optimizations, setup, configuration, monitoring, failure recovery and backups ElastiCache Solution Architecture - Cache DynamoDB Overview DynamoDB is one of the flagship product of AWS. Được quản lý hoàn toàn với tính khả dụng cao với khả năng nhân rộng với 3 AZ (các DB trên phần này rõ ràng cần tự làm, quản lý) NoSQL database - not a relational database Scale với các công việc lớn, cơ sở dữ liệu “serverless” Hàng triệu yêu cầu mỗi giây, hàng nghìn tỷ hàng, 100 TB dung lượng lưu trữ Nhanh chóng và nhất quán về hiệu suất Độ trễ mili giây 1 chữ số - truy xuất độ trễ thấp Tích hợp với IAM để bảo mật, ủy quyền và quản trị Chi phí thấp và tương thích khả năng tự mở rộng DynamoDB Accelerator - DAX Fully Managed in-memory cache forDynamoDB (đang hiểu là cache cho DynamoDB đã được quản lý bởi AWS) 10x performance improvement - độ trễ micro giây 1 chữ số - khi truy cập bảng trong DynamoDB Tính bảo mật, khả năng mở rộng cao và tính khả dụng Khác với ElastiCache trong CCP Level (chứng chỉ hiện tại): DAX chỉ được sử dụng và tích hợp với DynamoDB, trong khi ElastiCache có thể được sử dụng cho các database khác Lab 02: DynamoDB Hands OnRedshift Overview Redshift is based on PostgreSQL, but it’s not used for OLTP It’s OLAP – online analytical processing, xử lý phân tích trực tuyến (phân tích và lưu trữ dữ liệu) Load dữ liệu mỗi lần một giờ, không phải mỗi giây 10x better performance than other data warehouses, scale to PBs of data Lưu trữ dữ liệu dạng cột (thay vì theo hàng) Massively Parallel Query Execution (MPP), (thực thi truy vấn song song hàng loạt) tính khả dụng cao Pay as you go based on the instances provisioned Has a SQL interface for performing the queries BI tools such as AWS Quicksight or Tableau integrate with it EMR Overview So EMR is actually not really a database. It’s to create what’s called a Hadoop clusterwhen you wanna do big data on AWS, and a Hadoop cluster is used to analyze and process vast amount of data. EMR stands for “Elastic MapReduce” EMR helps creating Hadoop clusters (Big Data) to analyze and process vast amount of data The clusters can be made of hundreds of EC2 instances Also supports Apache Spark, HBase, Presto, Flink… EMR takes care of all the provisioning and configuration Auto-scaling and integrated with Spot instances Use cases: data processing, machine learning, web indexing, big data…. Athena Overview Athena is a fully serverless database that has SQL capability. And it’s used for only one thing. It’s used to query data in Amazon S3. Fully Serverless database with SQL capabilities - Used to query data in S3 Pay per query Output results back to S3 Secured through IAM Use Case: one-time SQL queries, serverless queries on S3, log analytics QuickSight Overview Serverless machine learning-powered business intelligence service to create interactive dashboards(Dịch vụ thông minh machine learning, serverless để tạo các bảng điều khiển tương tác) Nhanh chóng, có thể mở rộng tự động, có thể nhúng, với giá mỗi phiên Use cases: Business analytics Building visualizations Perform ad-hoc analysis Get business insights using data Integrated with RDS, Aurora, Athena, Redshift, S3… DocumentDB Overview Aurora is an “AWS-implementation” of PostgreSQL / MySQL … DocumentDB is the same for MongoDB (which is a NoSQL database) MongoDB is used to store, query, and index JSON data Similar “deployment concepts” as Aurora Fully Managed, highly available with replication across 3 AZ Aurora storage automatically grows in increments of 10GB, up to 64 TB. Automatically scales to workloads with millions of requests per seconds Amazon Neptune (For Social Network) Fully managed graph database A popular graph dataset would be a social network Users have friends Posts have comments Comments have likes from users Users share and like posts… Highly available across 3 AZ, with up to 15 read replicas Build and run applications working with highly connected datasets – optimized for these complex and hard queries Can store up to billions of relations and query the graph with milliseconds latency Highly available with replications across multiple AZs Great for knowledge graphs (Wikipedia), fraud detection, recommendation engines, social networking Amazon QLDBAmazon Managed BlockchainAWS GlueDMS – Database Migration Service Di chuyển nhanh chóng và an toàn cơ sở dữ liệu sang AWS, có khả năng phục hồi, tự phục hồi Cơ sở dữ liệu nguồn vẫn khả dụng trong quá trình di chuyển Supports: Di chuyển đồng nhất: ví dụ như Oracle sangOracle Di chuyển không đồng nhất: từ Microsoft SQL Server sang Aurora Databases &amp; Analytics Summary in AWS Relational Databases - OLTP: RDS &amp; Aurora (SQL) Differences between Multi-AZ, Read Replicas, Multi-Region In-memory Database: ElastiCache Key/Value Database: DynamoDB (serverless) &amp; DAX (cache for DynamoDB) Warehouse - OLAP: Redshift (SQL) HadoopCluster:EMR Athena: query data on Amazon S3 (serverless &amp; SQL) QuickSight: dashboards on your data (serverless) DocumentDB:“AuroraforMongoDB”(JSON–NoSQLdatabase) AmazonQLDB: FinancialTransactionsLedger(immutablejournal,cryptographicallyverifiable) • Amazon Managed Blockchain: managed Hyperledger Fabric &amp; Ethereum blockchains Glue: Managed ETL (Extract Transform Load) and Data Catalog service Database Migration: DMS Neptune:graphdatabase","link":"/2021/05/09/Section-9-Databases-Analytics/"},{"title":"Section 10- Other Compute Services- ECS, Lambda, Batch, Lightsail","text":"Cùng tìm hiểu một số dịch vụ tính toán khác trong AWS! What is Docker?Docker sẽ không có trong exam, nhưng đọc để biết sử dụng Docker trên AWS ECS, Fargate &amp; ECR OverviewECS ECS = Elastic Container Service Launch Docker containers on Bạn chính là người cung cấp và duy trì, bảo dưỡng cơ sở hạ tầng (chính là các EC2 instances) AWS sẽ quan tâm việc start/stop các instances Có được tích hợp với Application Load Balancer Fargate Launch Docker containers on AWS Bạn không cần phải cung cấp cơ sở hạ tầng (sẽ không EC2 Instances để quản lý) - đơn giản hơn! Serverless offering AWS chỉ chạy các containers dựa trên CPU/RAM bạn cần ECR ECR = Elastic Container Registry: Nơi lưu trữ Docker images Private Docker Registry on AWS This is where you store your Docker images so they can be run by ECS or Fargate So remember, ECS versus Fargate versus ECR,that’s all you need to know going into the exam. Serverless Introduction Serversless và một kiểu mẫu mới mà tại đó developers không phải quản lý bất kì servers nào nữa … Họ chỉ deploy code Họ chỉ deploy … functions! Ban đầu … Serverles = FaaS (Function as a Service) Serverless được đi tiên phong bởi AWS Lambda nhưng giờ đây, nó đã bao gồm bất cứ cái gì cần quản lý: database, messagin, lưu trữ … Serverless does not mean there are no servers… Nó có nghĩa là bạn không cần quản lý / cung cấp / và xem chúng Lambda OverviewXem trang chủ có How it works cực hayWhy AWS Lamda Lợi ích của AWS Lambda Giá ngon: Trả tiền cho mỗi request và thời gian tính toán Free tier of 1,000,000 AWS Lambda requests and 400,000 GBs of compute time Tích hợp với toàn bộ bộ dịch vụ AWS Event-Driven (hướng sự kiện): các functions chỉ được gọi bởi AWS khi bạn cần Tích hợp với nhiều ngôn ngữ lập trình Giám sát dễ dàng với AWS CloudWatch Dễ dàng nhận được nhiều tài nguyên hơn cho mỗi chức năng (lên đến 3GB RAM!) Tăng RAM cũng sẽ cải thiện CPU và mạng! AWS Lambda language supportLambda cung cấp rất nhiều ngôn ngữ cho bạn Node.js (JavaScript) Python Java (Java 8 compatible) C# (.NET Core) Golang C# / Powershell Ruby Custom Runtime API (community supported, example Rust) Lambda Container Image The container image must implement the Lambda Runtime API ECS / Fargate is preferred for running arbitrary Docker imagesExample: Serverless Thumbnail creattion AWS ExampleEx1: Tạo Thumbnail với ảnh s3 Ex2: Cron Job Ex3: AWS Lamdba Pricing (very cheap) Bạn có thể xem các thông tin giá tại https://aws.amazon.com/lambda/pricing/ Giá mỗi lần gọi 1.000.000 request đầu tiên là miễn phí $0.20 cho mỗi 1 triệu request sau đó ($0.0000002 cho mỗi request) Giá cho mỗi khoảng thời gian (tăng dần với mỗi 100ms) 400,000 GB-seconds of compute time per month if FREE == 400,000 seconds if function is 1GB RAM == 3,200,000 seconds if function is 128 MB RAM After that $1.00 for 600,000 GB-seconds Giá AWS Lambda rất rẻ, do đó nó thực sự được sử dụng rất phổ biến :D Lab 01: Lambda Hands OnAPI Gateway Overview Bây giờ chúng ta cùng nói về API Gateway. Nó hữu ích và được sử dụng khi bạn muốn xây dựng một serverless API Đã được quản lý toàn bộ dịch vụ cho developers để dễ dàng tạo, publish, bảo trì, giám sát và bảo mật APIs Serverless và có thể mở rộng Hỗ trợ với các RESTfull APIs và WebSocket APIs Hỗ trợ bảo mật, xác thực người dùng, điều chỉnh API, khóa API, giám sát … 114. Batch Overview Fully managed batch processing at any scale Efficiently run 100,000s of computing batch jobs on AWS A “batch” job is a job with a star t and an end (opposed to continuous) Batch will dynamically launch EC2 instances or Spot Instances AWS Batch provisions the right amount of compute / memory You submit or schedule batch jobs and AWS Batch does the rest! Batch jobs are defined as Docker images and run on ECS Helpful for cost optimizations and focusing less on the infrastructure Batch vs LamdbaLambda: Time limit Limited runtimes Limited temporary disk space Serverless Batch: No time limit Any runtime as long as it’s packaged as a Docker image Rely on EBS / instance store for disk space Relies on EC2 (can be managed by AWS) Lightsail Overview Máy chủ ảo, lưu trữ, cơ sở dữ liệu và mạng Giá thấp và có thể dự đoán được Thay thế đơn giản hơn để sử dụng EC2, RDS, ELB, EBS, Route 53 Một công cụ tuyệt vời cho những người ít kinh nghiệm với cloud Có thể thiết lập thông báo và giám sát tài nguyên Lightsail Use cases: Simple web applications (has templates for LAMP, Nginx, MEAN, Node.js…) Websites (templates for WordPress, Magento, Plesk, Joomla) Dev /Test environment Có tính khả dụng cao nhưng không auto-scaling, tích hợp AWS hạn chế Cuối cùng, Lightsail cũng rất tuyệt nếu bạn có môi trường phát triển và thử nghiệm trong AWS. Có một khái niệm về tính khả dụng cao trong Lightsail nhưng không có tự động mở rộng quy mô và thực sự có những tích hợp AWS hạn chế. Vì vậy, tóm lại, Lightsail thực sự là thứ mà bạn sẽ không sử dụng ngày hôm nay nhưng từ góc độ kiểm tra, khi đi thi, nếu bạn thấy ai đó không có kinh nghiệm về đám mây và cần bắt đầu nhanh chóng với mức giá thấp và có thể dự đoán được mà không cần định cấu hình nhiều thứ sẽ hãy chọn Lightsail, nếu không, hầu như luôn là một câu trả lời sai. Lab 02: Lightsail Hands OnOther Compute - SummaryBatch allows you to run batch jobs on AWSacross a set of managed EC2 instances.And actually, the batch service actually runson top of the ECS service. Docker: container technology to run applications ECS: run Docker containers on EC2 instances Fargate: Run Docker containers without provisioning the infrastructure • Serverless offering (no EC2 instances) ECR: Private Docker Images Repository Batch: run batch jobs on AWS across managed EC2 instances Lightsail: predictable &amp; low pricing for simple application &amp; DB stacks","link":"/2021/05/16/Section-10-Other-Compute-Services-ECS-Lambda-Batch-Lightsail/"},{"title":"Section 11- Deployments &amp; Managing Infrastructure at Scale","text":"Tìm hiểu một số công cụ cho phần Deployment và quản lý hạ tầng nào! CloudFormation Overview - IaaS CloudFormation là một cách khai báo để phác thảo Cơ sở hạ tầng AWS của bạn, cho bất kỳ tài nguyên nào (hầu hết chúng đều được hỗ trợ). Ví dụ như với template CloudFormation, bạn nói rằng: Tôi muốn một security group Tôi muốn 2 EC2 instance sử dụng security group Tôi muốn 1 S3 bucket Tôi muốn một load balancer (ELB) trước các thành phần này =&gt; Và sau đó CloudFormation tạo những thứ đó cho bạn, theo đúng thứ tự với những cấu hình chính xác mà bạn đã chỉ định Lợi ích của AWS CloudFormationInfrastructure as code Không có tài nguyên nào được tạo thủ công hết, điều này rất tuyệt vời khi bạn kiểm soát Các thay đổi về cơ sở hạ tầng đều thông qua code :D Chi phí Mỗi tài nguyên trong stack được gán với một định danh, do đó bạn có thể dễ dàng xem giá của mỗi stack Bạn hoàn toàn có thể ước lượng được giá các resource sử dụng CloudFormation template Ngoài ra bạn có thể áp dụng chiến lược tiết kiệm: Trong môi trường Dev, bạn có thể tự động xoá các template vào 5PM và tạo lại vào 8AM, tiết kiệm, không hề có tài nguyên nào tồn tại từ 5PM đến 8AM Năng suất Khả năng hủy và tái tạo cơ sở hạ tầng trên đám mây một cách nhanh chóng Tự động tạo ra các Diagram với các template của bạn Lập trình thủ tục: Bạn không cần sắp xếp thứ tự tạo một bảng trên DynamoDB hay tại EC2 Instance trước hoặc làm chúng cùng nhau =&gt; Tất cả đã được CloudFormation đủ thông minh để tự thực hiện Đừng phát minh lại bánh xe Tận dụng các template hiện có trên web! Tận dụng tài liệu Hỗ trợ (hầu hết) tất cả các AWS Resource Mọi thứ chúng ta sẽ thấy trong khóa học này đều được hỗ trợ Bạn có thể sử dụng “tài nguyên tùy chỉnh” cho các tài nguyên không được hỗ trợ CloudFormation Stack DesignerVí dụ cho một WordPress CloudFormation Stack. Chúng ta có thể nhìn thấy tất cả resources. Chúng ta cũng có thể thấy quan hệ giữa các tài nguyên này Kiến trúc điển hình: Web App 3-tier Lab 01: CloudFormation Hands OnBeanstalk OverviewTrước khi nói về Beanstalk, chúng ta hãy cùng xem những vấn đề của devepoper với AWS Developer problems on AWS Quản lý cơ sở hạ tầng Deploying Code Cấu hình tất cả database, load balancers, .. Mối quan tâm về scale Và Đa số ứng dụng web đều có kiến trúc giống nhau (ALB + ASG) Rõ ràng, tất cả developes muốn là để code của họ chạy! Có thể nhất quán trên các ứng dụng, môi trường khác nhau. Bây giờ kiến trúc web 3-tier ở trên là một cái gì đó chúng ta có thể dễ dàng tái sản xuất theo cách thủ công. Chúng tôi cũng có thể tái tạo nó trên AWS thông qua CloudFormation. Nhưng có một cách tốt hơn. Vì vậy, khi bạn là nhà phát triển trên AWS,bạn không muốn quản lý cơ sở hạ tầng.Bạn chỉ muốn triển khai mã, được chứ? Beanstalk = Platform as a Service (PaaS) (because we just worry about the code) Elastic Beanstalk Elastic Beanstalk là quan điểm tập trung vào nhà phát triển về việc triển khai ứng dụng trên AWS Nó sử dụng tất cả các thành phần chúng ta tìm hiểu trước đó: EC2, ASG, ELB, RDS, … Nhưng tất cả sẽ được đặt trong 1 view, rất dễ hiểu Chúng tôi vẫn có toàn quyền kiểm soát cấu hình Beanstalk là miễn phí, nhưng bạn sẽ trả tiền cho các dịch vụ ở phía dưới nó Một số lợi ích của Beanstalk Quản lý các service Cấu hình các Instance, OS được Beanstalk care Chiến lược triển khai có thể định cấu hình nhưng được thực hiện bởi Elastic Beanstalk Capacity provisioning Load balancing &amp; auto-scaling Application health-monitoring &amp; responsiveness Just the application code is the responsibility of the developer Ba mô hình kiến trúc: Triển khai đơn Instance: Tốt cho các dev LB + ASG: tốt cho các ứng dụng web product or pre-products Chỉ ASG: chỉ tốt cho các sản phẩm không phải là ứng dụng web (workers …) Như đã nói ở trên Beanstalk hỗ trợ rất nhiều nền tảng: Go Java SE Java withTomcat .NET on Windows Server with IIS Node.js PHP Python Ruby Packer Builder Thậm chí là Single Container Docker Multi-Container Docker Preconfigured Docker Hay kể cả không hỗ trợ, bạn có thể viết các platform cho riêng bạn! Lab 02: Beanstalk Hands OnCodeDeploy OverviewVì vậy CodeDeploys cũng là một cách để chúng tôi triển khai ứng dụng của mình một cách tự động. Bây giờ sự khác biệt mà CodeDeploy dễ hơn một chút. Nó không cần phải sử dụng Beanstalk hoặc CloudFormation. Điều này là hoàn toàn độc lập. Và nó là một dịch vụ tiên tiến, vì vậy tôi thực sự không thể giới thiệu nó cho bạn, nhưng điều bạn cần nhớ là nó cho phép bạn nâng cấp cả phiên bản EC2, ứng dụng của bạn, và các ứng dụng Máy chủ Tại chỗ (On-Premises Servers) của bạn từ phiên bản một đến phiên bản hai, tự động từ một giao diện duy nhất. Vì vậy, hy vọng rằng đó là hữu ích. CodeCommit Overview Trước khi push code của ứng dụng lên server, bạn cần lưu trữ chúng ở đâu đó. Các developer thường lưu trữ code trên một repository, sử dụng Git technology. Một nơi lưu trữ nổi tiếng là GitHub, và bạn biết không, AWS cũng có một sản phẩm cạnh tranh là CodeCommit CodeCommit Dịch vụ kiểm soát mã nguồn với Git-based repository Dễ dàng mời người khác cộng tác code Mỗi khi code thay đổi sẽ tự động được đánh version Lợi ích Fully managed Scalable &amp; highly available Private, Secured, Integrated with AWS CodeBuild Overview Dịch vụ “code building trên đám mây” (cái tên nói lên tất cả :v) Biên dịch mã nguồn, chạy thử nghiệm và tạo các gói sẵn sàng được triển khai (ví dụ: CodeDeploy) Lợi ích Fully managed, serverless Continuously scalable &amp; highly available Secure Pay-as-you-go pricing – only pay for the build time CodePipeline Overview Đây là thành phần kết nối giữa code commit và code build Sắp xếp các bước khác nhau để mã tự động được đưa lên production! Code =&gt; Build =&gt; Test =&gt; Provision =&gt; Deploy Basis for CICD (Continuous Integration &amp; Continuous Delivery) Lợi ích Fullymanaged,compatiblewithCodeCommit,CodeBuild,CodeDeploy,ElasticBeanstalk,CloudFormation, GitHub, 3rd-party services (GitHub…) &amp; custom plugins… Fast delivery &amp; rapid updates CodeArtifact Overview Các gói phần mềm phụ thuộc vào nhau để được xây dựng (còn được gọi là phụ thuộc mã) và các gói phần mềm mới được tạo\\ Lưu trữ và truy xuất các phụ thuộc này được gọi là quản lý các artifact Theo cách truyền thống, bạn cần cài đặt và quản lý các artifact của riêng mình Với AWS, CodeArtifact là phần quản lý các artifact bảo mật, có thể mở rộng và tiết kiệm chi phí cho quá trình phát triển phần mềm Hoạt động với các công cụ quản lý phụ thuộc phổ biến như Maven, Gradle, npm, sợi, bện, pip và NuGet Các nhà phát triển và CodeBuild sau đó có thể truy xuất các phụ thuộc trực tiếp từ CodeArtifact CodeStar Overview Cung cấp một UI thích hợp nhất để quản lý các hoạt động của phần mềm ở một nơi duy nhất Đây là “cách nhanh chóng” để bắt đầu thiết lập chính xác CodeCommit, CodePipeline,CodeBuild, CodeDeploy, Elastic Beanstalk, EC2, v.v. Có thể chỉnh sửa code “in-the-cloud” sử dụng AWS Cloud 9 Cloud9 Overview AWS Cloud9 is a cloud IDE (Integrated Development Environment) for writing, running and debugging code “Classic” IDE (like IntelliJ,Visual Studio Code…) are downloaded on a computer before being used Một cloud IDE có thể được sử dụng trong trình duyệt web, có nghĩa là bạn có thể làm việc trên các dự án của mình từ văn phòng, nhà riêng hoặc bất cứ nơi nào có internet mà không cần thiết lập AWS Cloud9 cũng cho phép cộng tác mã trong thời gian thực (lập trình cặp) Lab 03: CodeStar &amp; Cloud9 Hands OnSystems Manager (SSM) Overview Giúp bạn quản lý EC2 và các hệ thống On-Premises Một dịch vụ Hybird khác Nhận thông tin chi tiết về hoạt động về tình trạng cơ sở hạ tầng của bạn Bao gồm hơn 10 sản phẩm Những chức năng quan trọng nhất Tự động vá lỗi để nâng cao tính tuân thủ Chạy lệnh trên toàn bộ nhóm máy chủ Lưu trữ cấu hình tham số với SSM Parameter Store Làm việc với cả Windows và Linux OS How Systems Manager works Chúng tôi cần cài đặt SSM agent vào các hệ thống mà chúng tôi kiểm soát. Mặc định Amazon Linux AMI và một vài Ubuntu AMI đã có Nếu một phiên bản không thể được kiểm soát bằng SSM, đó có thể là vấn đề với SSM agent! Nhờ tác nhân SSM, chúng tôi có thể chạy lệnh, vá lỗi và định cấu hình máy chủ của mình OpsWorks Overview Chef &amp; Puppet giúp bạn thực hiện cấu hình máy chủ tự động hoặc các hành động lặp đi lặp lại Nó làm việc tốt với EC2 hoặc On-Premises VM AWS OpsWorks = Managed Chef &amp; Puppet Đây là một giải pháp thay thế cho SSM Chỉ cung cấp cho các tài nguyên AWS tiêu chuẩn EC2 Instances, Databases, Load Balancers, EBS volumes… In the exam: Chef or Puppet needed =&gt; AWS OpsWorks OpsWorks Architecture Deployment - Summary CloudFormation: (AWS only) Infrastructure as Code, works with almost all of AWS resources Repeat across Regions &amp; Accounts Beanstalk: (AWS only) Platform as a Service (PaaS), limited to certain programming languages or Docker Deploy code consistently with a known architecture: ex, ALB + EC2 + RDS CodeDeploy (hybrid): deploy &amp; upgrade any application onto servers Systems Manager (hybrid): patch, configure and run commands at scale OpsWorks (hybrid): managed Chef and Puppet in AWS CodeCommit: Store code in private git repository (version controlled) CodeBuild: Build &amp; test code in AWS CodeDeploy: Deploy code onto servers CodePipeline: Orchestration of pipeline (from code to build to deploy) CodeArtifact: Store software packages / dependencies on AWS CodeStar: Unified view for allowing developers to do CICD and code Cloud9: Cloud IDE (Integrated Development Environment) with collab","link":"/2021/05/17/Section-11-Deployments-Managing-Infrastructure-at-Scale/"},{"title":"Section 12- Leveraging the AWS Global Infrastructure","text":"Phần này chúng ta cùng tìm hiểu về cách deploy một hệ thống Global trong AWS! Why Global Applications?Một ứng dụng global là một ứng dụng được deploy ở nhiều khu vực địa lý. Và trên AWS, chúng được gọi là các Regions và/hoặc **Edge Locations&amp;&amp; Giảm độ trễ • Độ trễ là thời gian cần thiết để một gói mạng đến máy chủ Phải mất thời gian để một gói hàng (packet) từ Châu Á đến được Hoa Kỳ Triển khai các ứng dụng của bạn gần người dùng hơn để giảm độ trễ, mang lại trải nghiệm tốt hơn Khôi phục sau thảm hoạ Nếu một khu vực AWS gặp sự cố (động đất, bão, ngắt điện, chính trị) … Bạn có thể chuyển sang một Region khác ngon hơn mà ứng dụng của bạn vẫn hoạt động Một kế hoạch DR rất quan trọng để tăng tính khả dụng của ứng dụng của bạn Bảo vệ tấn công: cơ sở hạ tầng toàn cầu phân tán khó bị tấn công hơn Global AWS Infrastructure Regions: Để deploy ứng dụng và cơ sở hạ tầng Availability Zones (chấm xanh): Tạo ra nhiều data centers Edge Locations (Points of Presence) (chấm hồng): Cho các nội dung phân phối gần người dùng hơn Network: Dây mạng trắng :v Xem thêm tại: https://aws.amazon.com/about-aws/global-infrastructure/regions_az/ Global Applications in AWS Global DNS: Route 53 Tuyệt vời để định tuyến người dùng đến việc triển khai gần nhất với độ trễ ít nhất Tuyệt vời cho các chiến lược khôi phục sau thảm họa • Global Content Delivery Network (CDN): CloudFront Nhân rộng một phần ứng dụng của bạn đến AWS Edge Locations - giảm độ trễ Cache các request chung - cải thiện trải nghiệm người dùng và giảm độ trễ • S3 Transfer Acceleration Tăng tốc upload và download toàn cầu vào Amazon S3 • AWS Global Accelerator Cải thiện tính khả dụng và hiệu suất của ứng dụng toàn cầu bằng cách sử dụng mạng toàn cầu AWS Route 53 OverviewĐây là dịch vụ đầu tiên rất quan trọng chúng tôi muốn giới thiệu khi bạn muốn deploy một ứng dụng global là Amazon Route 53 Route 53 is a managed DNS or Domain Name System. And what does the DNS? DNS là một tập hợp các quy tắc và bản ghi giúp khách hàng hiểu cách truy cập máy chủ thông qua URL. Trong AWS, các bản ghi phổ biến nhất là: www.google.com =&gt; 12.34.56.78 == A record (IPv4) www.google.com =&gt; 2001:0db8:85a3:0000:0000:8a2e:0370:7334 == AAAA IPv6 search.google.com =&gt; www.google.com == CNAME: hostname to hostname example.com =&gt; AWS resource == Alias (ex: ELB, CloudFront, S3, RDS, etc…) Route 53 - Diagram Route 53 Routing PoliciesChúng ta sẽ tìm hiểu thêm ở level cao hơn Lab 01: Route 53 Hands OnCloudFront OverviewBây giờ hãy nói về CloudFront. CloudFront là một mạng phân phối nội dung, hoặc CDN,vì vậy bất cứ khi nào bạn nhìn thấy CDN tại kỳ thi, hãy nghĩ đến CloudFront. Nó cải thiện hiệu suất đọc bằng cách lưu nội dung vào bộ nhớ đệm của trang web của bạn tại các vị trí cạnh khác nhau. Và bởi vì nội dung của bạn được lưu trữ trên khắp thế giới, thì người dùng của bạn trên toàn thế giới sẽ có độ trễ thấp hơn, và điều này sẽ cải thiện trải nghiệm người dùng. CloudFront được tạo ra từ 216 điểm hiện diện trên toàn cầu (Point of Presence), tương ứng với các vị trí cạnh AWS trên khắp thế giới. Và AWS tiếp tục thêm các vị trí để cải thiện trải nghiệm người dùng hơn nữa ở mọi nơi. **Ngoài ra nó còn giúp chống tấn công DDoSvì đã được tích hợp Shield, AWS Web Application Firewall CloudFront - Origins S3 bucket Phân phối các file và cache chúng tại các edge Bảo mật nâng cao với CloudFront Origin Access Identity (OAI) CloudFront có thể được sử dụng như một quyền (upload file lên S3) Custom Origin (HTTP) Application Load Balancer EC2 instance S3 website (must first enable the bucket as a static S3 website) Any HTTP backend you want CloudFront at a high level CloudFront – S3 as an Origin CloudFront vs S3 Cross Region Replication CloudFront Global Edge network File được cache với một TTL (có thể 1 ngày) Thích hợp cho các nội dung tĩnh, phải có mặt ở khắp mọi nơi S3 Cross Region Replication: Phải được thiết lập cho từng khu vực bạn muốn nhân rộng Các tệp được cập nhật gần như theo thời gian thực Chỉ đọc Tuyệt vời cho nội dung động cần khả dụng với độ trễ thấp ở một số khu vực Lab 02: CloudFront Hands OnS3 Transfer AccelerationTăng tốc độ truyền bằng cách chuyển tệp đến một AWS edge location sẽ chuyển tiếp dữ liệu đến S3 bucket trong target region Test tool: https://s3-accelerate-speedtest.s3-accelerate.amazonaws.com/en/accelerate-speed-comparsion.html Trang test =&gt; nhanh hơn 13% AWS Global Accelerator Cải thiện tính khả dụng và hiệu suất của ứng dụng toàn cầu bằng cách sử dụng mạng toàn cầu AWS Tận dụng mạng nội bộ AWS để tối ưu hóa lộ trình đến ứng dụng của bạn (cải thiện 60%)AWS Global Accelerator vs CloudFront 2 Anycast IP được tạo cho ứng dụng của bạn và lưu lượng truy cập được gửi qua Edge Locations Edge locations gửi lưu lượng truy cập đến ứng dụng của bạn AWS Global Accelerator vs CloudFront Cả hai đều sử dụng mạng toàn cầu AWS và các edge locations của mạng này trên khắp thế giới Cả 2 đều tích hợp AWS Shield để chống DDoS CloudFront – Content Delivery Network Cải thiện hiệu suất cho nội dung có thể lưu vào bộ nhớ cache của bạn (chẳng hạn như hình ảnh và video) Content is served at the edge Global Accelerator Không có bộ nhớ đệm, các proxying packets ở rìa tới các ứng dụng đang chạy trong một hoặc nhiều Khu vực AWS. Cải thiện hiệu suất cho một loạt các ứng dụng qua TCP hoặc UDP Tốt cho các trường hợp sử dụng HTTP yêu cầu địa chỉ IP tĩnh Tốt cho các trường hợp sử dụng HTTP yêu cầu chuyển đổi dự phòng khu vực nhanh, xác định Seed test: https://speedtest.globalaccelerator.aws AWS Outposts Đám mây lai: các doanh nghiệp giữ cơ sở hạ tầng tại chỗ cùng với cơ sở hạ tầng đám mây Do đó, có hai cách xử lý hệ thống CNTT: Một cho AWS cloud (sử dụng AWS console, CLI và AWS APIs) Một cho các hạ tầng “tại chỗ” AWS Outposts là “giá đỡ máy chủ” (server racks) cung cấp cơ sở hạ tầng giống AWS, dịch vụ, API và công cụ AWS để tạo các ứng dụng của riêng bạn tại chỗ giống như trong đám mây. AWS sẽ thiết lập và quản lý “Outposts Racks” trong cơ sở hạ tầng tại chỗ của bạn và bạn có thể bắt đầu tận dụng các dịch vụ AWS tại chỗ Bạn chịu trách nhiệm về bảo mật vật lý của Outposts Rack Benefits Khả năng truy cập vào các hệ thống tại chỗ với độ trễ thấp Xử lý dữ liệu cục bộ Data residency Easier migration from on-premises to the cloud Fully managed service Một số dịch vụ hoạt động trên Outposts Leveraging the AWS Global Infrastructure Summary Global DNS: Route 53 Great to route users to the closest deployment with least latency Great for disaster recovery strategies Global Content Delivery Network (CDN): CloudFront Replicate part of your application to AWS Edge Locations – decrease latency Cache common requests – improved user experience and decreased latency S3 Transfer Acceleration Accelerate global uploads &amp; downloads into Amazon S3 AWS Global Accelerator: Improve global application availability and performance using the AWS global network AWS Outposts Deploy Outposts Racks in your own Data Centers to extend AWS services","link":"/2021/05/18/Section-12-Leveraging-the-AWS-Global-Infrastructure/"},{"title":"Section 13- Cloud Integrations","text":"Khi chúng tôi bắt đầu triển khai nhiều ứng dụng, chắc chắn chúng sẽ cần giao tiếp với nhau. Sẽ có 2 kiểu giao tiếp giữa các ứng dụng. Đồng bộ giữa các ứng dụng có thể có vấn đề nếu có lưu lượng truy cập tăng đột biến. Điều gì sẽ xảy ra nếu bạn đột nhiên cần mã hóa 1000 video nhưng thông thường chỉ là 10? Trong trường hợp đó, tốt hơn là bạn nên tách các ứng dụng của mình ra: sử dụng SQS: queue model sử dụng SNS: pub/sub model sử dụng Kinesis: real-time data streaming model (out of scope for the exam) Các dịch vụ này có thể mở rộng quy mô độc lập với ứng dụng của chúng tôi! 143. SQS Overview: Queue SQS = Simple Queue Service Đây là một trong những dịch vụ lâu nhất của AWS (khoảng 10 năm) Dịch vụ được quản lý hoàn toàn (~ serverless), sử dụng để tách các ứng dụng Scales from 1 message per second to 10,000s per second Lưu trữ message mặc định: 4 ngày, tối đa 14 ngày Không giới hạn số lượng thư có thể có trong hàng đợi Tin nhắn sẽ bị xóa sau khi người tiêu dùng đọc chúng Độ trễ thấp (&lt;10 ms on publish and receive) Consumers share the work to read messages &amp; scale horizontally SQS để phân tách giữa các tầng ứng dụng Lab 01: SQS Hands On Create queue =&gt; Standard =&gt; Create luôn. Và chúng ta có thể gửi hoặc nhận message từ đây Ấn Send and receive message. Check receive messages availiable là 2 SNS OverviewNếu bạn muốn gửi một tin nhắn cho nhiều người nhận thì sao? The “event publishers” only sends message to one SNS topic As many “event subscribers” as we want to listen to the SNS topic notifications Mỗi người đăng ký chủ đề sẽ nhận được tất cả các tin nhắn Up to 10,000,000 subscriptions per topic, 100,000 topics limit SNS có thể HTTP / HTTPS (with delivery retries – how many times) Emails,SMSmessages,MobileNotifications SQS queues (fan-out pattern), Lambda Functions (write-your-own integration) Lab 02: SNS Hands OnKinesis Overview Trong kì thi, tất cả những gì bạn cần biết chỉ làKinesis = real-time big data streaming Managed service to collect, process, and analyze real-time streaming data at any scale Amazon MQ OverviewSQS, SNS là các dịch vụ “gốc đám mây” và chúng đang sử dụng các giao thức độc quyền từ AWS. Trong khi đó, các ứng dụng truyền thống chạy tại chỗ có thể sử dụng các giao thức mở như: MQTT, AMQP, STOMP, Openwire, WSS. Khi di chuyển sang đám mây, thay vì thiết kế lại ứng dụng để sử dụng SQS và SNS, chúng ta có thể sử dụng Amazon MQ. Amazon MQ = managed Apache ActiveMQ Một vài chú ý với Amazon MQ mà bạn nên biết Amazon MQ không “scale” nhiều như SQS/SNS Amazon MQ chạy trên một máy chuyên dụng (không phải serverless) Amazon MQ có cả tính năng hàng đợi (~SQS) và topic (~SNS) Vì vậy, Amazon MQ sẽ chỉ được sử dụng và chỉ khi một công ty đang di chuyển lên đám mây và cần sử dụng một trong những giao thức mở này, chẳng hạn như, MQTT AMQP STOMP, vân vân, vân vân.Nếu không, nó sẽ sử dụng SQS và SNS bởi vì họ mở rộng quy mô tốt hơn rất nhiều. Và chúng được tích hợp nhiều hơn với các dịch vụ web của Amazon hơn là Amazon MQ. Cloud Integrations Summary SQS: Queue service in AWS Multiple Producers, messages are kept up to 14 days Multiple Consumers share the read and delete messages when done Used to decouple applications in AWS SNS: Notification service in AWS Subscribers:Email,Lambda,SQS,HTTP,Mobile… Multiple Subscribers, send all messages to all of them No message retention Kinesis: real-time data streaming, persistence and analysis Amazon MQ: managed Apache MQ in the cloud (MQTT, AMQP.. protocols)","link":"/2021/05/18/Section-13-Cloud-Integrations/"},{"title":"Section 14- Cloud Monitoring","text":"Cùng tìm hiểu một số dịch vụ giám sát trên Cloud! CloudWatchAmazon CloudWatch Metrics CloudWatch cung cấp các metrics cho mọi dịch vụ trong AWS Metric là một biến để giám sát (CPUUtilization, NetworkIn…) Metric có timestamps Có thể tạo CloudWatch dashboards của các metrics Và đây là ví dụ về CloudWatch Billing metric Các Metrics quan trọng EC2 instance: CPU Utilization, Status Checks, Network (not RAM) Mặc định metrics cho mỗi 5 phút Bạn hoàn toàn có thể theo dõi chi tiết hơn nhưng mất thêm phí: metrics cho mỗi 1 phút EBS volumes: Disk Read/Writes S3 bucket: BucketSizeBytes, NumberOfObjects, AllRequests Billing: Total Estimated Charge (only in us-east-1) Service Limits: mức độ bạn đã và đang sử dụng 1 dịch vụ API Custom metrics: đẩy lên các metrics mà bạn muốn Amazon CloudWatch Alarms Alrms được sử dụng để trigger các thông báo cho một vào metric Các alarm action: Auto Scaling: increase or decrease EC2 instances “desired” count EC2 Actions: stop, terminate, reboot or recover an EC2 instance SNS notifications: send a notification into an SNS topic Các tuỳ chọn khác nhau (lấy mẫu, %, max, min,…) Có thể chọn khoảng thời gian để xác định khi nào sẽ bật alarm Ví dụ: Tạo một billing alarm trên CloudWatch Billing metric Các trạng thái của Alarm: OK, INSUFFICIENT_DATA, ALARM Lab 01: CloudWatch Metrics &amp; CloudWatch - Alarms Hands On Xem các metric, chọn 1 metric để theo dõi Tạo Alarm (Cả tạo Alarm trong Instance EC2 nữa) Create billing alarm CloudWatch Logs Overview Mặc định, không có logs từ EC2 instance đến CloudWatch Bạn cần chạy 1 CloudWatch agent trên EC2 để push các file logs mà bạn muốn (log ứng dụng, log nginx …) Hãy chắc chắn rằng quyền IAM là đúng The CloudWatch log agent can be setup on-premises too (không nhất thiết chỉ là EC2) Lab 02: CloudWatch Logs Hands OnCloudWatch Events / EventBridge Schedule: Cron jobs (theo các scheduled scripts) Event Pattern: các sự kiện phản ứng lại khi 1 dịch vụ làm 1 việc gì đó Trigger Lambda functions, send SQS/SNS messages… Amazon EventBridge EventBridge là sự phát triển tiếp theo của CloudWatch Events Defaukt event bus: được sinh bởi các dịch vụ AWS (CloudWatch Events) Parner event bus: nhận các sự kiện từ SaaS service hoặc ứng dụng (Zendesk, DataDog, Segment, Auth0…) Custom Event bues: cho các ứng dụng của bạn Schema Registry: model event schema EventBridge có một tên khác để đánh dấu các khả năng mới Tên CloudWatch Events sẽ được thay thế với EventBridge Lab 03: CloudWatch Events / EventBridge Hands On Từ CloudWatch =&gt; Events =&gt; Create CHọn schedule =&gt; Add Targets Kịch bản 2: Tạo Event Partern Một user login EC2 thay đổi trạng thái Kịch bản tiếp theo: Event Bridge. Từ EventBridge thấy được các rules đã tạo bên Events CloudTrail Overview Cung cấp quản trị, tuân thủ và kiểm toán cho tài khoản AWS của bạn. Mặc định CloudTrail đã được enabled! Lấy lịch sử của các sự kiện / API calls được tạo trong tài khoản AWS: Console SDK CLI AWS Services Có thể put logs từ CloudTrail đến CloudWatch Logs hoặc S3 **Một trail có thể được áp dụng cho Tất cả Regions (mặc định) hoặc đơn Region Nếu 1 resource bị xoá trong AWS, hãy điều tra CloudTrail đầu tiên CloudTrail Diagram CloudTrail Events Quản lý các sự kiện Các thao tác được thực hiện trên các tài nguyên trong tài khoản AWS của bạn Ví dụ Configuring security (IAM AttachRolePolicy) Configuring rules for routing data (Amazon EC2 CreateSubnet) Setting up logging (AWS CloudTrail CreateTrail) Mặc định, trails đã được cấu hình để log việc quản lý các sự kiện Có thể chia ra: Read Events (các sự kiện không sửa đổi lại resources) từ các Write Events (các sự kiện sửa đổi resource) Data Events: Mặc định, data events không được log (bởi vì toán tử volume cao - high volume operations) Các hoạt động Amazon S3 ở object-level (ví dụ như GetObject, DeleteObject, PutObject) có thể chia thành Read and Write Events AWS Lambda function execution activity (the Invoke API) CloudTrail Insights Events: phần tiếp theo sẽ đề cập CloudTrail InsightsBây giờ chúng ta hãy nói về CloudTrail Insights. Chúng ta sử dụng CloudTrail để quản lý các sự kiện và có rất nhiều sự kiện quản lý trên tất cả các loại dịch vụ xảy ra rất nhanh trong tài khoản của bạn, có thể khá khó để hiểu những gì trông kỳ quặc, những gì trông bất thường và những gì không. Và đây là lúc CloudTrail Insights xuất hiện. Với CloudTrail Insights và bạn đã kích hoạt nó và bạn phải trả tiền cho nó, nó sẽ phân tích các sự kiện của bạn và cố gắng phát hiện hoạt động bất thường trong tài khoản của bạn. Một số hành động không thường xuyên có thể kể đến Cung cấp tài nguyên không chính xác Đánh giới hạn cho các dịch vụ Bursts of AWS IAM actions Khoảng cách trong hoạt động bảo trì định kỳ CloudTrail Insights phân tích các sự kiện quản lý bình thường để tạo đường cơ sở và sau đó tiếp tực phân tích các sự kiện write để detect các hoạt động không thường xuyên CloudTrail Events Retention Các sự kiện được lưu trong 90 ngày trên CloudTrail Để giữ các sự kiện lâu hơn, hãy log chúng lên S3 và sử dụng Athena Lab 03: CloudTrail Hands On Đầu tiên vào CloudTrail, nhìn được toàn bộ lịch sử các event của tài khoản của bạn đã thực hiện trong thời gian gần đây Nhấn vào Tab Event history Tìm kiếm thử event: TerminateInstances Hãy nhìn tab Insights và Trails bên sidebar =&gt; Tạo 1 Trails Config đẩy log lên S3 hoặc CloudWatch Logs Event types: Tham khảo thêm slide Theo dõi event từ S3, Lambda, all resource hoặc resource cụ thể Tạo xong sẽ được S3 và CloudWatch chứa các thông tin Log Test Trail Tạo key pair cho user Xem trong S3 và CloudWatch Tạo Athena table. vào Event histoty =&gt; Create Athena Table. Vào service Athena để xem X-Ray Overview Dịch vụ giúp debugging trên Production, với cách tốt cũ: Test locally Thêm log mọi chỗ Deploy lại trên production Định dạng log giữa các ứng dụng khác nhau và dẫn đến việc phân tích log là khó Debugging: một khối lớn là “dễ dàng”, với các dịch vụ phân tán thì “khó” (sử dụng SQS, SNS phân tán dịch vụ) Không có các views chung cho toàn bộ kiến trúc của bạn =&gt; Enter: …. AWS X-Ray! AWS X-Ray: Visual analysis of our applicationsƯu điểm của X-Ray Khắc phục sự cố hiệu suất (tắc nghẽn) Hiểu sự phụ thuộc trong kiến trúc microservice Các vấn đề về dịch vụ không chính xác Review request behavior Tìm được các lỗi và exceptions Are we meeting time SLA? Tôi bị tắc nghẽn ở đâu? Xác định những người dùng bị ảnh hưởng Ở level cao hơn sẽ có demo cho phần này Service Health Dashboard Hiển thị tất cả các khu vực, tất cả các dịch vụ tình trạng Hiển thị thông tin lịch sử cho mỗi ngày Có nguồn cấp dữ liệu RSS mà bạn có thể đăng ký https://status.aws.amazon.com =&gt; High level Personal Health DashboardAWS Personal Health Dashboar. cung cấp cảnh báo và hướng dẫn khắc phục khi AWS đang gặp phải các sự kiện có thể ảnh hưởng đến bạn. Trong khi Service Health Dashboard hiển thị trạng thái chung của các dịch vụ AWS, Personal Health Dashboard cung cấp cho bạn một cái nhìn được cá nhân hóa về hiệu suất và tính khả dụng của các dịch vụ AWS bên dưới tài nguyên AWS của bạn. Bảng điều khiển hiển thị thông tin liên quan và kịp thời để giúp bạn quản lý các sự kiện đang diễn ra và cung cấp thông báo chủ động để giúp bạn lập kế hoạch cho các hoạt động đã lên lịch. Đây là dịch vụ Global: https://phd.aws.amazon.com/ Cho biết sự cố AWS tác động trực tiếp đến bạn và tài nguyên AWS của bạn như thế nào Các hoạt động cảnh báo, khắc phục, chủ động, theo lịch trình Monitoring Summary CloudWatch: Metrics: monitor the performance of AWS services and billing metrics Alarms: automate notification, perform EC2 action, notify to SNS based on metric Logs: collect log files from EC2 instances, servers, Lambda functions… Events (or EventBridge): react to events in AWS, or trigger a rule on a schedule CloudTrail: audit API calls made within your AWS account CloudTrail Insights: automated analysis of your CloudTrail Events X-Ray: trace requests made through your distributed applications Service Health Dashboard: status of all AWS services across all regions Personal Health Dashboard: AWS events that impact your infrastructure","link":"/2021/05/22/Section-14-Cloud-Monitoring/"},{"title":"Section 16- Security &amp; Compliance","text":"Tìm hiểu 1 số phần liên quan đến việc tuân thủ và bảo mật trên AWS! AWS Shared Responsibility ModelPhần này sẽ có 2-3 câu hỏi trong đề thi, và việc hiểu được trách nhiệm giữa bạn và AWS là điều rất quan trọng AWS responsibility - Security of the Cloud Bảo vệ cơ sở hạ tầng (phần cứng, phần mềm, cơ sở vật chất và mạng) chạy tất cả các dịch vụ AWS Quản lý các dịch vụ như S3, Dynamo DB, RDS, etc. Customer responsibility - Security in the Cloud Đối với EC2 instance, customer có trách nhiệm quản lý OS khách (bao gồm các bản cập nhật bảo mật và bản vá), firewall và cấu hình mạng, IAM Mã hoá dữ liệu ứng dụng Shared controls: Patch Management, Configuration Management, Awareness &amp; Training Ví dụ với RDS Trách nhiệm của AWS Quản lý phiên bản EC2 cơ bản, vô hiệu hoá truy cập SSH Bản vá DB tự động Bản vá OS tự động Kiểm tra disks và instance cơ bản và đảm bảo các chức năng của nó hoạt động Trách nhiệm của bạn Kiểm tra ports / IP / security group của các inbound rules trong DB của SG Phân quyền và tạo user trong database Tạo database cần hoặc không cần quyền truy cập public Chắc chắn rằng parameter groups hoặc DB được cấu hình chỉ cho phép truy cập SSL Cài đặt mã hoá database Ví dụ với S3 Trách nhiệm AWS Đảm bảo bộ nhớ không giới hạn Đảm bảo mã hoá Đảm bảo phân tách dữ liệu giữa các customer khác nhau Đảm bảo rằng nhân viên của AWS không thể truy cập dữ liệu của bạn Trách nhiệm của bạn Cấu hình các bucket Cài đặt Bucket policy / public IAM user và roles Bật mã hoá Shared Responsibility Model diagramRef: https://aws.amazon.com/compliance/shared-responsibility-model/ DDoS Protection: WAF &amp; Shield DDOS Protection on AWS AWS Shield Standard: giúp bạn chống lại tấn công DDOS mà không phát sinh giá AWS Shield Advanced: Bảo vệ 24/7 DDoS cao hơn AWS WAF: Lọc các request nhất định dựa vào các rules CloudFront and Route 53 Bảo vệ tính khả dụng bằng cách sử dụng các global edge network (mạng biên toàn cầu) Kết hợp với AWS Shield, cung cấp khả năng giảm thiểu tấn công ở (rìa) Sẵn sàng scale - tận dụng AWS Auto Scaling AWS Shield AWS Shield Standard Dịch vụ miễn phí được kích hoạt cho mọi khách hàng AWS Cung cấp khả năng bảo vệ khỏi các cuộc tấn công như SYN / UDP Floods, các cuộc tấn công Reflection và các cuộc tấn công layer 3 / layer 4 khác AWS Shield Advanced Dịch vụ giảm thiểu DDoS tùy chọn ($ 3.000 mỗi tháng cho mỗi tổ chức) Bảo vệ khỏi các cuộc tấn công phức tạp hơn trên Amazon EC2, Elastic Load Balancing (ELB), Amazon CloudFront, AWS Global Accelerator, and Route 53 24/7 truy cập, liên hệ với các team phản hồi DDoS (DDoS response team - DRP) Bảo vệ khỏi mức phí cao hơn trong thời gian sử dụng tăng đột biến do DDoS AWS WAF – Web Application Firewall Bảo vệ các ứng dụng web của bạn khỏi các hình thức khai thác web phổ biến (Layer 7) Layer 7 is HTTP (vs Layer 4 is TCP) Deploy trên Application Load Balancer, API Gateway, CloudFront Định nghĩa các Web ACL (Web Access Control List): Các Rule có thể chứa Ip Address, HTTP body, or URI strings Bảo vệ khỏi các tấn công phổ biến như SQL Injection và Cross-Site Scripting (XSS) Size constraints, geo-match (block countries) Các quy tắc dựa trên tỷ lệ (để đếm số lần xuất hiện của các sự kiện) - để bảo vệ DDoS Kiến trúc ví dụ chống DDoSRef: https://d1.awsstatic.com/whitepapers/Security/DDoS_White_Paper.pdf Penetration Testing So, penetration testing is when you’re trying to attack your own infrastructure to test your security. Khách hàng AWS được hoan nghênh thực hiện đánh giá bảo mật hoặc kiểm tra thâm nhập đối với cơ sở hạ tầng AWS của họ mà không cần phê duyệt trước đối với 8 dịch vụ: Amazon EC2 instances, NAT Gateways, and Elastic Load Balancers Amazon RDS Amazon CloudFront Amazon Aurora Amazon API Gateways AWS Lambda and Lambda Edge functions Amazon Lightsail resources Amazon Elastic Beanstalk environments (Danh sách này có thể tăng theo thời gian) Penetration Testing on your AWS Cloud Các hoạt động bị cấm DNS zone walking via Amazon Route 53 Hosted Zones Denial of Service (DoS), Distributed Denial of Service (DDoS), Simulated DoS, Simulated DDoS Port flooding Protocol flooding Request flooding (login request flooding, API request flooding) Nếu có bất cứ vấn đề gì liên quan, liên hệ với aws-security-simulated-event@amazon.com Read more: https://aws.amazon.com/security/penetration-testing/ Data at rest vs. Data in transit Trạng thái nghỉ: dữ liệu đã được lưu trữ hoặc đang lưu trữ trên 1 thiết bị. Ví dụ như lưu trên ổ cứng, lưu RDS hoặc trong S3 Đang chuyển tiếp (đang chuyển động): dữ liệu được di chuyển từ vị trí này sang vị trí khác, như chuyển dữ liệu từ các server tại chỗ sang AWS, từ EC2 sang Dynamo DB,.. Chúng ta muốn mã hoá dữ liệu ở cả 2 trạng thái để bảo vệ chúng. Để làm điều này, chúng ta tận dụng các khoá mã hoá (encrytion keys) Encryption with KMS &amp; CloudHSMAWS KMS (Key Management Service)Bất cứ khi nào bạn nghe thấy “mã hóa” cho một dịch vụ AWS, rất có thể đó là KMS KMS = AWS manages the encryption keys for us Mã hoá sẽ được sử dụng EBS volumes: encrypt volumes S3 buckets: Server-side encryption of objects Redshift database: encryption of data RDS database: encryption of data EFS drives: encryption of data Các mã hoá sẽ được kích hoạt tự động CloudTrail Logs S3 Glacier Storage Gateway CloudHSM Với KMS AWS quản lý phần mềm mã hoá thì CloudHSM AWS sẽ cung cấp phần cứng mã hoá Các phần cứng này là chuyên dụng (HSM = Hardware Security Module) Bạn tự quản lý các key mã hoá của mình chứ không phải AWS Thiết bị HSM có khả năng chống giả mạo, tuân thủ FIPS 140-2 Level 3 CloudHSM Diagram Types of Customer Master Keys: CMK Customer Managed CMK: Tạo, quản lý và sử dụng bởi khách hàng, có thể bật hoặc tắt Áp dụng chính sách luân chuyển (khóa mới được tạo hàng năm, khóa cũ được giữ nguyên) Có thể bring-your-own-key AWS managed CMK: Được AWS tạo, quản lý và sử dụng thay mặt khách hàng Được sử dụng bởi AWS services (aws/s3, aws/ebs, aws/redshift) • AWS owned CMK: Tập hợp các CMK mà một dịch vụ AWS sở hữu và quản lý để sử dụng trong nhiều tài khoản AWS có thể sử dụng những thứ đó để bảo vệ tài nguyên trong tài khoản của bạn (nhưng bạn không thể xem các khóa) CloudHSM Keys (custom keystore): Các khóa được tạo từ thiết bị phần cứng CloudHSM của riêng bạn Các toán tử mã hoá được thực hiện trong CloudHSM cluster Lab 02: Encryption with KMS &amp; CloudHSM Hands On Bước 1: Vào dịch vụ Key Management Service (KMS)As we can see, we have three types of keys.We have the customer managed keys, which you can createbut they will cost you some moneyor you have the AWS manage keysand they’re created for the services of AWSand the custom key storewhich is going to use a CloudHSM clusterthat you need to create, own and manage. Tab AWS managament: Vào volume trong EC2, tạo Volumn, Chọn mã hoá =&gt; Master Key CloudTrail: Log file với các thể loại SSE-KMS luôn (File S3) Customer managed keys: Tạo key Vào volumn EC2 tạo lại Volumn với mã hoá =&gt; Chọn được key của bạn Secrets Manager OverviewSo Secrets Manager is a great way to store secrets,but on top of it, you can force the rotationof these secrets, I mean, they have to changeevery X number of days.For example, you can say, “Okay, every 90 days,I want to change my passwords.” Vào dịch vụ Secret Manager. =&gt; Store a new secret (Có giá nhé, nhìn ở mục Price) Tạo key và chọn các tự động rotation Xem cả sample code luôn, có vẻ xịn =)) Artifact Overview (not really a service) Cổng cung cấp cho khách hàng quyền truy cập theo yêu cầu vào tài liệu tuân thủ AWS và các thỏa thuận AWS Report + Agreements Vào service Artifact =&gt; Global service Download report Accept 1 agreements =&gt; Có vẻ chỉ là docs hơn là 1 dịch vụ Artifact Reports: Cho phép bạn tải xuống các tài liệu tuân thủ và bảo mật AWS từ các đánh giá của bên thứ ba, chẳng hạn như chứng nhận AWS ISO, Payment Card Industry (PCI), and System and Organization Control (SOC) reports Artifact Agreements: Cho phép bạn xem xét, chấp nhận và theo dõi trạng thái của các thỏa thuận AWS, chẳng hạn như Business Associate Addendum (BAA) or the Health Insurance Portability and Accountability Act (HIPAA) cho tài khoản cá nhân hoặc trong tổ chức của bạn Có thể được sử dụng để hỗ trợ kiểm toán nội bộ hoặc tuân thủ Amazon GuardDutyDành cho Machine Learming (méo hiểu) Inspector Overview Đánh giá bảo mật tự động cho EC2 Instances Phân tích hệ điều hành đang chạy chống lại các lỗ hổng đã biết Phân tích khả năng truy cập mạng không mong muốn AWS Inspector Agent phải được cài trong OS trong EC2 instances Sau khi đánh giá, bạn sẽ nhận được một báo cáo với danh sách các lỗ hổng bảo mật AWS Config Overview =&gt; Labs Giúp kiểm tra và ghi lại sự tuân thủ của các tài nguyên AWS của bạn Giúp ghi lại các cấu hình và thay đổi theo thời gian Khả năng lưu trữ dữ liệu cấu hình vào S3 (do Athena phân tích) Các câu hỏi có thể được giải quyết bằng AWS Config: Có quyền truy cập SSH không hạn chế vào các security group của tôi không? Các bucket có phải đang public access? Cấu hình ALB của tôi đã thay đổi như thế nào theo thời gian? Bạn có thể nhận được các cảnh báo (SNS notification) cho các thay đổi AWS Config là dịch vụ cho mỗi region Có thể tổng hợp giữa các khu vực và tài khoản Lab 03: AWS ConfigMacie Overview - Machine LearningSecurity Hub Overview =&gt; Có price Công cụ bảo mật trung tâm để quản lý bảo mật trên một số tài khoản AWS và tự động kiểm tra bảo mật Dashboard được tích hợp hiển thị các trạng thái bảo mật và tuân thủ hiện tại để có các hành động nhanh chóng Tự động tổng hợp các cảnh báo ở các định dạng được xác định trước hoặc phát hiện cá nhân từ các dịch vụ AWS và các công cụ đối tác AWS khác nhau: GuardDuty Inspector Macie IAMAccessAnalyzer AWS Systems Manager AWS Firewall Manager AWS Partner Network Solutions Cần phải enable AWS Config Service trước Amazon Detective Overview GuardDuty, Macie và Security Hub được sử dụng để xác định các vấn đề hoặc phát hiện tiềm ẩn về bảo mật Đôi khi các phát hiện bảo mật yêu cầu phân tích sâu hơn để xác định nguyên nhân gốc rễ và thực hiện hành động - đó là một quá trình phức tạp Amazon Dêtctive phân tích, điều tra và nhanh chóng xác định nguyên nhân gốc rễ của các vấn đề bảo mật hoặc các hoạt động đáng ngờ (sử dụng ML và đồ thị) Tự động thu thập và xử lý các sự kiện từ Nhật ký luồng VPC, CloudTrail, GuardDuty và tạo chế độ xem thống nhất Tạo hình ảnh trực quan với các chi tiết và ngữ cảnh để tìm ra nguyên nhân gốc rễ AWS Abuse Báo cáo các tài nguyên AWS bị nghi ngờ được sử dụng cho các mục đích lạm dụng hoặc bất hợp pháp Các hành vi lạm dụng &amp; bị cấm là: Spam - nhận các email không mong muốn từ địa chỉ IP thuộc sở hữu của AWS, các trang web và diễn đàn bị spam bởi các tài nguyên AWS Quét cổng - gửi các gói đến các cổng của bạn để phát hiện ra các gói không an toàn DoS hoặc DDoS Intrusion attempts – logging in on your resources Lưu trữ nội dung bị phản đối hoặc có bản quyền - phân phối nội dung bất hợp pháp hoặc có bản quyền mà không có sự đồng ý Phân phối phần mềm độc hại - Tài nguyên AWS phân phối phần mềm để gây hại cho máy tính hoặc máy móc Contact the AWS Abuse team: AWS abuse form, or abuse@amazonaws.com Root User Privileges Root user = Account Owner (created when the account is created) Có toàn quyền truy cập vào tất cả các dịch vụ và tài nguyên AWS Khóa các access keys người dùng root tài khoản AWS của bạn! Không sử dụng tài khoản gốc cho các công việc hàng ngày, ngay cả các công việc quản trị Các hành động chỉ có thể được thực hiện bởi người dùng root: **Thay đổi setting tài khoản (account name, email address, root user password, root user access keys) Xem các hoá đơn thuế nhất định • Close your AWS account Khôi phục quyền người dùng IAM Thay đổi hoặc hủy gói AWS Support của bạn Đăng kí với tư cách người bán trên Reserved Instance Marketplace Cấu hình Amazon S3 bucket để enable MFA Sửa hoặc xoá 1 Amazon S3 bucket policy cái mà bao gồm một VPC ID or VPC endpoint ID không hợp lệ Đăng nhập GovCloud Security &amp; Compliance Summary Shared Responsibility on AWS Shield: Automatic DDoS Protection + 24/7 support for advanced WAF: Firewall to filter incoming requests based on rules Penetration Testing KMS: Encryption keys managed by AWS CloudHSM: Hardware encryption, we manage encryption keys Artifact: Get access to compliance reports such as PCI, ISO, etc… GuardDuty: Find malicious behavior with VPC, DNS &amp; CloudTrail Logs Inspector : For EC2 only, install agent and find vulnerabilities Config: Track config changes and compliance against rules Macie: Find sensitive data (ex: PII data) in Amazon S3 buckets CloudTrail:Track API calls made by users within account AWS Security Hub: gather security findings from multiple AWS accounts Amazon Detective: find the root cause of security issues or suspicious activities AWS Abuse: Report AWS resources used for abusive or illegal purposes Root user privileges: Change account settings Close your AWS account Change or cancel your AWS Support plan Register as a seller in the Reserved Instance Marketplace","link":"/2021/05/22/Section-16-Security-Compliance/"},{"title":"Note chơi chơi 1106","text":"Gắn bó với một nơi 3 năm đã coi là “nhà” được chưa quý vị. Với hắn là có đó ạ, à mà kể ra theo đuổi, bám chặt hơn cả đỉa là 5 năm chứ bộ, chị HR ngán ngẩm :v anh phỏng vấn nhẵn mặt :v Vù … Trở về Hà Nội những ngày gần 100 năm trước, cụ thể là 5 năm, cuối xuân 2017. Những ngày mát mẻ, nắng vàng chiếu xiên qua tán cây, gió thổi vù vù, trời xanh mây trắng, chim ca ríu rít @@. Trường hắn tổ chức ngày hội nghề nghiệp cho sinh viên. Một cậu nhóc năm 3, đi hóng hớt. Ừ thì với ý nghĩ “trẻ trâu” đi chơi cho vui, nhận sổ với bút, bình nước là chính, vì còn lâu mình mới ra trường, thế là đi đầy đủ các công ty, dạo từ tầng 2 lên tầng 4. Quà chất đầy balo. Hơn 11h rồi, hắn đang định về thì chợt để mắt tới công ty F nọ tầng 2, hình như hắn chưa vào. Rồi cũng đi nốt cho đủ quà, vào phỏng vấn. Ơ cơ mà chả hiểu sao công ty ấy lại có sức hút kì lạ như là một định mệnh, tôi xin khẳng định lại là định mệnh chứ không hề có một bạn nữ nào đặc biệt hớp hồn hắn, và đó là nơi duy nhất hắn để lại thông tin. Vài ngày sau có 1 cuộc điện thoại phỏng vấn trên Keangnam, hắn tự tin vốn lý thuyết đầy bụng, khỏi cần ăn, giữa trưa bắt xe bus lên đường. Tạch lần 1. Chưa buồn lắm. Tạch cơ mà hắn được nói chuyện với một anh phỏng vấn đầy thân thiện, cởi mở và niềm nở, đặc biệt có điểm chung học chung trường và thầy. Đoạn cuối hai anh em tán chuyện về điểm chung đó. Giờ nghĩ lại mới thấy, chắc do mình chả trả lời được gì nên anh ấy tìm chủ đề để nói chuyện cho buổi phóng vấn đỡ nhàn chán =)). Sự cởi mở, nhiệt tình từ con người nơi đây càng làm hắn muốn gắn bó nơi này. Dù tạch nhưng hắn vẫn được tạo cơ hội làm thực tập sinh tham gia các khoá đào tạo tại công ty. Hè năm ấy đi thực tập với hừng hực khí thể để ra dáng của một người đi làm. Nhưng đời không như mơ, hôm đầu hắn nghe cái lịch trình đào tạo mà phát hoảng, lắm cái hắn chưa nghe thấy bao giờ mà học có 2,3 ngày hoặc 1 tuần. Tối về vắt tay lên trán, liệu mình có chọn nhầm nghề không ….. Nhưng chả hiểu sao hắn vẫn cứ đi đến công ty, có thể vì công ty có điều hoà. Quá trình thực tập khiến hắn càng trở nên thích môi trường ấy, một môi trường trẻ trung, năng động (mặc dù hắn không phải là người năng động :v), đào tạo bài bản, thoải mái, đồ uống free, team thì tràn ngập tiếng cười, có vài bố nhây hơn cả bạn hắn ở trường. Và rồi hắn cũng làm được một chiếc project đầu tiên trong đời, hí hứng với kết quả, mong chờ được đánh giá cao từ project để tiếp tục gắn bó nơi đây. (Project :v: mọi người cho star đi https://github.com/minhnv2306/open-nguyen-van-minh-photo-sharing) Nhưng không, tạch lần 2. Thực sự buồn, mang theo một biển nước mắt về quê tắm, nghỉ hè nốt những ngày cuối năm 3 trong những ngày ít ỏi còn lại chuẩn bị cho năm 4. Sáu tháng trôi nhanh như một con gió, chàng trai năm ấy đã ở nhà ôn luyện thêm và quyết định nộp tuyển lại công ty đó. Phỏng vấn lần 3. Lần này không lên Keangnam nữa, hắn được chuyển địa điểm về Trần Khát Chân. À ha, hắn cũng nghĩ thực tập chỗ này khá tiện, cạnh trường hắn học. Cũng như các lần phỏng vấn trước, hắn hồi hộp lắm, đến sớm, chuẩn bị kĩ càng. Tạch thêm lần nữa. Wtf, chán nản thực sự, hắn tự hỏi bản thân lại kém cỏi vậy sao. Hắn buồn bã đêm quên ăn, ngày quên ngủ. May có cái đồ án khoai kéo lại, hắn sợ hãi hơn, lao đầu vào tìm hiểu mà quên mất nỗi thất vọng về bản thân phỏng vấn tới 3 lần vẫn tạch … Nhưng cũng có những đêm, hắn thao thức và trằn trọc, không phải vì đói. Lúc này thì không còn suy nghĩ trẻ trâu đi phỏng vấn cho vui hay lấy kinh nghiệm nữa rồi, hết tuổi ăn chơi, hắn nghĩ mình cần công việc, hắn sợ cảnh màn trời chiếu đất cạp đất thay cơm. Hắn lại ôn tập lại, bài bản hơn và cụ thể hơn. Áp lực công việc từ độ tuổi chênh vênh 23 sao mà ghê đến thế =))))))) (Chú thích: đoạn trên là hư cấu, thực ra đêm không ngủ do ngày ngủ nhiều thôi, luật nhân quả) Thời gian thấm thoắt thoi đưa, 6 tháng nữa lại qua, đồ án của hắn cũng hòm hòm chờ lịch bảo vệ …. Lần 4 phỏng vấn, mang theo sự quyết tâm cao hơn cả núi, không được thì về quê chăn bò, tránh phải cạp đất. Đậu lại chính ông phỏng vấn hắn 6 tháng trước:- Ơ chú nhìn quen thế @@- Anh em mình mới gặp nhau 6 tháng trước chính tại phòng này anh ạ. Người đầu tiên đưa vào đời. Sau đó là những chuỗi ngày đỡ nước mắt hơn của hắn. Hắn phỏng vấn lên vị trí mới của công ty, lại là anh phỏng vấn hắn lần 1, anh phỏng vấn lại bảo chú nhìn quen quen…. Thời gian lại cứ trôi, đã gần 3 năm hắn làm việc tại đây, lúc vui có, lúc buồn cũng có, lúc gặp bug chửi thề trước không giờ có, lúc hạnh phúc 5 năm trước không có, 3 năm gần đây có, ghét ông phỏng vấn ở Trần Khát Chân trước có giờ không có =))), Sun đã làm hắn thay đổi rất nhiều. Sun* đã biến từ 1 cậu bé hiền lành, ngây thơ ngày nọ thành 1 người ngây thơ biết code. Cảm ơn Sun*, và những con người nơi đây vì những trải nghiệm, vì kiến thức, vì văn hoá, một “gia đình” tóm lại là vì tất cả. Ming","link":"/2021/06/11/Note-choi-choi-1106/"},{"title":"Section 18- Account Management, Billing &amp; Support","text":"Cùng tìm hiểu cách tổ chức các account trong một tổ chức và các tools theo dõi, giám sát cost trong AWS nhé ^^ Organizations Overview Đây là một dịch vụ Global Cho phép quản lý nhiều tài khoản AWS Tài khoản chính sẽ là master account Các lợi ích về giá: Thanh toán tổng hợp trên tất cả các tài khoản - một phương thức thanh toán Lợi ích về giá từ việc sử dụng tổng hợp (giảm giá số lượng cho EC2, S3 …) Tổng hợp các Reserved EC2 instances để tối ưu lưu trữ Có sẵn các API để tự động tạo các tài khoản AWS Hạn chế quyền truy cập trên các tài khoản bằng các sử dụng các chính sách kiểm soát dịch vụ (Service Control Policies - SCP) So all the things highlighted in bold in this slides are going to be common exam questions. Multi Account StrategiesMột vài chiến lược sử dụng nhiều tài khoản Tạo các tài khoản cho mỗi phòng ban, cho mỗi trung tâm chi phí dựa trên vùng truy cập (sử dụng SCP) hoặc tốt hơn thì cô lập tài nguyên (ví dụ VPC) để có được sự giới hạn phân tách dịch vụ dựa trên mỗi tài khoản và logging Sử dụng nhiều tài khoản vs một tài khoản trên nhiều VPC Sử dụng tagging cho mục đích thanh toán Enable CloudTrail trên tất cả các tài khoản và gửi logs đến tài khoản S3 trung tâm Gửi CloudWatch Logs đến tài khoản logging trung tâm Service Control Policies (SCP) Whitelist or blacklist IAM actions Áp dụng cho OU (ảnh trên) hoặc Account Level Không áp dụng với Master Account SCP được áp dụng với tất cả Người dùng và Quyền - Users and Roles của tài khoản, bao gồm cả tài khoản Root SCP không ảnh hưởng đến các quyền “liên kết dịch vụ”: Các quyền liên kết dịch vụ enable bởi các dịch vụ khác AWS với AWS Oranizations và không thể bị hạn chế bởi SCPs SCP phải có một Allow rõ ràng (không cho phép mọi thứ như mặc định) Các trường hợp sử dụng Hạn chế quyền truy cập vào các dịch vụ nhất định (ví dụ: không thể sử dụng EMR) Thực thi tuân thủ PCI bằng cách vô hiệu hóa rõ ràng các dịch vụ Hệ thống cấp bậc của SCP SCP Examples Blacklist and Whitelist strategies Lab 01: Organizations Hands OnAWS Control Tower Overview Đây là cách thiết lập và quản lý môi trường nhiều tài khoản AWS an toàn và tuân thủ dựa trên các best practices Lợi ích: Tự động thiết lập môi trường của bạn chỉ bằng một vài click Tự động hoá việc quản lý các chính sách bằng cách sử dụng “lan can” Phát hiện các vi phạm chính sách và khắc phục chúng Giám sát sự tuân thủ thông qua một bảng điều khiển tương tác AWS Control Tower chạy trên AWS Organizations: Nó tự động thiết lập AWS để tổ chức tài khoản và thực hiện các SCP (Chính sách Kiểm soát Dịch vụ) Lab 02: AWS Control Tower Hands On AWS Control Tower =&gt; Set up landing zone Setting up mất tầm 60 phút Có vẻ như quản lý thêm quyền và các tài khoản trong tổ chức Pricing Models of the CloudAWS có 4 mô hình định giá Pay as you go: trả dựa trên những gì bạn đã sử dụng Save when you reserve:: Tiết kiệm chi phí hơn nếu bạn đặt trước: Giảm thiểu các rủi ro, chi phí dự đoán trước được, yêu cầu tuân thủ các chính sách dài hạn Pay less by using more: Trả ít hơn bằng cách sử dụng nhiều hơn: giảm giá dựa trên volume Pay less as AWS grows Free services &amp; free tier in AWSAWS cũng cung cấp cho bạn rất nhiều dịch vụ miễn phí và dùng thử trong vòng 1 năm đăng kí tài khoản IAM VPC Consolidated Billing Elastic Beanstalk =&gt; You do pay for the resources created CloudFormation =&gt; You do pay for the resources created Auto Scaling Groups =&gt; You do pay for the resources created Tham khảo thêm các tầng Free Tier: https://aws.amazon.com/free/ EC2 t2.micro instance for a year S3, EBS, ELB, AWS Data transfer Compute Pricing – EC2 Chỉ bị tính phí cho những gì bạn sử dụng Số lượng instances Cấu hình cho instance Thông số vật lý Region OS và phần mềm Instance type Instance size Thời gian chạy ELB và lượng dữ liệu được xử lý Các giám sát chi tiết Chi tiết sẽ như sau On-demand instances: Tối thiểu là 60s Trả cho mỗi giây (Linux) và mỗi giờ (Windows) Reserved instances: Giảm tới 75% so với On-demand tính giá theo giờ Cam kết sử dụng 1 hoặc 3 năm Trả trước tất cả, trả trước một phần hoặc không trả trước Spot instances: Tiết kiệm tới 90% so với On-demand tính giá theo giờ Dedicated Host On-demand Cam kết sử dụng 1 hoặc 3 năm Compute Pricing – Lambda &amp; ECS Lambda Trả cho mỗi lần gọi Trả cho thời gian thực thi ECS Mô hình loại khởi chạy EC2: Không có phí bổ sung, bạn trả tiền cho các tài nguyên AWS được lưu trữ và tạo trong ứng dụng của mình Fargate: Trả tiền cho vCPU và tài nguyên bộ nhớ được phân bổ cho các ứng dụng của bạn trong vùng chứa của bạn Storage Pricing – S3 Storage class: S3 Standard, S3 Infrequent Access, S3 One-Zone IA, S3 Intelligent Tiering, S3 Glacier and S3 Glacier Deep Archive Số lượng và kích thước của Object: Giá có thể được phân cấp (dựa trên volume) Số lượng và loại request Data transfer OUT of the S3 region S3 Transfer Acceleration Chuyển đổi vòng đời Dịch vụ tương tự: EFS (trả tiền cho mỗi lần sử dụng, có quy tắc truy cập và vòng đời không thường xuyên) So, sending data into S3 is free, but retrieving data from S3, you will have to pay something. Storage Pricing - EBS Volume type (based on performance) Storage volume in GB per month provisionned IOPS: General Purpose SSD: Included Provisioned IOPS SSD: Provisionned amount in IOPS Magnetic: Number of requests Snapshots: Added data cost per GB per month Data transfer: Outbound data transfer are tiered for volume discounts Inbound is free Database Pricing - RDS Trả dựa vào số giờ bạn sử dụng Database characteristics: Engine Size Memory class Mục đích: On-demand Reserved instances (1 or 3 years) with required up-front Backup Storage: There is no additional charge for backup storage up to 100% of your total database storage for a region. Additional storage (per GB per month) Số lượng input và output request mỗi tháng Deployment type (storage and I/O are variable): Single AZ Multiple AZs Data transfer: Outbound data transfer are tiered for volume discounts Inbound is free Content Delivery – CloudFront Giá cả khác nhau giữa các khu vực địa lý khác nhau Tổng hợp cho từng vị trí cạnh (edge location), sau đó áp dụng cho hóa đơn của bạn Data Transfer Out (volume discount) Number of HTTP/HTTPS requests Networking Costs in AWS per GB - SimplifiedUse Private IP instead of Public IP for good savings and better network performance Use same AZ for maximum savings (at the cost of high availability) Savings Plan Overview Cam kết một số tiền nhất đinh cho mỗi giờ trong 1 hoặc 3 năm Cách dễ nhất để thiết lập các cam kết dài hạn trên AWS EC2 Savings Plan Giảm giá lên đến 72% so với loại On-Demand Cam kết sử dụng các nhóm instance riêng lẻ trong một khu vực (ví dụ: C5 hoặc M5) Bất kể AZ, kích thước (m5.xl đến m5.4xl), OS (Linux / Windows) Trả trước, trả trước một phần hoặc không trả trước Compute Savings Plan Giảm giá đến 66% so với On-Demand Regardless of Family,Region, size, OS, tenancy, computeoptions Compute Options: EC2, Fargate, Lambda Thiết lập từ bảng điều khiển AWS Cost Explorer Vào dịch vụ AWS Cost Explorer =&gt; Purchase Saving Plans Ước lượng giá xem tại: https://aws.amazon.com/savingsplans/pricing/ Billing &amp; Costing Tools Overview Ước lượng giá trên cloud: TCO Calculator Simple Monthly Calculator / Pricing Calculator Theo dõi giá trên cloud: Billing Dashboard CostAllocationTags Cost and Usage Reports Cost Explorer Giám sát kế hoạch chi phí: Billing Alarms Budgets Chúng ta cùng điểm qua 1 lượt các loại này nhé Estimating costs in the cloudAWSTotal Cost of Ownership (TCO) Calculators AWS giúp bạn giảm Tổng chi phí sở hữu (TCO) bằng cách giảm nhu cầu đầu tư vào các khoản chi tiêu vốn lớn và cung cấp mô hình “dùng bao nhiêu trả bấy nhiêu: TCO cho phép bạn ước tính chi phí tiết kiệm khi sử dụng AWS và cung cấp tập báo cáo chi tiết Một vài điểm so sánh giữa On-Premises vs AWShttps://aws.amazon.com/blogs/aws/the-new-aws-tco-calculator/ TCO Result Simple Monthly Calculator / Pricing CalculatorNote: Dịch vụ đã ngừng từ 30/06/2020 nhưng vẫn xuất hiện trong các kì thi =)) Sẽ được thay thế bằng AWS Pricing Calculator https://calculator.aws/#/ Giúp bạn ước lượng giá cho các giải pháp kiến trúc của bạn Tracking costs in the cloudAWS Billing Dashboard AWS Free Tier DashboardCost Allocation Tags Sử dụng tags phân bổ chi phí cho phép bạn theo dõi giá AWS ở mức độ chi tiết Các tags do AWS tạo Tự động áp dụng tài nguyên do bạn tạo Bắt đầu với prefix: aws (ví dụ aws: createdBy Các tags do người dùng định nghĩa Được định nghĩa mới người dùng Bắt đầu với prefix: user Tagging and Resource Groups Tags: được sử dụng cho các tài nguyên tổ chức: EC2: instances, images, load balancers, security groups… RDS,VPC resources, Route 53, IAM users, etc… Các tài nguyên được tạo bởi CloudFormation đều được gắn thẻ theo cùng một cách Tên tự do, các tags phổ biến như: Name, Enviroment, Team,… Tags cũng có thể được tạo để tạo Resource Groups Tạo, maintain và xem tập hợp các tài nguyên chia sẻ các thẻ chung Quản lý các tags này sử dụng Tag Editor Cost and Usage Reports Tìm hiểu sâu hơn về các chi phí và sử dụng chi tiết AWS Cost &amp; Usage Reports chứa bộ dữ liệu sử dụng và chi phí AWS toàn diện nhất khả dụng, bao gồm các siêu dữ liệu bổ sung về AWS services, giá và đặt trước ( e.g., Amazon EC2 Reserved Instances (RIs)). AWS Cost and Usage Reports liệt kê mức sử dụng AWS cho từng danh mục dịch vụ được sử dụng bởi tài khoản và người dùng IAM của tài khoản trong các mục hàng hàng giờ hoặc hàng ngày, cũng như bất kỳ thẻ nào bạn đã kích hoạt cho mục đích phân bổ chi phí. Có thể được tích hợp với Athena, Redshift or QuickSight Cost Explorer (Kiểu dự báo cost) Có thể giúp bạn hình dung, hiểu và quản lý chi phí và việc sử dụng AWS của bạn theo thời gian Tạo báo cáo tùy chỉnh phân tích dữ liệu chi phí và sử dụng. Phân tích dữ liệu của bạn ở cấp độ cao: tổng chi phí và mức sử dụng trên tất cả các tài khoản Hoặc mức độ chi tiết hàng tháng, hàng giờ, tài nguyên Chọn Savings Plans để tối ưu (giảm chi phí trên hoá đơn của bạn) Dự báo mức sử dụng lên đến 12 tháng dựa trên mức sử dụng trước đó Cost Explorer – Monthly Cost by AWS Service Cost Explorer– Hourly &amp; Resource Level Cost Explorer – Forecast Usage Monitoring Costs in the CloudBilling Alarm in CloudWatch Các số liệu billing được lưu trong CloudWatch us-east-1 Dữ liệu thanh toán thì dành cho chi phí AWS toàn bộ khu vực Bạn hoàn toàn có thể thiết lập một alarm đơn giản trên CloudWatch (không mạnh bằng AWS Budgets) AWS Budgets (Ngân sách) Tạo ngân sách và gửi cảnh báo khi chi phí vượt quá ngân sách Có 3 loại ngân sách bao gồm: Usage (đã sử dụng), Cost (chi phí), Reservation (đặt trước) Đối với các Reserved Instances (RI) Theo dõi việc sử dụng Hỗ trợ EC2, ElastiCache, RDS, Redshift Thiết lập tối đa 5 SNS thông báo cho mỗi ngân sách Có thể lọc theo: Service, Linked Account,Tag, Purchase Option, Instance Type, Region, Availability Zone, API Operation, etc… Các tùy chọn tương tự như AWS Cost Explorer! 2 ngân sách thì miễn phí, sau đó giá sẽ là $0.02/day/budget AWS Trusted Advisor Vào service Trusted Advisor Trusted Advisor là một dịch vụ rất hữu ích với khi bạn có một doanh nghiệp hoặc một kế hoạch kinh doanh. Không cần cài đặt bất kỳ thứ gì - đánh giá tài khoản AWS cấp cao Phân tích các tài khoản AWS của bạn và đưa ra đề xuất: Kiểm tra cốt lõi (Core) và đề xuất - tất cả khách hàng Có thể bật thông báo qua email hàng tuần từ bảng điều khiển Full Trusted Advisor - Khả dụng với kế hoạch hỗ trợ Business &amp; Enterprise Khả năng đặt cảnh báo CloudWatch khi đạt đến giới hạn Đặc biệt bạnh có thể lập trình: Truy cập sử dụng AWS Support API Ví dụ checking với Trusted Advisor Cost Optimization: Các phiên bản EC2 sử dụng thấp, các cân bằng tải không tải, các EBS volumnes không được sử dụng nữa Performance: Các phiên bản EC2 sử dụng cao, tối ưu hóa CloudFront CDN, tối ưu hóa thông lượng từ EC2 đến EBS Security: Đã kích hoạt MFA trên Root Account chưa, IAM key, các Access Keys đã lộ Khả năng chịu lỗi: EBS snapshot usage, Availability Zone Balance Giới hạn các dịch vụ AWS Support Plans PricingPlans cho cá nhân, nhóm hoặc doanh nghiệp, tuỳ mục đích yêu cầu của bạn AWS Basic Support Plan Free Customer Service &amp; Communities: Truy cập 24x7 vào dịch vụ khách hàng, tài liệu, sách trắng và diễn đàn hỗ trợ. AWS Trusted Advisor: Truy cập vào 7 kiểm tra và hướng dẫn Trusted Advisor cốt lõi để cung cấp tài nguyên của bạn theo các phương pháp hay nhất nhằm tăng hiệu suất và cải thiện bảo mật. AWS Personal Health Dashboard: Chế độ xem được cá nhân hóa về tình trạng của các dịch vụ AWS và cảnh báo khi tài nguyên của bạn bị ảnh hưởng. AWS Developer Support Plan All Basic Support Plan + Truy cập email trong giờ làm việc (business hours) tới Cloud Support Associates Không giới hạn trường hợp / 1 liên hệ chính Mức độ nghiêm trọng của trường hợp / thời gian phản hồi: Hướng dẫn chung: &lt;24 giờ làm việc Hệ thống bị lỗi: &lt;12 giờ làm việc AWS Business Support Plan (24/7) Được sử dụng nếu bạn có production workloads Trusted Advisor: Full quyền check và truy cập API 24x7 phone, email, and chat access với các Cloud Support Engineers Không giới hạn trường hợp / số liên lạc không giới hạn Quyền truy cập Infrastructure Event Management với chi phí bổ sung Mức độ nghiêm trọng của trường hợp / thời gian phản hồi: Hướng dẫn chung: &lt;24 giờ làm việc Hệ thống bị lỗi: &lt;12 giờ làm việc Thiệt hại hệ thống production: &lt; 4 giờ Down hệ thống production: &lt; 1 giờ AWS Enterprise Support Plan (24/7) Sử dụng nếu bạn có mission critical workloads All of Business Support Plan + Liên hệ truy cập với đội Technical Account Manager (TAM) Concierge Support Team (cho các phương pháp hay nhất về thanh toán và tài khoản) • Infrastructure Event Management,Well-Architected &amp; Operations Reviews Mức độ nghiêm trọng của trường hợp / thời gian phản hồi: … Thiệt hại hệ thống production: &lt; 4 giờ Down hệ thống production: &lt; 1 giờ Business-critical system down: &lt; 15 minutes Account Best Practices - Summary Operate multiple accounts using Organizations Use SCP (service control policies) to restrict account power Easily setup multiple accounts with best-practices with AWS Control Tower Use Tags &amp; Cost Allocation Tags for easy management &amp; billing IAM guidelines: MFA, least-privilege, password policy, password rotation Config to record all resources configurations &amp; compliance over time CloudFormation to deploy stacks across accounts and regions Trusted Advisor to get insights, Support Plan adapted to your needs Send Service Logs and Access Logs to S3 or CloudWatch Logs Đẩy Service Logs and Access Logs tới Amazon S3 hoặc CloudWatch Logs, thậm chí có thể trong một tài khoản riêng để ghi nhật ký chẳng hạn như bạn tuân thủ các phương pháp bảo mật tốt nhất. CloudTrail to record API calls made within your account If your Account is compromised: change the root password, delete and rotate all passwords / keys, contact the AWS support Billing and CostingTools – Summary TCO Calculator: from on-premises to AWS Simple Monthly Calculator / Pricing Calculator: cost of services on AWS • Billing Dashboard: high level overview + free tier dashboard Cost Allocation Tags: tag resources to create details on reports Cost and Usage Reports: most comprehensive billing dataset Cost Explorer: View current usage (detailed) and forecast usage Billing Alarms: in us-east-1 – track overall and per-service billing Budgets: more advanced – track usage, costs, RI, and get alerts Savings Plans: easy way to save based on long-term usage of AWS","link":"/2021/07/14/Section-18-Account-Management-Billing-Support/"},{"title":"Tản mạn về index trong MySQL","text":"Indexs (Chỉ mục - cũng được gọi là “keys” trong MySQL) là cấu trúc dữ liệu làm phương tiện lưu trữ để tìm các hàng nhanh hơn. Indexs rất quan trọng để có hiệu suất tốt và trở nên quan trọng hơn khi dữ liệu của bạn phát triển lớn hơn. Cơ sở dữ liệu nhỏ, tải nhẹ thường hoạt động tốt ngay cả khi không có đúng cách chỉ mục, nhưng khi tập dữ liệu tăng lên, hiệu suất có thể giảm rất nhanh. Thật không may, chỉ mục thường bị lãng quên hoặc hiểu lầm, vì vậy lập chỉ mục kém là nguyên nhân hàng đầu của vấn đề hiệu suất trong thế giới thực. Cơ bản về indexingNó hoạt động ra saoCách dễ hiểu nhất index hoạt động dư lào trong MySQL là nghĩ về index trong sách. Để tìm 1 topic cụ thể nào trong sách, bạn nhìn mục lục và nó sẽ nói cho bạn trang nào xuất hiện nội dung đó. Trong MySQL, phương pháp lưu trữ sử dụng index cũng tương tự vậy. Nó tìm kiếm index của cấu trúc dữ liệu như 1 giá trị. Khi tìm kiếm trùng khớp, nó có thể tìm thấy hàng đó. Khi bạn chạy câu lệnh:1mysql&gt; SELECT first_name FROM sakila.actor WHERE actor_id = 5; Cột actor_id là index, bởi vậy MySQL sẽ sử dụng index để tìm những hàng có actor_id là 5. Nói cách khác, nó thực hiện tra cứu các giá trị trong chỉ mục và trả về bất kỳ hàng nào chứa giá trị được chỉ định. Các loại index B-Tree Indexes Đa số kỹ thuật lưu trữ MySQL đều hỗ trợ loại index này. Ngoại lệ của kỹ thuật này là nó không hỗ trợ index với tất cả các phiên bản cho đến khi phiên bản MySQL 5.1, khi mà bắt đầu cho phép các cột AUTO_INCREMENT Hash index Hash index không được sử dụng rộng rãi vì nó không thế áp dụng cho nhiều trường hợp như B-Tree Indexs. Hash index có 1 số điểm mạnh sau: Chúng chỉ được sử dụng để so sánh bằng, sử dụng các toán tử = hoặc &lt;=&gt; (nhưng rất nhanh). Chúng không được sử dụng cho các toán tử so sánh, chẳng hạn như &lt; tìm thấy một phạm vi các giá trị. Các hệ thống phụ thuộc vào loại tra cứu giá trị đơn này được gọi là các cửa hàng giá trị khóa chính xác để sử dụng MySQL cho các ứng dụng đó, hãy sử dụng các chỉ mục băm bất cứ khi nào có thể. Toán tử ORDER By không tối ưu được nếu sử dụng hash index MySQL không thể xác định khoảng bao nhiêu hàng giữa hai giá trị (điều này được sử dụng bởi trình tối ưu hóa phạm vi để quyết định sử dụng chỉ mục nào). Điều này có thể ảnh hưởng đến một số truy vấn nếu bạn thay đổi bảng MyISAM hoặc InnoDB thành bảng MEMOR được lập chỉ mục băm. Chỉ toàn bộ khóa có thể được sử dụng để tìm kiếm một hàng. (Với chỉ mục cây B, mọi tiền tố ngoài cùng bên trái của khóa đều có thể được sử dụng để tìm hàng.) Spatial (R-Tree) indexes: Hỗ trợ tốt cho các ứng dụng liên quan đến địa lý MyISAM hỗ trợ các chỉ mục không gian, mà bạn có thể sử dụng với các loại một phần như GEOME TRY. Không giống như các chỉ mục B-Tree, các chỉ mục không gian không yêu cầu các mệnh đề WHERE của bạn hoạt động trên tiền tố ngoài cùng bên trái của chỉ mục. Họ lập chỉ mục dữ liệu theo tất cả các kích thước giống nhauthời gian. Kết quả là, tra cứu có thể sử dụng bất kỳ sự kết hợp kích thước nào một cách hiệu quả. Tuy nhiên, bạn phải sử dụng các chức năng của MySQL GIS, chẳng hạn như MBRCONTAINS (), để làm việc này và hỗ trợ MySQL MySQL GIS rất tuyệt, vì vậy hầu hết mọi người không sử dụng nó. Giải pháp tiếp cận cho GIS trong RDBMS mã nguồn mở là PostGIS trong PostgreQuery. (ứng dụng cho các ứng dụng liên quan đến địa lý) Các truy vấn sử dụng indexMultiple-Column IndexesMột bảng có thể chọn nhiều cột làm index. Một chỉ mục có thể bao gồm tối đa 16 cột. MySQL có thể sử dụng các chỉ mục nhiều cột cho các truy vấn kiểm tra tất cả các cột trong chỉ mục hoặc các truy vấn chỉ kiểm tra cột đầu tiên, hai cột đầu tiên, ba cột đầu tiên, v.v. Nếu bạn chỉ định các cột theo đúng thứ tự trong định nghĩa chỉ mục, một chỉ mục tổng hợp duy nhất có thể tăng tốc một số loại truy vấn trên cùng một bảng. Trước khi nói về các truy vấn mà có sử dụng index. Tôi muốn nói qua về leftmost prefix. Leftmost prefix dịch tạm sang tiếng Việt là “tiền tố trái nhất” của 1 index. Nó được áp dụng trong trường hợp “Multiple-Column Indexes”. Ví dụ khi bạn tạo index: 1234567CREATE TABLE test ( id INT NOT NULL, last_name CHAR(30) NOT NULL, first_name CHAR(30) NOT NULL, PRIMARY KEY (id), INDEX name (last_name,first_name)); Thì last_name ở đây chính là leftmost prefix của index có tên là name. Tại sao leftmost lại quan trọng như vậy, ta cùng xem xét phần tiếp theo nhé. Các truy vấn có sử dụng index trong B-TreeChính vì B-Tree index được sử dụng phổ biến nhất, phần này tôi sẽ liệt kê các truy vấn sử dụng index trong B-Tree Match the full value Truy vấn tìm đúng giá trị:1SELECT * FROM test WHERE last_name='Widenius'; Match a range of values Tất nhiên trùng giá trị trong một khoảng ta thì các index cũng được áp dụng (&gt;=, &lt;=, &gt;, &lt;) Match a leftmost prefix Điều này cho thấy thứ tự index thật sự quan trọng như thế nào. Nếu 1 bảng có nhiều cột trong 1 index, chỉ có leftmost prefix có thể được sử dụng để tối ưu truy vấn. Ví dụ index của bạn có 3 cột(col1, col2, col3), chỉ thao tác trên (col1), (col1, col2), và (col1, col2, col3) mới có thể giúp tối ưu hóa truy vấn, thao tác trên (col2) hay (col2, col3) hoàn toàn không có ý nghĩa:12345SELECT * FROM tbl_name WHERE col1=val1;SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;SELECT * FROM tbl_name WHERE col2=val2;SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;Như truy vấn ở trên thì chỉ có 2 truy vấn đầu đánh index có ý nghĩa, 2 truy vấn sau không áp dụng index. Vậy thì col2, col3 cho vào index có ý nghĩa gì? Nó sẽ có ý nghĩa index trong trường hợp bổ sung truy vấn, cải thiện truy vấn nhanh hơn (trong trường hợp truy vấn (col1, col2) hoặc (col1, col2, col3) ý). Như vậy quay trở lại với bảng đã áp dụng từ trên, các truy vấn sau sẽ phát huy được tác dụng của index (sử dụng leftmost prefix): 123456789101112SELECT * FROM test WHERE last_name='Widenius';SELECT * FROM test WHERE last_name='Widenius' AND first_name='Michael';SELECT * FROM test WHERE last_name='Widenius' AND (first_name='Michael' OR first_name='Monty');SELECT * FROM test WHERE last_name='Widenius' AND first_name &gt;='M' AND first_name &lt; 'N'; Còn các truy vấn này thì không:12345SELECT * FROM test WHERE first_name='Michael'; -- không sử dụng leftmostSELECT * FROM test WHERE last_name='Widenius' OR first_name='Michael'; -- dùng OR nên cũng không sử dụng leftmost (vế sao OR)Do đó việc sắp xếp thự tự các cột trong index là rất quan trọng để lấy được leftmost prefix. Match a column prefix Bạn có thể áp dụng index để tìm những người có last_name bắt đầu là “J”. Hạn chế của indexNhư đã đề cập ở trên, một số truy vẫn sẽ không sử dụng index: Không sử dụng leftmost Nếu không sử dụng leftmost trong truy vấn, index sẽ không phát huy được tác dụng của nó. Kỹ thuật lưu trữ không thể tối ưu truy vấn với 1 cái cột với các “bên phải của điều kiện với khoảng đầu tiên” (the right of thefirst range condition) Dễ hiểu nhất là thử áp dụng với LIKE. Nếu như phần trên đề cập có thể truy vấn với người dùng có last_name bắt đầu là “J” có áp dụng index thì với những truy vấn last_name kết thúc là”J” sẽ không áp dụng index vì nó là điều kiện bên phải. Đây là một hạn chế khá lớn của index.12SELECT * FROM test WHERE last_name LIKE 'J%'; -- áp dụng index trong truy vấnSELECT * FROM test WHERE last_name LIKE '%J'; -- còn đây thì không Xem truy vấn có sử dụng index không?Để xem truy vấn của bạn có sử dụng index hay không, bạn có thể sử dụng lệnh EXPLAIN trong sql. Nhìn vào số cột nó đã duyệt và cột extra, bạn có thể biết thêm thông tin hữu ích đó :D. Ví dụ sao tôi đã tạo 20k bản ghi user để truy vấn từ seed của Laravel:12345678910111213141516171819&lt;?phpuse Illuminate\\Database\\Seeder;class DatabaseSeeder extends Seeder{ /** * Seed the application's database. * * @return void */ public function run() { // $this-&gt;call(UsersTableSeeder::class); factory(App\\User::class, 20000)-&gt;create()-&gt;each(function ($user) { }); }}Và đây là truy vấn để test index:12345678910111213141516mysql&gt; explain select * from users where email LIKE &quot;m%&quot;;+----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | users | NULL | range | users_email_unique | users_email_unique | 1022 | NULL | 1514 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0,00 sec)mysql&gt; explain select * from users where email LIKE &quot;%m&quot;;+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| 1 | SIMPLE | users | NULL | ALL | NULL | NULL | NULL | NULL | 19853 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+1 row in set, 1 warning (0,00 sec)Nhìn qua là biết cái nào sử dụng index rồi đó. Index giúp ta giảm truy vấn từ duyệt 19853 bản ghi xuống 1514 bản ghi Tài liệu tham khảo:https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html","link":"/2021/08/01/Tan-man-ve-index-trong-MySQL/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"apache2","slug":"apache2","link":"/tags/apache2/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"naming","slug":"naming","link":"/tags/naming/"},{"name":"clean function","slug":"clean-function","link":"/tags/clean-function/"},{"name":"clean comment","slug":"clean-comment","link":"/tags/clean-comment/"},{"name":"clean error","slug":"clean-error","link":"/tags/clean-error/"},{"name":"collection","slug":"collection","link":"/tags/collection/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"docker compose file format","slug":"docker-compose-file-format","link":"/tags/docker-compose-file-format/"},{"name":"docker-volume","slug":"docker-volume","link":"/tags/docker-volume/"},{"name":"docker-best-practice","slug":"docker-best-practice","link":"/tags/docker-best-practice/"},{"name":"docker-network","slug":"docker-network","link":"/tags/docker-network/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-compose.yml","slug":"docker-compose-yml","link":"/tags/docker-compose-yml/"},{"name":"docker command","slug":"docker-command","link":"/tags/docker-command/"},{"name":"Kanji","slug":"Kanji","link":"/tags/Kanji/"},{"name":"async programing","slug":"async-programing","link":"/tags/async-programing/"},{"name":"authentication","slug":"authentication","link":"/tags/authentication/"},{"name":"configuration","slug":"configuration","link":"/tags/configuration/"},{"name":"tips laravel","slug":"tips-laravel","link":"/tags/tips-laravel/"},{"name":"requests","slug":"requests","link":"/tags/requests/"},{"name":"unit test","slug":"unit-test","link":"/tags/unit-test/"},{"name":"validation","slug":"validation","link":"/tags/validation/"},{"name":"Linux command line","slug":"Linux-command-line","link":"/tags/Linux-command-line/"},{"name":"process management","slug":"process-management","link":"/tags/process-management/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"sudo command","slug":"sudo-command","link":"/tags/sudo-command/"},{"name":"excelfile","slug":"excelfile","link":"/tags/excelfile/"},{"name":"phpcs phpcsfixer","slug":"phpcs-phpcsfixer","link":"/tags/phpcs-phpcsfixer/"},{"name":"phpcs","slug":"phpcs","link":"/tags/phpcs/"},{"name":"react boilerplate","slug":"react-boilerplate","link":"/tags/react-boilerplate/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"groupby, mysql","slug":"groupby-mysql","link":"/tags/groupby-mysql/"},{"name":"stripe","slug":"stripe","link":"/tags/stripe/"},{"name":"gcp","slug":"gcp","link":"/tags/gcp/"},{"name":"tracking php script","slug":"tracking-php-script","link":"/tags/tracking-php-script/"},{"name":"vba","slug":"vba","link":"/tags/vba/"},{"name":"jquery-validation","slug":"jquery-validation","link":"/tags/jquery-validation/"},{"name":"docker-instructions docker-best-practice","slug":"docker-instructions-docker-best-practice","link":"/tags/docker-instructions-docker-best-practice/"},{"name":"event","slug":"event","link":"/tags/event/"},{"name":"event notification","slug":"event-notification","link":"/tags/event-notification/"}],"categories":[{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"AWS Training","slug":"AWS-Training","link":"/categories/AWS-Training/"},{"name":"Authentication","slug":"Authentication","link":"/categories/Authentication/"},{"name":"Development and Operation","slug":"Development-and-Operation","link":"/categories/Development-and-Operation/"},{"name":"The Art of Readable Code","slug":"The-Art-of-Readable-Code","link":"/categories/The-Art-of-Readable-Code/"},{"name":"Clean our code","slug":"Clean-our-code","link":"/categories/Clean-our-code/"},{"name":"Web Server","slug":"Development-and-Operation/Web-Server","link":"/categories/Development-and-Operation/Web-Server/"},{"name":"Chapter 1 - Code Should Be Easy to Understand","slug":"The-Art-of-Readable-Code/Chapter-1-Code-Should-Be-Easy-to-Understand","link":"/categories/The-Art-of-Readable-Code/Chapter-1-Code-Should-Be-Easy-to-Understand/"},{"name":"CircleCI 2.0","slug":"Development-and-Operation/CircleCI-2-0","link":"/categories/Development-and-Operation/CircleCI-2-0/"},{"name":"Google Cloud Platform","slug":"Development-and-Operation/Google-Cloud-Platform","link":"/categories/Development-and-Operation/Google-Cloud-Platform/"},{"name":"Docker","slug":"Development-and-Operation/Docker","link":"/categories/Development-and-Operation/Docker/"},{"name":"Clean code - Robert C. Martin","slug":"Clean-our-code/Clean-code-Robert-C-Martin","link":"/categories/Clean-our-code/Clean-code-Robert-C-Martin/"},{"name":"Website Optimization","slug":"Others/Website-Optimization","link":"/categories/Others/Website-Optimization/"},{"name":"JP","slug":"JP","link":"/categories/JP/"},{"name":"Refactoring to Collections","slug":"Clean-our-code/Refactoring-to-Collections","link":"/categories/Clean-our-code/Refactoring-to-Collections/"},{"name":"JAVaScript","slug":"JAVaScript","link":"/categories/JAVaScript/"},{"name":"Laravel","slug":"Development-and-Operation/Laravel","link":"/categories/Development-and-Operation/Laravel/"},{"name":"Linux OS","slug":"Development-and-Operation/Linux-OS","link":"/categories/Development-and-Operation/Linux-OS/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Công cụ lập trình","slug":"Others/Cong-cu-lap-trinh","link":"/categories/Others/Cong-cu-lap-trinh/"},{"name":"PHPCS","slug":"Others/PHPCS","link":"/categories/Others/PHPCS/"},{"name":"Part I - Surface-Level Improvements","slug":"The-Art-of-Readable-Code/Part-I-Surface-Level-Improvements","link":"/categories/The-Art-of-Readable-Code/Part-I-Surface-Level-Improvements/"},{"name":"Part III - Reorganizing Your Code","slug":"The-Art-of-Readable-Code/Part-III-Reorganizing-Your-Code","link":"/categories/The-Art-of-Readable-Code/Part-III-Reorganizing-Your-Code/"},{"name":"Part IV - Selected Topics","slug":"The-Art-of-Readable-Code/Part-IV-Selected-Topics","link":"/categories/The-Art-of-Readable-Code/Part-IV-Selected-Topics/"},{"name":"Part II - Simplifying Loops and Logic","slug":"The-Art-of-Readable-Code/Part-II-Simplifying-Loops-and-Logic","link":"/categories/The-Art-of-Readable-Code/Part-II-Simplifying-Loops-and-Logic/"},{"name":"Unit Test","slug":"Unit-Test","link":"/categories/Unit-Test/"},{"name":"Asynchronous","slug":"JAVaScript/Asynchronous","link":"/categories/JAVaScript/Asynchronous/"},{"name":"MongoDB","slug":"Database/MongoDB","link":"/categories/Database/MongoDB/"},{"name":"React","slug":"JAVaScript/React","link":"/categories/JAVaScript/React/"},{"name":"MySQL","slug":"Database/MySQL","link":"/categories/Database/MySQL/"},{"name":"Event","slug":"JAVaScript/Event","link":"/categories/JAVaScript/Event/"},{"name":"Sưu tầm","slug":"Others/Suu-tam","link":"/categories/Others/Suu-tam/"},{"name":"special day","slug":"special-day","link":"/categories/special-day/"}]}